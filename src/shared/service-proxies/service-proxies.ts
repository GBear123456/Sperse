/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.10.0 (NJsonSchema v9.10.49.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    validateMemberSignUp(body: SignUpMemberRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ValidateMemberSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMemberSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMemberSignUp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateMemberSignUp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    signUpMember(body: SignUpMemberRequest | null | undefined): Observable<SignUpMemberResponse> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SignUpMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUpMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUpMember(<any>response_);
                } catch (e) {
                    return <Observable<SignUpMemberResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SignUpMemberResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSignUpMember(response: HttpResponseBase): Observable<SignUpMemberResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SignUpMemberResponse.fromJS(resultData200) : new SignUpMemberResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignUpMemberResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    signUp(body: SignUpRequest | null | undefined): Observable<SignUpMemberResponse> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(<any>response_);
                } catch (e) {
                    return <Observable<SignUpMemberResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SignUpMemberResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<SignUpMemberResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SignUpMemberResponse.fromJS(resultData200) : new SignUpMemberResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignUpMemberResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | null | undefined): Observable<SendPasswordResetCodeOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<SendPasswordResetCodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendPasswordResetCodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<SendPasswordResetCodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendPasswordResetCodeOutput.fromJS(resultData200) : new SendPasswordResetCodeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendPasswordResetCodeOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getResetPasswordCodeInfo(body: GetResetPasswordCodeInfoInput | null | undefined): Observable<GetResetPasswordCodeInfoOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/GetResetPasswordCodeInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResetPasswordCodeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResetPasswordCodeInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetResetPasswordCodeInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetResetPasswordCodeInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetResetPasswordCodeInfo(response: HttpResponseBase): Observable<GetResetPasswordCodeInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetResetPasswordCodeInfoOutput.fromJS(resultData200) : new GetResetPasswordCodeInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetResetPasswordCodeInfoOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @return Success
     */
    impersonateAsAdmin(tenantId: number | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ImpersonateAsAdmin?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateAsAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateAsAdmin(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonateAsAdmin(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendAutoLoginWithReset(body: SendAutoLoginLinkInput | null | undefined): Observable<SendAutoLoginLinkOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendAutoLoginWithReset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAutoLoginWithReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAutoLoginWithReset(<any>response_);
                } catch (e) {
                    return <Observable<SendAutoLoginLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendAutoLoginLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAutoLoginWithReset(response: HttpResponseBase): Observable<SendAutoLoginLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendAutoLoginLinkOutput.fromJS(resultData200) : new SendAutoLoginLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAutoLoginLinkOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendAutoLoginLink(body: SendAutoLoginLinkInput | null | undefined): Observable<SendAutoLoginLinkOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendAutoLoginLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAutoLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAutoLoginLink(<any>response_);
                } catch (e) {
                    return <Observable<SendAutoLoginLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendAutoLoginLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAutoLoginLink(response: HttpResponseBase): Observable<SendAutoLoginLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendAutoLoginLinkOutput.fromJS(resultData200) : new SendAutoLoginLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAutoLoginLinkOutput>(<any>null);
    }

    /**
     * @return Success
     */
    cancelUserAccount(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/CancelUserAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelUserAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelUserAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelUserAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityDto.fromJS(resultData200) : new ActivityDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @assignedTo (optional) 
     * @dateFrom (optional) 
     * @dateTo (optional) 
     * @return Success
     */
    getAll(assignedTo: number | null | undefined, dateFrom: moment.Moment | null | undefined, dateTo: moment.Moment | null | undefined): Observable<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetAll?";
        if (assignedTo !== undefined)
            url_ += "AssignedTo=" + encodeURIComponent("" + assignedTo) + "&"; 
        if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActivityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ActivityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    move(body: MoveActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMove(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    transition(body: TransitionActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Transition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUser(body: AssignActivityUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }
}

@Injectable()
export class ApiKeyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getAll(userId: number | null | undefined): Observable<ApiKeyInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/GetAll?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApiKeyInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiKeyInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApiKeyInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApiKeyInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    generate(body: GenerateApiKeyInput | null | undefined): Observable<ApiKeyInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(<any>response_);
                } catch (e) {
                    return <Observable<ApiKeyInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiKeyInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<ApiKeyInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiKeyInfo.fromJS(resultData200) : new ApiKeyInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerApplicant(body: RegisterApplicantRequest | null | undefined): Observable<RegisterApplicantResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/RegisterApplicant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterApplicant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterApplicant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterApplicantResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterApplicantResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterApplicant(response: HttpResponseBase): Observable<RegisterApplicantResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterApplicantResponse.fromJS(resultData200) : new RegisterApplicantResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterApplicantResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerByApplicant(body: RegisterByApplicantRequest | null | undefined): Observable<RegisterByApplicantResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/RegisterByApplicant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterByApplicant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterByApplicant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterByApplicantResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterByApplicantResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterByApplicant(response: HttpResponseBase): Observable<RegisterByApplicantResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterByApplicantResponse.fromJS(resultData200) : new RegisterByApplicantResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterByApplicantResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getInitialMemberApplication(applicantUserId: number, applicationId: string): Observable<OfferApplicationDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/GetInitialMemberApplication?";
        if (applicantUserId === undefined || applicantUserId === null)
            throw new Error("The parameter 'applicantUserId' must be defined and cannot be null.");
        else
            url_ += "applicantUserId=" + encodeURIComponent("" + applicantUserId) + "&"; 
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialMemberApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialMemberApplication(<any>response_);
                } catch (e) {
                    return <Observable<OfferApplicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferApplicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInitialMemberApplication(response: HttpResponseBase): Observable<OfferApplicationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferApplicationDto.fromJS(resultData200) : new OfferApplicationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @userId (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogs(filter: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userId: number | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogs?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogListDtoPagedResultDto.fromJS(resultData200) : new AuditLogListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @userId (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(filter: string | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userId: number | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<EntityChangeListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityChangeListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityChangeListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<EntityChangeListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntityChangeListDtoPagedResultDto.fromJS(resultData200) : new EntityChangeListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityChangeListDtoPagedResultDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BankAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currency: string): Observable<SyncAccountBankDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<SyncAccountBankDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAccountBankDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<SyncAccountBankDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SyncAccountBankDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountBankDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    recalculateAllBankAccountDailyStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/RecalculateAllBankAccountDailyStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculateAllBankAccountDailyStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculateAllBankAccountDailyStats(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecalculateAllBankAccountDailyStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @forecastModelId (optional) 
     * @accounts (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @groupBy (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currency: string, forecastModelId: number | null | undefined, accounts: number[] | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, groupBy: GroupByPeriod | null | undefined): Observable<BankAccountDailyStatDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&"; 
        if (forecastModelId !== undefined)
            url_ += "ForecastModelId=" + encodeURIComponent("" + forecastModelId) + "&"; 
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "Accounts=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountDailyStatDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountDailyStatDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<BankAccountDailyStatDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankAccountDailyStatDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountDailyStatDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    discardDiscrepancies(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: DiscardDiscrepanciesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancies?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancies(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDiscardDiscrepancies(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    discardDiscrepancy(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancy?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDiscardDiscrepancy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBankAccount(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateBankAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/UpdateBankAccount?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BANKCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getBankCode(body: GetBankCodeInput | null | undefined): Observable<GetBankCodeOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetBankCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCode(<any>response_);
                } catch (e) {
                    return <Observable<GetBankCodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBankCodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankCode(response: HttpResponseBase): Observable<GetBankCodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBankCodeOutput.fromJS(resultData200) : new GetBankCodeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankCodeOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAdvisorInfo(): Observable<GetAdvisorInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAdvisorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvisorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvisorInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetAdvisorInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAdvisorInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvisorInfo(response: HttpResponseBase): Observable<GetAdvisorInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAdvisorInfoOutput.fromJS(resultData200) : new GetAdvisorInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAdvisorInfoOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateLead(body: CreateOrEditLeadInput | null | undefined): Observable<CreateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/CreateOrUpdateLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLead(<any>response_);
                } catch (e) {
                    return <Observable<CreateLeadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateLeadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLead(response: HttpResponseBase): Observable<CreateLeadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateLeadOutput.fromJS(resultData200) : new CreateLeadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLeadOutput>(<any>null);
    }

    /**
     * @aiGeneratedOnly (optional) 
     * @return Success
     */
    getSystemTotals(aiGeneratedOnly: boolean | null | undefined): Observable<GetSystemTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetSystemTotals?";
        if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetSystemTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSystemTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSystemTotals(response: HttpResponseBase): Observable<GetSystemTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSystemTotalsOutput.fromJS(resultData200) : new GetSystemTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSystemTotalsOutput>(<any>null);
    }

    /**
     * @aiGeneratedOnly (optional) 
     * @return Success
     */
    getUserTotals(aiGeneratedOnly: boolean | null | undefined): Observable<GetUserTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetUserTotals?";
        if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetUserTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTotals(response: HttpResponseBase): Observable<GetUserTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserTotalsOutput.fromJS(resultData200) : new GetUserTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserTotalsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAiSystemTotals(): Observable<GetSystemTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAiSystemTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAiSystemTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAiSystemTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetSystemTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSystemTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAiSystemTotals(response: HttpResponseBase): Observable<GetSystemTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSystemTotalsOutput.fromJS(resultData200) : new GetSystemTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSystemTotalsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAiUserTotals(): Observable<GetUserTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetAiUserTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAiUserTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAiUserTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetUserTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAiUserTotals(response: HttpResponseBase): Observable<GetUserTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserTotalsOutput.fromJS(resultData200) : new GetUserTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserTotalsOutput>(<any>null);
    }

    /**
     * @aiGeneratedOnly (optional) 
     * @return Success
     */
    getLeaderBoard(aiGeneratedOnly: boolean | null | undefined): Observable<GetLeaderBoardOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetLeaderBoard?";
        if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaderBoard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaderBoard(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaderBoardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaderBoardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaderBoard(response: HttpResponseBase): Observable<GetLeaderBoardOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLeaderBoardOutput.fromJS(resultData200) : new GetLeaderBoardOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaderBoardOutput>(<any>null);
    }

    /**
     * @aiGeneratedOnly (optional) 
     * @return Success
     */
    getUserRank(aiGeneratedOnly: boolean | null | undefined): Observable<GetUserRankOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetUserRank?";
        if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRank(<any>response_);
                } catch (e) {
                    return <Observable<GetUserRankOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserRankOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRank(response: HttpResponseBase): Observable<GetUserRankOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserRankOutput.fromJS(resultData200) : new GetUserRankOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserRankOutput>(<any>null);
    }

    /**
     * @aiGeneratedOnly (optional) 
     * @return Success
     */
    getRecentlyAddedContacts(aiGeneratedOnly: boolean | null | undefined): Observable<RecentlyAddedContact[]> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetRecentlyAddedContacts?";
        if (aiGeneratedOnly !== undefined)
            url_ += "aiGeneratedOnly=" + encodeURIComponent("" + aiGeneratedOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyAddedContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyAddedContacts(<any>response_);
                } catch (e) {
                    return <Observable<RecentlyAddedContact[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecentlyAddedContact[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyAddedContacts(response: HttpResponseBase): Observable<RecentlyAddedContact[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RecentlyAddedContact.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecentlyAddedContact[]>(<any>null);
    }

    /**
     * @personId (optional) 
     * @return Success
     */
    getBankCodeHistory(personId: number | null | undefined): Observable<BankCodeHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/BANKCode/GetBankCodeHistory?";
        if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCodeHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCodeHistory(<any>response_);
                } catch (e) {
                    return <Observable<BankCodeHistoryInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankCodeHistoryInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankCodeHistory(response: HttpResponseBase): Observable<BankCodeHistoryInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankCodeHistoryInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankCodeHistoryInfo[]>(<any>null);
    }
}

@Injectable()
export class BudgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    import(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: BudgetImportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Budget/Import?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    generateReport(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GenerateBudgetReportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Budget/GenerateReport?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BusinessEntityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBusinessEntities(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BusinessEntityDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBusinessEntities?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessEntities(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessEntities(response: HttpResponseBase): Observable<BusinessEntityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTypes(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BusinessEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetTypes?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypes(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypes(response: HttpResponseBase): Observable<BusinessEntityTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityTypeDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<BusinessEntityInfoDto> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/Get?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessEntityInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessEntityInfoDto.fromJS(resultData200) : new BusinessEntityInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityInfoDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createBusinessEntity(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateBusinessEntityDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/CreateBusinessEntity?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBusinessEntity(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBusinessEntity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBusinessEntity(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateBusinessEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBusinessEntity?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBusinessEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBusinessEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @businessEntityId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, businessEntityId: number | null | undefined): Observable<BusinessEntityBankAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (businessEntityId !== undefined)
            url_ += "businessEntityId=" + encodeURIComponent("" + businessEntityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityBankAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityBankAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<BusinessEntityBankAccountDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityBankAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityBankAccountDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: BusinessEntityUpdateBankAccountsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<CacheDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<CacheDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CacheDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<CacheDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CacheDtoListResultDto.fromJS(resultData200) : new CacheDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CacheDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    clearCache(body: StringEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cacheStrings(body: { [key: string] : string[]; } | null | undefined): Observable<{ [key: string] : moment.Moment; }> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/CacheStrings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCacheStrings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCacheStrings(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : moment.Moment; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : moment.Moment; }>><any>_observableThrow(response_);
        }));
    }

    protected processCacheStrings(response: HttpResponseBase): Observable<{ [key: string] : moment.Moment; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : moment.Moment; }>(<any>null);
    }
}

@Injectable()
export class CashflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: StatsFilter | null | undefined): Observable<CashFlowStatsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowStatsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<CashFlowStatsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowStatsDto.fromJS(resultData200) : new CashFlowStatsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowInitialData(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<CashFlowInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowInitialData(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowInitialData>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowInitialData>><any>_observableThrow(response_);
        }));
    }

    protected processGetCashFlowInitialData(response: HttpResponseBase): Observable<CashFlowInitialData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowInitialData.fromJS(resultData200) : new CashFlowInitialData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getStatsDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: StatsDetailFilter | null | undefined): Observable<CashFlowStatsDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStatsDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatsDetails(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowStatsDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatsDetails(response: HttpResponseBase): Observable<CashFlowStatsDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashFlowStatsDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDetailDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowGridSettings(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<CashFlowGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowGridSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowGridSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCashFlowGridSettings(response: HttpResponseBase): Observable<CashFlowGridSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowGridSettingsDto.fromJS(resultData200) : new CashFlowGridSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowGridSettingsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    saveCashFlowGridSettings(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CashFlowGridSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/SaveCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCashFlowGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCashFlowGridSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CashFlowForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getModels(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<ForecastModelDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetModels?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModels(<any>response_);
                } catch (e) {
                    return <Observable<ForecastModelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastModelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModels(response: HttpResponseBase): Observable<ForecastModelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastModelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastModelDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    addForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AddForecastInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/AddForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddForecast(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddForecast(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    importForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ImportForecastInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/ImportForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImportForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastsInput | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecasts(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecasts(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecast(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecast(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    deleteForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastScheduleDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecastSchedule(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastScheduleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<ForecastScheduleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastSchedule(response: HttpResponseBase): Observable<ForecastScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ForecastScheduleDto.fromJS(resultData200) : new ForecastScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getForecastSchedules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<ForecastScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedules(<any>response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastSchedules(response: HttpResponseBase): Observable<ForecastScheduleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastModelInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecastModel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    renameForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RenameForecastModelInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/RenameForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CategoryTreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @includeNonCashflowNodes (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, includeNonCashflowNodes: boolean | null | undefined): Observable<GetCategoryTreeOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Get?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (includeNonCashflowNodes !== undefined)
            url_ += "includeNonCashflowNodes=" + encodeURIComponent("" + includeNonCashflowNodes) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetCategoryTreeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCategoryTreeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCategoryTreeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCategoryTreeOutput.fromJS(resultData200) : new GetCategoryTreeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryTreeOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @reportTemplate (optional) 
     * @return Success
     */
    getReportTemplateDefinition(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, reportTemplate: ReportTemplate | null | undefined): Observable<GetReportTemplateDefinitionOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/GetReportTemplateDefinition?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (reportTemplate !== undefined)
            url_ += "reportTemplate=" + encodeURIComponent("" + reportTemplate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplateDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplateDefinition(<any>response_);
                } catch (e) {
                    return <Observable<GetReportTemplateDefinitionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportTemplateDefinitionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplateDefinition(response: HttpResponseBase): Observable<GetReportTemplateDefinitionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReportTemplateDefinitionOutput.fromJS(resultData200) : new GetReportTemplateDefinitionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplateDefinitionOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCategoryInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCategoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateCategoryStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCategoryStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategoryStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategoryStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @moveToCategoryId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    deleteCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, moveToCategoryId: number | null | undefined, deleteAllReferences: boolean | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (moveToCategoryId !== undefined)
            url_ += "MoveToCategoryId=" + encodeURIComponent("" + moveToCategoryId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateAccountingTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateAccountingTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @moveToAccountingTypeId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    deleteAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, moveToAccountingTypeId: number | null | undefined, deleteAllReferences: boolean | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (moveToAccountingTypeId !== undefined)
            url_ += "MoveToAccountingTypeId=" + encodeURIComponent("" + moveToAccountingTypeId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @isOverride (optional) 
     * @body (optional) 
     * @return Success
     */
    sync(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, isOverride: boolean | null | undefined, body: SyncDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Sync?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @isOverride (optional) 
     * @body (optional) 
     * @return Success
     */
    import(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, isOverride: boolean | null | undefined, body: AccountingCategoryDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Import?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @userId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ChatMessageDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessageDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessageDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ChatMessageDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessageDtoListResultDto.fromJS(resultData200) : new ChatMessageDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessageDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClassificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    getRules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, input: GetRulesInput | null | undefined): Observable<RuleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(<any>response_);
                } catch (e) {
                    return <Observable<RuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<RuleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RuleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RuleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/CreateRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getRuleForEdit(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<EditRuleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRuleForEdit?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRuleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRuleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<EditRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRuleForEdit(response: HttpResponseBase): Observable<EditRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditRuleDto.fromJS(resultData200) : new EditRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditRuleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    editRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: EditRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/EditRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    moveRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: MoveRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/MoveRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @sourceTransactionList (optional) 
     * @applyOption (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, sourceTransactionList: number[] | null | undefined, applyOption: ApplyToTransactionsOption | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (sourceTransactionList !== undefined)
            sourceTransactionList && sourceTransactionList.forEach(item => { url_ += "SourceTransactionList=" + encodeURIComponent("" + item) + "&"; });
        if (applyOption !== undefined)
            url_ += "ApplyOption=" + encodeURIComponent("" + applyOption) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    addMapping(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AddMappingDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AddMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteMapping(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    reclassify(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RecategorizeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reclassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReclassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReclassify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReclassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    resetToDefaults(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ResetToDefaults?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetToDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetToDefaults(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetToDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    reset(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ResetClassificationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reset?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateTransactionsCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateTransactionsCategoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransactionsCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateTransactionsCategoryWithFilter(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateTransactionsCategoryWithFilterInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategoryWithFilter?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategoryWithFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategoryWithFilter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransactionsCategoryWithFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getTransactionCommonDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GetTransactionCommonDetailsInput | null | undefined): Observable<TransactionCommonDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetTransactionCommonDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionCommonDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionCommonDetails(<any>response_);
                } catch (e) {
                    return <Observable<TransactionCommonDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionCommonDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionCommonDetails(response: HttpResponseBase): Observable<TransactionCommonDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionCommonDetailsDto.fromJS(resultData200) : new TransactionCommonDetailsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCommonDetailsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    autoClassify(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AutoClassifyDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AutoClassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoClassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoClassify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAutoClassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    changeCategoryForRules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ChangeCategoryForRulesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ChangeCategoryForRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCategoryForRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCategoryForRules(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeCategoryForRules(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getKeyAttributeValues(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GetKeyAttributeValuesInput | null | undefined): Observable<AttributeValuesDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetKeyAttributeValues?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyAttributeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyAttributeValues(<any>response_);
                } catch (e) {
                    return <Observable<AttributeValuesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttributeValuesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyAttributeValues(response: HttpResponseBase): Observable<AttributeValuesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AttributeValuesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttributeValuesDto[]>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @threadId (optional) 
     * @return Success
     */
    getComments(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, threadId: number | null | undefined): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/GetComments?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(<any>response_);
                } catch (e) {
                    return <Observable<CommentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCommentInput | null | undefined): Observable<CreateCommentOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(<any>response_);
                } catch (e) {
                    return <Observable<CreateCommentOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCommentOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<CreateCommentOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCommentOutput.fromJS(resultData200) : new CreateCommentOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCommentOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCommentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/UpdateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @commentId (optional) 
     * @return Success
     */
    deleteComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, commentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/DeleteComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createTransactionCommentThread(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateTransactionCommentThreadInput | null | undefined): Observable<CreateTransactionCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateTransactionCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransactionCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransactionCommentThread(<any>response_);
                } catch (e) {
                    return <Observable<CreateTransactionCommentThreadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateTransactionCommentThreadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTransactionCommentThread(response: HttpResponseBase): Observable<CreateTransactionCommentThreadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateTransactionCommentThreadOutput.fromJS(resultData200) : new CreateTransactionCommentThreadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTransactionCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createCashFlowCommentThread(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCashFlowCommentThreadInput | null | undefined): Observable<CreateCashFlowCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateCashFlowCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCashFlowCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCashFlowCommentThread(<any>response_);
                } catch (e) {
                    return <Observable<CreateCashFlowCommentThreadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCashFlowCommentThreadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCashFlowCommentThread(response: HttpResponseBase): Observable<CreateCashFlowCommentThreadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCashFlowCommentThreadOutput.fromJS(resultData200) : new CreateCashFlowCommentThreadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCashFlowCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    setResolved(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: SetResolvedInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/SetResolved?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetResolved(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetResolved(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetResolved(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPendingCommissionContacts(): Observable<PendingCommissionContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/GetPendingCommissionContacts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingCommissionContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingCommissionContacts(<any>response_);
                } catch (e) {
                    return <Observable<PendingCommissionContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PendingCommissionContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingCommissionContacts(response: HttpResponseBase): Observable<PendingCommissionContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PendingCommissionContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingCommissionContactInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCommissionableAmount(body: UpdateCommissionableAmountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionableAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionableAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionableAmount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommissionableAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCommissionRate(body: UpdateCommissionRateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionRate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommissionRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCommissionAffiliate(body: UpdateCommissionAffiliateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/UpdateCommissionAffiliate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionAffiliate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionAffiliate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommissionAffiliate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancelCommissions(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CancelCommissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelCommissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelCommissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelCommissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    recordEarnings(body: RecordEarningsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/RecordEarnings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecordEarnings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecordEarnings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecordEarnings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    requestWithdrawal(body: RequestWithdrawalInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/RequestWithdrawal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestWithdrawal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestWithdrawal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestWithdrawal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    completeWithdrawals(body: CompleteWithdrawalInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CompleteWithdrawals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteWithdrawals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteWithdrawals(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteWithdrawals(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approveLedger(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/ApproveLedger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveLedger(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveLedger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancelLedger(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Commission/CancelLedger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLedger(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLedger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscribableEditionComboboxItemDtoListResultDto.fromJS(resultData200) : new SubscribableEditionComboboxItemDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | null | undefined): Observable<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoPagedResultDto.fromJS(resultData200) : new NameValueDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class CommonUserInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompany(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/CommonUserInfo/GetCompany";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactInfo(contactId: number | null | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfo(<any>response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfo(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactInfoDto.fromJS(resultData200) : new ContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(<any>null);
    }

    /**
     * @affiliateCode (optional) 
     * @return Success
     */
    getAffiliateInfo(affiliateCode: string | null | undefined): Observable<GetAffiliateInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAffiliateInfo?";
        if (affiliateCode !== undefined)
            url_ += "affiliateCode=" + encodeURIComponent("" + affiliateCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetAffiliateInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAffiliateInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateInfo(response: HttpResponseBase): Observable<GetAffiliateInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAffiliateInfoOutput.fromJS(resultData200) : new GetAffiliateInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAffiliateInfoOutput>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactLastModificationInfo(contactId: number | null | undefined): Observable<ContactLastModificationInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactLastModificationInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLastModificationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLastModificationInfo(<any>response_);
                } catch (e) {
                    return <Observable<ContactLastModificationInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactLastModificationInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactLastModificationInfo(response: HttpResponseBase): Observable<ContactLastModificationInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactLastModificationInfoDto.fromJS(resultData200) : new ContactLastModificationInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLastModificationInfoDto>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactDetails(contactId: number | null | undefined): Observable<ContactDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactDetails?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactDetails(<any>response_);
                } catch (e) {
                    return <Observable<ContactDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactDetails(response: HttpResponseBase): Observable<ContactDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactDetailsDto.fromJS(resultData200) : new ContactDetailsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDetailsDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getContactInfoForUser(userId: number | null | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfoForUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForUser(<any>response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfoForUser(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactInfoDto.fromJS(resultData200) : new ContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getContactShortInfoForUser(userId: number | null | undefined): Observable<ContactShortInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactShortInfoForUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactShortInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactShortInfoForUser(<any>response_);
                } catch (e) {
                    return <Observable<ContactShortInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactShortInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactShortInfoForUser(response: HttpResponseBase): Observable<ContactShortInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactShortInfo.fromJS(resultData200) : new ContactShortInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactShortInfo>(<any>null);
    }

    /**
     * @contactLeadId (optional) 
     * @targetContactLeadId (optional) 
     * @leadContactGroupId (optional) 
     * @return Success
     */
    getContactInfoForMerge(contactId: number, contactLeadId: number | null | undefined, targetContactId: number, targetContactLeadId: number | null | undefined, leadContactGroupId: string | null | undefined): Observable<GetContactInfoForMergeOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfoForMerge?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (contactLeadId !== undefined)
            url_ += "ContactLeadId=" + encodeURIComponent("" + contactLeadId) + "&"; 
        if (targetContactId === undefined || targetContactId === null)
            throw new Error("The parameter 'targetContactId' must be defined and cannot be null.");
        else
            url_ += "TargetContactId=" + encodeURIComponent("" + targetContactId) + "&"; 
        if (targetContactLeadId !== undefined)
            url_ += "TargetContactLeadId=" + encodeURIComponent("" + targetContactLeadId) + "&"; 
        if (leadContactGroupId !== undefined)
            url_ += "LeadContactGroupId=" + encodeURIComponent("" + leadContactGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForMerge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForMerge(<any>response_);
                } catch (e) {
                    return <Observable<GetContactInfoForMergeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactInfoForMergeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfoForMerge(response: HttpResponseBase): Observable<GetContactInfoForMergeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetContactInfoForMergeOutput.fromJS(resultData200) : new GetContactInfoForMergeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactInfoForMergeOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSourceContactInfo(contactId: number): Observable<GetSourceContactInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSourceContactInfo?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceContactInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetSourceContactInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSourceContactInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSourceContactInfo(response: HttpResponseBase): Observable<GetSourceContactInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSourceContactInfoOutput.fromJS(resultData200) : new GetSourceContactInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSourceContactInfoOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateContact(body: CreateOrUpdateContactInput | null | undefined): Observable<CreateOrUpdateContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/CreateOrUpdateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateContact(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrUpdateContactOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrUpdateContactOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateContact(response: HttpResponseBase): Observable<CreateOrUpdateContactOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrUpdateContactOutput.fromJS(resultData200) : new CreateOrUpdateContactOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateContactOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    mergeContact(body: MergeContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/MergeContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @forceDelete (optional) 
     * @notifyUser (optional) 
     * @return Success
     */
    deleteContact(id: number | null | undefined, forceDelete: boolean | null | undefined, notifyUser: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/DeleteContact?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (forceDelete !== undefined)
            url_ += "ForceDelete=" + encodeURIComponent("" + forceDelete) + "&"; 
        if (notifyUser !== undefined)
            url_ += "NotifyUser=" + encodeURIComponent("" + notifyUser) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @namePrefix (optional) 
     * @firstName (optional) 
     * @middleName (optional) 
     * @lastName (optional) 
     * @nameSuffix (optional) 
     * @companyName (optional) 
     * @emailAddresses (optional) 
     * @phoneNumbers (optional) 
     * @streetAddress (optional) 
     * @city (optional) 
     * @stateId (optional) 
     * @zip (optional) 
     * @countryId (optional) 
     * @groupId (optional) 
     * @return Success
     */
    getSimilarContacts(namePrefix: string | null | undefined, firstName: string | null | undefined, middleName: string | null | undefined, lastName: string | null | undefined, nameSuffix: string | null | undefined, companyName: string | null | undefined, emailAddresses: string[] | null | undefined, phoneNumbers: string[] | null | undefined, streetAddress: string | null | undefined, city: string | null | undefined, stateId: string | null | undefined, zip: string | null | undefined, countryId: string | null | undefined, groupId: string | null | undefined): Observable<SimilarContactOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSimilarContacts?";
        if (namePrefix !== undefined)
            url_ += "NamePrefix=" + encodeURIComponent("" + namePrefix) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (middleName !== undefined)
            url_ += "MiddleName=" + encodeURIComponent("" + middleName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (nameSuffix !== undefined)
            url_ += "NameSuffix=" + encodeURIComponent("" + nameSuffix) + "&"; 
        if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&"; 
        if (emailAddresses !== undefined)
            emailAddresses && emailAddresses.forEach(item => { url_ += "EmailAddresses=" + encodeURIComponent("" + item) + "&"; });
        if (phoneNumbers !== undefined)
            phoneNumbers && phoneNumbers.forEach(item => { url_ += "PhoneNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (streetAddress !== undefined)
            url_ += "StreetAddress=" + encodeURIComponent("" + streetAddress) + "&"; 
        if (city !== undefined)
            url_ += "City=" + encodeURIComponent("" + city) + "&"; 
        if (stateId !== undefined)
            url_ += "StateId=" + encodeURIComponent("" + stateId) + "&"; 
        if (zip !== undefined)
            url_ += "Zip=" + encodeURIComponent("" + zip) + "&"; 
        if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&"; 
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimilarContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimilarContacts(<any>response_);
                } catch (e) {
                    return <Observable<SimilarContactOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimilarContactOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSimilarContacts(response: HttpResponseBase): Observable<SimilarContactOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SimilarContactOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimilarContactOutput[]>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @leadId (optional) 
     * @includeProspective (optional) 
     * @return Success
     */
    getSourceContacts(searchPhrase: string | null | undefined, leadId: number | null | undefined, includeProspective: boolean | null | undefined, topCount: number): Observable<SourceContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSourceContacts?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (leadId !== undefined)
            url_ += "LeadId=" + encodeURIComponent("" + leadId) + "&"; 
        if (includeProspective !== undefined)
            url_ += "IncludeProspective=" + encodeURIComponent("" + includeProspective) + "&"; 
        if (topCount === undefined || topCount === null)
            throw new Error("The parameter 'topCount' must be defined and cannot be null.");
        else
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSourceContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSourceContacts(<any>response_);
                } catch (e) {
                    return <Observable<SourceContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SourceContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSourceContacts(response: HttpResponseBase): Observable<SourceContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SourceContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SourceContactInfo[]>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @hasUserAccount (optional) 
     * @exceptUserIds (optional) 
     * @excludeSubContacts (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined, hasUserAccount: boolean | null | undefined, exceptUserIds: number[] | null | undefined, excludeSubContacts: boolean | null | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&"; 
        if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactStatus(body: UpdateContactStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactStatuses(body: UpdateContactStatusesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatuses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactStatuses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getContactGroups(): Observable<ContactGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactGroups(<any>response_);
                } catch (e) {
                    return <Observable<ContactGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactGroups(response: HttpResponseBase): Observable<ContactGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGroupDto[]>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsers(contactGroupId: string, searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAllowedAssignableUsers?";
        if (contactGroupId === undefined || contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' must be defined and cannot be null.");
        else
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllowedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getAffiliateHistory(contactId: number | null | undefined): Observable<AffiliateInfoHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAffiliateHistory?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAffiliateHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAffiliateHistory(<any>response_);
                } catch (e) {
                    return <Observable<AffiliateInfoHistoryInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AffiliateInfoHistoryInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAffiliateHistory(response: HttpResponseBase): Observable<AffiliateInfoHistoryInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AffiliateInfoHistoryInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffiliateInfoHistoryInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUser(body: AssignUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUserForEach(body: AssignUserForEachInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUserForEach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUserForEach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUserForEach(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUserForEach(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateCode(body: UpdateContactAffiliateCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateRate(body: UpdateContactAffiliateRateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateRate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateRate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateIsAdvisor(body: UpdateAffiliateIsAdvisorInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateIsAdvisor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateIsAdvisor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateIsAdvisor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateIsAdvisor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateXref(body: UpdateContactXrefInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateXref";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateXref(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateXref(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateXref(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCustomFields(body: UpdateContactCustomFieldsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateCustomFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomFields(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCustomFields(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateContact(body: UpdateAffiliateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateAffiliateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendReferralPartnersEmail(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/SendReferralPartnersEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReferralPartnersEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReferralPartnersEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendReferralPartnersEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    isAccessible(contactId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/IsAccessible?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsAccessible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsAccessible(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsAccessible(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ContactAddressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactAddress(body: CreateContactAddressInput | null | undefined): Observable<CreateContactAddressOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/CreateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactAddressOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactAddressOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactAddress(response: HttpResponseBase): Observable<CreateContactAddressOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactAddressOutput.fromJS(resultData200) : new CreateContactAddressOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactAddressOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactAddress(body: UpdateContactAddressInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/UpdateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactAddress(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/DeleteContactAddress?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressUsageTypes(): Observable<AddressUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<AddressUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressUsageTypes(response: HttpResponseBase): Observable<AddressUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AddressUsageTypeDtoListResultDto.fromJS(resultData200) : new AddressUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressUsageTypeDtoListResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressOwnershipTypes(): Observable<AddressOwnershipTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressOwnershipTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressOwnershipTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressOwnershipTypes(<any>response_);
                } catch (e) {
                    return <Observable<AddressOwnershipTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressOwnershipTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressOwnershipTypes(response: HttpResponseBase): Observable<AddressOwnershipTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AddressOwnershipTypeDtoListResultDto.fromJS(resultData200) : new AddressOwnershipTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressOwnershipTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactCommunicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMessage(id: number, contactId: number): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetMessage?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessage(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessage(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MessageDto.fromJS(resultData200) : new MessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageDto>(<any>null);
    }

    /**
     * @parentId (optional) 
     * @userId (optional) 
     * @filter (optional) 
     * @deliveryType (optional) 
     * @status (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getMessages(contactId: number, parentId: number | null | undefined, userId: number | null | undefined, filter: string | null | undefined, deliveryType: CommunicationMessageDeliveryType | null | undefined, status: CommunicationMessageSendingStatus | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<MessageListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetMessages?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (deliveryType !== undefined)
            url_ += "DeliveryType=" + encodeURIComponent("" + deliveryType) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(<any>response_);
                } catch (e) {
                    return <Observable<MessageListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MessageListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<MessageListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MessageListDtoPagedResultDto.fromJS(resultData200) : new MessageListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageListDtoPagedResultDto>(<any>null);
    }

    /**
     * @templateId (optional) 
     * @return Success
     */
    getEmailData(templateId: number | null | undefined, contactId: number): Observable<GetEmailDataOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetEmailData?";
        if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&"; 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailData(<any>response_);
                } catch (e) {
                    return <Observable<GetEmailDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmailDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailData(response: HttpResponseBase): Observable<GetEmailDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmailDataOutput.fromJS(resultData200) : new GetEmailDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailDataOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    saveAttachment(body: Body | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SaveAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAttachment(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAttachment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getAttachmentLink(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/GetAttachmentLink?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentLink(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttachmentLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteAttachment(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/DeleteAttachment?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttachment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendEmail(body: SendEmailInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendSMS(body: SendSMSInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactCommunication/SendSMS";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSMS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSMS(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSendSMS(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class ContactEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactEmail(body: CreateContactEmailInput | null | undefined): Observable<CreateContactEmailOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/CreateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactEmailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactEmailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactEmail(response: HttpResponseBase): Observable<CreateContactEmailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactEmailOutput.fromJS(resultData200) : new CreateContactEmailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactEmailOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactEmail(body: UpdateContactEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/UpdateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactEmail(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/DeleteContactEmail?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEmailUsageTypes(): Observable<EmailUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/GetEmailUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<EmailUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailUsageTypes(response: HttpResponseBase): Observable<EmailUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmailUsageTypeDtoListResultDto.fromJS(resultData200) : new EmailUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailUsageTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactLink(body: CreateContactLinkInput | null | undefined): Observable<CreateContactLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/CreateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactLink(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactLink(response: HttpResponseBase): Observable<CreateContactLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactLinkOutput.fromJS(resultData200) : new CreateContactLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactLinkOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactLink(body: UpdateContactLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/UpdateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactLink(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/DeleteContactLink?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getContactLinkTypes(): Observable<ContactLinkTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/GetContactLinkTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLinkTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLinkTypes(<any>response_);
                } catch (e) {
                    return <Observable<ContactLinkTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactLinkTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactLinkTypes(response: HttpResponseBase): Observable<ContactLinkTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactLinkTypeDtoListResultDto.fromJS(resultData200) : new ContactLinkTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLinkTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactLists(body: UpdateContactListsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/UpdateContactLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addContactsToLists(body: AddContactsToListsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/AddContactsToLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContactsToLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContactsToLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddContactsToLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactIds (optional) 
     * @listIds (optional) 
     * @return Success
     */
    removeContactsFromLists(contactIds: number[] | null | undefined, listIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/RemoveContactsFromLists?";
        if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "ContactIds=" + encodeURIComponent("" + item) + "&"; });
        if (listIds !== undefined)
            listIds && listIds.forEach(item => { url_ += "ListIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContactsFromLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContactsFromLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveContactsFromLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: UpdateContactListInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moveToListId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToListId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToListId !== undefined)
            url_ += "MoveToListId=" + encodeURIComponent("" + moveToListId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactPhoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactPhones(contactId: number | null | undefined): Observable<ContactPhoneInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetContactPhones?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactPhones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactPhones(<any>response_);
                } catch (e) {
                    return <Observable<ContactPhoneInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactPhoneInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactPhones(response: HttpResponseBase): Observable<ContactPhoneInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactPhoneInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactPhoneInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactPhone(body: CreateContactPhoneInput | null | undefined): Observable<CreateContactPhoneOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/CreateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactPhoneOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactPhoneOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactPhone(response: HttpResponseBase): Observable<CreateContactPhoneOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactPhoneOutput.fromJS(resultData200) : new CreateContactPhoneOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactPhoneOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactPhone(body: UpdateContactPhoneInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/UpdateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactPhone(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/DeleteContactPhone?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPhoneUsageTypes(): Observable<PhoneUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetPhoneUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhoneUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhoneUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<PhoneUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhoneUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhoneUsageTypes(response: HttpResponseBase): Observable<PhoneUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhoneUsageTypeDtoListResultDto.fromJS(resultData200) : new PhoneUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhoneUsageTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactPhotoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactPhoto(body: CreateContactPhotoInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/CreateContactPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearContactPhoto(contactId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/ClearContactPhoto?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearContactPhoto(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearContactPhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRatings(): Observable<ContactRatingInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(<any>response_);
                } catch (e) {
                    return <Observable<ContactRatingInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactRatingInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<ContactRatingInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactRatingInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactRatingInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rateContact(body: RateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rateContacts(body: RateContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRateContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactStarsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markContact(body: MarkContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markContacts(body: MarkContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactTags(body: UpdateContactTagsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UpdateContactTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    tagContacts(body: TagContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/TagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTagContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    untagContacts(body: UntagContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UntagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUntagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUntagContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUntagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: UpdateContactTagInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moveToTagId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToTagId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToTagId !== undefined)
            url_ += "MoveToTagId=" + encodeURIComponent("" + moveToTagId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    requestAutoLoginToken(userKey: string): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactUser/RequestAutoLoginToken?";
        if (userKey === undefined || userKey === null)
            throw new Error("The parameter 'userKey' must be defined and cannot be null.");
        else
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestAutoLoginToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestAutoLoginToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRequestAutoLoginToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @code (optional) 
     * @return Success
     */
    getCountryStates(code: string | null | undefined): Observable<CountryStateDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountryStates?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryStates(<any>response_);
                } catch (e) {
                    return <Observable<CountryStateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryStateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountryStates(response: HttpResponseBase): Observable<CountryStateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryStateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryStateDto[]>(<any>null);
    }
}

@Injectable()
export class CreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @reportId (optional) 
     * @return Success
     */
    downloadCreditReport(reportId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Reports/CreditReport/DownloadCreditReport?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadCreditReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @dateTime (optional) 
     * @return Success
     */
    getLastCreditReport(dateTime: moment.Moment | null | undefined): Observable<CreditReportOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetLastCreditReport?";
        if (dateTime !== undefined)
            url_ += "DateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<CreditReportOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreditReportOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCreditReport(response: HttpResponseBase): Observable<CreditReportOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreditReportOutput.fromJS(resultData200) : new CreditReportOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditReportOutput>(<any>null);
    }

    /**
     * @creditReport (optional) 
     * @accountIds (optional) 
     * @return Success
     */
    getAccountInfo(creditReport: number | null | undefined, accountIds: number[] | null | undefined): Observable<AccountInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetAccountInfo?";
        if (creditReport !== undefined)
            url_ += "creditReport=" + encodeURIComponent("" + creditReport) + "&"; 
        if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "accountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfo(<any>response_);
                } catch (e) {
                    return <Observable<AccountInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountInfo(response: HttpResponseBase): Observable<AccountInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AccountInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountInfoDto[]>(<any>null);
    }

    /**
     * @periodYears (optional) 
     * @reportId (optional) 
     * @return Success
     */
    getCreditReportHistory(periodYears: number | null | undefined, reportId: number | null | undefined): Observable<BureauScoreHistoryDtoListKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetCreditReportHistory?";
        if (periodYears !== undefined)
            url_ += "periodYears=" + encodeURIComponent("" + periodYears) + "&"; 
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReportHistory(<any>response_);
                } catch (e) {
                    return <Observable<BureauScoreHistoryDtoListKeyValuePair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BureauScoreHistoryDtoListKeyValuePair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreditReportHistory(response: HttpResponseBase): Observable<BureauScoreHistoryDtoListKeyValuePair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BureauScoreHistoryDtoListKeyValuePair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BureauScoreHistoryDtoListKeyValuePair[]>(<any>null);
    }

    /**
     * @return Success
     */
    loadAlerts(): Observable<AlertDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/LoadAlerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAlerts(<any>response_);
                } catch (e) {
                    return <Observable<AlertDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AlertDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoadAlerts(response: HttpResponseBase): Observable<AlertDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AlertDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AlertDto[]>(<any>null);
    }
}

@Injectable()
export class CreditSimulatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getScoreSimulatorInfo(): Observable<ScoreSimulatorInfoDto> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/GetScoreSimulatorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScoreSimulatorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScoreSimulatorInfo(<any>response_);
                } catch (e) {
                    return <Observable<ScoreSimulatorInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScoreSimulatorInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScoreSimulatorInfo(response: HttpResponseBase): Observable<ScoreSimulatorInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScoreSimulatorInfoDto.fromJS(resultData200) : new ScoreSimulatorInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScoreSimulatorInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    simulateScore(body: ScoreSimulatorDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/SimulateScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulateScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulateScore(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSimulateScore(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CurrencyInfo[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Currency/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CurrencyInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CurrencyInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyInfo[]>(<any>null);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @hasUserAccount (optional) 
     * @exceptUserIds (optional) 
     * @excludeSubContacts (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined, hasUserAccount: boolean | null | undefined, exceptUserIds: number[] | null | undefined, excludeSubContacts: boolean | null | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Customer/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&"; 
        if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIds (optional) 
     * @return Success
     */
    getAccountTotals(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountIds: number[] | null | undefined, currencyId: string): Observable<AccountTotals> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetAccountTotals?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTotals(<any>response_);
                } catch (e) {
                    return <Observable<AccountTotals>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountTotals>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountTotals(response: HttpResponseBase): Observable<AccountTotals> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountTotals.fromJS(resultData200) : new AccountTotals();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTotals>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIds (optional) 
     * @return Success
     */
    getCategorizationStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currencyId: string, bankAccountIds: number[] | null | undefined): Observable<CategorizationStatus> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetCategorizationStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategorizationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategorizationStatus(<any>response_);
                } catch (e) {
                    return <Observable<CategorizationStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategorizationStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategorizationStatus(response: HttpResponseBase): Observable<CategorizationStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategorizationStatus.fromJS(resultData200) : new CategorizationStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategorizationStatus>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIdsString (optional) 
     * @startDate (optional) 
     * @return Success
     */
    getDailyBalanceStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountIdsString: string | null | undefined, currencyId: string, startDate: moment.Moment | null | undefined, endDate: moment.Moment): Observable<GetDailyBalanceStatsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetDailyBalanceStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountIdsString !== undefined)
            url_ += "BankAccountIdsString=" + encodeURIComponent("" + bankAccountIdsString) + "&"; 
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailyBalanceStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailyBalanceStats(<any>response_);
                } catch (e) {
                    return <Observable<GetDailyBalanceStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailyBalanceStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailyBalanceStats(response: HttpResponseBase): Observable<GetDailyBalanceStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDailyBalanceStatsOutput.fromJS(resultData200) : new GetDailyBalanceStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailyBalanceStatsOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @maxCount (optional) 
     * @bankAccountIdsString (optional) 
     * @startDate (optional) 
     * @return Success
     */
    getSpendingCategories(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, maxCount: number | null | undefined, bankAccountIdsString: string | null | undefined, currencyId: string, startDate: moment.Moment | null | undefined, endDate: moment.Moment): Observable<GetSpendingCategoriesOutput[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetSpendingCategories?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (maxCount !== undefined)
            url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&"; 
        if (bankAccountIdsString !== undefined)
            url_ += "BankAccountIdsString=" + encodeURIComponent("" + bankAccountIdsString) + "&"; 
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpendingCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpendingCategories(<any>response_);
                } catch (e) {
                    return <Observable<GetSpendingCategoriesOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSpendingCategoriesOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpendingCategories(response: HttpResponseBase): Observable<GetSpendingCategoriesOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetSpendingCategoriesOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSpendingCategoriesOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getTotals(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetTotals?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotals(response: HttpResponseBase): Observable<GetTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTotalsOutput.fromJS(resultData200) : new GetTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTotalsOutput>(<any>null);
    }

    /**
     * @groupBy (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @periodCount (optional) 
     * @isCumulative (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getCustomerAndLeadStats(groupBy: GroupByPeriod | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, periodCount: number | null | undefined, isCumulative: boolean | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetCustomerAndLeadStatsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomerAndLeadStats?";
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (periodCount !== undefined)
            url_ += "PeriodCount=" + encodeURIComponent("" + periodCount) + "&"; 
        if (isCumulative !== undefined)
            url_ += "IsCumulative=" + encodeURIComponent("" + isCumulative) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAndLeadStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAndLeadStats(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAndLeadStats(response: HttpResponseBase): Observable<GetCustomerAndLeadStatsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCustomerAndLeadStatsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAndLeadStatsOutput[]>(<any>null);
    }

    /**
     * @groupBy (optional) 
     * @periodCount (optional) 
     * @isCumulative (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactAndLeadStats(groupBy: GroupByPeriod | null | undefined, periodCount: number | null | undefined, isCumulative: boolean | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetCustomerAndLeadStatsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactAndLeadStats?";
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        if (periodCount !== undefined)
            url_ += "PeriodCount=" + encodeURIComponent("" + periodCount) + "&"; 
        if (isCumulative !== undefined)
            url_ += "IsCumulative=" + encodeURIComponent("" + isCumulative) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactAndLeadStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactAndLeadStats(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactAndLeadStats(response: HttpResponseBase): Observable<GetCustomerAndLeadStatsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCustomerAndLeadStatsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAndLeadStatsOutput[]>(<any>null);
    }

    /**
     * @topCount (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getRecentlyCreatedCustomers(topCount: number | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetRecentlyCreatedCustomersOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetRecentlyCreatedCustomers?";
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedCustomers(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentlyCreatedCustomersOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentlyCreatedCustomersOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyCreatedCustomers(response: HttpResponseBase): Observable<GetRecentlyCreatedCustomersOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetRecentlyCreatedCustomersOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentlyCreatedCustomersOutput[]>(<any>null);
    }

    /**
     * @topCount (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getRecentlyCreatedLeads(topCount: number | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetRecentlyCreatedLeadsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetRecentlyCreatedLeads?";
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedLeads(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentlyCreatedLeadsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentlyCreatedLeadsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyCreatedLeads(response: HttpResponseBase): Observable<GetRecentlyCreatedLeadsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetRecentlyCreatedLeadsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentlyCreatedLeadsOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByCompanySize(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetContactsByCompanySizeOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByCompanySize?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByCompanySize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByCompanySize(<any>response_);
                } catch (e) {
                    return <Observable<GetContactsByCompanySizeOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactsByCompanySizeOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsByCompanySize(response: HttpResponseBase): Observable<GetContactsByCompanySizeOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetContactsByCompanySizeOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactsByCompanySizeOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByRegion(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetContactsByRegionOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByRegion?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByRegion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByRegion(<any>response_);
                } catch (e) {
                    return <Observable<GetContactsByRegionOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactsByRegionOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsByRegion(response: HttpResponseBase): Observable<GetContactsByRegionOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetContactsByRegionOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactsByRegionOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getLeadsCountByAge(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<LeadAgeRangeGetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetLeadsCountByAge?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadsCountByAge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadsCountByAge(<any>response_);
                } catch (e) {
                    return <Observable<LeadAgeRangeGetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadAgeRangeGetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadsCountByAge(response: HttpResponseBase): Observable<LeadAgeRangeGetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LeadAgeRangeGetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadAgeRangeGetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getLeadsCountByStage(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetLeadsCountByStage?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadsCountByStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadsCountByStage(<any>response_);
                } catch (e) {
                    return <Observable<GetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadsCountByStage(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByRating(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByRating?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByRating(<any>response_);
                } catch (e) {
                    return <Observable<GetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsByRating(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactsByStar(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetCountByStarOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByStar?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByStar(<any>response_);
                } catch (e) {
                    return <Observable<GetCountByStarOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountByStarOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsByStar(response: HttpResponseBase): Observable<GetCountByStarOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountByStarOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountByStarOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactInfoStatsByStar(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<GetContactInfoStatsByStarOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactInfoStatsByStar?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoStatsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoStatsByStar(<any>response_);
                } catch (e) {
                    return <Observable<GetContactInfoStatsByStarOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactInfoStatsByStarOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfoStatsByStar(response: HttpResponseBase): Observable<GetContactInfoStatsByStarOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetContactInfoStatsByStarOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactInfoStatsByStarOutput[]>(<any>null);
    }

    /**
     * @groupBy (optional) 
     * @starNames (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @sourceOrganizationUnitIds (optional) 
     * @return Success
     */
    getContactStatsByStar(groupBy: GroupByPeriod | null | undefined, starNames: string[] | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, contactGroupId: string | null | undefined, sourceContactId: number | null | undefined, sourceOrganizationUnitIds: number[] | null | undefined): Observable<ContactsStatsByStarInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactStatsByStar?";
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        if (starNames !== undefined)
            starNames && starNames.forEach(item => { url_ += "StarNames=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactStatsByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactStatsByStar(<any>response_);
                } catch (e) {
                    return <Observable<ContactsStatsByStarInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactsStatsByStarInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactStatsByStar(response: HttpResponseBase): Observable<ContactsStatsByStarInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactsStatsByStarInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactsStatsByStarInfo[]>(<any>null);
    }

    /**
     * @contactGroupId (optional) 
     * @sourceContactId (optional) 
     * @return Success
     */
    getStatus(contactGroupId: string | null | undefined, sourceContactId: number | null | undefined): Observable<GetCRMStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetStatus?";
        if (contactGroupId !== undefined)
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (sourceContactId !== undefined)
            url_ += "SourceContactId=" + encodeURIComponent("" + sourceContactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetCRMStatusOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCRMStatusOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetCRMStatusOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCRMStatusOutput.fromJS(resultData200) : new GetCRMStatusOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCRMStatusOutput>(<any>null);
    }
}

@Injectable()
export class DepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getAccessibleDepartments(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Departments/GetAccessibleDepartments?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessibleDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessibleDepartments(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccessibleDepartments(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPartnerTypes(): Observable<PartnerTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetPartnerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerTypes(<any>response_);
                } catch (e) {
                    return <Observable<PartnerTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartnerTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartnerTypes(response: HttpResponseBase): Observable<PartnerTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartnerTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStars(): Observable<ContactStarInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetStars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStars(<any>response_);
                } catch (e) {
                    return <Observable<ContactStarInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactStarInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStars(response: HttpResponseBase): Observable<ContactStarInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactStarInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactStarInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTags(): Observable<ContactTagInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<ContactTagInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactTagInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<ContactTagInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactTagInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactTagInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLists(): Observable<ContactListInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLists(<any>response_);
                } catch (e) {
                    return <Observable<ContactListInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLists(response: HttpResponseBase): Observable<ContactListInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactListInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationTypes(): Observable<OrganizationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationTypes(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationTypes(response: HttpResponseBase): Observable<OrganizationTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getInterests(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetInterests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInterests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInterests(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInterests(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @partnersOnly (optional) 
     * @return Success
     */
    getOrganizationUnits(searchPhrase: string | null | undefined, topCount: number | null | undefined, partnersOnly: boolean | null | undefined): Observable<OrganizationUnitShortDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationUnits?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (partnersOnly !== undefined)
            url_ += "PartnersOnly=" + encodeURIComponent("" + partnersOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitShortDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitShortDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitShortDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitShortDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitShortDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultOrganizationUnit(): Observable<OrganizationUnitShortDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetDefaultOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitShortDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitShortDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitShortDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitShortDto.fromJS(resultData200) : new OrganizationUnitShortDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitShortDto>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getAll(contactId: number | null | undefined): Observable<DocumentInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetAll?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DocumentInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentInfo[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getContent(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetContent?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContent(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetContent(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUrl(id: string | null | undefined): Observable<GetUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetUrl?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUrlOutput.fromJS(resultData200) : new GetUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUrlOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    upload(body: UploadDocumentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateType(body: UpdateTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    copyTemplate(body: CopyTemplateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/CopyTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCopyTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @documentId (optional) 
     * @return Success
     */
    getViewWopiRequestInfo(documentId: string | null | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetViewWopiRequestInfo?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewWopiRequestInfo(<any>response_);
                } catch (e) {
                    return <Observable<WopiRequestOutcoming>><any>_observableThrow(e);
                }
            } else
                return <Observable<WopiRequestOutcoming>><any>_observableThrow(response_);
        }));
    }

    protected processGetViewWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WopiRequestOutcoming.fromJS(resultData200) : new WopiRequestOutcoming();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(<any>null);
    }

    /**
     * @documentId (optional) 
     * @return Success
     */
    getEditWopiRequestInfo(documentId: string | null | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetEditWopiRequestInfo?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditWopiRequestInfo(<any>response_);
                } catch (e) {
                    return <Observable<WopiRequestOutcoming>><any>_observableThrow(e);
                }
            } else
                return <Observable<WopiRequestOutcoming>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WopiRequestOutcoming.fromJS(resultData200) : new WopiRequestOutcoming();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(<any>null);
    }
}

@Injectable()
export class DocumentTemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @folderId (optional) 
     * @infiniteValidityPeriod (optional) 
     * @return Success
     */
    getUrl(folderId: number | null | undefined, fileName: string, infiniteValidityPeriod: boolean | null | undefined): Observable<GetFileUrlDto> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentTemplates/GetUrl?";
        if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&"; 
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (infiniteValidityPeriod !== undefined)
            url_ += "infiniteValidityPeriod=" + encodeURIComponent("" + infiniteValidityPeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetFileUrlDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFileUrlDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetFileUrlDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetFileUrlDto.fromJS(resultData200) : new GetFileUrlDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFileUrlDto>(<any>null);
    }
}

@Injectable()
export class DocumentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<DocumentTypeInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentTypeInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentTypeInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateDocumentTypeInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateDocumentTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<EditionListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<EditionListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<EditionListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionListDtoListResultDto.fromJS(resultData200) : new EditionListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionListDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateEdition(body: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @selectedEditionId (optional) 
     * @addAllItem (optional) 
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class EmailingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    payload(recipientUserId: number, recipientHash: string, emailType: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Emailing/Payload?";
        if (recipientUserId === undefined || recipientUserId === null)
            throw new Error("The parameter 'recipientUserId' must be defined and cannot be null.");
        else
            url_ += "recipientUserId=" + encodeURIComponent("" + recipientUserId) + "&"; 
        if (recipientHash === undefined || recipientHash === null)
            throw new Error("The parameter 'recipientHash' must be defined and cannot be null.");
        else
            url_ += "recipientHash=" + encodeURIComponent("" + recipientHash) + "&"; 
        if (emailType === undefined || emailType === null)
            throw new Error("The parameter 'emailType' must be defined and cannot be null.");
        else
            url_ += "emailType=" + encodeURIComponent("" + emailType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPayload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    createIAgeMembers(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Emailing/CreateIAgeMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIAgeMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIAgeMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIAgeMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EmailSmtpSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/EmailSmtpSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EmailTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @type (optional) 
     * @return Success
     */
    getTemplates(type: EmailTemplateType | null | undefined): Observable<GetTemplatesResponse[]> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/GetTemplates?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(<any>response_);
                } catch (e) {
                    return <Observable<GetTemplatesResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTemplatesResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<GetTemplatesResponse[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetTemplatesResponse.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplatesResponse[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTemplate(id: number | null | undefined): Observable<GetTemplateReponse> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/GetTemplate?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplate(<any>response_);
                } catch (e) {
                    return <Observable<GetTemplateReponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTemplateReponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetTemplate(response: HttpResponseBase): Observable<GetTemplateReponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTemplateReponse.fromJS(resultData200) : new GetTemplateReponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTemplateReponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateEmailTemplateRequest | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateEmailTemplateRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/EmailTemplate/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSubscriptions(): Observable<EventSubscriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/GetSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<EventSubscriptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventSubscriptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptions(response: HttpResponseBase): Observable<EventSubscriptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventSubscriptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventSubscriptionDto[]>(<any>null);
    }

    /**
     * @eventSubscriptionId (optional) 
     * @searchString (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEventExecutions(eventSubscriptionId: number | null | undefined, searchString: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<EventJobExecutionDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/GetEventExecutions?";
        if (eventSubscriptionId !== undefined)
            url_ += "EventSubscriptionId=" + encodeURIComponent("" + eventSubscriptionId) + "&"; 
        if (searchString !== undefined)
            url_ += "SearchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventExecutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventExecutions(<any>response_);
                } catch (e) {
                    return <Observable<EventJobExecutionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventJobExecutionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventExecutions(response: HttpResponseBase): Observable<EventJobExecutionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EventJobExecutionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventJobExecutionDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    subscribe(body: SubscribeForEventInput | null | undefined): Observable<SubscribeForEventOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/Subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribe(<any>response_);
                } catch (e) {
                    return <Observable<SubscribeForEventOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribeForEventOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubscribe(response: HttpResponseBase): Observable<SubscribeForEventOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscribeForEventOutput.fromJS(resultData200) : new SubscribeForEventOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribeForEventOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    unsubscribe(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Event/Unsubscribe?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnsubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnsubscribe(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnsubscribe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ExtensionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCategories(): Observable<ExtensionCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/GetCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(<any>response_);
                } catch (e) {
                    return <Observable<ExtensionCategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtensionCategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<ExtensionCategoryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExtensionCategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtensionCategoryDto[]>(<any>null);
    }

    /**
     * @categoryId (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAll(categoryId: number | null | undefined, topCount: number | null | undefined): Observable<ExtensionDto[]> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/GetAll?";
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ExtensionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtensionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ExtensionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExtensionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtensionDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    import(body: ImportExtensionDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/HUB/Extension/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<FlatFeatureDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Feature/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FlatFeatureDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatFeatureDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FlatFeatureDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FlatFeatureDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatFeatureDto[]>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getYTelSettings(): Observable<YTelSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYTelSettings(<any>response_);
                } catch (e) {
                    return <Observable<YTelSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YTelSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetYTelSettings(response: HttpResponseBase): Observable<YTelSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? YTelSettingsEditDto.fromJS(resultData200) : new YTelSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YTelSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getTenantManagementSettings(): Observable<TenantManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetTenantManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantManagementSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantManagementSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantManagementSettings(response: HttpResponseBase): Observable<TenantManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantManagementSettingsEditDto.fromJS(resultData200) : new TenantManagementSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantManagementSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserManagementSettings(): Observable<HostUserManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostUserManagementSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostUserManagementSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserManagementSettings(response: HttpResponseBase): Observable<HostUserManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostUserManagementSettingsEditDto.fromJS(resultData200) : new HostUserManagementSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostUserManagementSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getBugsnagSettings(): Observable<BugsnagSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetBugsnagSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBugsnagSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBugsnagSettings(<any>response_);
                } catch (e) {
                    return <Observable<BugsnagSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BugsnagSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBugsnagSettings(response: HttpResponseBase): Observable<BugsnagSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BugsnagSettingsDto.fromJS(resultData200) : new BugsnagSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BugsnagSettingsDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateYTelSettings(body: YTelSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateYTelSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateYTelSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBugsnagSettings(body: BugsnagSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateBugsnagSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBugsnagSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBugsnagSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBugsnagSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTenantManagementSettings(body: TenantManagementSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateTenantManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserManagementSettings(body: HostUserManagementSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralSettings(): Observable<GeneralSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralSettings(<any>response_);
                } catch (e) {
                    return <Observable<GeneralSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralSettings(response: HttpResponseBase): Observable<GeneralSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GeneralSettingsEditDto.fromJS(resultData200) : new GeneralSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateGeneralSettings(body: GeneralSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeneralSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEmailSettings(body: EmailSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    import(body: ImportInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getStatuses(id: number | null | undefined): Observable<GetImportStatusOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetStatuses?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatuses(<any>response_);
                } catch (e) {
                    return <Observable<GetImportStatusOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetImportStatusOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatuses(response: HttpResponseBase): Observable<GetImportStatusOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetImportStatusOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImportStatusOutput[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    cancel(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Cancel?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @importId (optional) 
     * @return Success
     */
    getFileUrl(importId: number | null | undefined): Observable<GetFileUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetFileUrl?";
        if (importId !== undefined)
            url_ += "importId=" + encodeURIComponent("" + importId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetFileUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFileUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFileUrl(response: HttpResponseBase): Observable<GetFileUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetFileUrlOutput.fromJS(resultData200) : new GetFileUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFileUrlOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getMappedFields(body: string[] | null | undefined): Observable<ImportFieldInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetMappedFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappedFields(<any>response_);
                } catch (e) {
                    return <Observable<ImportFieldInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportFieldInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMappedFields(response: HttpResponseBase): Observable<ImportFieldInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ImportFieldInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportFieldInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    importContact(body: ImportContactInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/ImportContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportContact(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImportContact(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class InstanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @invalidateCache (optional) 
     * @return Success
     */
    getStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, invalidateCache: boolean | null | undefined): Observable<GetStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (invalidateCache !== undefined)
            url_ += "invalidateCache=" + encodeURIComponent("" + invalidateCache) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetStatusOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStatusOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetStatusOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStatusOutput.fromJS(resultData200) : new GetStatusOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStatusOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @accountingTreeType (optional) 
     * @return Success
     */
    setup(instanceType: InstanceType | null | undefined, accountingTreeType: AccountingTreeType | null | undefined): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/Setup?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (accountingTreeType !== undefined)
            url_ += "accountingTreeType=" + encodeURIComponent("" + accountingTreeType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<SetupOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetupOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<SetupOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetupOutput.fromJS(resultData200) : new SetupOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetupOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberInput | null | undefined): Observable<RegisterMemberOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(<any>response_);
                } catch (e) {
                    return <Observable<RegisterMemberOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterMemberOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<RegisterMemberOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterMemberOutput.fromJS(resultData200) : new RegisterMemberOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterMemberOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getUsers(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<GetUsersInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUsers?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<GetUsersInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsersInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<GetUsersInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetUsersInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsersInfoDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    addUser(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AddUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/AddUser?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    removeUser(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, userId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/RemoveUser?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getUserInstanceInfo(userId: number | null | undefined): Observable<GetUserInstanceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUserInstanceInfo?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInstanceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInstanceInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetUserInstanceInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserInstanceInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInstanceInfo(response: HttpResponseBase): Observable<GetUserInstanceInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserInstanceInfoOutput.fromJS(resultData200) : new GetUserInstanceInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserInstanceInfoOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getMaxVisibleDate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetMaxVisibleDate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxVisibleDate(<any>response_);
                } catch (e) {
                    return <Observable<moment.Moment>><any>_observableThrow(e);
                }
            } else
                return <Observable<moment.Moment>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxVisibleDate(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<moment.Moment>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @maxVisibleDate (optional) 
     * @return Success
     */
    setMaxVisibleDate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, maxVisibleDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/SetMaxVisibleDate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (maxVisibleDate !== undefined)
            url_ += "maxVisibleDate=" + encodeURIComponent(maxVisibleDate ? "" + maxVisibleDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaxVisibleDate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetMaxVisibleDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getInstanceOwnerEmailAddress(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetInstanceOwnerEmailAddress?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstanceOwnerEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstanceOwnerEmailAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstanceOwnerEmailAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @userIds (optional) 
     * @return Success
     */
    getUsersWithInstance(userIds: number[] | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUsersWithInstance?";
        if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersWithInstance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersWithInstance(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersWithInstance(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceInfo.fromJS(resultData200) : new InvoiceInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceInfo>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateInvoiceInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateInvoiceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStatus(body: UpdateInvoiceStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteInvoice(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoice?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @ids (optional) 
     * @return Success
     */
    deleteInvoices(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoices?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNewInvoiceInfo(): Observable<GetNewInvoiceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetNewInvoiceInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetNewInvoiceInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNewInvoiceInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewInvoiceInfo(response: HttpResponseBase): Observable<GetNewInvoiceInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNewInvoiceInfoOutput.fromJS(resultData200) : new GetNewInvoiceInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNewInvoiceInfoOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @regenerateNew (optional) 
     * @return Success
     */
    generatePdf(id: number | null | undefined, regenerateNew: boolean | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GeneratePdf?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (regenerateNew !== undefined)
            url_ += "regenerateNew=" + encodeURIComponent("" + regenerateNew) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePdf(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePdf(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @templateId (optional) 
     * @return Success
     */
    getEmailData(templateId: number | null | undefined, invoiceId: number): Observable<GetEmailDataOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetEmailData?";
        if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&"; 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined and cannot be null.");
        else
            url_ += "InvoiceId=" + encodeURIComponent("" + invoiceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailData(<any>response_);
                } catch (e) {
                    return <Observable<GetEmailDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmailDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailData(response: HttpResponseBase): Observable<GetEmailDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmailDataOutput.fromJS(resultData200) : new GetEmailDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmailDataOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addBankCardPayment(body: AddBankCardPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/AddBankCardPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBankCardPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBankCardPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddBankCardPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    voidBankCardPayment(body: VoidBankCardPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/VoidBankCardPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVoidBankCardPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVoidBankCardPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVoidBankCardPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getInvoiceAddresses(contactId: number | null | undefined): Observable<InvoiceAddressInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetInvoiceAddresses?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceAddresses(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceAddressInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceAddressInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceAddresses(response: HttpResponseBase): Observable<InvoiceAddressInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InvoiceAddressInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceAddressInfo[]>(<any>null);
    }
}

@Injectable()
export class KBAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    requestKBA(body: RequestKBAInput | null | undefined): Observable<RequestKBAOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/RequestKBA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestKBA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestKBA(<any>response_);
                } catch (e) {
                    return <Observable<RequestKBAOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestKBAOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRequestKBA(response: HttpResponseBase): Observable<RequestKBAOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestKBAOutput.fromJS(resultData200) : new RequestKBAOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestKBAOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    processKBAResponse(body: KBAResult | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/ProcessKBAResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessKBAResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessKBAResponse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessKBAResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<LanguageTextListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<LanguageTextListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LanguageTextListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<LanguageTextListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LanguageTextListDtoPagedResultDto.fromJS(resultData200) : new LanguageTextListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LanguageTextListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LeadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancelLead(body: CancelLeadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/CancelLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getCancellationReasons(): Observable<LeadCancellationReasonDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetCancellationReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReasons(<any>response_);
                } catch (e) {
                    return <Observable<LeadCancellationReasonDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadCancellationReasonDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCancellationReasons(response: HttpResponseBase): Observable<LeadCancellationReasonDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadCancellationReasonDtoListResultDto.fromJS(resultData200) : new LeadCancellationReasonDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadCancellationReasonDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateOrUpdateLeadInput | null | undefined): Observable<CreateOrUpdateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrUpdateLeadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrUpdateLeadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateOrUpdateLeadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrUpdateLeadOutput.fromJS(resultData200) : new CreateOrUpdateLeadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateLeadOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitTenancyRequest(body: SubmitTenancyRequestInput | null | undefined): Observable<SubmitTenancyRequestOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitTenancyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitTenancyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitTenancyRequest(<any>response_);
                } catch (e) {
                    return <Observable<SubmitTenancyRequestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitTenancyRequestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitTenancyRequest(response: HttpResponseBase): Observable<SubmitTenancyRequestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitTenancyRequestOutput.fromJS(resultData200) : new SubmitTenancyRequestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitTenancyRequestOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitFreeTrialRequest(body: SubmitFreeTrialRequestInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitFreeTrialRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitFreeTrialRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitFreeTrialRequest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitFreeTrialRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitClientRequest(body: SubmitClientRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitClientRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitClientRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitClientRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitClientRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLeadStage(body: UpdateLeadStageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeadStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLeadStagePoint(body: UpdateLeadStagePointInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadStagePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadStagePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadStagePoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeadStagePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    processLead(body: ProcessLeadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/ProcessLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @leadId (optional) 
     * @return Success
     */
    getLeadInfo(leadId: number | null | undefined): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLeadInfo?";
        if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadInfo(<any>response_);
                } catch (e) {
                    return <Observable<LeadInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadInfo(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadInfoDto.fromJS(resultData200) : new LeadInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastLeadInfo(contactGroupId: string, contactId: number): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLastLeadInfo?";
        if (contactGroupId === undefined || contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' must be defined and cannot be null.");
        else
            url_ += "contactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastLeadInfo(<any>response_);
                } catch (e) {
                    return <Observable<LeadInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastLeadInfo(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadInfoDto.fromJS(resultData200) : new LeadInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLeadInfo(body: UpdateLeadInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeadInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSourceContact(body: UpdateLeadSourceContactInput | null | undefined): Observable<UpdateLeadSourceContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceContact(<any>response_);
                } catch (e) {
                    return <Observable<UpdateLeadSourceContactOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateLeadSourceContactOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSourceContact(response: HttpResponseBase): Observable<UpdateLeadSourceContactOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateLeadSourceContactOutput.fromJS(resultData200) : new UpdateLeadSourceContactOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateLeadSourceContactOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSourceContacts(body: UpdateLeadSourceContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSourceContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSourceOrganizationUnit(body: UpdateLeadSourceOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSourceOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSourceOrganizationUnits(body: UpdateLeadSourceOrganizationUnitsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateSourceOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSourceOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSourceOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSourceOrganizationUnits(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @leadId (optional) 
     * @forceDelete (optional) 
     * @return Success
     */
    deleteLead(leadId: number | null | undefined, forceDelete: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLead?";
        if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&"; 
        if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @forceDelete (optional) 
     * @body (optional) 
     * @return Success
     */
    deleteLeads(forceDelete: boolean | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLeads?";
        if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeads(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeads(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @hasUserAccount (optional) 
     * @exceptUserIds (optional) 
     * @excludeSubContacts (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined, hasUserAccount: boolean | null | undefined, exceptUserIds: number[] | null | undefined, excludeSubContacts: boolean | null | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&"; 
        if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(<any>null);
    }

    /**
     * @stageIds (optional) 
     * @return Success
     */
    getStageChecklistPoints(leadId: number, stageIds: number[] | null | undefined): Observable<StageChecklistPointInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetStageChecklistPoints?";
        if (leadId === undefined || leadId === null)
            throw new Error("The parameter 'leadId' must be defined and cannot be null.");
        else
            url_ += "LeadId=" + encodeURIComponent("" + leadId) + "&"; 
        if (stageIds !== undefined)
            stageIds && stageIds.forEach(item => { url_ += "StageIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageChecklistPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageChecklistPoints(<any>response_);
                } catch (e) {
                    return <Observable<StageChecklistPointInfoOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StageChecklistPointInfoOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageChecklistPoints(response: HttpResponseBase): Observable<StageChecklistPointInfoOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StageChecklistPointInfoOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointInfoOutput[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateDealInfo(body: UpdateLeadDealInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateDealInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDealInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDealInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDealInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LeadTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLeadTypes(): Observable<LeadTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LeadType/GetLeadTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadTypes(<any>response_);
                } catch (e) {
                    return <Observable<LeadTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadTypes(response: HttpResponseBase): Observable<LeadTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LeadTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadTypeDto[]>(<any>null);
    }
}

@Injectable()
export class LearningResourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<LearningResourceGroupInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LearningResourceGroupInfoOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LearningResourceGroupInfoOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LearningResourceGroupInfoOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LearningResourceGroupInfoOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LearningResourceGroupInfoOutput[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateLearningResourceInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateLearningResourceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setImage(body: SetLearningResourceImageInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/SetImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetImage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSetImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LearningResource/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LinkTrackingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<LinkTrackingOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LinkTracking/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LinkTrackingOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkTrackingOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LinkTrackingOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LinkTrackingOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkTrackingOutput[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LinkTracking/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @url (optional) 
     * @return Success
     */
    addLink(url: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/LinkTracking/AddLink?";
        if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LocalizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @culture (optional) 
     * @ui_culture (optional) 
     * @return Success
     */
    getLocalizationSource(tenantId: number, sourceName: string, version: string, culture: string | null | undefined, ui_culture: string | null | undefined): Observable<LocalizationSourceDto> {
        let url_ = this.baseUrl + "/api/Localization/GetLocalizationSource?";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined and cannot be null.");
        else
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&"; 
        if (culture !== undefined)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&"; 
        if (ui_culture !== undefined)
            url_ += "ui-culture=" + encodeURIComponent("" + ui_culture) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalizationSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalizationSource(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationSourceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationSourceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalizationSource(response: HttpResponseBase): Observable<LocalizationSourceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationSourceDto.fromJS(resultData200) : new LocalizationSourceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationSourceDto>(<any>null);
    }

    /**
     * @sourceName (optional) 
     * @return Success
     */
    loadLocalizationSource(sourceName: string | null | undefined): Observable<LocalizationSourceDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Localization/LoadLocalizationSource?";
        if (sourceName !== undefined)
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadLocalizationSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadLocalizationSource(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationSourceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationSourceDto>><any>_observableThrow(response_);
        }));
    }

    protected processLoadLocalizationSource(response: HttpResponseBase): Observable<LocalizationSourceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationSourceDto.fromJS(resultData200) : new LocalizationSourceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationSourceDto>(<any>null);
    }
}

@Injectable()
export class ManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    reScheduleApplications(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Manage/ReScheduleApplications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReScheduleApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReScheduleApplications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReScheduleApplications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @packageId (optional) 
     * @return Success
     */
    selectPackage(packageId: number | null | undefined): Observable<SelectPackageResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SelectPackage?";
        if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectPackage(<any>response_);
                } catch (e) {
                    return <Observable<SelectPackageResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectPackageResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSelectPackage(response: HttpResponseBase): Observable<SelectPackageResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SelectPackageResponseDto.fromJS(resultData200) : new SelectPackageResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectPackageResponseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitMemberInfo(body: MemberInfoDto | null | undefined): Observable<SubmitMemberInfoResultDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SubmitMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<SubmitMemberInfoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitMemberInfoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitMemberInfo(response: HttpResponseBase): Observable<SubmitMemberInfoResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitMemberInfoResultDto.fromJS(resultData200) : new SubmitMemberInfoResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitMemberInfoResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    paymentAuthorize(body: MemberPaymentAuthorizeRequestDto | null | undefined): Observable<PaymentAuthorizeResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/PaymentAuthorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<PaymentAuthorizeResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentAuthorizeResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentAuthorize(response: HttpResponseBase): Observable<PaymentAuthorizeResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentAuthorizeResponseDto.fromJS(resultData200) : new PaymentAuthorizeResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAuthorizeResponseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    cancelMembership(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/CancelMembership";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelMembership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMembership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelMembership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MemberServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @includeDeactivated (optional) 
     * @return Success
     */
    getAll(includeDeactivated: boolean | null | undefined): Observable<MemberServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetAll?";
        if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MemberServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MemberServiceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MemberServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberServiceDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSystemTypes(): Observable<SystemTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetSystemTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemTypes(<any>response_);
                } catch (e) {
                    return <Observable<SystemTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSystemTypes(response: HttpResponseBase): Observable<SystemTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SystemTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSystemFeatures(systemType: string): Observable<FlatFeatureDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/GetSystemFeatures?";
        if (systemType === undefined || systemType === null)
            throw new Error("The parameter 'systemType' must be defined and cannot be null.");
        else
            url_ += "systemType=" + encodeURIComponent("" + systemType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemFeatures(<any>response_);
                } catch (e) {
                    return <Observable<FlatFeatureDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatFeatureDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSystemFeatures(response: HttpResponseBase): Observable<FlatFeatureDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FlatFeatureDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatFeatureDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdate(body: MemberServiceDto | null | undefined): Observable<CreateOrUpdateMemberServiceOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrUpdateMemberServiceOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrUpdateMemberServiceOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<CreateOrUpdateMemberServiceOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrUpdateMemberServiceOutput.fromJS(resultData200) : new CreateOrUpdateMemberServiceOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateMemberServiceOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberService/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ServiceProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @includeDeactivated (optional) 
     * @return Success
     * @deprecated
     */
    getAll(includeDeactivated: boolean | null | undefined): Observable<MemberServiceDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ServiceProduct/GetAll?";
        if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MemberServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MemberServiceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MemberServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberServiceDto[]>(<any>null);
    }
}

@Injectable()
export class MemberSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateCode(body: UpdateUserAffiliateCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberSettings/UpdateAffiliateCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBANKCode(body: UpdateUserBANKCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/MemberSettings/UpdateBANKCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBANKCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBANKCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBANKCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MemberSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @serviceType (optional) 
     * @serviceTypeId (optional) 
     * @return Success
     */
    getMemberInfo(systemType: string, serviceType: string | null | undefined, serviceTypeId: string | null | undefined): Observable<GetMemberInfoOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/MemberSubscription/GetMemberInfo?";
        if (systemType === undefined || systemType === null)
            throw new Error("The parameter 'systemType' must be defined and cannot be null.");
        else
            url_ += "SystemType=" + encodeURIComponent("" + systemType) + "&"; 
        if (serviceType !== undefined)
            url_ += "ServiceType=" + encodeURIComponent("" + serviceType) + "&"; 
        if (serviceTypeId !== undefined)
            url_ += "ServiceTypeId=" + encodeURIComponent("" + serviceTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfo(response: HttpResponseBase): Observable<GetMemberInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberInfoOutput.fromJS(resultData200) : new GetMemberInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberInfoOutput>(<any>null);
    }
}

@Injectable()
export class NotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactIds (optional) 
     * @ascendingSorting (optional) 
     * @return Success
     */
    getNotes(contactIds: number[] | null | undefined, ascendingSorting: boolean | null | undefined): Observable<NoteInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/GetNotes?";
        if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "contactIds=" + encodeURIComponent("" + item) + "&"; });
        if (ascendingSorting !== undefined)
            url_ += "ascendingSorting=" + encodeURIComponent("" + ascendingSorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotes(<any>response_);
                } catch (e) {
                    return <Observable<NoteInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NoteInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotes(response: HttpResponseBase): Observable<NoteInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NoteInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoteInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createNote(body: CreateNoteInput | null | undefined): Observable<CreateNoteOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/CreateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNote(<any>response_);
                } catch (e) {
                    return <Observable<CreateNoteOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateNoteOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNote(response: HttpResponseBase): Observable<CreateNoteOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateNoteOutput.fromJS(resultData200) : new CreateNoteOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateNoteOutput>(<any>null);
    }

    /**
     * @return Success
     */
    deleteNote(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/DeleteNote?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateNote(body: UpdateNoteInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/UpdateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    pinNote(body: PinNoteInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/PinNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPinNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPinNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPinNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unpinNote(body: UnpinNoteInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/UnpinNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpinNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpinNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnpinNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @state (optional) 
     * @return Success
     */
    getUserNotificationCount(state: UserNotificationState | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotificationCount?";
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotificationCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: GuidEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getAll(body: GetAllInput | null | undefined): Observable<OfferDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OfferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OfferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OfferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDetails(testMode: boolean, campaignId: number): Observable<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetDetails?";
        if (testMode === undefined || testMode === null)
            throw new Error("The parameter 'testMode' must be defined and cannot be null.");
        else
            url_ += "TestMode=" + encodeURIComponent("" + testMode) + "&"; 
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<OfferDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<OfferDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferDetailsDto.fromJS(resultData200) : new OfferDetailsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getApplicationDetails(): Observable<GetApplicationDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetApplicationDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationDetails(response: HttpResponseBase): Observable<GetApplicationDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetApplicationDetailsOutput.fromJS(resultData200) : new GetApplicationDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationDetailsOutput>(<any>null);
    }

    /**
     * @groupByPeriod (optional) 
     * @campaignId (optional) 
     * @from (optional) 
     * @to (optional) 
     * @return Success
     */
    getOffersStats(groupByPeriod: GroupByPeriod | null | undefined, campaignId: number | null | undefined, from: moment.Moment | null | undefined, to: moment.Moment | null | undefined): Observable<OfferApplicationGroup[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetOffersStats?";
        if (groupByPeriod !== undefined)
            url_ += "GroupByPeriod=" + encodeURIComponent("" + groupByPeriod) + "&"; 
        if (campaignId !== undefined)
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOffersStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOffersStats(<any>response_);
                } catch (e) {
                    return <Observable<OfferApplicationGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferApplicationGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOffersStats(response: HttpResponseBase): Observable<OfferApplicationGroup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OfferApplicationGroup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationGroup[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitRequest(body: SubmitRequestInput | null | undefined): Observable<SubmitRequestOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitRequest(<any>response_);
                } catch (e) {
                    return <Observable<SubmitRequestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitRequestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitRequest(response: HttpResponseBase): Observable<SubmitRequestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitRequestOutput.fromJS(resultData200) : new SubmitRequestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitRequestOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitApplication(body: SubmitApplicationInput | null | undefined): Observable<SubmitApplicationOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApplication(<any>response_);
                } catch (e) {
                    return <Observable<SubmitApplicationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitApplicationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitApplication(response: HttpResponseBase): Observable<SubmitApplicationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitApplicationOutput.fromJS(resultData200) : new SubmitApplicationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitApplicationOutput>(<any>null);
    }

    /**
     * @applicationId (optional) 
     * @return Success
     */
    startFinalizeApplication(applicationId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/StartFinalizeApplication?";
        if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartFinalizeApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartFinalizeApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartFinalizeApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @applicationId (optional) 
     * @return Success
     */
    getFinalizeApplicationStatus(applicationId: number | null | undefined): Observable<FinalizeApplicationResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetFinalizeApplicationStatus?";
        if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinalizeApplicationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinalizeApplicationStatus(<any>response_);
                } catch (e) {
                    return <Observable<FinalizeApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FinalizeApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinalizeApplicationStatus(response: HttpResponseBase): Observable<FinalizeApplicationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FinalizeApplicationResponse.fromJS(resultData200) : new FinalizeApplicationResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinalizeApplicationResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getMemberInfo(): Observable<GetMemberInfoResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberInfoResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberInfoResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfo(response: HttpResponseBase): Observable<GetMemberInfoResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberInfoResponse.fromJS(resultData200) : new GetMemberInfoResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberInfoResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rank(body: RankRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/Rank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRank(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRank(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPostDeclineOffers(): Observable<OfferDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetPostDeclineOffers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostDeclineOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostDeclineOffers(<any>response_);
                } catch (e) {
                    return <Observable<OfferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPostDeclineOffers(response: HttpResponseBase): Observable<OfferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OfferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDto[]>(<any>null);
    }
}

@Injectable()
export class OfferAnnouncementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendAnnouncement(body: SendAnnouncementRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferAnnouncement/SendAnnouncement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAnnouncement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendAnnouncement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @fetchAll (optional) 
     * @return Success
     */
    pull(fetchAll: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Pull?";
        if (fetchAll !== undefined)
            url_ += "fetchAll=" + encodeURIComponent("" + fetchAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPull(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPull(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDetailsForEdit(campaignId: number): Observable<OfferDetailsForEditDto> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/GetDetailsForEdit?";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<OfferDetailsForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDetailsForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailsForEdit(response: HttpResponseBase): Observable<OfferDetailsForEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferDetailsForEditDto.fromJS(resultData200) : new OfferDetailsForEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsForEditDto>(<any>null);
    }

    /**
     * @campaignId (optional) 
     * @body (optional) 
     * @return Success
     */
    extend(campaignId: number | null | undefined, body: ExtendOfferDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Extend?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @value (optional) 
     * @body (optional) 
     * @return Success
     */
    setAttribute(offerAttribute: OfferAttributeType, value: string | null | undefined, body: OfferFilter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetAttribute?";
        if (offerAttribute === undefined || offerAttribute === null)
            throw new Error("The parameter 'offerAttribute' must be defined and cannot be null.");
        else
            url_ += "offerAttribute=" + encodeURIComponent("" + offerAttribute) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAttribute(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSetAttribute(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @value (optional) 
     * @body (optional) 
     * @return Success
     */
    setFlag(offerFlag: OfferFlagType, value: boolean | null | undefined, body: OfferFilter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetFlag?";
        if (offerFlag === undefined || offerFlag === null)
            throw new Error("The parameter 'offerFlag' must be defined and cannot be null.");
        else
            url_ += "offerFlag=" + encodeURIComponent("" + offerFlag) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFlag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFlag(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSetFlag(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    extendFromCSV(body: string | null | undefined): Observable<ExtendFromCSVOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/ExtendFromCSV";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendFromCSV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendFromCSV(<any>response_);
                } catch (e) {
                    return <Observable<ExtendFromCSVOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtendFromCSVOutput>><any>_observableThrow(response_);
        }));
    }

    protected processExtendFromCSV(response: HttpResponseBase): Observable<ExtendFromCSVOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExtendFromCSVOutput.fromJS(resultData200) : new ExtendFromCSVOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtendFromCSVOutput>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @hasUserAccount (optional) 
     * @exceptUserIds (optional) 
     * @excludeSubContacts (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined, hasUserAccount: boolean | null | undefined, exceptUserIds: number[] | null | undefined, excludeSubContacts: boolean | null | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&"; 
        if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getHistory(id: number | null | undefined): Observable<OrderHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetHistory?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistory(<any>response_);
                } catch (e) {
                    return <Observable<OrderHistoryInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderHistoryInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistory(response: HttpResponseBase): Observable<OrderHistoryInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrderHistoryInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderHistoryInfo[]>(<any>null);
    }

    /**
     * @stageIds (optional) 
     * @return Success
     */
    getStageChecklistPoints(orderId: number, stageIds: number[] | null | undefined): Observable<StageChecklistPointInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetStageChecklistPoints?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&"; 
        if (stageIds !== undefined)
            stageIds && stageIds.forEach(item => { url_ += "StageIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStageChecklistPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStageChecklistPoints(<any>response_);
                } catch (e) {
                    return <Observable<StageChecklistPointInfoOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StageChecklistPointInfoOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStageChecklistPoints(response: HttpResponseBase): Observable<StageChecklistPointInfoOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StageChecklistPointInfoOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointInfoOutput[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setAmount(body: SetAmountInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/SetAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAmount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStage(body: UpdateOrderStageInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStagePoint(body: UpdateOrderStagePointInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateStagePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStagePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStagePoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStagePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAffiliateContact(body: UpdateOrderAffiliateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateAffiliateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAffiliateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAffiliateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAffiliateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    process(body: ProcessOrderInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Process";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancel(body: CancelOrderInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @forceDelete (optional) 
     * @return Success
     */
    delete(id: number | null | undefined, forceDelete: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (forceDelete !== undefined)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrderSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getSubscriptionHistory(contactId: number | null | undefined): Observable<OrderSubscriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/GetSubscriptionHistory?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionHistory(<any>response_);
                } catch (e) {
                    return <Observable<OrderSubscriptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderSubscriptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionHistory(response: HttpResponseBase): Observable<OrderSubscriptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrderSubscriptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSubscriptionDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateOrderSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePeriod(body: UpdateOrderSubscriptionPeriodInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/UpdatePeriod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePeriod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePeriod(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePeriod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancel(body: CancelOrderSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancelAll(body: CancelAllInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/CancelAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @isCaptured (optional) 
     * @return Success
     */
    completeManualSubscriptionPayment(trackingCode: string, isCaptured: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/CompleteManualSubscriptionPayment?";
        if (trackingCode === undefined || trackingCode === null)
            throw new Error("The parameter 'trackingCode' must be defined and cannot be null.");
        else
            url_ += "trackingCode=" + encodeURIComponent("" + trackingCode) + "&"; 
        if (isCaptured !== undefined)
            url_ += "isCaptured=" + encodeURIComponent("" + isCaptured) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteManualSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteManualSubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteManualSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getOrganizationContactInfo(contactId: number | null | undefined): Observable<OrganizationContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizationContactInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationContactInfo(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationContactInfo(response: HttpResponseBase): Observable<OrganizationContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationContactInfoDto.fromJS(resultData200) : new OrganizationContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationContactInfoDto>(<any>null);
    }

    /**
     * @searchString (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getOrganizations(searchString: string | null | undefined, topCount: number | null | undefined): Observable<OrganizationShortInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizations?";
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizations(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationShortInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationShortInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizations(response: HttpResponseBase): Observable<OrganizationShortInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationShortInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationShortInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrganization(body: CreateOrganizationInput | null | undefined): Observable<CreateOrganizationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/CreateOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganization(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrganizationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrganizationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganization(response: HttpResponseBase): Observable<CreateOrganizationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrganizationOutput.fromJS(resultData200) : new CreateOrganizationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrganizationOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrgUnitForOrganization(body: CreateOrgUnitForOrganizationInput | null | undefined): Observable<CreateOrgUnitForOrganizationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/CreateOrgUnitForOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrgUnitForOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrgUnitForOrganization(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrgUnitForOrganizationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrgUnitForOrganizationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrgUnitForOrganization(response: HttpResponseBase): Observable<CreateOrgUnitForOrganizationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrgUnitForOrganizationOutput.fromJS(resultData200) : new CreateOrgUnitForOrganizationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrgUnitForOrganizationOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOrganizationInfo(body: UpdateOrganizationInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/UpdateOrganizationInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number, currentPersonOrgRelationId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (currentPersonOrgRelationId === undefined || currentPersonOrgRelationId === null)
            throw new Error("The parameter 'currentPersonOrgRelationId' must be defined and cannot be null.");
        else
            url_ += "CurrentPersonOrgRelationId=" + encodeURIComponent("" + currentPersonOrgRelationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    mergeOrganizations(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/MergeOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeOrganizations(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeOrganizations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDtoListResultDto.fromJS(resultData200) : new OrganizationUnitDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200) : new OrganizationUnitUserListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitUserListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userId (optional) 
     * @organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | null | undefined): Observable<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoPagedResultDto.fromJS(resultData200) : new NameValueDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class PackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<PackageDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Package/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PackageDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackageDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PackageDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PackageDtoListResultDto.fromJS(resultData200) : new PackageDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackageDtoListResultDto>(<any>null);
    }

    /**
     * @module (optional) 
     * @return Success
     */
    getPackagesConfig(module: ModuleType | null | undefined): Observable<GetPackagesConfigOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Package/GetPackagesConfig?";
        if (module !== undefined)
            url_ += "Module=" + encodeURIComponent("" + module) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackagesConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackagesConfig(<any>response_);
                } catch (e) {
                    return <Observable<GetPackagesConfigOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPackagesConfigOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackagesConfig(response: HttpResponseBase): Observable<GetPackagesConfigOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPackagesConfigOutput.fromJS(resultData200) : new GetPackagesConfigOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPackagesConfigOutput>(<any>null);
    }
}

@Injectable()
export class PartnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<PartnerInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/Get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PartnerInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartnerInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PartnerInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PartnerInfoDto.fromJS(resultData200) : new PartnerInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateType(body: UpdatePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    bulkUpdateType(body: BulkUpdatePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/BulkUpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBulkUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @hasUserAccount (optional) 
     * @exceptUserIds (optional) 
     * @excludeSubContacts (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined, hasUserAccount: boolean | null | undefined, exceptUserIds: number[] | null | undefined, excludeSubContacts: boolean | null | undefined): Observable<EntityContactInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (hasUserAccount !== undefined)
            url_ += "HasUserAccount=" + encodeURIComponent("" + hasUserAccount) + "&"; 
        if (exceptUserIds !== undefined)
            exceptUserIds && exceptUserIds.forEach(item => { url_ += "ExceptUserIds=" + encodeURIComponent("" + item) + "&"; });
        if (excludeSubContacts !== undefined)
            url_ += "ExcludeSubContacts=" + encodeURIComponent("" + excludeSubContacts) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityContactInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityContactInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityContactInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityContactInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityContactInfo[]>(<any>null);
    }
}

@Injectable()
export class PartnerTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: RenamePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @moveToTypeId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number | null | undefined, moveToTypeId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToTypeId !== undefined)
            url_ += "MoveToTypeId=" + encodeURIComponent("" + moveToTypeId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getPayments(contactId: number | null | undefined): Observable<GetPaymentsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPayments?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayments(<any>response_);
                } catch (e) {
                    return <Observable<GetPaymentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPaymentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayments(response: HttpResponseBase): Observable<GetPaymentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPaymentsDto.fromJS(resultData200) : new GetPaymentsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPaymentsDto>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getPaymentMethods(contactId: number | null | undefined): Observable<PaymentMethodInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPaymentMethods?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentMethods(<any>response_);
                } catch (e) {
                    return <Observable<PaymentMethodInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentMethodInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentMethods(response: HttpResponseBase): Observable<PaymentMethodInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PaymentMethodInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodInfo[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactionTypes(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetTransactionTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypes(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPaymentProviders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPaymentProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentProviders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentProviders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @includeIrrelevant (optional) 
     * @return Success
     */
    getAllPermissions(includeIrrelevant: boolean | null | undefined): Observable<FlatPermissionWithLevelDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Permission/GetAllPermissions?";
        if (includeIrrelevant !== undefined)
            url_ += "includeIrrelevant=" + encodeURIComponent("" + includeIrrelevant) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<FlatPermissionWithLevelDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FlatPermissionWithLevelDtoListResultDto.fromJS(resultData200) : new FlatPermissionWithLevelDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionWithLevelDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class PersonContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonInfo(body: UpdatePersonInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonBANKCode(body: UpdatePersonBANKCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonBANKCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonBANKCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonBANKCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonBANKCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonName(body: UpdatePersonNameInput | null | undefined): Observable<UpdatePersonNameOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonName(<any>response_);
                } catch (e) {
                    return <Observable<UpdatePersonNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdatePersonNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonName(response: HttpResponseBase): Observable<UpdatePersonNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdatePersonNameOutput.fromJS(resultData200) : new UpdatePersonNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdatePersonNameOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createUserForContact(body: CreateUserForContactInput | null | undefined): Observable<CreateUserForContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/CreateUserForContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserForContact(<any>response_);
                } catch (e) {
                    return <Observable<CreateUserForContactOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateUserForContactOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserForContact(response: HttpResponseBase): Observable<CreateUserForContactOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateUserForContactOutput.fromJS(resultData200) : new CreateUserForContactOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserForContactOutput>(<any>null);
    }

    /**
     * @personId (optional) 
     * @return Success
     */
    getPersonHistory(personId: number | null | undefined): Observable<PersonHistoryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/GetPersonHistory?";
        if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonHistory(<any>response_);
                } catch (e) {
                    return <Observable<PersonHistoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PersonHistoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonHistory(response: HttpResponseBase): Observable<PersonHistoryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PersonHistoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonHistoryDto[]>(<any>null);
    }
}

@Injectable()
export class PersonOrgRelationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreatePersonOrgRelationInput | null | undefined): Observable<CreatePersonOrgRelationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreatePersonOrgRelationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreatePersonOrgRelationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreatePersonOrgRelationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreatePersonOrgRelationOutput.fromJS(resultData200) : new CreatePersonOrgRelationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreatePersonOrgRelationOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdatePersonOrgRelationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    setPrimaryOrgRelation(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/SetPrimaryOrgRelation?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrimaryOrgRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrimaryOrgRelation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPrimaryOrgRelation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PipelineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getPipelineDefinition(id: number | null | undefined): Observable<PipelineDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinition?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPipelineDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPipelineDefinition(<any>response_);
                } catch (e) {
                    return <Observable<PipelineDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PipelineDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPipelineDefinition(response: HttpResponseBase): Observable<PipelineDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PipelineDto.fromJS(resultData200) : new PipelineDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PipelineDto>(<any>null);
    }

    /**
     * @purposeId (optional) 
     * @contactGroupId (optional) 
     * @return Success
     */
    getPipelineDefinitions(purposeId: string | null | undefined, contactGroupId: string | null | undefined): Observable<PipelineDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinitions?";
        if (purposeId !== undefined)
            url_ += "purposeId=" + encodeURIComponent("" + purposeId) + "&"; 
        if (contactGroupId !== undefined)
            url_ += "contactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPipelineDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPipelineDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<PipelineDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PipelineDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPipelineDefinitions(response: HttpResponseBase): Observable<PipelineDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PipelineDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PipelineDto[]>(<any>null);
    }

    /**
     * @pipelineId (optional) 
     * @entityId (optional) 
     * @sortOrder (optional) 
     * @return Success
     */
    updateEntitySortOrder(pipelineId: number | null | undefined, entityId: number | null | undefined, sortOrder: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/UpdateEntitySortOrder?";
        if (pipelineId !== undefined)
            url_ += "pipelineId=" + encodeURIComponent("" + pipelineId) + "&"; 
        if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntitySortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntitySortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEntitySortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePipelineSortOrder(body: UpdateSortOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/UpdatePipelineSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePipelineSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePipelineSortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePipelineSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: PipelineCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: PipelineRenameInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getProductInfo(id: number | null | undefined): Observable<ProductInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProductInfo?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductInfo(<any>response_);
                } catch (e) {
                    return <Observable<ProductInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductInfo(response: HttpResponseBase): Observable<ProductInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProductInfo.fromJS(resultData200) : new ProductInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductInfo>(<any>null);
    }

    /**
     * @type (optional) 
     * @return Success
     */
    getProducts(type: ProductType | null | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProducts?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @searchPhrase (optional) 
     * @code (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getProductsByPhrase(contactId: number | null | undefined, searchPhrase: string | null | undefined, code: string | null | undefined, topCount: number | null | undefined): Observable<ProductPaymentOptionsInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetProductsByPhrase?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<ProductPaymentOptionsInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPaymentOptionsInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByPhrase(response: HttpResponseBase): Observable<ProductPaymentOptionsInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductPaymentOptionsInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPaymentOptionsInfo[]>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @searchPhrase (optional) 
     * @code (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getInvoiceProductsByPhrase(contactId: number | null | undefined, searchPhrase: string | null | undefined, code: string | null | undefined, topCount: number | null | undefined): Observable<ProductShortInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/GetInvoiceProductsByPhrase?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceProductsByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceProductsByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<ProductShortInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductShortInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceProductsByPhrase(response: HttpResponseBase): Observable<ProductShortInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductShortInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductShortInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductInput | null | undefined): Observable<CreateProductOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<CreateProductOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateProductOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<CreateProductOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateProductOutput.fromJS(resultData200) : new CreateProductOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateProductOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setProductImage(body: SetProductImageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/SetProductImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProductImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProductImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetProductImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    synchronizeSubscriptions(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/SynchronizeSubscriptions?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronizeSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronizeSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSynchronizeSubscriptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteProduct(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/DeleteProduct?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateProductGroups(body: UpdateProductGroupInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Product/UpdateProductGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductGroups(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductGroups(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProductGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProductGroups(): Observable<ProductGroupInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProductGroup/GetProductGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductGroups(<any>response_);
                } catch (e) {
                    return <Observable<ProductGroupInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductGroupInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductGroups(response: HttpResponseBase): Observable<ProductGroupInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProductGroupInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductGroupInfo[]>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<GetCurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<GetCurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentUserProfileEditDto.fromJS(resultData200) : new GetCurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearProfilePicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ClearProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    downloadPicture(body: DownloadPictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/DownloadPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @userId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateMonthlyGoal(body: UpdateMonthlyGoalInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateMonthlyGoal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMonthlyGoal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMonthlyGoal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMonthlyGoal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEmailSettings(): Observable<UserEmailSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<UserEmailSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEmailSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<UserEmailSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserEmailSettings.fromJS(resultData200) : new UserEmailSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEmailSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEmailSettings(body: UserEmailSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfileContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getContactBase(): Observable<ProfileContactBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileContact/GetContactBase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactBase(<any>response_);
                } catch (e) {
                    return <Observable<ProfileContactBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileContactBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactBase(response: HttpResponseBase): Observable<ProfileContactBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileContactBaseDto.fromJS(resultData200) : new ProfileContactBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileContactBaseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactBase(body: ProfileContactBaseDto | null | undefined): Observable<ProfileContactBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileContact/UpdateContactBase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactBase(<any>response_);
                } catch (e) {
                    return <Observable<ProfileContactBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileContactBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactBase(response: HttpResponseBase): Observable<ProfileContactBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileContactBaseDto.fromJS(resultData200) : new ProfileContactBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileContactBaseDto>(<any>null);
    }
}

@Injectable()
export class ProfileLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLinks(): Observable<LinkDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/GetLinks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinks(<any>response_);
                } catch (e) {
                    return <Observable<LinkDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinks(response: HttpResponseBase): Observable<LinkDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LinkDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createLink(body: CreateLinkInput | null | undefined): Observable<CreateLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/CreateLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLink(<any>response_);
                } catch (e) {
                    return <Observable<CreateLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLink(response: HttpResponseBase): Observable<CreateLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateLinkOutput.fromJS(resultData200) : new CreateLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLinkOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLink(body: UpdateLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/UpdateLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteLink(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/DeleteLink?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLinks(body: UpdateLinksInput | null | undefined): Observable<LinkDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfileLink/UpdateLinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLinks(<any>response_);
                } catch (e) {
                    return <Observable<LinkDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLinks(response: HttpResponseBase): Observable<LinkDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LinkDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkDto[]>(<any>null);
    }
}

@Injectable()
export class ProfilePersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProfileSummary(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/GetProfileSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfileSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfileSummary(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfileSummary(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateProfileSummary(input: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePerson/UpdateProfileSummary?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfileSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfileSummary(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfileSummary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfilePhotoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPhotos(): Observable<ProfilePhotoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/GetPhotos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhotos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhotos(<any>response_);
                } catch (e) {
                    return <Observable<ProfilePhotoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilePhotoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhotos(response: HttpResponseBase): Observable<ProfilePhotoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProfilePhotoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilePhotoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createPhoto(body: CreateProfilePhotoInput | null | undefined): Observable<ProfilePhotoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/CreatePhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePhoto(<any>response_);
                } catch (e) {
                    return <Observable<ProfilePhotoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfilePhotoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePhoto(response: HttpResponseBase): Observable<ProfilePhotoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfilePhotoDto.fromJS(resultData200) : new ProfilePhotoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfilePhotoDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deletePhoto(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/DeletePhoto?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePhoto(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getFilestackSettings(): Observable<FilestackSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePhoto/GetFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilestackSettings(<any>response_);
                } catch (e) {
                    return <Observable<FilestackSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FilestackSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilestackSettings(response: HttpResponseBase): Observable<FilestackSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FilestackSettingsDto.fromJS(resultData200) : new FilestackSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FilestackSettingsDto>(<any>null);
    }
}

@Injectable()
export class ProfilePublishServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @name (optional) 
     * @return Success
     */
    getPublicProfileInfo(name: string | null | undefined): Observable<PublishedProfileDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/GetPublicProfileInfo?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicProfileInfo(<any>response_);
                } catch (e) {
                    return <Observable<PublishedProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublishedProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPublicProfileInfo(response: HttpResponseBase): Observable<PublishedProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PublishedProfileDto.fromJS(resultData200) : new PublishedProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentPublishedProfile(): Observable<PublishedProfileBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/GetCurrentPublishedProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentPublishedProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentPublishedProfile(<any>response_);
                } catch (e) {
                    return <Observable<PublishedProfileBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublishedProfileBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentPublishedProfile(response: HttpResponseBase): Observable<PublishedProfileBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PublishedProfileBaseDto.fromJS(resultData200) : new PublishedProfileBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileBaseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    checkNameIsAvailable(body: NameInput | null | undefined): Observable<NameIsAvailableDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/CheckNameIsAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckNameIsAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckNameIsAvailable(<any>response_);
                } catch (e) {
                    return <Observable<NameIsAvailableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameIsAvailableDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckNameIsAvailable(response: HttpResponseBase): Observable<NameIsAvailableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameIsAvailableDto.fromJS(resultData200) : new NameIsAvailableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameIsAvailableDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    publishProfile(body: PublishProfileInput | null | undefined): Observable<PublishedProfileBaseDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ProfilePublish/PublishProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProfile(<any>response_);
                } catch (e) {
                    return <Observable<PublishedProfileBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublishedProfileBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPublishProfile(response: HttpResponseBase): Observable<PublishedProfileBaseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PublishedProfileBaseDto.fromJS(resultData200) : new PublishedProfileBaseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublishedProfileBaseDto>(<any>null);
    }
}

@Injectable()
export class PropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getPropertyDetails(id: number | null | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyDetails?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyDetails(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertyDetails(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PropertyDto.fromJS(resultData200) : new PropertyDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getPropertyAcquisitionDetails(id: number | null | undefined): Observable<PropertyAcquisitionDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyAcquisitionDetails?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyAcquisitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyAcquisitionDetails(<any>response_);
                } catch (e) {
                    return <Observable<PropertyAcquisitionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyAcquisitionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertyAcquisitionDetails(response: HttpResponseBase): Observable<PropertyAcquisitionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PropertyAcquisitionDto.fromJS(resultData200) : new PropertyAcquisitionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyAcquisitionDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getPropertyInvestmentDetails(id: number | null | undefined): Observable<PropertyInvestmentDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetPropertyInvestmentDetails?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyInvestmentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyInvestmentDetails(<any>response_);
                } catch (e) {
                    return <Observable<PropertyInvestmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyInvestmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertyInvestmentDetails(response: HttpResponseBase): Observable<PropertyInvestmentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PropertyInvestmentDto.fromJS(resultData200) : new PropertyInvestmentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyInvestmentDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePropertyDetails(body: PropertyBaseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePropertyDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePropertyAcquisitionDetails(body: PropertyAcquisitionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyAcquisitionDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyAcquisitionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyAcquisitionDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePropertyAcquisitionDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePropertyInvestmentDetails(body: PropertyInvestmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/UpdatePropertyInvestmentDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyInvestmentDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyInvestmentDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePropertyInvestmentDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @propertyId (optional) 
     * @return Success
     */
    getDeals(propertyId: number | null | undefined): Observable<PropertyDealInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GetDeals?";
        if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeals(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDealInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDealInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeals(response: HttpResponseBase): Observable<PropertyDealInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PropertyDealInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDealInfo[]>(<any>null);
    }

    /**
     * @propertyId (optional) 
     * @return Success
     */
    generateInvestmentPdf(propertyId: number | null | undefined): Observable<GetUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Property/GenerateInvestmentPdf?";
        if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateInvestmentPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateInvestmentPdf(<any>response_);
                } catch (e) {
                    return <Observable<GetUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateInvestmentPdf(response: HttpResponseBase): Observable<GetUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUrlOutput.fromJS(resultData200) : new GetUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUrlOutput>(<any>null);
    }
}

@Injectable()
export class QuestionnaireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @moduleName (optional) 
     * @identifier (optional) 
     * @return Success
     */
    get(moduleName: string | null | undefined, identifier: string | null | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/Get?";
        if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(<any>null);
    }

    /**
     * @moduleName (optional) 
     * @identifier (optional) 
     * @return Success
     */
    getInternal(moduleName: string | null | undefined, identifier: string | null | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/GetInternal?";
        if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternal(<any>response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInternal(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitResponse(body: QuestionnaireResponseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitResponseInternal(body: QuestionnaireResponseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponseInternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponseInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponseInternal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitResponseInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitQuestionsAndAnswers(body: SubmitQuestionsAndAnswersDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitQuestionsAndAnswers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitQuestionsAndAnswers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitQuestionsAndAnswers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitQuestionsAndAnswers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RapidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClients(): Observable<GetRapidClientsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetClients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(<any>response_);
                } catch (e) {
                    return <Observable<GetRapidClientsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRapidClientsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<GetRapidClientsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetRapidClientsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidClientsOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTokenForCurrentUser(): Observable<GetRapidTokenOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetTokenForCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenForCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<GetRapidTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRapidTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTokenForCurrentUser(response: HttpResponseBase): Observable<GetRapidTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRapidTokenOutput.fromJS(resultData200) : new GetRapidTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidTokenOutput>(<any>null);
    }

    /**
     * @contactIds (optional) 
     * @return Success
     */
    getTokenForContacts(contactIds: number[] | null | undefined): Observable<GetRapidTokenOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetTokenForContacts?";
        if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "contactIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenForContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenForContacts(<any>response_);
                } catch (e) {
                    return <Observable<GetRapidTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRapidTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTokenForContacts(response: HttpResponseBase): Observable<GetRapidTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRapidTokenOutput.fromJS(resultData200) : new GetRapidTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRapidTokenOutput>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getKonnectiveData(contactId: number | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetKonnectiveData?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKonnectiveData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKonnectiveData(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKonnectiveData(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getRefundsAndCancellationsForCurrentUser(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetRefundsAndCancellationsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetRefundsAndCancellationsForCurrentUser?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundsAndCancellationsForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundsAndCancellationsForCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundsAndCancellationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundsAndCancellationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundsAndCancellationsForCurrentUser(response: HttpResponseBase): Observable<GetRefundsAndCancellationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRefundsAndCancellationsOutput.fromJS(resultData200) : new GetRefundsAndCancellationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundsAndCancellationsOutput>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getRefundsAndCancellationsForContact(contactId: number | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetRefundsAndCancellationsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/GetRefundsAndCancellationsForContact?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRefundsAndCancellationsForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRefundsAndCancellationsForContact(<any>response_);
                } catch (e) {
                    return <Observable<GetRefundsAndCancellationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRefundsAndCancellationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRefundsAndCancellationsForContact(response: HttpResponseBase): Observable<GetRefundsAndCancellationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRefundsAndCancellationsOutput.fromJS(resultData200) : new GetRefundsAndCancellationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRefundsAndCancellationsOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactAgents(body: CreateContactAgentsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Rapid/CreateContactAgents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactAgents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactAgents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @sourceOrganizationUnitIds (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getSubscriberDailyStatsReport(sourceOrganizationUnitIds: number[] | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<SubscriberDailyStatsReportInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Report/GetSubscriberDailyStatsReport?";
        if (sourceOrganizationUnitIds !== undefined)
            sourceOrganizationUnitIds && sourceOrganizationUnitIds.forEach(item => { url_ += "SourceOrganizationUnitIds=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriberDailyStatsReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriberDailyStatsReport(<any>response_);
                } catch (e) {
                    return <Observable<SubscriberDailyStatsReportInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriberDailyStatsReportInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriberDailyStatsReport(response: HttpResponseBase): Observable<SubscriberDailyStatsReportInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscriberDailyStatsReportInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriberDailyStatsReportInfo[]>(<any>null);
    }
}

@Injectable()
export class ReportingCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getReportingAndCoACategorization(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/ReportingCategory/GetReportingAndCoACategorization?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportingAndCoACategorization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportingAndCoACategorization(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportingAndCoACategorization(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getUrl(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: string | null | undefined): Observable<GetReportUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GetUrl?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetReportUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetReportUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReportUrlOutput.fromJS(resultData200) : new GetReportUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportUrlOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    generate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GenerateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Generate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    generateBalanceSheetReport(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GenerateBalanceSheetReportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GenerateBalanceSheetReport?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateBalanceSheetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateBalanceSheetReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateBalanceSheetReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    generateIncomeStatementByEntityReport(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GenerateIncomeStatementByEntityReportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GenerateIncomeStatementByEntityReport?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateIncomeStatementByEntityReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateIncomeStatementByEntityReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateIncomeStatementByEntityReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Delete?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    sendReportNotification(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: SendReportNotificationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/SendReportNotification?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReportNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReportNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendReportNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @permission (optional) 
     * @moduleType (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined, moduleType: ModuleType | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (moduleType !== undefined)
            url_ += "ModuleType=" + encodeURIComponent("" + moduleType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleListDtoListResultDto.fromJS(resultData200) : new RoleListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SecurityManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountId (optional) 
     * @userId (optional) 
     * @body (optional) 
     * @return Success
     */
    grantBankAccountPermissions(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountId: number | null | undefined, userId: number | null | undefined, body: Permissions | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GrantBankAccountPermissions?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountId !== undefined)
            url_ += "bankAccountId=" + encodeURIComponent("" + bankAccountId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantBankAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @userId (optional) 
     * @body (optional) 
     * @return Success
     */
    revokeBankAccountPermissions(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, userId: number | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/RevokeBankAccountPermissions?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeBankAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRevokeBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBankAccountAssignedUsers(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BankAccountUsers[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GetBankAccountAssignedUsers?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountAssignedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountAssignedUsers(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountUsers[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountUsers[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccountAssignedUsers(response: HttpResponseBase): Observable<BankAccountUsers[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankAccountUsers.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountUsers[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }

    /**
     * @return Success
     */
    authTest(): Observable<AuthTestOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/AuthTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthTest(<any>response_);
                } catch (e) {
                    return <Observable<AuthTestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthTestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAuthTest(response: HttpResponseBase): Observable<AuthTestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthTestOutput.fromJS(resultData200) : new AuthTestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTestOutput>(<any>null);
    }
}

@Injectable()
export class StageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createStage(body: CreateStageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/CreateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    renameStage(body: RenameStageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/RenameStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    mergeStages(body: MergeStagesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/MergeStages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeStages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeStages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStageSortOrder(body: UpdateSortOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/UpdateStageSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageSortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStageSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StageChecklistServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @stageId (optional) 
     * @return Success
     */
    getPoints(stageId: number | null | undefined): Observable<StageChecklistPointDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/GetPoints?";
        if (stageId !== undefined)
            url_ += "stageId=" + encodeURIComponent("" + stageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoints(<any>response_);
                } catch (e) {
                    return <Observable<StageChecklistPointDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StageChecklistPointDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPoints(response: HttpResponseBase): Observable<StageChecklistPointDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StageChecklistPointDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StageChecklistPointDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createPoint(body: CreateStageChecklistPointInput | null | undefined): Observable<CreatePointInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/CreatePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePoint(<any>response_);
                } catch (e) {
                    return <Observable<CreatePointInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreatePointInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePoint(response: HttpResponseBase): Observable<CreatePointInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreatePointInfoOutput.fromJS(resultData200) : new CreatePointInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreatePointInfoOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    renamePoint(body: RenameStageChecklistPointInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/RenamePoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenamePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePointSortOrder(body: UpdateStageChecklistPointSortOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/UpdatePointSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePointSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePointSortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePointSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deletePoint(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/StageChecklist/DeletePoint?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    setupSyncUserApplication(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: SetupSyncUserApplicationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SetupSyncUserApplication?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupSyncUserApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupSyncUserApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetupSyncUserApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    requestConnection(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RequestConnectionInput | null | undefined): Observable<RequestConnectionOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/RequestConnection?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestConnection(<any>response_);
                } catch (e) {
                    return <Observable<RequestConnectionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestConnectionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRequestConnection(response: HttpResponseBase): Observable<RequestConnectionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestConnectionOutput.fromJS(resultData200) : new RequestConnectionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestConnectionOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @forcedSync (optional) 
     * @syncType (optional) 
     * @return Success
     */
    syncAllAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, forcedSync: boolean | null | undefined, syncType: string | null | undefined): Observable<SyncAllAccountsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAllAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (forcedSync !== undefined)
            url_ += "forcedSync=" + encodeURIComponent("" + forcedSync) + "&"; 
        if (syncType !== undefined)
            url_ += "syncType=" + encodeURIComponent("" + syncType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllAccounts(<any>response_);
                } catch (e) {
                    return <Observable<SyncAllAccountsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAllAccountsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAllAccounts(response: HttpResponseBase): Observable<SyncAllAccountsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncAllAccountsOutput.fromJS(resultData200) : new SyncAllAccountsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAllAccountsOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncAccountId (optional) 
     * @fullResync (optional) 
     * @return Success
     */
    syncAccount(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncAccountId: number | null | undefined, fullResync: boolean | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAccount?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&"; 
        if (fullResync !== undefined)
            url_ += "fullResync=" + encodeURIComponent("" + fullResync) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAccount(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @fullResync (optional) 
     * @body (optional) 
     * @return Success
     */
    requestSyncForAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, fullResync: boolean | null | undefined, body: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/RequestSyncForAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (fullResync !== undefined)
            url_ += "fullResync=" + encodeURIComponent("" + fullResync) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestSyncForAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestSyncForAccounts(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRequestSyncForAccounts(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getSyncProgress(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<SyncProgressOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/GetSyncProgress?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSyncProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSyncProgress(<any>response_);
                } catch (e) {
                    return <Observable<SyncProgressOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncProgressOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSyncProgress(response: HttpResponseBase): Observable<SyncProgressOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncProgressOutput.fromJS(resultData200) : new SyncProgressOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncProgressOutput>(<any>null);
    }
}

@Injectable()
export class SyncAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncTypeId (optional) 
     * @return Success
     */
    getActive(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncTypeId: string | null | undefined): Observable<SyncAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/GetActive?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActive(<any>response_);
                } catch (e) {
                    return <Observable<SyncAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActive(response: HttpResponseBase): Observable<SyncAccountDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SyncAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    create(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateSyncAccountInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Create?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    rename(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RenameSyncAccountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Rename?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    changeAutoSyncTime(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ChangeAutoSyncInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/ChangeAutoSyncTime?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAutoSyncTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAutoSyncTime(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeAutoSyncTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncAccountId (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncAccountId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Delete?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    createIsAllowed(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/CreateIsAllowed?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIsAllowed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIsAllowed(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIsAllowed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @editionIdSpecified (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<TenantListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<TenantListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<TenantListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantListDtoPagedResultDto.fromJS(resultData200) : new TenantListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    clearCustomCss(body: CustomCssType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomPrivacyPolicyDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomPrivacyPolicyDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomPrivacyPolicyDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomPrivacyPolicyDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomPrivacyPolicyDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomToSDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomToSDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomToSDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomToSDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomToSDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearFavicons(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearFavicons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearFavicons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearFavicons(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearFavicons(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setCustomLayout(body: LayoutType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/SetCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCustomLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    validateCustomLayout(body: LayoutType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ValidateCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCustomLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantHostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantAppHost(): Observable<TenantAppHostOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetTenantAppHost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantAppHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantAppHost(<any>response_);
                } catch (e) {
                    return <Observable<TenantAppHostOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantAppHostOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantAppHost(response: HttpResponseBase): Observable<TenantAppHostOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantAppHostOutput.fromJS(resultData200) : new TenantAppHostOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAppHostOutput>(<any>null);
    }

    /**
     * @appUi (optional) 
     * @return Success
     */
    getPlatformAppUrl(appUi: boolean | null | undefined): Observable<GetPlatformAppUrlOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetPlatformAppUrl?";
        if (appUi !== undefined)
            url_ += "appUi=" + encodeURIComponent("" + appUi) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlatformAppUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlatformAppUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetPlatformAppUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPlatformAppUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlatformAppUrl(response: HttpResponseBase): Observable<GetPlatformAppUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPlatformAppUrlOutput.fromJS(resultData200) : new GetPlatformAppUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPlatformAppUrlOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getMemberPortalUrl(): Observable<GetMemberPortalUrlOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetMemberPortalUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPortalUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPortalUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberPortalUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberPortalUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPortalUrl(response: HttpResponseBase): Observable<GetMemberPortalUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberPortalUrlOutput.fromJS(resultData200) : new GetMemberPortalUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberPortalUrlOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    checkHostNameDnsMapping(body: CheckHostNameDnsMappingInput | null | undefined): Observable<CheckHostNameDnsMappingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/CheckHostNameDnsMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHostNameDnsMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHostNameDnsMapping(<any>response_);
                } catch (e) {
                    return <Observable<CheckHostNameDnsMappingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckHostNameDnsMappingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckHostNameDnsMapping(response: HttpResponseBase): Observable<CheckHostNameDnsMappingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckHostNameDnsMappingOutput.fromJS(resultData200) : new CheckHostNameDnsMappingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckHostNameDnsMappingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSslBindings(): Observable<TenantSslBindingInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetSslBindings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSslBindings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSslBindings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslBindingInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSslBindings(response: HttpResponseBase): Observable<TenantSslBindingInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslBindingInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addSslBinding(body: AddSslBindingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/AddSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSslBinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSslBinding(body: UpdateSslBindingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSslBinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSslBinding(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/DeleteSslBinding?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSslBinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantIntegrationsSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIntegrationsSettings(): Observable<IntegrationsSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/GetIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIntegrationsSettings(<any>response_);
                } catch (e) {
                    return <Observable<IntegrationsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<IntegrationsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetIntegrationsSettings(response: HttpResponseBase): Observable<IntegrationsSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IntegrationsSettings.fromJS(resultData200) : new IntegrationsSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegrationsSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIntegrationsSettings(body: IntegrationsSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/UpdateIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIntegrationsSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIntegrationsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantOfferProviderSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEPCVIPOfferProviderSettings(): Observable<EPCVIPOfferProviderSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/GetEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPOfferProviderSettings(<any>response_);
                } catch (e) {
                    return <Observable<EPCVIPOfferProviderSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<EPCVIPOfferProviderSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<EPCVIPOfferProviderSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EPCVIPOfferProviderSettings.fromJS(resultData200) : new EPCVIPOfferProviderSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPOfferProviderSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEPCVIPOfferProviderSettings(body: EPCVIPOfferProviderSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/UpdateEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPOfferProviderSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantPaymentSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBaseCommercePaymentSettings(): Observable<BaseCommercePaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaseCommercePaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<BaseCommercePaymentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaseCommercePaymentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetBaseCommercePaymentSettings(response: HttpResponseBase): Observable<BaseCommercePaymentSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseCommercePaymentSettings.fromJS(resultData200) : new BaseCommercePaymentSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaseCommercePaymentSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBaseCommercePaymentSettings(body: BaseCommercePaymentSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBaseCommercePaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBaseCommercePaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getACHWorksSettings(): Observable<ACHWorksSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetACHWorksSettings(<any>response_);
                } catch (e) {
                    return <Observable<ACHWorksSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<ACHWorksSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetACHWorksSettings(response: HttpResponseBase): Observable<ACHWorksSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ACHWorksSettings.fromJS(resultData200) : new ACHWorksSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ACHWorksSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateACHWorksSettings(body: ACHWorksSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateACHWorksSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateACHWorksSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRecurlyPaymentSettings(): Observable<RecurlyPaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurlyPaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<RecurlyPaymentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurlyPaymentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecurlyPaymentSettings(response: HttpResponseBase): Observable<RecurlyPaymentSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecurlyPaymentSettings.fromJS(resultData200) : new RecurlyPaymentSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurlyPaymentSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateRecurlyPaymentSettings(body: RecurlyPaymentSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRecurlyPaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRecurlyPaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<PayPalSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalSettings.fromJS(resultData200) : new PayPalSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePayPalSettings(body: PayPalSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdatePayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePayPalSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<BankTransferSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankTransferSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankTransferSettings.fromJS(resultData200) : new BankTransferSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBankTransferSettings(body: BankTransferSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankTransferSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getStripeSettings(): Observable<StripeSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetStripeSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStripeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStripeSettings(<any>response_);
                } catch (e) {
                    return <Observable<StripeSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetStripeSettings(response: HttpResponseBase): Observable<StripeSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeSettings.fromJS(resultData200) : new StripeSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStripeSettings(body: StripeSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateStripeSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStripeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStripeSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStripeSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @includeAdvisorDetails (optional) 
     * @return Success
     */
    getInvoiceSettings(includeAdvisorDetails: boolean | null | undefined): Observable<InvoiceSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetInvoiceSettings?";
        if (includeAdvisorDetails !== undefined)
            url_ += "includeAdvisorDetails=" + encodeURIComponent("" + includeAdvisorDetails) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceSettings(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceSettings(response: HttpResponseBase): Observable<InvoiceSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceSettingsDto.fromJS(resultData200) : new InvoiceSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceSettingsDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateInvoiceSettings(body: InvoiceSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateInvoiceSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvoiceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvoiceSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInvoiceSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEPCVIPMailerSettings(): Observable<EPCVIPMailerSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPMailerSettings(<any>response_);
                } catch (e) {
                    return <Observable<EPCVIPMailerSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EPCVIPMailerSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEPCVIPMailerSettings(response: HttpResponseBase): Observable<EPCVIPMailerSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EPCVIPMailerSettingsEditDto.fromJS(resultData200) : new EPCVIPMailerSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPMailerSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOngageSettings(): Observable<OngageSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOngageSettings(<any>response_);
                } catch (e) {
                    return <Observable<OngageSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OngageSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOngageSettings(response: HttpResponseBase): Observable<OngageSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OngageSettingsEditDto.fromJS(resultData200) : new OngageSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OngageSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getIAgeSettings(): Observable<IAgeSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIAgeSettings(<any>response_);
                } catch (e) {
                    return <Observable<IAgeSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IAgeSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIAgeSettings(response: HttpResponseBase): Observable<IAgeSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IAgeSettingsEditDto.fromJS(resultData200) : new IAgeSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IAgeSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getSendGridSettings(): Observable<SendGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetSendGridSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSendGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSendGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<SendGridSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendGridSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSendGridSettings(response: HttpResponseBase): Observable<SendGridSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendGridSettingsDto.fromJS(resultData200) : new SendGridSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendGridSettingsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getYTelSettings(): Observable<YTelSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYTelSettings(<any>response_);
                } catch (e) {
                    return <Observable<YTelSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<YTelSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetYTelSettings(response: HttpResponseBase): Observable<YTelSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? YTelSettingsEditDto.fromJS(resultData200) : new YTelSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YTelSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRapidSettings(): Observable<RapidSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetRapidSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRapidSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRapidSettings(<any>response_);
                } catch (e) {
                    return <Observable<RapidSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RapidSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRapidSettings(response: HttpResponseBase): Observable<RapidSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RapidSettingsDto.fromJS(resultData200) : new RapidSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RapidSettingsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getFilestackSettings(): Observable<FilestackSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilestackSettings(<any>response_);
                } catch (e) {
                    return <Observable<FilestackSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FilestackSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilestackSettings(response: HttpResponseBase): Observable<FilestackSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FilestackSettingsDto.fromJS(resultData200) : new FilestackSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FilestackSettingsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLdapSettings(): Observable<LdapSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetLdapSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLdapSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLdapSettings(<any>response_);
                } catch (e) {
                    return <Observable<LdapSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LdapSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLdapSettings(response: HttpResponseBase): Observable<LdapSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LdapSettingsEditDto.fromJS(resultData200) : new LdapSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LdapSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEmailSettings(): Observable<EmailSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<EmailSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmailSettingsEditDto.fromJS(resultData200) : new EmailSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserManagementSettings(): Observable<TenantUserManagementSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantUserManagementSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantUserManagementSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserManagementSettings(response: HttpResponseBase): Observable<TenantUserManagementSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantUserManagementSettingsEditDto.fromJS(resultData200) : new TenantUserManagementSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantUserManagementSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySettings(): Observable<PasswordComplexitySettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetPasswordComplexitySettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySettings(<any>response_);
                } catch (e) {
                    return <Observable<PasswordComplexitySettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PasswordComplexitySettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySettings(response: HttpResponseBase): Observable<PasswordComplexitySettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PasswordComplexitySettingsEditDto.fromJS(resultData200) : new PasswordComplexitySettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PasswordComplexitySettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserLockOutSettings(): Observable<UserLockOutSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetUserLockOutSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLockOutSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLockOutSettings(<any>response_);
                } catch (e) {
                    return <Observable<UserLockOutSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLockOutSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserLockOutSettings(response: HttpResponseBase): Observable<UserLockOutSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLockOutSettingsEditDto.fromJS(resultData200) : new UserLockOutSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLockOutSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getTwoFactorLoginSettings(): Observable<TwoFactorLoginSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetTwoFactorLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTwoFactorLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTwoFactorLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<TwoFactorLoginSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TwoFactorLoginSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTwoFactorLoginSettings(response: HttpResponseBase): Observable<TwoFactorLoginSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TwoFactorLoginSettingsEditDto.fromJS(resultData200) : new TwoFactorLoginSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwoFactorLoginSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMemberPortalSettings(): Observable<MemberPortalSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetMemberPortalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberPortalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberPortalSettings(<any>response_);
                } catch (e) {
                    return <Observable<MemberPortalSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberPortalSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberPortalSettings(response: HttpResponseBase): Observable<MemberPortalSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MemberPortalSettingsDto.fromJS(resultData200) : new MemberPortalSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberPortalSettingsDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEPCVIPMailerSettings(body: EPCVIPMailerSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPMailerSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEPCVIPMailerSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOngageSettings(body: OngageSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOngageSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOngageSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIAgeSettings(body: IAgeSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIAgeSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIAgeSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSendGridSettings(body: SendGridSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateSendGridSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSendGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSendGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSendGridSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateYTelSettings(body: YTelSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateYTelSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateYTelSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateYTelSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateYTelSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateRapidSettings(body: RapidSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateRapidSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRapidSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRapidSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRapidSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateFilestackSettings(body: FilestackSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateFilestackSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFilestackSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFilestackSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFilestackSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLdapSettings(body: LdapSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateLdapSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLdapSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLdapSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLdapSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserManagementSettings(body: TenantUserManagementSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateUserManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePasswordComplexitySettings(body: PasswordComplexitySetting | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdatePasswordComplexitySettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordComplexitySettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordComplexitySettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePasswordComplexitySettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserLockOutSettings(body: UserLockOutSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateUserLockOutSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserLockOutSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserLockOutSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserLockOutSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTwoFactorLoginSettings(body: TwoFactorLoginSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateTwoFactorLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTwoFactorLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTwoFactorLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTwoFactorLoginSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateMemberPortalSettings(body: MemberPortalSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateMemberPortalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberPortalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberPortalSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMemberPortalSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralSettings(): Observable<GeneralSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralSettings(<any>response_);
                } catch (e) {
                    return <Observable<GeneralSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralSettings(response: HttpResponseBase): Observable<GeneralSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GeneralSettingsEditDto.fromJS(resultData200) : new GeneralSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateGeneralSettings(body: GeneralSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateGeneralSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeneralSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEmailSettings(body: EmailSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSettingsCreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIdcsSettings(): Observable<IdcsSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/GetIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdcsSettings(<any>response_);
                } catch (e) {
                    return <Observable<IdcsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdcsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetIdcsSettings(response: HttpResponseBase): Observable<IdcsSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdcsSettings.fromJS(resultData200) : new IdcsSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdcsSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIdcsSettings(body: IdcsSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/UpdateIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdcsSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIdcsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSslCertificateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantSslCertificates(): Observable<TenantSslCertificateInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/GetTenantSslCertificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantSslCertificates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantSslCertificates(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantSslCertificates(response: HttpResponseBase): Observable<TenantSslCertificateInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslCertificateInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addTenantSslCertificate(body: AddTenantSslCertificateInput | null | undefined): Observable<TenantSslCertificateInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/AddTenantSslCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTenantSslCertificate(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo>><any>_observableThrow(response_);
        }));
    }

    protected processAddTenantSslCertificate(response: HttpResponseBase): Observable<TenantSslCertificateInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslCertificateInfo.fromJS(resultData200) : new TenantSslCertificateInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTenantSslCertificate(sslCertificateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/DeleteTenantSslCertificate?";
        if (sslCertificateId === undefined || sslCertificateId === null)
            throw new Error("The parameter 'sslCertificateId' must be defined and cannot be null.");
        else
            url_ += "SslCertificateId=" + encodeURIComponent("" + sslCertificateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenantSslCertificate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenantSslCertificate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addPaymentInfo(body: PaymentRequestInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/AddPaymentInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddPaymentInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setupSubscription(body: SetupSubscriptionInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/SetupSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetupSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    requestPayment(body: RequestPaymentDto | null | undefined): Observable<RequestPaymentResult> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RequestPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPayment(<any>response_);
                } catch (e) {
                    return <Observable<RequestPaymentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestPaymentResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestPayment(response: HttpResponseBase): Observable<RequestPaymentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestPaymentResult.fromJS(resultData200) : new RequestPaymentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestPaymentResult>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    completeSubscriptionPayment(body: PaymentRequestInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteSubscriptionPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteSubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rejectPendingPayment(body: ModuleType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RejectPendingPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPendingPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPendingPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRejectPendingPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getModuleSubscriptions(): Observable<ModuleSubscriptionInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetModuleSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<ModuleSubscriptionInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleSubscriptionInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModuleSubscriptions(response: HttpResponseBase): Observable<ModuleSubscriptionInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ModuleSubscriptionInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSubscriptionInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    completeTenantRegistration(body: CompleteTenantRegistrationInput | null | undefined): Observable<CompleteTenantRegistrationOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteTenantRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTenantRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTenantRegistration(<any>response_);
                } catch (e) {
                    return <Observable<CompleteTenantRegistrationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompleteTenantRegistrationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteTenantRegistration(response: HttpResponseBase): Observable<CompleteTenantRegistrationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompleteTenantRegistrationOutput.fromJS(resultData200) : new CompleteTenantRegistrationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompleteTenantRegistrationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<BankTransferSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankTransferSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankTransferSettingsDto.fromJS(resultData200) : new BankTransferSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettingsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<PayPalSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalSettingsDto.fromJS(resultData200) : new PayPalSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettingsDto>(<any>null);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @strings (optional) 
     * @return Success
     */
    getCommonPhrases(strings: string[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetCommonPhrases?";
        if (strings !== undefined)
            strings && strings.forEach(item => { url_ += "strings=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommonPhrases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonPhrases(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommonPhrases(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @text (optional) 
     * @return Success
     */
    getKeywords(text: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetKeywords?";
        if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeywords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeywords(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeywords(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes | null | undefined): Observable<NameValueDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezones?";
        if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<NameValueDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoListResultDto.fromJS(resultData200) : new NameValueDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoListResultDto>(<any>null);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    authenticateByCode(body: AuthenticateByCodeModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateByCode(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateByCode(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @secureId (optional) 
     * @return Success
     */
    impersonatedAuthenticate(secureId: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (secureId !== undefined)
            url_ += "secureId=" + encodeURIComponent("" + secureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TransactionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getFiltersInitialData(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<FiltersInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetFiltersInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiltersInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiltersInitialData(<any>response_);
                } catch (e) {
                    return <Observable<FiltersInitialData>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiltersInitialData>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiltersInitialData(response: HttpResponseBase): Observable<FiltersInitialData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiltersInitialData.fromJS(resultData200) : new FiltersInitialData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiltersInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCounterparties(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<CounterpartyDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetCounterparties?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterparties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterparties(<any>response_);
                } catch (e) {
                    return <Observable<CounterpartyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CounterpartyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounterparties(response: HttpResponseBase): Observable<CounterpartyDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CounterpartyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CounterpartyDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @currencyId (optional) 
     * @accountIds (optional) 
     * @businessEntityIds (optional) 
     * @return Success
     */
    getStartingBalance(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, currencyId: string | null | undefined, accountIds: number[] | null | undefined, businessEntityIds: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetStartingBalance?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (businessEntityIds !== undefined)
            businessEntityIds && businessEntityIds.forEach(item => { url_ += "BusinessEntityIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStartingBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStartingBalance(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStartingBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionAttributeTypes(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<GetTransactionAttributeTypesOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionAttributeTypes?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionAttributeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionAttributeTypes(<any>response_);
                } catch (e) {
                    return <Observable<GetTransactionAttributeTypesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTransactionAttributeTypesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionAttributeTypes(response: HttpResponseBase): Observable<GetTransactionAttributeTypesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionAttributeTypesOutput.fromJS(resultData200) : new GetTransactionAttributeTypesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionAttributeTypesOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, transactionId: number): Observable<GetTransactionDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetTransactionDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTransactionDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<GetTransactionDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionDetailsOutput.fromJS(resultData200) : new GetTransactionDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionDetailsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactionTypesAndCategories(): Observable<TransactionTypesAndCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionTypesAndCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypesAndCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypesAndCategories(<any>response_);
                } catch (e) {
                    return <Observable<TransactionTypesAndCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionTypesAndCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypesAndCategories(response: HttpResponseBase): Observable<TransactionTypesAndCategoriesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionTypesAndCategoriesDto.fromJS(resultData200) : new TransactionTypesAndCategoriesDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionTypesAndCategoriesDto>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @permissions (optional) 
     * @role (optional) 
     * @onlyLockedUsers (optional) 
     * @group (optional) 
     * @isActive (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, group: UserGroup | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<UserListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (group !== undefined)
            url_ += "Group=" + encodeURIComponent("" + group) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserListDtoListResultDto.fromJS(resultData200) : new UserListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListDtoListResultDto>(<any>null);
    }

    /**
     * @filter (optional) 
     * @permissions (optional) 
     * @role (optional) 
     * @onlyLockedUsers (optional) 
     * @group (optional) 
     * @isActive (optional) 
     * @return Success
     */
    getUserCount(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, group: UserGroup | null | undefined, isActive: boolean | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserCount?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (group !== undefined)
            url_ += "Group=" + encodeURIComponent("" + group) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: Int64EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserPicture(body: UpdateUserPictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearUserPicture(userId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ClearUserPicture?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    inviteUsers(body: InviteUserInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/InviteUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInviteUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInviteUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @notifyUser (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined, notifyUser: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (notifyUser !== undefined)
            url_ += "NotifyUser=" + encodeURIComponent("" + notifyUser) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlockUser(body: Int64EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEmail(body: UpdateUserEmailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePhone(body: UpdateUserPhoneDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdatePhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetPassword(body: ResetUserPasswordDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOptions(body: UpdateUserOptionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    grantPermission(body: GrantPermissionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GrantPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    prohibitPermission(body: ProhibitPermissionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ProhibitPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProhibitPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProhibitPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProhibitPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addToRole(body: UpdateUserRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/AddToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddToRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    removeFromRole(id: number | null | undefined, roleName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/RemoveFromRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined and cannot be null.");
        else
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveFromRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moduleType (optional) 
     * @return Success
     */
    getAvailableUserCount(moduleType: ModuleType | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetAvailableUserCount?";
        if (moduleType !== undefined)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableUserCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableUserCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getAutoLoginLink(userId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetAutoLoginLink?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoLoginLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoLoginLink(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAutoLoginLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class UserAssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsersForActivity(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/UserAssignment/GetAllowedAssignableUsersForActivity?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsersForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsersForActivity(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllowedAssignableUsersForActivity(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }
}

@Injectable()
export class UserCommissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @startDate (optional) 
     * @return Success
     */
    getLedger(startDate: moment.Moment | null | undefined): Observable<GetLedgerOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/GetLedger?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLedger(<any>response_);
                } catch (e) {
                    return <Observable<GetLedgerOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLedgerOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLedger(response: HttpResponseBase): Observable<GetLedgerOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLedgerOutput.fromJS(resultData200) : new GetLedgerOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLedgerOutput>(<any>null);
    }

    /**
     * @amount (optional) 
     * @return Success
     */
    requestWithdrawal(amount: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/RequestWithdrawal?";
        if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestWithdrawal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestWithdrawal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestWithdrawal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTotals(): Observable<GetLedgerTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/UserCommission/GetTotals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetLedgerTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLedgerTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotals(response: HttpResponseBase): Observable<GetLedgerTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLedgerTotalsOutput.fromJS(resultData200) : new GetLedgerTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLedgerTotalsOutput>(<any>null);
    }
}

@Injectable()
export class UserInvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @payerOrganizationUnitId (optional) 
     * @return Success
     */
    generatePdf(id: number | null | undefined, payerOrganizationUnitId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/UserInvoice/GeneratePdf?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (payerOrganizationUnitId !== undefined)
            url_ += "payerOrganizationUnitId=" + encodeURIComponent("" + payerOrganizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneratePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneratePdf(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGeneratePdf(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<LinkedUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<LinkedUserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkedUserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LinkedUserDtoPagedResultDto.fromJS(resultData200) : new LinkedUserDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkedUserDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<LinkedUserDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<LinkedUserDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkedUserDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LinkedUserDtoListResultDto.fromJS(resultData200) : new LinkedUserDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkedUserDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<UserLoginAttemptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginAttemptDtoListResultDto.fromJS(resultData200) : new UserLoginAttemptDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginAttemptDtoListResultDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getRecentLoginAttemptsForOtherUser(userId: number | null | undefined): Observable<UserLoginAttemptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentLoginAttemptsForOtherUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentLoginAttemptsForOtherUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentLoginAttemptsForOtherUser(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentLoginAttemptsForOtherUser(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginAttemptDtoListResultDto.fromJS(resultData200) : new UserLoginAttemptDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginAttemptDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkflowEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addRule(body: AddWorkflowRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/AddRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    editRule(body: EditWorkflowRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/EditRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @ruleId (optional) 
     * @return Success
     */
    deleteRule(ruleId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/DeleteRule?";
        if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRules(): Observable<WorkflowRuleDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetRules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowRuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowRuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<WorkflowRuleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkflowRuleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowRuleDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTriggers(): Observable<WorkflowTriggerDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetTriggers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTriggers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTriggers(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowTriggerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowTriggerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTriggers(response: HttpResponseBase): Observable<WorkflowTriggerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkflowTriggerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTriggerDto[]>(<any>null);
    }

    /**
     * @ruleId (optional) 
     * @return Success
     */
    triggerRule(ruleId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/TriggerRule?";
        if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTriggerRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class SignUpMemberRequest implements ISignUpMemberRequest {
    firstName!: string;
    lastName!: string;
    email!: string;
    phoneNumber!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isUSCitizen!: boolean;
    pendingPasswordReset!: boolean | undefined;

    constructor(data?: ISignUpMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.postalCode = data["postalCode"];
            this.countryCode = data["countryCode"];
            this.isUSCitizen = data["isUSCitizen"];
            this.pendingPasswordReset = data["pendingPasswordReset"];
        }
    }

    static fromJS(data: any): SignUpMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isUSCitizen"] = this.isUSCitizen;
        data["pendingPasswordReset"] = this.pendingPasswordReset;
        return data; 
    }
}

export interface ISignUpMemberRequest {
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isUSCitizen: boolean;
    pendingPasswordReset: boolean | undefined;
}

export class TenantModel implements ITenantModel {
    id!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITenantModel {
    id: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
}

export class SignUpMemberResponse implements ISignUpMemberResponse {
    authenticateResult!: AuthenticateResultModel | undefined;

    constructor(data?: ISignUpMemberResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticateResult = data["authenticateResult"] ? AuthenticateResultModel.fromJS(data["authenticateResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SignUpMemberResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticateResult"] = this.authenticateResult ? this.authenticateResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISignUpMemberResponse {
    authenticateResult: AuthenticateResultModel | undefined;
}

export class SignUpRequest implements ISignUpRequest {
    fullName!: string;
    email!: string;
    password!: string;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISignUpRequest {
    fullName: string;
    email: string;
    password: string;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;
    autoDetectTenancy!: boolean | undefined;
    features!: string[] | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
    autoDetectTenancy: boolean | undefined;
    features: string[] | undefined;
}

export class SendPasswordResetCodeOutput implements ISendPasswordResetCodeOutput {
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: ISendPasswordResetCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeOutput {
    detectedTenancies: TenantModel[] | undefined;
}

export class GetResetPasswordCodeInfoInput implements IGetResetPasswordCodeInfoInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IGetResetPasswordCodeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): GetResetPasswordCodeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetResetPasswordCodeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IGetResetPasswordCodeInfoInput {
    userId: number | undefined;
    resetCode: string | undefined;
    c: string | undefined;
}

export class GetResetPasswordCodeInfoOutput implements IGetResetPasswordCodeInfoOutput {
    tenantId!: number | undefined;
    isValid!: boolean | undefined;

    constructor(data?: IGetResetPasswordCodeInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.isValid = data["isValid"];
        }
    }

    static fromJS(data: any): GetResetPasswordCodeInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetResetPasswordCodeInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isValid"] = this.isValid;
        return data; 
    }
}

export interface IGetResetPasswordCodeInfoOutput {
    tenantId: number | undefined;
    isValid: boolean | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    userId!: number | undefined;
    resetCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    userId: number | undefined;
    resetCode: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SendAutoLoginLinkInput implements ISendAutoLoginLinkInput {
    emailAddress!: string;
    autoDetectTenancy!: boolean | undefined;
    features!: string[] | undefined;
    appRoute!: string | undefined;

    constructor(data?: ISendAutoLoginLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
            this.appRoute = data["appRoute"];
        }
    }

    static fromJS(data: any): SendAutoLoginLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAutoLoginLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        data["appRoute"] = this.appRoute;
        return data; 
    }
}

export interface ISendAutoLoginLinkInput {
    emailAddress: string;
    autoDetectTenancy: boolean | undefined;
    features: string[] | undefined;
    appRoute: string | undefined;
}

export class SendAutoLoginLinkOutput implements ISendAutoLoginLinkOutput {
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: ISendAutoLoginLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendAutoLoginLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAutoLoginLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISendAutoLoginLinkOutput {
    detectedTenancies: TenantModel[] | undefined;
}

export enum ActivityType {
    Task = "Task", 
    Event = "Event", 
}

export class ActivityDto implements IActivityDto {
    id!: number | undefined;
    creatorUserId!: number | undefined;
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creatorUserId = data["creatorUserId"];
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IActivityDto {
    id: number | undefined;
    creatorUserId: number | undefined;
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class CreateActivityDto implements ICreateActivityDto {
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateActivityDto {
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class UpdateActivityDto implements IUpdateActivityDto {
    id!: number;
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateActivityDto {
    id: number;
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class MoveActivityDto implements IMoveActivityDto {
    id!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IMoveActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): MoveActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IMoveActivityDto {
    id: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    sortOrder: number | undefined;
}

export class TransitionActivityDto implements ITransitionActivityDto {
    id!: number;
    stageId!: number;
    sortOrder!: number | undefined;

    constructor(data?: ITransitionActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): TransitionActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ITransitionActivityDto {
    id: number;
    stageId: number;
    sortOrder: number | undefined;
}

export class AssignActivityUserDto implements IAssignActivityUserDto {
    id!: number;
    assignedUserIds!: number[] | undefined;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: IAssignActivityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): AssignActivityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignActivityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface IAssignActivityUserDto {
    id: number;
    assignedUserIds: number[] | undefined;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class UserInfoDto implements IUserInfoDto {
    id!: number | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.photoPublicId = data["photoPublicId"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["photoPublicId"] = this.photoPublicId;
        return data; 
    }
}

export interface IUserInfoDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    photoPublicId: string | undefined;
}

export class ApiKeyInfo implements IApiKeyInfo {
    id!: number | undefined;
    name!: string | undefined;
    key!: string | undefined;
    expirationDate!: moment.Moment | undefined;
    creationTime!: moment.Moment | undefined;
    userId!: number | undefined;
    userName!: string | undefined;

    constructor(data?: IApiKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.key = data["key"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ApiKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["key"] = this.key;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IApiKeyInfo {
    id: number | undefined;
    name: string | undefined;
    key: string | undefined;
    expirationDate: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    userId: number | undefined;
    userName: string | undefined;
}

export class GenerateApiKeyInput implements IGenerateApiKeyInput {
    name!: string;
    expirationDate!: moment.Moment | undefined;
    userId!: number | undefined;

    constructor(data?: IGenerateApiKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): GenerateApiKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateApiKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IGenerateApiKeyInput {
    name: string;
    expirationDate: moment.Moment | undefined;
    userId: number | undefined;
}

export enum OfferProviderType {
    EPCVIP = "EPCVIP", 
}

export enum DIOSVertical {
    Undefined = "Undefined", 
    PersonalLoans = "PersonalLoans", 
    Beauty = "Beauty", 
    Auto = "Auto", 
    Legal = "Legal", 
    CreditRepair = "CreditRepair", 
    CreditScore = "CreditScore", 
    Travel = "Travel", 
    Jobs = "Jobs", 
    BusinessLoans = "BusinessLoans", 
    HybridLoans = "HybridLoans", 
    DebtConsolidation = "DebtConsolidation", 
    CreditCards = "CreditCards", 
    MerchantServices = "MerchantServices", 
    Dating = "Dating", 
    Crypto = "Crypto", 
    CreditMonitoring = "CreditMonitoring", 
}

export class TrackingInformation implements ITrackingInformation {
    campaignId!: number | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    applicationDate!: moment.Moment | undefined;
    subId!: string | undefined;
    affiliateId!: number | undefined;
    vertical!: DIOSVertical | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    clickId!: string | undefined;

    constructor(data?: ITrackingInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.applicationDate = data["applicationDate"] ? moment(data["applicationDate"].toString()) : <any>undefined;
            this.subId = data["subId"];
            this.affiliateId = data["affiliateId"];
            this.vertical = data["vertical"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.clickId = data["clickId"];
        }
    }

    static fromJS(data: any): TrackingInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["applicationDate"] = this.applicationDate ? this.applicationDate.toISOString() : <any>undefined;
        data["subId"] = this.subId;
        data["affiliateId"] = this.affiliateId;
        data["vertical"] = this.vertical;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["clickId"] = this.clickId;
        return data; 
    }
}

export interface ITrackingInformation {
    campaignId: number | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    applicationDate: moment.Moment | undefined;
    subId: string | undefined;
    affiliateId: number | undefined;
    vertical: DIOSVertical | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    clickId: string | undefined;
}

export enum TimeOfDay {
    Morning = "Morning", 
    Afternoon = "Afternoon", 
    Evening = "Evening", 
    Anytime = "Anytime", 
    Night = "Night", 
}

export enum CreditScoreRating {
    NotSure = "NotSure", 
    Excellent = "Excellent", 
    Good = "Good", 
    Fair = "Fair", 
    Poor = "Poor", 
}

export enum Gender {
    Female = "Female", 
    Male = "Male", 
}

export class PersonalInformationExtended implements IPersonalInformationExtended {
    address2!: string | undefined;
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address2 = data["address2"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.middleName = data["middleName"];
            this.email = data["email"];
            this.alternateEmail = data["alternateEmail"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.licenseNumber = data["licenseNumber"];
            this.licenseState = data["licenseState"];
            this.isActiveMilitary = data["isActiveMilitary"];
            this.phone = data["phone"];
            this.phoneMobile = data["phoneMobile"];
            this.preferredContactTOD = data["preferredContactTOD"];
            this.address1 = data["address1"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.postalCode = data["postalCode"];
            this.countryCode = data["countryCode"];
            this.isHomeOwner = data["isHomeOwner"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.creditScoreRating = data["creditScoreRating"];
            this.gender = data["gender"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data; 
    }
}

export interface IPersonalInformationExtended {
    address2: string | undefined;
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class DebtInformation implements IDebtInformation {
    debtAmount!: number | undefined;
    creditCardDebtAmount!: number | undefined;
    studentDebtAmount!: number | undefined;

    constructor(data?: IDebtInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.debtAmount = data["debtAmount"];
            this.creditCardDebtAmount = data["creditCardDebtAmount"];
            this.studentDebtAmount = data["studentDebtAmount"];
        }
    }

    static fromJS(data: any): DebtInformation {
        data = typeof data === 'object' ? data : {};
        let result = new DebtInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtAmount"] = this.debtAmount;
        data["creditCardDebtAmount"] = this.creditCardDebtAmount;
        data["studentDebtAmount"] = this.studentDebtAmount;
        return data; 
    }
}

export interface IDebtInformation {
    debtAmount: number | undefined;
    creditCardDebtAmount: number | undefined;
    studentDebtAmount: number | undefined;
}

export enum LoanReason {
    DebtConsolidation = "DebtConsolidation", 
    EmergencySituation = "EmergencySituation", 
    AutoRepairs = "AutoRepairs", 
    AutoPurchase = "AutoPurchase", 
    Moving = "Moving", 
    HomeImprovement = "HomeImprovement", 
    Medical = "Medical", 
    Business = "Business", 
    Vacation = "Vacation", 
    RentOrMortgage = "RentOrMortgage", 
    Wedding = "Wedding", 
    MajorPurchases = "MajorPurchases", 
    Other = "Other", 
    CreditCardDebtRelief = "CreditCardDebtRelief", 
    StudentLoanDebtRelief = "StudentLoanDebtRelief", 
}

export class LoanInformationExtended implements ILoanInformationExtended {
    approvedLoanAmount!: number | undefined;
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvedLoanAmount = data["approvedLoanAmount"];
            this.requestedLoanAmount = data["requestedLoanAmount"];
            this.loanReason = data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedLoanAmount"] = this.approvedLoanAmount;
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data; 
    }
}

export interface ILoanInformationExtended {
    approvedLoanAmount: number | undefined;
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export enum PayFrequency {
    Weekly = "Weekly", 
    BiWeekly = "BiWeekly", 
    Monthly = "Monthly", 
    SemiMonthly = "SemiMonthly", 
}

export enum IncomeType {
    Employed = "Employed", 
    Benefits = "Benefits", 
    SelfEmployed = "SelfEmployed", 
}

export class EmploymentInformationExtended implements IEmploymentInformationExtended {
    employerAddress2!: string | undefined;
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employerAddress2 = data["employerAddress2"];
            this.isEmployed = data["isEmployed"];
            this.employerName = data["employerName"];
            this.jobTitle = data["jobTitle"];
            this.monthsAtEmployer = data["monthsAtEmployer"];
            this.phoneWork = data["phoneWork"];
            this.phoneWorkExtension = data["phoneWorkExtension"];
            this.employerAddress1 = data["employerAddress1"];
            this.employerCity = data["employerCity"];
            this.employerStateCode = data["employerStateCode"];
            this.employerPostalCode = data["employerPostalCode"];
            this.netMonthlyIncome = data["netMonthlyIncome"];
            this.payFrequency = data["payFrequency"];
            this.payNextDate = data["payNextDate"] ? moment(data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = data["payAfterNextDate"] ? moment(data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employerAddress2"] = this.employerAddress2;
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data; 
    }
}

export interface IEmploymentInformationExtended {
    employerAddress2: string | undefined;
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export enum BankAccountType {
    Checking = "Checking", 
    Savings = "Savings", 
}

export class BankInformation implements IBankInformation {
    bankAccountType!: BankAccountType | undefined;
    bankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankABA!: string | undefined;
    bankPhone!: string | undefined;
    isDirectDeposit!: boolean | undefined;
    monthsAtBank!: number | undefined;

    constructor(data?: IBankInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountType = data["bankAccountType"];
            this.bankName = data["bankName"];
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankABA = data["bankABA"];
            this.bankPhone = data["bankPhone"];
            this.isDirectDeposit = data["isDirectDeposit"];
            this.monthsAtBank = data["monthsAtBank"];
        }
    }

    static fromJS(data: any): BankInformation {
        data = typeof data === 'object' ? data : {};
        let result = new BankInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountType"] = this.bankAccountType;
        data["bankName"] = this.bankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankABA"] = this.bankABA;
        data["bankPhone"] = this.bankPhone;
        data["isDirectDeposit"] = this.isDirectDeposit;
        data["monthsAtBank"] = this.monthsAtBank;
        return data; 
    }
}

export interface IBankInformation {
    bankAccountType: BankAccountType | undefined;
    bankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankABA: string | undefined;
    bankPhone: string | undefined;
    isDirectDeposit: boolean | undefined;
    monthsAtBank: number | undefined;
}

export class LegalInformation implements ILegalInformation {
    isTCPAChecked!: boolean | undefined;

    constructor(data?: ILegalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isTCPAChecked = data["isTCPAChecked"];
        }
    }

    static fromJS(data: any): LegalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LegalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTCPAChecked"] = this.isTCPAChecked;
        return data; 
    }
}

export interface ILegalInformation {
    isTCPAChecked: boolean | undefined;
}

export class RegisterApplicantRequest implements IRegisterApplicantRequest {
    testMode!: boolean | undefined;
    isAuthenticated!: boolean | undefined;
    newUserPassword!: string | undefined;
    finalizeLeadUrl!: string | undefined;
    sendWelcomeEmail!: boolean | undefined;
    returnNewUserInfo!: boolean | undefined;
    systemType!: OfferProviderType;
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformationExtended | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformationExtended | undefined;
    employmentInformation!: EmploymentInformationExtended | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IRegisterApplicantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.testMode = data["testMode"];
            this.isAuthenticated = data["isAuthenticated"];
            this.newUserPassword = data["newUserPassword"];
            this.finalizeLeadUrl = data["finalizeLeadUrl"];
            this.sendWelcomeEmail = data["sendWelcomeEmail"];
            this.returnNewUserInfo = data["returnNewUserInfo"];
            this.systemType = data["systemType"];
            this.trackingInformation = data["trackingInformation"] ? TrackingInformation.fromJS(data["trackingInformation"]) : <any>undefined;
            this.personalInformation = data["personalInformation"] ? PersonalInformationExtended.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformationExtended.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformationExtended.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testMode"] = this.testMode;
        data["isAuthenticated"] = this.isAuthenticated;
        data["newUserPassword"] = this.newUserPassword;
        data["finalizeLeadUrl"] = this.finalizeLeadUrl;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["returnNewUserInfo"] = this.returnNewUserInfo;
        data["systemType"] = this.systemType;
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterApplicantRequest {
    testMode: boolean | undefined;
    isAuthenticated: boolean | undefined;
    newUserPassword: string | undefined;
    finalizeLeadUrl: string | undefined;
    sendWelcomeEmail: boolean | undefined;
    returnNewUserInfo: boolean | undefined;
    systemType: OfferProviderType;
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformationExtended | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformationExtended | undefined;
    employmentInformation: EmploymentInformationExtended | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class UserInfo implements IUserInfo {
    userName!: string | undefined;
    password!: string | undefined;
    loginUrl!: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.loginUrl = data["loginUrl"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["loginUrl"] = this.loginUrl;
        return data; 
    }
}

export interface IUserInfo {
    userName: string | undefined;
    password: string | undefined;
    loginUrl: string | undefined;
}

export class RegisterApplicantResponse implements IRegisterApplicantResponse {
    applicantUserId!: number | undefined;
    newUserInfo!: UserInfo | undefined;

    constructor(data?: IRegisterApplicantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicantUserId = data["applicantUserId"];
            this.newUserInfo = data["newUserInfo"] ? UserInfo.fromJS(data["newUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantUserId"] = this.applicantUserId;
        data["newUserInfo"] = this.newUserInfo ? this.newUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterApplicantResponse {
    applicantUserId: number | undefined;
    newUserInfo: UserInfo | undefined;
}

export class RegisterByApplicantRequest implements IRegisterByApplicantRequest {
    systemType!: OfferProviderType;
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformationExtended | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformationExtended | undefined;
    employmentInformation!: EmploymentInformationExtended | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IRegisterByApplicantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.trackingInformation = data["trackingInformation"] ? TrackingInformation.fromJS(data["trackingInformation"]) : <any>undefined;
            this.personalInformation = data["personalInformation"] ? PersonalInformationExtended.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformationExtended.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformationExtended.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterByApplicantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterByApplicantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterByApplicantRequest {
    systemType: OfferProviderType;
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformationExtended | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformationExtended | undefined;
    employmentInformation: EmploymentInformationExtended | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class RegisterByApplicantResponse implements IRegisterByApplicantResponse {
    authToken!: string | undefined;
    secureId!: string | undefined;

    constructor(data?: IRegisterByApplicantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authToken = data["authToken"];
            this.secureId = data["secureId"];
        }
    }

    static fromJS(data: any): RegisterByApplicantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterByApplicantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authToken"] = this.authToken;
        data["secureId"] = this.secureId;
        return data; 
    }
}

export interface IRegisterByApplicantResponse {
    authToken: string | undefined;
    secureId: string | undefined;
}

export class PersonalInformation implements IPersonalInformation {
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.middleName = data["middleName"];
            this.email = data["email"];
            this.alternateEmail = data["alternateEmail"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.licenseNumber = data["licenseNumber"];
            this.licenseState = data["licenseState"];
            this.isActiveMilitary = data["isActiveMilitary"];
            this.phone = data["phone"];
            this.phoneMobile = data["phoneMobile"];
            this.preferredContactTOD = data["preferredContactTOD"];
            this.address1 = data["address1"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.postalCode = data["postalCode"];
            this.countryCode = data["countryCode"];
            this.isHomeOwner = data["isHomeOwner"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.creditScoreRating = data["creditScoreRating"];
            this.gender = data["gender"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data; 
    }
}

export interface IPersonalInformation {
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class LoanInformation implements ILoanInformation {
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestedLoanAmount = data["requestedLoanAmount"];
            this.loanReason = data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data; 
    }
}

export interface ILoanInformation {
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export class EmploymentInformation implements IEmploymentInformation {
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmployed = data["isEmployed"];
            this.employerName = data["employerName"];
            this.jobTitle = data["jobTitle"];
            this.monthsAtEmployer = data["monthsAtEmployer"];
            this.phoneWork = data["phoneWork"];
            this.phoneWorkExtension = data["phoneWorkExtension"];
            this.employerAddress1 = data["employerAddress1"];
            this.employerCity = data["employerCity"];
            this.employerStateCode = data["employerStateCode"];
            this.employerPostalCode = data["employerPostalCode"];
            this.netMonthlyIncome = data["netMonthlyIncome"];
            this.payFrequency = data["payFrequency"];
            this.payNextDate = data["payNextDate"] ? moment(data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = data["payAfterNextDate"] ? moment(data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformation {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data; 
    }
}

export interface IEmploymentInformation {
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export class OfferApplicationDto implements IOfferApplicationDto {
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IOfferApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trackingInformation = data["trackingInformation"] ? TrackingInformation.fromJS(data["trackingInformation"]) : <any>undefined;
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OfferApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOfferApplicationDto {
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuditLogListDtoPagedResultDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export class EntityChangeListDtoPagedResultDto implements IEntityChangeListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IEntityChangeListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityChangeListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityChangeListDtoPagedResultDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export enum SyncProgressStatus {
    InProgress = "InProgress", 
    ActionRequired = "ActionRequired", 
    SyncPending = "SyncPending", 
    Unavailable = "Unavailable", 
    Completed = "Completed", 
    Failed = "Failed", 
}

export class BankAccountDto implements IBankAccountDto {
    id!: number | undefined;
    typeId!: string | undefined;
    typeName!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    businessEntityName!: string | undefined;
    businessEntityId!: number | undefined;
    isActive!: boolean | undefined;
    balance!: number | undefined;
    totalCreditLine!: number | undefined;
    availableBalance!: number | undefined;
    utilized!: number | undefined;
    syncAccountId!: number | undefined;
    isUsed!: boolean | undefined;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;
    syncStatus!: SyncProgressStatus | undefined;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.businessEntityName = data["businessEntityName"];
            this.businessEntityId = data["businessEntityId"];
            this.isActive = data["isActive"];
            this.balance = data["balance"];
            this.totalCreditLine = data["totalCreditLine"];
            this.availableBalance = data["availableBalance"];
            this.utilized = data["utilized"];
            this.syncAccountId = data["syncAccountId"];
            this.isUsed = data["isUsed"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = data["lastGoodSyncDate"] ? moment(data["lastGoodSyncDate"].toString()) : <any>undefined;
            this.syncStatus = data["syncStatus"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["businessEntityName"] = this.businessEntityName;
        data["businessEntityId"] = this.businessEntityId;
        data["isActive"] = this.isActive;
        data["balance"] = this.balance;
        data["totalCreditLine"] = this.totalCreditLine;
        data["availableBalance"] = this.availableBalance;
        data["utilized"] = this.utilized;
        data["syncAccountId"] = this.syncAccountId;
        data["isUsed"] = this.isUsed;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        data["syncStatus"] = this.syncStatus;
        return data; 
    }
}

export interface IBankAccountDto {
    id: number | undefined;
    typeId: string | undefined;
    typeName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    businessEntityName: string | undefined;
    businessEntityId: number | undefined;
    isActive: boolean | undefined;
    balance: number | undefined;
    totalCreditLine: number | undefined;
    availableBalance: number | undefined;
    utilized: number | undefined;
    syncAccountId: number | undefined;
    isUsed: boolean | undefined;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
    syncStatus: SyncProgressStatus | undefined;
}

export class SyncAccountBankDto implements ISyncAccountBankDto {
    syncAccountId!: number | undefined;
    bankId!: number | undefined;
    name!: string | undefined;
    balance!: number | undefined;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;
    refreshAllowedSinceDate!: moment.Moment | undefined;
    bankAccounts!: BankAccountDto[] | undefined;
    syncAccountStatus!: SyncProgressStatus | undefined;
    syncRef!: string | undefined;
    syncTypeId!: string | undefined;
    autoSyncTime!: string | undefined;

    constructor(data?: ISyncAccountBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncAccountId = data["syncAccountId"];
            this.bankId = data["bankId"];
            this.name = data["name"];
            this.balance = data["balance"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = data["lastGoodSyncDate"] ? moment(data["lastGoodSyncDate"].toString()) : <any>undefined;
            this.refreshAllowedSinceDate = data["refreshAllowedSinceDate"] ? moment(data["refreshAllowedSinceDate"].toString()) : <any>undefined;
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountDto.fromJS(item));
            }
            this.syncAccountStatus = data["syncAccountStatus"];
            this.syncRef = data["syncRef"];
            this.syncTypeId = data["syncTypeId"];
            this.autoSyncTime = data["autoSyncTime"];
        }
    }

    static fromJS(data: any): SyncAccountBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        data["bankId"] = this.bankId;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        data["refreshAllowedSinceDate"] = this.refreshAllowedSinceDate ? this.refreshAllowedSinceDate.toISOString() : <any>undefined;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        data["syncAccountStatus"] = this.syncAccountStatus;
        data["syncRef"] = this.syncRef;
        data["syncTypeId"] = this.syncTypeId;
        data["autoSyncTime"] = this.autoSyncTime;
        return data; 
    }
}

export interface ISyncAccountBankDto {
    syncAccountId: number | undefined;
    bankId: number | undefined;
    name: string | undefined;
    balance: number | undefined;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
    refreshAllowedSinceDate: moment.Moment | undefined;
    bankAccounts: BankAccountDto[] | undefined;
    syncAccountStatus: SyncProgressStatus | undefined;
    syncRef: string | undefined;
    syncTypeId: string | undefined;
    autoSyncTime: string | undefined;
}

export enum GroupByPeriod {
    Daily = "Daily", 
    Weekly = "Weekly", 
    Monthly = "Monthly", 
    Quarterly = "Quarterly", 
    Yearly = "Yearly", 
}

export class BankAccountDailyStatDto implements IBankAccountDailyStatDto {
    date!: moment.Moment | undefined;
    startingBalance!: number | undefined;
    startingBalanceAdjustments!: number | undefined;
    inflows!: number | undefined;
    outflows!: number | undefined;
    adjustments!: number | undefined;
    endingBalance!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    averageDailyBalance!: number | undefined;
    creditCount!: number | undefined;
    debitCount!: number | undefined;
    period!: GroupByPeriod | undefined;
    isForecast!: boolean | undefined;

    constructor(data?: IBankAccountDailyStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startingBalance = data["startingBalance"];
            this.startingBalanceAdjustments = data["startingBalanceAdjustments"];
            this.inflows = data["inflows"];
            this.outflows = data["outflows"];
            this.adjustments = data["adjustments"];
            this.endingBalance = data["endingBalance"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.averageDailyBalance = data["averageDailyBalance"];
            this.creditCount = data["creditCount"];
            this.debitCount = data["debitCount"];
            this.period = data["period"];
            this.isForecast = data["isForecast"];
        }
    }

    static fromJS(data: any): BankAccountDailyStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDailyStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startingBalance"] = this.startingBalance;
        data["startingBalanceAdjustments"] = this.startingBalanceAdjustments;
        data["inflows"] = this.inflows;
        data["outflows"] = this.outflows;
        data["adjustments"] = this.adjustments;
        data["endingBalance"] = this.endingBalance;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["averageDailyBalance"] = this.averageDailyBalance;
        data["creditCount"] = this.creditCount;
        data["debitCount"] = this.debitCount;
        data["period"] = this.period;
        data["isForecast"] = this.isForecast;
        return data; 
    }
}

export interface IBankAccountDailyStatDto {
    date: moment.Moment | undefined;
    startingBalance: number | undefined;
    startingBalanceAdjustments: number | undefined;
    inflows: number | undefined;
    outflows: number | undefined;
    adjustments: number | undefined;
    endingBalance: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    averageDailyBalance: number | undefined;
    creditCount: number | undefined;
    debitCount: number | undefined;
    period: GroupByPeriod | undefined;
    isForecast: boolean | undefined;
}

export class DiscardDiscrepanciesInput implements IDiscardDiscrepanciesInput {
    bankIds!: number[] | undefined;
    bankAccountIds!: number[] | undefined;
    currencyId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;

    constructor(data?: IDiscardDiscrepanciesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.currencyId = data["currencyId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscardDiscrepanciesInput {
        data = typeof data === 'object' ? data : {};
        let result = new DiscardDiscrepanciesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["currencyId"] = this.currencyId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDiscardDiscrepanciesInput {
    bankIds: number[] | undefined;
    bankAccountIds: number[] | undefined;
    currencyId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
}

export class UpdateBankAccountDto implements IUpdateBankAccountDto {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    isActive!: boolean;
    businessEntityId!: number | undefined;

    constructor(data?: IUpdateBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.typeId = data["typeId"];
            this.isActive = data["isActive"];
            this.businessEntityId = data["businessEntityId"];
        }
    }

    static fromJS(data: any): UpdateBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["isActive"] = this.isActive;
        data["businessEntityId"] = this.businessEntityId;
        return data; 
    }
}

export interface IUpdateBankAccountDto {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    isActive: boolean;
    businessEntityId: number | undefined;
}

export class GetBankCodeInput implements IGetBankCodeInput {
    content!: string;
    source!: string | undefined;

    constructor(data?: IGetBankCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): GetBankCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["source"] = this.source;
        return data; 
    }
}

export interface IGetBankCodeInput {
    content: string;
    source: string | undefined;
}

export class GetBankCodeOutput implements IGetBankCodeOutput {
    action!: number | undefined;
    blueprint!: number | undefined;
    knowledge!: number | undefined;
    nurturing!: number | undefined;
    value!: string | undefined;

    constructor(data?: IGetBankCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.blueprint = data["blueprint"];
            this.knowledge = data["knowledge"];
            this.nurturing = data["nurturing"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): GetBankCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["blueprint"] = this.blueprint;
        data["knowledge"] = this.knowledge;
        data["nurturing"] = this.nurturing;
        data["value"] = this.value;
        return data; 
    }
}

export interface IGetBankCodeOutput {
    action: number | undefined;
    blueprint: number | undefined;
    knowledge: number | undefined;
    nurturing: number | undefined;
    value: string | undefined;
}

export class AdvisorLinkInfo implements IAdvisorLinkInfo {
    linkTypeId!: string | undefined;
    url!: string | undefined;

    constructor(data?: IAdvisorLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): AdvisorLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AdvisorLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAdvisorLinkInfo {
    linkTypeId: string | undefined;
    url: string | undefined;
}

export class GetAdvisorInfoOutput implements IGetAdvisorInfoOutput {
    fullName!: string | undefined;
    emailAddress!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    profilePictureId!: string | undefined;
    advisorLinks!: AdvisorLinkInfo[] | undefined;

    constructor(data?: IGetAdvisorInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
            this.emailAddress = data["emailAddress"];
            this.phone = data["phone"];
            this.bankCode = data["bankCode"];
            this.profilePictureId = data["profilePictureId"];
            if (data["advisorLinks"] && data["advisorLinks"].constructor === Array) {
                this.advisorLinks = [];
                for (let item of data["advisorLinks"])
                    this.advisorLinks.push(AdvisorLinkInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAdvisorInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdvisorInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["profilePictureId"] = this.profilePictureId;
        if (this.advisorLinks && this.advisorLinks.constructor === Array) {
            data["advisorLinks"] = [];
            for (let item of this.advisorLinks)
                data["advisorLinks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAdvisorInfoOutput {
    fullName: string | undefined;
    emailAddress: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    profilePictureId: string | undefined;
    advisorLinks: AdvisorLinkInfo[] | undefined;
}

export class CreateContactEmailInputWithoutCheck implements ICreateContactEmailInputWithoutCheck {
    contactId!: number | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactEmailInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactEmailInputWithoutCheck {
    contactId: number | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactPhoneInputWithoutCheck implements ICreateContactPhoneInputWithoutCheck {
    contactId!: number | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactPhoneInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactPhoneInputWithoutCheck {
    contactId: number | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactAddressInputWithoutCheck implements ICreateContactAddressInputWithoutCheck {
    contactId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactAddressInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateContactAddressInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateContactAddressInputWithoutCheck {
    contactId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class CreateOrEditLeadInput implements ICreateOrEditLeadInput {
    id!: number | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    companyName!: string | undefined;
    emailAddress!: CreateContactEmailInputWithoutCheck | undefined;
    phoneNumber!: CreateContactPhoneInputWithoutCheck | undefined;
    address!: CreateContactAddressInputWithoutCheck | undefined;
    isAIGeneratedBankCode!: boolean | undefined;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;

    constructor(data?: ICreateOrEditLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.companyName = data["companyName"];
            this.emailAddress = data["emailAddress"] ? CreateContactEmailInputWithoutCheck.fromJS(data["emailAddress"]) : <any>undefined;
            this.phoneNumber = data["phoneNumber"] ? CreateContactPhoneInputWithoutCheck.fromJS(data["phoneNumber"]) : <any>undefined;
            this.address = data["address"] ? CreateContactAddressInputWithoutCheck.fromJS(data["address"]) : <any>undefined;
            this.isAIGeneratedBankCode = data["isAIGeneratedBankCode"];
            this.bankCode = data["bankCode"];
            this.bankCodeSource = data["bankCodeSource"];
        }
    }

    static fromJS(data: any): CreateOrEditLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["companyName"] = this.companyName;
        data["emailAddress"] = this.emailAddress ? this.emailAddress.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["isAIGeneratedBankCode"] = this.isAIGeneratedBankCode;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        return data; 
    }
}

export interface ICreateOrEditLeadInput {
    id: number | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    companyName: string | undefined;
    emailAddress: CreateContactEmailInputWithoutCheck | undefined;
    phoneNumber: CreateContactPhoneInputWithoutCheck | undefined;
    address: CreateContactAddressInputWithoutCheck | undefined;
    isAIGeneratedBankCode: boolean | undefined;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
}

export class CreateLeadOutput implements ICreateLeadOutput {
    contactId!: number | undefined;
    leadId!: number | undefined;

    constructor(data?: ICreateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.leadId = data["leadId"];
        }
    }

    static fromJS(data: any): CreateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        return data; 
    }
}

export interface ICreateLeadOutput {
    contactId: number | undefined;
    leadId: number | undefined;
}

export class GetSystemTotalsOutput implements IGetSystemTotalsOutput {
    systemTotals!: { [key: string] : number; } | undefined;
    lastCrackedCode!: string | undefined;
    generationTime!: moment.Moment | undefined;

    constructor(data?: IGetSystemTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["systemTotals"]) {
                this.systemTotals = {};
                for (let key in data["systemTotals"]) {
                    if (data["systemTotals"].hasOwnProperty(key))
                        this.systemTotals[key] = data["systemTotals"][key];
                }
            }
            this.lastCrackedCode = data["lastCrackedCode"];
            this.generationTime = data["generationTime"] ? moment(data["generationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSystemTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSystemTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.systemTotals) {
            data["systemTotals"] = {};
            for (let key in this.systemTotals) {
                if (this.systemTotals.hasOwnProperty(key))
                    data["systemTotals"][key] = this.systemTotals[key];
            }
        }
        data["lastCrackedCode"] = this.lastCrackedCode;
        data["generationTime"] = this.generationTime ? this.generationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetSystemTotalsOutput {
    systemTotals: { [key: string] : number; } | undefined;
    lastCrackedCode: string | undefined;
    generationTime: moment.Moment | undefined;
}

export class GetUserTotalsOutput implements IGetUserTotalsOutput {
    totalCount!: number | undefined;
    lastCrackedCode!: string | undefined;

    constructor(data?: IGetUserTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.lastCrackedCode = data["lastCrackedCode"];
        }
    }

    static fromJS(data: any): GetUserTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["lastCrackedCode"] = this.lastCrackedCode;
        return data; 
    }
}

export interface IGetUserTotalsOutput {
    totalCount: number | undefined;
    lastCrackedCode: string | undefined;
}

export class LeaderInfo implements ILeaderInfo {
    rank!: number | undefined;
    fullName!: string | undefined;
    publicPhotoId!: string | undefined;
    bankCode!: string | undefined;
    codesCracked!: number | undefined;

    constructor(data?: ILeaderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rank = data["rank"];
            this.fullName = data["fullName"];
            this.publicPhotoId = data["publicPhotoId"];
            this.bankCode = data["bankCode"];
            this.codesCracked = data["codesCracked"];
        }
    }

    static fromJS(data: any): LeaderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["fullName"] = this.fullName;
        data["publicPhotoId"] = this.publicPhotoId;
        data["bankCode"] = this.bankCode;
        data["codesCracked"] = this.codesCracked;
        return data; 
    }
}

export interface ILeaderInfo {
    rank: number | undefined;
    fullName: string | undefined;
    publicPhotoId: string | undefined;
    bankCode: string | undefined;
    codesCracked: number | undefined;
}

export class GetLeaderBoardOutput implements IGetLeaderBoardOutput {
    leaders!: LeaderInfo[] | undefined;
    generationTime!: moment.Moment | undefined;

    constructor(data?: IGetLeaderBoardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["leaders"] && data["leaders"].constructor === Array) {
                this.leaders = [];
                for (let item of data["leaders"])
                    this.leaders.push(LeaderInfo.fromJS(item));
            }
            this.generationTime = data["generationTime"] ? moment(data["generationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLeaderBoardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaderBoardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.leaders && this.leaders.constructor === Array) {
            data["leaders"] = [];
            for (let item of this.leaders)
                data["leaders"].push(item.toJSON());
        }
        data["generationTime"] = this.generationTime ? this.generationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetLeaderBoardOutput {
    leaders: LeaderInfo[] | undefined;
    generationTime: moment.Moment | undefined;
}

export class GetUserRankOutput implements IGetUserRankOutput {
    rank!: number | undefined;
    generationDate!: moment.Moment | undefined;

    constructor(data?: IGetUserRankOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rank = data["rank"];
            this.generationDate = data["generationDate"] ? moment(data["generationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserRankOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRankOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rank"] = this.rank;
        data["generationDate"] = this.generationDate ? this.generationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetUserRankOutput {
    rank: number | undefined;
    generationDate: moment.Moment | undefined;
}

export class RecentlyAddedContact implements IRecentlyAddedContact {
    sourceContactFullName!: string | undefined;
    bankCode!: string | undefined;
    bankCodeDate!: moment.Moment | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;

    constructor(data?: IRecentlyAddedContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceContactFullName = data["sourceContactFullName"];
            this.bankCode = data["bankCode"];
            this.bankCodeDate = data["bankCodeDate"] ? moment(data["bankCodeDate"].toString()) : <any>undefined;
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
        }
    }

    static fromJS(data: any): RecentlyAddedContact {
        data = typeof data === 'object' ? data : {};
        let result = new RecentlyAddedContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceContactFullName"] = this.sourceContactFullName;
        data["bankCode"] = this.bankCode;
        data["bankCodeDate"] = this.bankCodeDate ? this.bankCodeDate.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data; 
    }
}

export interface IRecentlyAddedContact {
    sourceContactFullName: string | undefined;
    bankCode: string | undefined;
    bankCodeDate: moment.Moment | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
}

export class BankCodeHistoryInfo implements IBankCodeHistoryInfo {
    bankCode!: string | undefined;
    source!: string | undefined;
    overridden!: boolean | undefined;
    selfAssessmentB!: number | undefined;
    selfAssessmentA!: number | undefined;
    selfAssessmentN!: number | undefined;
    selfAssessmentK!: number | undefined;
    dateTime!: moment.Moment | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    userPhotoPublicId!: string | undefined;

    constructor(data?: IBankCodeHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankCode = data["bankCode"];
            this.source = data["source"];
            this.overridden = data["overridden"];
            this.selfAssessmentB = data["selfAssessmentB"];
            this.selfAssessmentA = data["selfAssessmentA"];
            this.selfAssessmentN = data["selfAssessmentN"];
            this.selfAssessmentK = data["selfAssessmentK"];
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userPhotoPublicId = data["userPhotoPublicId"];
        }
    }

    static fromJS(data: any): BankCodeHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCodeHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["source"] = this.source;
        data["overridden"] = this.overridden;
        data["selfAssessmentB"] = this.selfAssessmentB;
        data["selfAssessmentA"] = this.selfAssessmentA;
        data["selfAssessmentN"] = this.selfAssessmentN;
        data["selfAssessmentK"] = this.selfAssessmentK;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userPhotoPublicId"] = this.userPhotoPublicId;
        return data; 
    }
}

export interface IBankCodeHistoryInfo {
    bankCode: string | undefined;
    source: string | undefined;
    overridden: boolean | undefined;
    selfAssessmentB: number | undefined;
    selfAssessmentA: number | undefined;
    selfAssessmentN: number | undefined;
    selfAssessmentK: number | undefined;
    dateTime: moment.Moment | undefined;
    userId: number | undefined;
    userName: string | undefined;
    userPhotoPublicId: string | undefined;
}

export class BudgetImportInput implements IBudgetImportInput {
    year!: number;
    businessEntityId!: number;
    currencyId!: string;
    excelFile!: string | undefined;
    override!: boolean | undefined;

    constructor(data?: IBudgetImportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.year = data["year"];
            this.businessEntityId = data["businessEntityId"];
            this.currencyId = data["currencyId"];
            this.excelFile = data["excelFile"];
            this.override = data["override"];
        }
    }

    static fromJS(data: any): BudgetImportInput {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetImportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["businessEntityId"] = this.businessEntityId;
        data["currencyId"] = this.currencyId;
        data["excelFile"] = this.excelFile;
        data["override"] = this.override;
        return data; 
    }
}

export interface IBudgetImportInput {
    year: number;
    businessEntityId: number;
    currencyId: string;
    excelFile: string | undefined;
    override: boolean | undefined;
}

export class SendReportNotificationInfo implements ISendReportNotificationInfo {
    recipientUserEmailAddress!: string;
    sendReportInAttachments!: boolean;

    constructor(data?: ISendReportNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recipientUserEmailAddress = data["recipientUserEmailAddress"];
            this.sendReportInAttachments = data["sendReportInAttachments"];
        }
    }

    static fromJS(data: any): SendReportNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SendReportNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipientUserEmailAddress"] = this.recipientUserEmailAddress;
        data["sendReportInAttachments"] = this.sendReportInAttachments;
        return data; 
    }
}

export interface ISendReportNotificationInfo {
    recipientUserEmailAddress: string;
    sendReportInAttachments: boolean;
}

export class GenerateBudgetReportInput implements IGenerateBudgetReportInput {
    businessEntityId!: number;
    year!: number;
    currencyId!: string;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateBudgetReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.businessEntityId = data["businessEntityId"];
            this.year = data["year"];
            this.currencyId = data["currencyId"];
            this.notificationData = data["notificationData"] ? SendReportNotificationInfo.fromJS(data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateBudgetReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateBudgetReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        data["year"] = this.year;
        data["currencyId"] = this.currencyId;
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGenerateBudgetReportInput {
    businessEntityId: number;
    year: number;
    currencyId: string;
    notificationData: SendReportNotificationInfo | undefined;
}

export class BusinessEntityDto implements IBusinessEntityDto {
    id!: number | undefined;
    name!: string | undefined;
    isDefault!: boolean | undefined;
    parentId!: number | undefined;
    hasChildren!: boolean | undefined;

    constructor(data?: IBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            this.parentId = data["parentId"];
            this.hasChildren = data["hasChildren"];
        }
    }

    static fromJS(data: any): BusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["parentId"] = this.parentId;
        data["hasChildren"] = this.hasChildren;
        return data; 
    }
}

export interface IBusinessEntityDto {
    id: number | undefined;
    name: string | undefined;
    isDefault: boolean | undefined;
    parentId: number | undefined;
    hasChildren: boolean | undefined;
}

export enum BusinessEntityType {
    Other = "Other", 
    LLC = "LLC", 
    SoleProprietership = "SoleProprietership", 
    LLP = "LLP", 
    LLLP = "LLLP", 
    Corp = "Corp", 
    Trust = "Trust", 
    LP = "LP", 
    Inc = "Inc", 
    Partnership = "Partnership", 
}

export class BusinessEntityTypeDto implements IBusinessEntityTypeDto {
    id!: BusinessEntityType | undefined;
    name!: string | undefined;

    constructor(data?: IBusinessEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BusinessEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBusinessEntityTypeDto {
    id: BusinessEntityType | undefined;
    name: string | undefined;
}

export enum BusinessEntityStatus {
    Active = "Active", 
    Inactive = "Inactive", 
}

export class BusinessEntityInfoDto implements IBusinessEntityInfoDto {
    name!: string | undefined;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    status!: BusinessEntityStatus | undefined;
    isDefault!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IBusinessEntityInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.type = data["type"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.status = data["status"];
            this.isDefault = data["isDefault"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BusinessEntityInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["status"] = this.status;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessEntityInfoDto {
    name: string | undefined;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    status: BusinessEntityStatus | undefined;
    isDefault: boolean | undefined;
    id: number | undefined;
}

export class CreateBusinessEntityDto implements ICreateBusinessEntityDto {
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    neighborhood!: string | undefined;
    streetAddress!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: ICreateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.type = data["type"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.neighborhood = data["neighborhood"];
            this.streetAddress = data["streetAddress"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): CreateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["neighborhood"] = this.neighborhood;
        data["streetAddress"] = this.streetAddress;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateBusinessEntityDto {
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    neighborhood: string | undefined;
    streetAddress: string | undefined;
    isDefault: boolean | undefined;
}

export class UpdateBusinessEntityDto implements IUpdateBusinessEntityDto {
    id!: number;
    status!: BusinessEntityStatus | undefined;
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    type!: BusinessEntityType | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    neighborhood!: string | undefined;
    streetAddress!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IUpdateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.type = data["type"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.neighborhood = data["neighborhood"];
            this.streetAddress = data["streetAddress"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["neighborhood"] = this.neighborhood;
        data["streetAddress"] = this.streetAddress;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateBusinessEntityDto {
    id: number;
    status: BusinessEntityStatus | undefined;
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    type: BusinessEntityType | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    neighborhood: string | undefined;
    streetAddress: string | undefined;
    isDefault: boolean | undefined;
}

export class BusinessEntityBankAccountDto implements IBusinessEntityBankAccountDto {
    bankAccountId!: number | undefined;
    bankName!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    isLinked!: boolean | undefined;
    isUsed!: boolean | undefined;

    constructor(data?: IBusinessEntityBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.bankName = data["bankName"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.isLinked = data["isLinked"];
            this.isUsed = data["isUsed"];
        }
    }

    static fromJS(data: any): BusinessEntityBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["bankName"] = this.bankName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["isLinked"] = this.isLinked;
        data["isUsed"] = this.isUsed;
        return data; 
    }
}

export interface IBusinessEntityBankAccountDto {
    bankAccountId: number | undefined;
    bankName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    isLinked: boolean | undefined;
    isUsed: boolean | undefined;
}

export class BusinessEntityUpdateBankAccountsInput implements IBusinessEntityUpdateBankAccountsInput {
    businessEntityId!: number;
    bankAccountIds!: number[];
    isLinked!: boolean;

    constructor(data?: IBusinessEntityUpdateBankAccountsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bankAccountIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.businessEntityId = data["businessEntityId"];
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.isLinked = data["isLinked"];
        }
    }

    static fromJS(data: any): BusinessEntityUpdateBankAccountsInput {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityUpdateBankAccountsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["isLinked"] = this.isLinked;
        return data; 
    }
}

export interface IBusinessEntityUpdateBankAccountsInput {
    businessEntityId: number;
    bankAccountIds: number[];
    isLinked: boolean;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class CacheDtoListResultDto implements ICacheDtoListResultDto {
    items!: CacheDto[] | undefined;

    constructor(data?: ICacheDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CacheDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICacheDtoListResultDto {
    items: CacheDto[] | undefined;
}

export class StringEntityDto implements IStringEntityDto {
    id!: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IStringEntityDto {
    id: string | undefined;
}

export class Period implements IPeriod {
    start!: moment.Moment | undefined;
    end!: moment.Moment | undefined;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"] ? moment(data["start"].toString()) : <any>undefined;
            this.end = data["end"] ? moment(data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPeriod {
    start: moment.Moment | undefined;
    end: moment.Moment | undefined;
}

export class StatsFilter implements IStatsFilter {
    forecastModelId!: number | undefined;
    showResolvedComments!: boolean | undefined;
    groupByPeriod!: GroupByPeriod | undefined;
    dailyPeriods!: Period[] | undefined;
    calculateStartingBalance!: boolean | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.showResolvedComments = false;
            this.calculateStartingBalance = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.showResolvedComments = data["showResolvedComments"] !== undefined ? data["showResolvedComments"] : false;
            this.groupByPeriod = data["groupByPeriod"];
            if (data["dailyPeriods"] && data["dailyPeriods"].constructor === Array) {
                this.dailyPeriods = [];
                for (let item of data["dailyPeriods"])
                    this.dailyPeriods.push(Period.fromJS(item));
            }
            this.calculateStartingBalance = data["calculateStartingBalance"] !== undefined ? data["calculateStartingBalance"] : true;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["showResolvedComments"] = this.showResolvedComments;
        data["groupByPeriod"] = this.groupByPeriod;
        if (this.dailyPeriods && this.dailyPeriods.constructor === Array) {
            data["dailyPeriods"] = [];
            for (let item of this.dailyPeriods)
                data["dailyPeriods"].push(item.toJSON());
        }
        data["calculateStartingBalance"] = this.calculateStartingBalance;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsFilter {
    forecastModelId: number | undefined;
    showResolvedComments: boolean | undefined;
    groupByPeriod: GroupByPeriod | undefined;
    dailyPeriods: Period[] | undefined;
    calculateStartingBalance: boolean | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export enum AdjustmentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export class TransactionStatsDto implements ITransactionStatsDto {
    adjustmentType!: AdjustmentType | undefined;
    cashflowTypeId!: string | undefined;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    accountId!: number | undefined;
    currencyId!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;
    count!: number | undefined;
    comment!: string | undefined;
    forecastId!: number | undefined;

    constructor(data?: ITransactionStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adjustmentType = data["adjustmentType"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            this.currencyId = data["currencyId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.count = data["count"];
            this.comment = data["comment"];
            this.forecastId = data["forecastId"];
        }
    }

    static fromJS(data: any): TransactionStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        data["currencyId"] = this.currencyId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["count"] = this.count;
        data["comment"] = this.comment;
        data["forecastId"] = this.forecastId;
        return data; 
    }
}

export interface ITransactionStatsDto {
    adjustmentType: AdjustmentType | undefined;
    cashflowTypeId: string | undefined;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number | undefined;
    currencyId: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
    count: number | undefined;
    comment: string | undefined;
    forecastId: number | undefined;
}

export class CashFlowCommentThreadDto implements ICashFlowCommentThreadDto {
    threadId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    cashFlowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    accountId!: number | undefined;
    categorization!: { [key: string] : string; } | undefined;

    constructor(data?: ICashFlowCommentThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            if (data["categorization"]) {
                this.categorization = {};
                for (let key in data["categorization"]) {
                    if (data["categorization"].hasOwnProperty(key))
                        this.categorization[key] = data["categorization"][key];
                }
            }
        }
    }

    static fromJS(data: any): CashFlowCommentThreadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowCommentThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        if (this.categorization) {
            data["categorization"] = {};
            for (let key in this.categorization) {
                if (this.categorization.hasOwnProperty(key))
                    data["categorization"][key] = this.categorization[key];
            }
        }
        return data; 
    }
}

export interface ICashFlowCommentThreadDto {
    threadId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    cashFlowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number | undefined;
    categorization: { [key: string] : string; } | undefined;
}

export class BudgetDto implements IBudgetDto {
    businessEntityId!: number | undefined;
    categoryId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.businessEntityId = data["businessEntityId"];
            this.categoryId = data["categoryId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): BudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        data["categoryId"] = this.categoryId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IBudgetDto {
    businessEntityId: number | undefined;
    categoryId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export class CashFlowStatsDto implements ICashFlowStatsDto {
    transactionStats!: TransactionStatsDto[] | undefined;
    commentThreads!: CashFlowCommentThreadDto[] | undefined;
    budgets!: BudgetDto[] | undefined;

    constructor(data?: ICashFlowStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionStats"] && data["transactionStats"].constructor === Array) {
                this.transactionStats = [];
                for (let item of data["transactionStats"])
                    this.transactionStats.push(TransactionStatsDto.fromJS(item));
            }
            if (data["commentThreads"] && data["commentThreads"].constructor === Array) {
                this.commentThreads = [];
                for (let item of data["commentThreads"])
                    this.commentThreads.push(CashFlowCommentThreadDto.fromJS(item));
            }
            if (data["budgets"] && data["budgets"].constructor === Array) {
                this.budgets = [];
                for (let item of data["budgets"])
                    this.budgets.push(BudgetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionStats && this.transactionStats.constructor === Array) {
            data["transactionStats"] = [];
            for (let item of this.transactionStats)
                data["transactionStats"].push(item.toJSON());
        }
        if (this.commentThreads && this.commentThreads.constructor === Array) {
            data["commentThreads"] = [];
            for (let item of this.commentThreads)
                data["commentThreads"].push(item.toJSON());
        }
        if (this.budgets && this.budgets.constructor === Array) {
            data["budgets"] = [];
            for (let item of this.budgets)
                data["budgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowStatsDto {
    transactionStats: TransactionStatsDto[] | undefined;
    commentThreads: CashFlowCommentThreadDto[] | undefined;
    budgets: BudgetDto[] | undefined;
}

export class BankDto implements IBankDto {
    id!: number | undefined;
    name!: string | undefined;
    bankAccounts!: BankAccountDto[] | undefined;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBankDto {
    id: number | undefined;
    name: string | undefined;
    bankAccounts: BankAccountDto[] | undefined;
}

export class BankAccountBalanceDto implements IBankAccountBalanceDto {
    bankAccountId!: number | undefined;
    currencyId!: string | undefined;
    balance!: number | undefined;
    balanceDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IBankAccountBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.currencyId = data["currencyId"];
            this.balance = data["balance"];
            this.balanceDate = data["balanceDate"] ? moment(data["balanceDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): BankAccountBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["currencyId"] = this.currencyId;
        data["balance"] = this.balance;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IBankAccountBalanceDto {
    bankAccountId: number | undefined;
    currencyId: string | undefined;
    balance: number | undefined;
    balanceDate: moment.Moment | undefined;
    isActive: boolean | undefined;
}

export class CashFlowInitialData implements ICashFlowInitialData {
    banks!: BankDto[] | undefined;
    businessEntities!: BusinessEntityDto[] | undefined;
    cashflowTypes!: { [key: string] : string; } | undefined;
    bankAccountBalances!: BankAccountBalanceDto[] | undefined;

    constructor(data?: ICashFlowInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(BusinessEntityDto.fromJS(item));
            }
            if (data["cashflowTypes"]) {
                this.cashflowTypes = {};
                for (let key in data["cashflowTypes"]) {
                    if (data["cashflowTypes"].hasOwnProperty(key))
                        this.cashflowTypes[key] = data["cashflowTypes"][key];
                }
            }
            if (data["bankAccountBalances"] && data["bankAccountBalances"].constructor === Array) {
                this.bankAccountBalances = [];
                for (let item of data["bankAccountBalances"])
                    this.bankAccountBalances.push(BankAccountBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        if (this.cashflowTypes) {
            data["cashflowTypes"] = {};
            for (let key in this.cashflowTypes) {
                if (this.cashflowTypes.hasOwnProperty(key))
                    data["cashflowTypes"][key] = this.cashflowTypes[key];
            }
        }
        if (this.bankAccountBalances && this.bankAccountBalances.constructor === Array) {
            data["bankAccountBalances"] = [];
            for (let item of this.bankAccountBalances)
                data["bankAccountBalances"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowInitialData {
    banks: BankDto[] | undefined;
    businessEntities: BusinessEntityDto[] | undefined;
    cashflowTypes: { [key: string] : string; } | undefined;
    bankAccountBalances: BankAccountBalanceDto[] | undefined;
}

export enum SectionGroup {
    Income = "Income", 
    CostOfSales = "CostOfSales", 
    Expense = "Expense", 
    OtherIncomeExpense = "OtherIncomeExpense", 
}

export class StatsDetailFilter implements IStatsDetailFilter {
    searchTerm!: string | undefined;
    forecastModelId!: number | undefined;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchTerm = data["searchTerm"];
            this.forecastModelId = data["forecastModelId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        data["forecastModelId"] = this.forecastModelId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilter {
    searchTerm: string | undefined;
    forecastModelId: number | undefined;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export enum Status {
    Historical = "Historical", 
    Partial = "Partial", 
    Projected = "Projected", 
    Completed = "Completed", 
}

export enum StatsType {
    Transaction = "Transaction", 
    Adjustment = "Adjustment", 
    Forecast = "Forecast", 
}

export class CashFlowStatsDetailDto implements ICashFlowStatsDetailDto {
    id!: number | undefined;
    date!: moment.Moment | undefined;
    businessEntityName!: string | undefined;
    cashflowTypeId!: string | undefined;
    categoryId!: number | undefined;
    categoryName!: string | undefined;
    descriptor!: string | undefined;
    isDescriptorCalculated!: boolean | undefined;
    bankName!: string | undefined;
    accountId!: number | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    currencyId!: string | undefined;
    credit!: number | undefined;
    debit!: number | undefined;
    amount!: number | undefined;
    description!: string | undefined;
    comment!: string | undefined;
    commentThreadId!: number | undefined;
    forecastId!: number | undefined;
    forecastDate!: moment.Moment | undefined;
    status!: Status | undefined;
    counterpartyName!: string | undefined;
    type!: StatsType | undefined;

    constructor(data?: ICashFlowStatsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.businessEntityName = data["businessEntityName"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.descriptor = data["descriptor"];
            this.isDescriptorCalculated = data["isDescriptorCalculated"];
            this.bankName = data["bankName"];
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.currencyId = data["currencyId"];
            this.credit = data["credit"];
            this.debit = data["debit"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.comment = data["comment"];
            this.commentThreadId = data["commentThreadId"];
            this.forecastId = data["forecastId"];
            this.forecastDate = data["forecastDate"] ? moment(data["forecastDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.counterpartyName = data["counterpartyName"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): CashFlowStatsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["businessEntityName"] = this.businessEntityName;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["descriptor"] = this.descriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["bankName"] = this.bankName;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["currencyId"] = this.currencyId;
        data["credit"] = this.credit;
        data["debit"] = this.debit;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["commentThreadId"] = this.commentThreadId;
        data["forecastId"] = this.forecastId;
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["counterpartyName"] = this.counterpartyName;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICashFlowStatsDetailDto {
    id: number | undefined;
    date: moment.Moment | undefined;
    businessEntityName: string | undefined;
    cashflowTypeId: string | undefined;
    categoryId: number | undefined;
    categoryName: string | undefined;
    descriptor: string | undefined;
    isDescriptorCalculated: boolean | undefined;
    bankName: string | undefined;
    accountId: number | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    currencyId: string | undefined;
    credit: number | undefined;
    debit: number | undefined;
    amount: number | undefined;
    description: string | undefined;
    comment: string | undefined;
    commentThreadId: number | undefined;
    forecastId: number | undefined;
    forecastDate: moment.Moment | undefined;
    status: Status | undefined;
    counterpartyName: string | undefined;
    type: StatsType | undefined;
}

export enum PeriodScope {
    Days = "Days", 
    Weeks = "Weeks", 
    Months = "Months", 
    Quarters = "Quarters", 
    Years = "Years", 
    None = "None", 
}

export enum MonthPeriodScope {
    Days = "Days", 
    Weeks = "Weeks", 
}

export class CashflowGridGeneralSettingsDto implements ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals!: number;
    hideZeroValuesInCells!: number;
    showNegativeValuesInRed!: number;
    showColumnsWithZeroActivity!: PeriodScope;
    showNetChangeRow!: boolean;
    showBalanceDiscrepancy!: boolean;
    splitMonthType!: MonthPeriodScope;

    constructor(data?: ICashflowGridGeneralSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.showAmountsWithDecimals = data["showAmountsWithDecimals"];
            this.hideZeroValuesInCells = data["hideZeroValuesInCells"];
            this.showNegativeValuesInRed = data["showNegativeValuesInRed"];
            this.showColumnsWithZeroActivity = data["showColumnsWithZeroActivity"];
            this.showNetChangeRow = data["showNetChangeRow"];
            this.showBalanceDiscrepancy = data["showBalanceDiscrepancy"];
            this.splitMonthType = data["splitMonthType"];
        }
    }

    static fromJS(data: any): CashflowGridGeneralSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridGeneralSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAmountsWithDecimals"] = this.showAmountsWithDecimals;
        data["hideZeroValuesInCells"] = this.hideZeroValuesInCells;
        data["showNegativeValuesInRed"] = this.showNegativeValuesInRed;
        data["showColumnsWithZeroActivity"] = this.showColumnsWithZeroActivity;
        data["showNetChangeRow"] = this.showNetChangeRow;
        data["showBalanceDiscrepancy"] = this.showBalanceDiscrepancy;
        data["splitMonthType"] = this.splitMonthType;
        return data; 
    }
}

export interface ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals: number;
    hideZeroValuesInCells: number;
    showNegativeValuesInRed: number;
    showColumnsWithZeroActivity: PeriodScope;
    showNetChangeRow: boolean;
    showBalanceDiscrepancy: boolean;
    splitMonthType: MonthPeriodScope;
}

export class CashflowGridVisualSettingsDto implements ICashflowGridVisualSettingsDto {
    fontName!: string;
    fontSize!: string;
    cfoTheme!: string;
    showFooterBar!: boolean;

    constructor(data?: ICashflowGridVisualSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fontName = data["fontName"];
            this.fontSize = data["fontSize"];
            this.cfoTheme = data["cfoTheme"];
            this.showFooterBar = data["showFooterBar"];
        }
    }

    static fromJS(data: any): CashflowGridVisualSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridVisualSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fontName"] = this.fontName;
        data["fontSize"] = this.fontSize;
        data["cfoTheme"] = this.cfoTheme;
        data["showFooterBar"] = this.showFooterBar;
        return data; 
    }
}

export interface ICashflowGridVisualSettingsDto {
    fontName: string;
    fontSize: string;
    cfoTheme: string;
    showFooterBar: boolean;
}

export class LocalizationAndCurrencyDto implements ILocalizationAndCurrencyDto {
    numberFormatting!: string;
    currency!: string;

    constructor(data?: ILocalizationAndCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.numberFormatting = data["numberFormatting"];
            this.currency = data["currency"];
        }
    }

    static fromJS(data: any): LocalizationAndCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationAndCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberFormatting"] = this.numberFormatting;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface ILocalizationAndCurrencyDto {
    numberFormatting: string;
    currency: string;
}

export class CashFlowGridSettingsDto implements ICashFlowGridSettingsDto {
    general!: CashflowGridGeneralSettingsDto;
    visualPreferences!: CashflowGridVisualSettingsDto;
    localizationAndCurrency!: LocalizationAndCurrencyDto;

    constructor(data?: ICashFlowGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new CashflowGridGeneralSettingsDto();
            this.visualPreferences = new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = new LocalizationAndCurrencyDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? CashflowGridGeneralSettingsDto.fromJS(data["general"]) : new CashflowGridGeneralSettingsDto();
            this.visualPreferences = data["visualPreferences"] ? CashflowGridVisualSettingsDto.fromJS(data["visualPreferences"]) : new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = data["localizationAndCurrency"] ? LocalizationAndCurrencyDto.fromJS(data["localizationAndCurrency"]) : new LocalizationAndCurrencyDto();
        }
    }

    static fromJS(data: any): CashFlowGridSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["visualPreferences"] = this.visualPreferences ? this.visualPreferences.toJSON() : <any>undefined;
        data["localizationAndCurrency"] = this.localizationAndCurrency ? this.localizationAndCurrency.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICashFlowGridSettingsDto {
    general: CashflowGridGeneralSettingsDto;
    visualPreferences: CashflowGridVisualSettingsDto;
    localizationAndCurrency: LocalizationAndCurrencyDto;
}

export class ForecastModelDto implements IForecastModelDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IForecastModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ForecastModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IForecastModelDto {
    id: number | undefined;
    name: string | undefined;
}

export class AddForecastInput implements IAddForecastInput {
    forecastModelId!: number;
    bankAccountId!: number;
    date!: moment.Moment;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    cashFlowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    currencyId!: string;
    amount!: number;
    description!: string | undefined;

    constructor(data?: IAddForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.bankAccountId = data["bankAccountId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.currencyId = data["currencyId"];
            this.amount = data["amount"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): AddForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["bankAccountId"] = this.bankAccountId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data; 
    }
}

export interface IAddForecastInput {
    forecastModelId: number;
    bankAccountId: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    cashFlowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    currencyId: string;
    amount: number;
    description: string | undefined;
}

export enum ImportForecastInputType {
    Inflows = "Inflows", 
    Outflows = "Outflows", 
}

export class ImportForecastInput implements IImportForecastInput {
    forecastDate!: moment.Moment;
    entity!: string;
    type!: ImportForecastInputType;
    categoryCoAId!: string | undefined;
    descriptor!: string | undefined;
    description!: string | undefined;
    model!: string | undefined;
    currencyId!: string;
    amount!: number;
    cashFlowTypeId!: string | undefined;

    constructor(data?: IImportForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastDate = data["forecastDate"] ? moment(data["forecastDate"].toString()) : <any>undefined;
            this.entity = data["entity"];
            this.type = data["type"];
            this.categoryCoAId = data["categoryCoAId"];
            this.descriptor = data["descriptor"];
            this.description = data["description"];
            this.model = data["model"];
            this.currencyId = data["currencyId"];
            this.amount = data["amount"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
        }
    }

    static fromJS(data: any): ImportForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["entity"] = this.entity;
        data["type"] = this.type;
        data["categoryCoAId"] = this.categoryCoAId;
        data["descriptor"] = this.descriptor;
        data["description"] = this.description;
        data["model"] = this.model;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        return data; 
    }
}

export interface IImportForecastInput {
    forecastDate: moment.Moment;
    entity: string;
    type: ImportForecastInputType;
    categoryCoAId: string | undefined;
    descriptor: string | undefined;
    description: string | undefined;
    model: string | undefined;
    currencyId: string;
    amount: number;
    cashFlowTypeId: string | undefined;
}

export class CreateForecastsInput implements ICreateForecastsInput {
    forecasts!: AddForecastInput[];

    constructor(data?: ICreateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["forecasts"] && data["forecasts"].constructor === Array) {
                this.forecasts = [];
                for (let item of data["forecasts"])
                    this.forecasts.push(AddForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.forecasts && this.forecasts.constructor === Array) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateForecastsInput {
    forecasts: AddForecastInput[];
}

export class UpdateForecastInput implements IUpdateForecastInput {
    id!: number;
    date!: moment.Moment | undefined;
    amount!: number | undefined;
    bankAccountId!: number | undefined;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    description!: string | undefined;
    transactionDescriptor!: string | undefined;

    constructor(data?: IUpdateForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.transactionDescriptor = data["transactionDescriptor"];
        }
    }

    static fromJS(data: any): UpdateForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["transactionDescriptor"] = this.transactionDescriptor;
        return data; 
    }
}

export interface IUpdateForecastInput {
    id: number;
    date: moment.Moment | undefined;
    amount: number | undefined;
    bankAccountId: number | undefined;
    cashflowTypeId: string;
    categoryId: number | undefined;
    description: string | undefined;
    transactionDescriptor: string | undefined;
}

export class UpdateForecastsInput implements IUpdateForecastsInput {
    forecasts!: UpdateForecastInput[];

    constructor(data?: IUpdateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["forecasts"] && data["forecasts"].constructor === Array) {
                this.forecasts = [];
                for (let item of data["forecasts"])
                    this.forecasts.push(UpdateForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.forecasts && this.forecasts.constructor === Array) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateForecastsInput {
    forecasts: UpdateForecastInput[];
}

export enum WeekDay {
    Sunday = "Sunday", 
    Monday = "Monday", 
    Tuesday = "Tuesday", 
    Wednesday = "Wednesday", 
    Thursday = "Thursday", 
    Friday = "Friday", 
    Saturday = "Saturday", 
}

export class CreateForecastScheduleDto implements ICreateForecastScheduleDto {
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: ICreateForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): CreateForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface ICreateForecastScheduleDto {
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class UpdateForecastScheduleInput implements IUpdateForecastScheduleInput {
    id!: number;
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IUpdateForecastScheduleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): UpdateForecastScheduleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastScheduleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IUpdateForecastScheduleInput {
    id: number;
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class ForecastScheduleDto implements IForecastScheduleDto {
    id!: number | undefined;
    bankAccountId!: number | undefined;
    categoryId!: number | undefined;
    forecastModelIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    frequencyId!: string | undefined;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.categoryId = data["categoryId"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): ForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IForecastScheduleDto {
    id: number | undefined;
    bankAccountId: number | undefined;
    categoryId: number | undefined;
    forecastModelIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    frequencyId: string | undefined;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class CreateForecastModelInput implements ICreateForecastModelInput {
    name!: string;

    constructor(data?: ICreateForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateForecastModelInput {
    name: string;
}

export class RenameForecastModelInput implements IRenameForecastModelInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): RenameForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IRenameForecastModelInput {
    id: number;
    newName: string;
}

export class TypeDto implements ITypeDto {
    name!: string | undefined;

    constructor(data?: ITypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ITypeDto {
    name: string | undefined;
}

export class AccountingTypeDto implements IAccountingTypeDto {
    typeId!: string | undefined;
    name!: string | undefined;
    isSystem!: boolean | undefined;

    constructor(data?: IAccountingTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.name = data["name"];
            this.isSystem = data["isSystem"];
        }
    }

    static fromJS(data: any): AccountingTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["isSystem"] = this.isSystem;
        return data; 
    }
}

export interface IAccountingTypeDto {
    typeId: string | undefined;
    name: string | undefined;
    isSystem: boolean | undefined;
}

export class CategoryDto implements ICategoryDto {
    accountingTypeId!: number | undefined;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    reportingCategoryId!: number | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.coAID = data["coAID"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.reportingCategoryId = data["reportingCategoryId"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["reportingCategoryId"] = this.reportingCategoryId;
        return data; 
    }
}

export interface ICategoryDto {
    accountingTypeId: number | undefined;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    reportingCategoryId: number | undefined;
}

export class GetCategoryTreeOutput implements IGetCategoryTreeOutput {
    types!: { [key: string] : TypeDto; } | undefined;
    accountingTypes!: { [key: string] : AccountingTypeDto; } | undefined;
    categories!: { [key: string] : CategoryDto; } | undefined;

    constructor(data?: IGetCategoryTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"]) {
                this.types = {};
                for (let key in data["types"]) {
                    if (data["types"].hasOwnProperty(key))
                        this.types[key] = data["types"][key] ? TypeDto.fromJS(data["types"][key]) : new TypeDto();
                }
            }
            if (data["accountingTypes"]) {
                this.accountingTypes = {};
                for (let key in data["accountingTypes"]) {
                    if (data["accountingTypes"].hasOwnProperty(key))
                        this.accountingTypes[key] = data["accountingTypes"][key] ? AccountingTypeDto.fromJS(data["accountingTypes"][key]) : new AccountingTypeDto();
                }
            }
            if (data["categories"]) {
                this.categories = {};
                for (let key in data["categories"]) {
                    if (data["categories"].hasOwnProperty(key))
                        this.categories[key] = data["categories"][key] ? CategoryDto.fromJS(data["categories"][key]) : new CategoryDto();
                }
            }
        }
    }

    static fromJS(data: any): GetCategoryTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    data["types"][key] = this.types[key];
            }
        }
        if (this.accountingTypes) {
            data["accountingTypes"] = {};
            for (let key in this.accountingTypes) {
                if (this.accountingTypes.hasOwnProperty(key))
                    data["accountingTypes"][key] = this.accountingTypes[key];
            }
        }
        if (this.categories) {
            data["categories"] = {};
            for (let key in this.categories) {
                if (this.categories.hasOwnProperty(key))
                    data["categories"][key] = this.categories[key];
            }
        }
        return data; 
    }
}

export interface IGetCategoryTreeOutput {
    types: { [key: string] : TypeDto; } | undefined;
    accountingTypes: { [key: string] : AccountingTypeDto; } | undefined;
    categories: { [key: string] : CategoryDto; } | undefined;
}

export enum ReportTemplate {
    Personal = "Personal", 
    Suspense = "Suspense", 
    Business = "Business", 
    Yacht = "Yacht", 
    JH1 = "JH1", 
}

export class ReportSectionDto implements IReportSectionDto {
    group!: SectionGroup | undefined;
    name!: string | undefined;

    constructor(data?: IReportSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.group = data["group"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ReportSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        return data; 
    }
}

export interface IReportSectionDto {
    group: SectionGroup | undefined;
    name: string | undefined;
}

export class GetReportTemplateDefinitionOutput implements IGetReportTemplateDefinitionOutput {
    sections!: { [key: string] : ReportSectionDto; } | undefined;
    categorySectionMap!: { [key: string] : number; } | undefined;

    constructor(data?: IGetReportTemplateDefinitionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["sections"]) {
                this.sections = {};
                for (let key in data["sections"]) {
                    if (data["sections"].hasOwnProperty(key))
                        this.sections[key] = data["sections"][key] ? ReportSectionDto.fromJS(data["sections"][key]) : new ReportSectionDto();
                }
            }
            if (data["categorySectionMap"]) {
                this.categorySectionMap = {};
                for (let key in data["categorySectionMap"]) {
                    if (data["categorySectionMap"].hasOwnProperty(key))
                        this.categorySectionMap[key] = data["categorySectionMap"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetReportTemplateDefinitionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDefinitionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sections) {
            data["sections"] = {};
            for (let key in this.sections) {
                if (this.sections.hasOwnProperty(key))
                    data["sections"][key] = this.sections[key];
            }
        }
        if (this.categorySectionMap) {
            data["categorySectionMap"] = {};
            for (let key in this.categorySectionMap) {
                if (this.categorySectionMap.hasOwnProperty(key))
                    data["categorySectionMap"][key] = this.categorySectionMap[key];
            }
        }
        return data; 
    }
}

export interface IGetReportTemplateDefinitionOutput {
    sections: { [key: string] : ReportSectionDto; } | undefined;
    categorySectionMap: { [key: string] : number; } | undefined;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    accountingTypeId!: number;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.coAID = data["coAID"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateCategoryInput {
    accountingTypeId: number;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    id!: number;
    coAID!: string | undefined;
    name!: string;
    accountingTypeId!: number;
    parentId!: number | undefined;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.coAID = data["coAID"];
            this.name = data["name"];
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        return data; 
    }
}

export interface IUpdateCategoryInput {
    id: number;
    coAID: string | undefined;
    name: string;
    accountingTypeId: number;
    parentId: number | undefined;
}

export class UpdateCategoryStatusInput implements IUpdateCategoryStatusInput {
    id!: number | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateCategoryStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCategoryStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateCategoryStatusInput {
    id: number | undefined;
    isActive: boolean | undefined;
}

export class CreateAccountingTypeInput implements ICreateAccountingTypeInput {
    cashflowTypeId!: string | undefined;
    name!: string;
    sortOrder!: number | undefined;

    constructor(data?: ICreateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashflowTypeId = data["cashflowTypeId"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateAccountingTypeInput {
    cashflowTypeId: string | undefined;
    name: string;
    sortOrder: number | undefined;
}

export class UpdateAccountingTypeInput implements IUpdateAccountingTypeInput {
    id!: number;
    name!: string;
    cashflowTypeId!: string | undefined;

    constructor(data?: IUpdateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.cashflowTypeId = data["cashflowTypeId"];
        }
    }

    static fromJS(data: any): UpdateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cashflowTypeId"] = this.cashflowTypeId;
        return data; 
    }
}

export interface IUpdateAccountingTypeInput {
    id: number;
    name: string;
    cashflowTypeId: string | undefined;
}

export class SyncDto implements ISyncDto {
    syncAccountId!: number | undefined;

    constructor(data?: ISyncDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncAccountId = data["syncAccountId"];
        }
    }

    static fromJS(data: any): SyncDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        return data; 
    }
}

export interface ISyncDto {
    syncAccountId: number | undefined;
}

export class AccountingCategoryDto implements IAccountingCategoryDto {
    id!: string | undefined;
    name!: string;
    parentId!: string | undefined;
    coAID!: string | undefined;
    isActive!: boolean | undefined;
    cashType!: string | undefined;
    accountingType!: string;
    sortId!: number | undefined;
    reportingCategoryCode!: string | undefined;
    reportingCategoryName!: string | undefined;

    constructor(data?: IAccountingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.coAID = data["coAID"];
            this.isActive = data["isActive"];
            this.cashType = data["cashType"];
            this.accountingType = data["accountingType"];
            this.sortId = data["sortId"];
            this.reportingCategoryCode = data["reportingCategoryCode"];
            this.reportingCategoryName = data["reportingCategoryName"];
        }
    }

    static fromJS(data: any): AccountingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["isActive"] = this.isActive;
        data["cashType"] = this.cashType;
        data["accountingType"] = this.accountingType;
        data["sortId"] = this.sortId;
        data["reportingCategoryCode"] = this.reportingCategoryCode;
        data["reportingCategoryName"] = this.reportingCategoryName;
        return data; 
    }
}

export interface IAccountingCategoryDto {
    id: string | undefined;
    name: string;
    parentId: string | undefined;
    coAID: string | undefined;
    isActive: boolean | undefined;
    cashType: string | undefined;
    accountingType: string;
    sortId: number | undefined;
    reportingCategoryCode: string | undefined;
    reportingCategoryName: string | undefined;
}

export enum FriendshipState {
    _1 = 1, 
    _2 = 2, 
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageReadState {
    _1 = 1, 
    _2 = 2, 
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export class ChatMessageDtoListResultDto implements IChatMessageDtoListResultDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IChatMessageDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatMessageDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChatMessageDtoListResultDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class GetRulesInput implements IGetRulesInput {

    constructor(data?: IGetRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): GetRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetRulesInput {
}

export class RuleDto implements IRuleDto {
    parentId!: number | undefined;
    name!: string | undefined;
    categoryId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    sortOrder!: number | undefined;
    isActive!: boolean | undefined;
    transactionCount!: number | undefined;
    id!: number | undefined;

    constructor(data?: IRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sortOrder = data["sortOrder"];
            this.isActive = data["isActive"];
            this.transactionCount = data["transactionCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        data["transactionCount"] = this.transactionCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRuleDto {
    parentId: number | undefined;
    name: string | undefined;
    categoryId: number | undefined;
    creationTime: moment.Moment | undefined;
    sortOrder: number | undefined;
    isActive: boolean | undefined;
    transactionCount: number | undefined;
    id: number | undefined;
}

export enum CashFlowAmountFormat {
    Unspecified = "Unspecified", 
    Debits = "Debits", 
    Credits = "Credits", 
}

export enum CategorizationRuleConditionType {
    Exist = "Exist", 
    Equal = "Equal", 
}

export class ConditionAttributeDto implements IConditionAttributeDto {
    attributeTypeId!: string;
    conditionTypeId!: CategorizationRuleConditionType;
    conditionValue!: string | undefined;

    constructor(data?: IConditionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeTypeId = data["attributeTypeId"];
            this.conditionTypeId = data["conditionTypeId"];
            this.conditionValue = data["conditionValue"];
        }
    }

    static fromJS(data: any): ConditionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        data["conditionTypeId"] = this.conditionTypeId;
        data["conditionValue"] = this.conditionValue;
        return data; 
    }
}

export interface IConditionAttributeDto {
    attributeTypeId: string;
    conditionTypeId: CategorizationRuleConditionType;
    conditionValue: string | undefined;
}

export class ConditionDto implements IConditionDto {
    minAmount!: number | undefined;
    maxAmount!: number | undefined;
    cashFlowAmountFormat!: CashFlowAmountFormat | undefined;
    bankId!: number | undefined;
    bankAccountId!: number | undefined;
    transactionCategoryId!: string | undefined;
    descriptionWords!: string | undefined;
    attributes!: { [key: string] : ConditionAttributeDto; } | undefined;
    transactionTypes!: string[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minAmount = data["minAmount"];
            this.maxAmount = data["maxAmount"];
            this.cashFlowAmountFormat = data["cashFlowAmountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.descriptionWords = data["descriptionWords"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? ConditionAttributeDto.fromJS(data["attributes"][key]) : new ConditionAttributeDto();
                }
            }
            if (data["transactionTypes"] && data["transactionTypes"].constructor === Array) {
                this.transactionTypes = [];
                for (let item of data["transactionTypes"])
                    this.transactionTypes.push(item);
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["cashFlowAmountFormat"] = this.cashFlowAmountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["descriptionWords"] = this.descriptionWords;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        if (this.transactionTypes && this.transactionTypes.constructor === Array) {
            data["transactionTypes"] = [];
            for (let item of this.transactionTypes)
                data["transactionTypes"].push(item);
        }
        return data; 
    }
}

export interface IConditionDto {
    minAmount: number | undefined;
    maxAmount: number | undefined;
    cashFlowAmountFormat: CashFlowAmountFormat | undefined;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    transactionCategoryId: string | undefined;
    descriptionWords: string | undefined;
    attributes: { [key: string] : ConditionAttributeDto; } | undefined;
    transactionTypes: string[] | undefined;
}

export enum ApplyToTransactionsOption {
    None = "None", 
    MatchedAndUnclassified = "MatchedAndUnclassified", 
    SelectedOnly = "SelectedOnly", 
    AllExisting = "AllExisting", 
}

export class CreateRuleDto implements ICreateRuleDto {
    parentId!: number | undefined;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;

    constructor(data?: ICreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): CreateRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface ICreateRuleDto {
    parentId: number | undefined;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
}

export class EditRuleDto implements IEditRuleDto {
    id!: number;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;

    constructor(data?: IEditRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): EditRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface IEditRuleDto {
    id: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
}

export class MoveRuleDto implements IMoveRuleDto {
    parentId!: number | undefined;
    sortOrder!: number | undefined;
    isRecategorize!: boolean | undefined;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;
    id!: number | undefined;

    constructor(data?: IMoveRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.sortOrder = data["sortOrder"];
            this.isRecategorize = data["isRecategorize"];
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MoveRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isRecategorize"] = this.isRecategorize;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMoveRuleDto {
    parentId: number | undefined;
    sortOrder: number | undefined;
    isRecategorize: boolean | undefined;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
    id: number | undefined;
}

export class AddMappingDto implements IAddMappingDto {
    oldName!: string;
    newName!: string;

    constructor(data?: IAddMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldName = data["oldName"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): AddMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldName"] = this.oldName;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IAddMappingDto {
    oldName: string;
    newName: string;
}

export class RecategorizeInput implements IRecategorizeInput {
    bankAccountIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    ruleId!: number | undefined;

    constructor(data?: IRecategorizeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.ruleId = data["ruleId"];
        }
    }

    static fromJS(data: any): RecategorizeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecategorizeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ruleId"] = this.ruleId;
        return data; 
    }
}

export interface IRecategorizeInput {
    bankAccountIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    ruleId: number | undefined;
}

export class ResetClassificationDto implements IResetClassificationDto {
    unclassify!: boolean | undefined;
    removeRules!: boolean | undefined;
    removeCategoryTree!: boolean | undefined;
    removeForecasts!: boolean | undefined;

    constructor(data?: IResetClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unclassify = false;
            this.removeRules = false;
            this.removeCategoryTree = false;
            this.removeForecasts = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.unclassify = data["unclassify"] !== undefined ? data["unclassify"] : false;
            this.removeRules = data["removeRules"] !== undefined ? data["removeRules"] : false;
            this.removeCategoryTree = data["removeCategoryTree"] !== undefined ? data["removeCategoryTree"] : false;
            this.removeForecasts = data["removeForecasts"] !== undefined ? data["removeForecasts"] : false;
        }
    }

    static fromJS(data: any): ResetClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unclassify"] = this.unclassify;
        data["removeRules"] = this.removeRules;
        data["removeCategoryTree"] = this.removeCategoryTree;
        data["removeForecasts"] = this.removeForecasts;
        return data; 
    }
}

export interface IResetClassificationDto {
    unclassify: boolean | undefined;
    removeRules: boolean | undefined;
    removeCategoryTree: boolean | undefined;
    removeForecasts: boolean | undefined;
}

export class UpdateTransactionsCategoryInput implements IUpdateTransactionsCategoryInput {
    transactionIds!: number[] | undefined;
    categoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean | undefined;

    constructor(data?: IUpdateTransactionsCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
            this.categoryId = data["categoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = data["suppressCashflowMismatch"] !== undefined ? data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryInput {
    transactionIds: number[] | undefined;
    categoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean | undefined;
}

export class StatsDetailFilterBase implements IStatsDetailFilterBase {
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilterBase {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilterBase {
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class UpdateTransactionsCategoryWithFilterInput implements IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter!: StatsDetailFilterBase | undefined;
    destinationCategoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean | undefined;

    constructor(data?: IUpdateTransactionsCategoryWithFilterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionFilter = data["transactionFilter"] ? StatsDetailFilterBase.fromJS(data["transactionFilter"]) : <any>undefined;
            this.destinationCategoryId = data["destinationCategoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = data["suppressCashflowMismatch"] !== undefined ? data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryWithFilterInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryWithFilterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionFilter"] = this.transactionFilter ? this.transactionFilter.toJSON() : <any>undefined;
        data["destinationCategoryId"] = this.destinationCategoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter: StatsDetailFilterBase | undefined;
    destinationCategoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean | undefined;
}

export class GetTransactionCommonDetailsInput implements IGetTransactionCommonDetailsInput {
    transactionIds!: number[] | undefined;

    constructor(data?: IGetTransactionCommonDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetTransactionCommonDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionCommonDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data; 
    }
}

export interface IGetTransactionCommonDetailsInput {
    transactionIds: number[] | undefined;
}

export enum AmountFormat {
    Debits = "Debits", 
    Credits = "Credits", 
}

export class TransactionAttributeDto implements ITransactionAttributeDto {
    typeId!: string | undefined;
    value!: string | undefined;

    constructor(data?: ITransactionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TransactionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITransactionAttributeDto {
    typeId: string | undefined;
    value: string | undefined;
}

export class TransactionCommonDetailsDto implements ITransactionCommonDetailsDto {
    amountFormat!: AmountFormat | undefined;
    bankId!: number | undefined;
    bankAccountId!: number | undefined;
    standardDescriptor!: string | undefined;
    transactionCategoryId!: string | undefined;
    transactionTypeId!: string | undefined;
    descriptionPhrases!: string[] | undefined;
    attributes!: TransactionAttributeDto[] | undefined;
    sourceTransactionsAreMatchingExistingRules!: boolean | undefined;

    constructor(data?: ITransactionCommonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amountFormat = data["amountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.transactionTypeId = data["transactionTypeId"];
            if (data["descriptionPhrases"] && data["descriptionPhrases"].constructor === Array) {
                this.descriptionPhrases = [];
                for (let item of data["descriptionPhrases"])
                    this.descriptionPhrases.push(item);
            }
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
            this.sourceTransactionsAreMatchingExistingRules = data["sourceTransactionsAreMatchingExistingRules"];
        }
    }

    static fromJS(data: any): TransactionCommonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountFormat"] = this.amountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["transactionTypeId"] = this.transactionTypeId;
        if (this.descriptionPhrases && this.descriptionPhrases.constructor === Array) {
            data["descriptionPhrases"] = [];
            for (let item of this.descriptionPhrases)
                data["descriptionPhrases"].push(item);
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["sourceTransactionsAreMatchingExistingRules"] = this.sourceTransactionsAreMatchingExistingRules;
        return data; 
    }
}

export interface ITransactionCommonDetailsDto {
    amountFormat: AmountFormat | undefined;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    standardDescriptor: string | undefined;
    transactionCategoryId: string | undefined;
    transactionTypeId: string | undefined;
    descriptionPhrases: string[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
    sourceTransactionsAreMatchingExistingRules: boolean | undefined;
}

export class AutoClassifyDto implements IAutoClassifyDto {
    bankAccountIds!: number[] | undefined;

    constructor(data?: IAutoClassifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
        }
    }

    static fromJS(data: any): AutoClassifyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoClassifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        return data; 
    }
}

export interface IAutoClassifyDto {
    bankAccountIds: number[] | undefined;
}

export class ChangeCategoryForRulesInput implements IChangeCategoryForRulesInput {
    ruleIds!: number[] | undefined;
    categotyId!: number;
    reclassifyTransactions!: boolean | undefined;

    constructor(data?: IChangeCategoryForRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reclassifyTransactions = false;
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ruleIds"] && data["ruleIds"].constructor === Array) {
                this.ruleIds = [];
                for (let item of data["ruleIds"])
                    this.ruleIds.push(item);
            }
            this.categotyId = data["categotyId"];
            this.reclassifyTransactions = data["reclassifyTransactions"] !== undefined ? data["reclassifyTransactions"] : false;
        }
    }

    static fromJS(data: any): ChangeCategoryForRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeCategoryForRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleIds && this.ruleIds.constructor === Array) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["categotyId"] = this.categotyId;
        data["reclassifyTransactions"] = this.reclassifyTransactions;
        return data; 
    }
}

export interface IChangeCategoryForRulesInput {
    ruleIds: number[] | undefined;
    categotyId: number;
    reclassifyTransactions: boolean | undefined;
}

export class GetKeyAttributeValuesInput implements IGetKeyAttributeValuesInput {
    ruleId!: number | undefined;
    transactionIds!: number[] | undefined;

    constructor(data?: IGetKeyAttributeValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleId = data["ruleId"];
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetKeyAttributeValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetKeyAttributeValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data; 
    }
}

export interface IGetKeyAttributeValuesInput {
    ruleId: number | undefined;
    transactionIds: number[] | undefined;
}

export class AttributeValuesDto implements IAttributeValuesDto {
    attributeTypeId!: string | undefined;
    attributeValues!: string[] | undefined;

    constructor(data?: IAttributeValuesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeTypeId = data["attributeTypeId"];
            if (data["attributeValues"] && data["attributeValues"].constructor === Array) {
                this.attributeValues = [];
                for (let item of data["attributeValues"])
                    this.attributeValues.push(item);
            }
        }
    }

    static fromJS(data: any): AttributeValuesDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValuesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        if (this.attributeValues && this.attributeValues.constructor === Array) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item);
        }
        return data; 
    }
}

export interface IAttributeValuesDto {
    attributeTypeId: string | undefined;
    attributeValues: string[] | undefined;
}

export class UserKeyInfo implements IUserKeyInfo {
    id!: number | undefined;
    userName!: string | undefined;
    fullName!: string | undefined;

    constructor(data?: IUserKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UserKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUserKeyInfo {
    id: number | undefined;
    userName: string | undefined;
    fullName: string | undefined;
}

export class CommentDto implements ICommentDto {
    threadId!: number | undefined;
    comment!: string | undefined;
    createdByUser!: UserKeyInfo | undefined;
    creationTime!: moment.Moment | undefined;
    updatedByUser!: UserKeyInfo | undefined;
    lastModificationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
            this.createdByUser = data["createdByUser"] ? UserKeyInfo.fromJS(data["createdByUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.updatedByUser = data["updatedByUser"] ? UserKeyInfo.fromJS(data["updatedByUser"]) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICommentDto {
    threadId: number | undefined;
    comment: string | undefined;
    createdByUser: UserKeyInfo | undefined;
    creationTime: moment.Moment | undefined;
    updatedByUser: UserKeyInfo | undefined;
    lastModificationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateCommentInput implements ICreateCommentInput {
    threadId!: number | undefined;
    comment!: string;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateCommentInput {
    threadId: number | undefined;
    comment: string;
}

export class CreateCommentOutput implements ICreateCommentOutput {
    id!: number | undefined;

    constructor(data?: ICreateCommentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCommentOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCommentOutput {
    id: number | undefined;
}

export class UpdateCommentInput implements IUpdateCommentInput {
    comment!: string;
    id!: number | undefined;

    constructor(data?: IUpdateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateCommentInput {
    comment: string;
    id: number | undefined;
}

export class CreateTransactionCommentThreadInput implements ICreateTransactionCommentThreadInput {
    transactionId!: number;
    comment!: string;

    constructor(data?: ICreateTransactionCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadInput {
    transactionId: number;
    comment: string;
}

export class CreateTransactionCommentThreadOutput implements ICreateTransactionCommentThreadOutput {
    threadId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateTransactionCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadOutput {
    threadId: number | undefined;
    id: number | undefined;
}

export class CreateCashFlowCommentThreadInput implements ICreateCashFlowCommentThreadInput {
    accountId!: number | undefined;
    comment!: string;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: ICreateCashFlowCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.comment = data["comment"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["comment"] = this.comment;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadInput {
    accountId: number | undefined;
    comment: string;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class CreateCashFlowCommentThreadOutput implements ICreateCashFlowCommentThreadOutput {
    threadId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateCashFlowCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadOutput {
    threadId: number | undefined;
    id: number | undefined;
}

export class SetResolvedInput implements ISetResolvedInput {
    threadId!: number;
    isResolved!: boolean;

    constructor(data?: ISetResolvedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.isResolved = data["isResolved"];
        }
    }

    static fromJS(data: any): SetResolvedInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetResolvedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["isResolved"] = this.isResolved;
        return data; 
    }
}

export interface ISetResolvedInput {
    threadId: number;
    isResolved: boolean;
}

export class PendingCommissionContactInfo implements IPendingCommissionContactInfo {
    id!: number | undefined;
    name!: string | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IPendingCommissionContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): PendingCommissionContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PendingCommissionContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IPendingCommissionContactInfo {
    id: number | undefined;
    name: string | undefined;
    affiliateCode: string | undefined;
}

export class UpdateCommissionableAmountInput implements IUpdateCommissionableAmountInput {
    commissionIds!: number[] | undefined;
    commissionableAmount!: number;

    constructor(data?: IUpdateCommissionableAmountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["commissionIds"] && data["commissionIds"].constructor === Array) {
                this.commissionIds = [];
                for (let item of data["commissionIds"])
                    this.commissionIds.push(item);
            }
            this.commissionableAmount = data["commissionableAmount"];
        }
    }

    static fromJS(data: any): UpdateCommissionableAmountInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionableAmountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.commissionIds && this.commissionIds.constructor === Array) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["commissionableAmount"] = this.commissionableAmount;
        return data; 
    }
}

export interface IUpdateCommissionableAmountInput {
    commissionIds: number[] | undefined;
    commissionableAmount: number;
}

export class UpdateCommissionRateInput implements IUpdateCommissionRateInput {
    commissionIds!: number[] | undefined;
    commissionRate!: number;

    constructor(data?: IUpdateCommissionRateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["commissionIds"] && data["commissionIds"].constructor === Array) {
                this.commissionIds = [];
                for (let item of data["commissionIds"])
                    this.commissionIds.push(item);
            }
            this.commissionRate = data["commissionRate"];
        }
    }

    static fromJS(data: any): UpdateCommissionRateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionRateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.commissionIds && this.commissionIds.constructor === Array) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["commissionRate"] = this.commissionRate;
        return data; 
    }
}

export interface IUpdateCommissionRateInput {
    commissionIds: number[] | undefined;
    commissionRate: number;
}

export class UpdateCommissionAffiliateInput implements IUpdateCommissionAffiliateInput {
    commissionIds!: number[] | undefined;
    affiliateContactId!: number;
    assignToBuyerContact!: boolean | undefined;
    reassignTier2Commissions!: boolean | undefined;

    constructor(data?: IUpdateCommissionAffiliateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["commissionIds"] && data["commissionIds"].constructor === Array) {
                this.commissionIds = [];
                for (let item of data["commissionIds"])
                    this.commissionIds.push(item);
            }
            this.affiliateContactId = data["affiliateContactId"];
            this.assignToBuyerContact = data["assignToBuyerContact"];
            this.reassignTier2Commissions = data["reassignTier2Commissions"];
        }
    }

    static fromJS(data: any): UpdateCommissionAffiliateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommissionAffiliateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.commissionIds && this.commissionIds.constructor === Array) {
            data["commissionIds"] = [];
            for (let item of this.commissionIds)
                data["commissionIds"].push(item);
        }
        data["affiliateContactId"] = this.affiliateContactId;
        data["assignToBuyerContact"] = this.assignToBuyerContact;
        data["reassignTier2Commissions"] = this.reassignTier2Commissions;
        return data; 
    }
}

export interface IUpdateCommissionAffiliateInput {
    commissionIds: number[] | undefined;
    affiliateContactId: number;
    assignToBuyerContact: boolean | undefined;
    reassignTier2Commissions: boolean | undefined;
}

export class RecordEarningsInput implements IRecordEarningsInput {
    contactIds!: number[] | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment;

    constructor(data?: IRecordEarningsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecordEarningsInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecordEarningsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecordEarningsInput {
    contactIds: number[] | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment;
}

export class RequestWithdrawalInput implements IRequestWithdrawalInput {
    contactId!: number;
    amount!: number | undefined;
    date!: moment.Moment | undefined;

    constructor(data?: IRequestWithdrawalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.amount = data["amount"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestWithdrawalInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestWithdrawalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRequestWithdrawalInput {
    contactId: number;
    amount: number | undefined;
    date: moment.Moment | undefined;
}

export enum PaymentSystem {
    CheckPayment = "CheckPayment", 
    CreditAccountBalance = "CreditAccountBalance", 
    CryptoBitcoin = "CryptoBitcoin", 
    DebitCardTransfer = "DebitCardTransfer", 
    TransferBankACH = "TransferBankACH", 
    TransferBankSEPA = "TransferBankSEPA", 
    TransferBankWire = "TransferBankWire", 
    PayQuicker = "PayQuicker", 
    PayPal = "PayPal", 
    SpersePay = "SpersePay", 
    Tipalti = "Tipalti", 
}

export class CompleteWithdrawalInput implements ICompleteWithdrawalInput {
    withdrawalIds!: number[] | undefined;
    paymentSystem!: PaymentSystem;
    payDate!: moment.Moment;

    constructor(data?: ICompleteWithdrawalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["withdrawalIds"] && data["withdrawalIds"].constructor === Array) {
                this.withdrawalIds = [];
                for (let item of data["withdrawalIds"])
                    this.withdrawalIds.push(item);
            }
            this.paymentSystem = data["paymentSystem"];
            this.payDate = data["payDate"] ? moment(data["payDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CompleteWithdrawalInput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteWithdrawalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.withdrawalIds && this.withdrawalIds.constructor === Array) {
            data["withdrawalIds"] = [];
            for (let item of this.withdrawalIds)
                data["withdrawalIds"].push(item);
        }
        data["paymentSystem"] = this.paymentSystem;
        data["payDate"] = this.payDate ? this.payDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICompleteWithdrawalInput {
    withdrawalIds: number[] | undefined;
    paymentSystem: PaymentSystem;
    payDate: moment.Moment;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    packageName!: string | undefined;
    moduleId!: string | undefined;
    moduleName!: string | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.packageName = data["packageName"];
            this.moduleId = data["moduleId"];
            this.moduleName = data["moduleName"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["packageName"] = this.packageName;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    packageName: string | undefined;
    moduleId: string | undefined;
    moduleName: string | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class SubscribableEditionComboboxItemDtoListResultDto implements ISubscribableEditionComboboxItemDtoListResultDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDtoListResultDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: INameValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INameValueDtoPagedResultDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class ContactGroupInfo implements IContactGroupInfo {
    groupId!: string | undefined;
    isActive!: boolean | undefined;
    isProspective!: boolean | undefined;

    constructor(data?: IContactGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.isActive = data["isActive"];
            this.isProspective = data["isProspective"];
        }
    }

    static fromJS(data: any): ContactGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        return data; 
    }
}

export interface IContactGroupInfo {
    groupId: string | undefined;
    isActive: boolean | undefined;
    isProspective: boolean | undefined;
}

export enum MaritalStatus {
    Single = "Single", 
    Married = "Married", 
    Divorced = "Divorced", 
    Widowed = "Widowed", 
    Separated = "Separated", 
}

export class PersonInfoDto implements IPersonInfoDto {
    namePrefix!: string | undefined;
    middleName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    identityConfirmationDate!: moment.Moment | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    contactId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IPersonInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namePrefix = data["namePrefix"];
            this.middleName = data["middleName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.identityConfirmationDate = data["identityConfirmationDate"] ? moment(data["identityConfirmationDate"].toString()) : <any>undefined;
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.contactId = data["contactId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): PersonInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["middleName"] = this.middleName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["identityConfirmationDate"] = this.identityConfirmationDate ? this.identityConfirmationDate.toISOString() : <any>undefined;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IPersonInfoDto {
    namePrefix: string | undefined;
    middleName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    identityConfirmationDate: moment.Moment | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    contactId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class OrganizationShortInfo implements IOrganizationShortInfo {
    id!: number | undefined;
    name!: string | undefined;
    thumbnail!: string | undefined;
    rootOrganizationUnitId!: number | undefined;

    constructor(data?: IOrganizationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.thumbnail = data["thumbnail"];
            this.rootOrganizationUnitId = data["rootOrganizationUnitId"];
        }
    }

    static fromJS(data: any): OrganizationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["thumbnail"] = this.thumbnail;
        data["rootOrganizationUnitId"] = this.rootOrganizationUnitId;
        return data; 
    }
}

export interface IOrganizationShortInfo {
    id: number | undefined;
    name: string | undefined;
    thumbnail: string | undefined;
    rootOrganizationUnitId: number | undefined;
}

export class PersonOrgRelationTypeInfo implements IPersonOrgRelationTypeInfo {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IPersonOrgRelationTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PersonOrgRelationTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPersonOrgRelationTypeInfo {
    id: string | undefined;
    name: string | undefined;
}

export class PersonOrgRelationShortInfo implements IPersonOrgRelationShortInfo {
    id!: number | undefined;
    isActive!: boolean | undefined;
    isPrimary!: boolean | undefined;
    organization!: OrganizationShortInfo | undefined;
    relationType!: PersonOrgRelationTypeInfo | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IPersonOrgRelationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
            this.isPrimary = data["isPrimary"];
            this.organization = data["organization"] ? OrganizationShortInfo.fromJS(data["organization"]) : <any>undefined;
            this.relationType = data["relationType"] ? PersonOrgRelationTypeInfo.fromJS(data["relationType"]) : <any>undefined;
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): PersonOrgRelationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isPrimary"] = this.isPrimary;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["relationType"] = this.relationType ? this.relationType.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface IPersonOrgRelationShortInfo {
    id: number | undefined;
    isActive: boolean | undefined;
    isPrimary: boolean | undefined;
    organization: OrganizationShortInfo | undefined;
    relationType: PersonOrgRelationTypeInfo | undefined;
    jobTitle: string | undefined;
}

export class ContactEmailDto implements IContactEmailDto {
    usageTypeId!: string | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactEmailDto {
    usageTypeId: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactPhoneDto implements IContactPhoneDto {
    usageTypeId!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactPhoneDto {
    usageTypeId: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactAddressDto implements IContactAddressDto {
    usageTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    zip!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
            this.zip = data["zip"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["zip"] = this.zip;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactAddressDto {
    usageTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    zip: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactLinkDto implements IContactLinkDto {
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isSocialNetwork!: boolean | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
            this.isSocialNetwork = data["isSocialNetwork"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isSocialNetwork"] = this.isSocialNetwork;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactLinkDto {
    linkTypeId: string | undefined;
    url: string | undefined;
    isSocialNetwork: boolean | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactInfoDetailsDto implements IContactInfoDetailsDto {
    contactId!: number | undefined;
    publicPersonProfileUrl!: string | undefined;
    emails!: ContactEmailDto[] | undefined;
    phones!: ContactPhoneDto[] | undefined;
    addresses!: ContactAddressDto[] | undefined;
    links!: ContactLinkDto[] | undefined;

    constructor(data?: IContactInfoDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.publicPersonProfileUrl = data["publicPersonProfileUrl"];
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactInfoDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["publicPersonProfileUrl"] = this.publicPersonProfileUrl;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactInfoDetailsDto {
    contactId: number | undefined;
    publicPersonProfileUrl: string | undefined;
    emails: ContactEmailDto[] | undefined;
    phones: ContactPhoneDto[] | undefined;
    addresses: ContactAddressDto[] | undefined;
    links: ContactLinkDto[] | undefined;
}

export class PersonContactInfoDto implements IPersonContactInfoDto {
    person!: PersonInfoDto | undefined;
    jobTitle!: string | undefined;
    orgRelationId!: number | undefined;
    xref!: string | undefined;
    userEmailAddress!: string | undefined;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;
    orgRelations!: PersonOrgRelationShortInfo[] | undefined;
    id!: number | undefined;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IPersonContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.person = data["person"] ? PersonInfoDto.fromJS(data["person"]) : <any>undefined;
            this.jobTitle = data["jobTitle"];
            this.orgRelationId = data["orgRelationId"];
            this.xref = data["xref"];
            this.userEmailAddress = data["userEmailAddress"];
            this.customField1 = data["customField1"];
            this.customField2 = data["customField2"];
            this.customField3 = data["customField3"];
            this.customField4 = data["customField4"];
            this.customField5 = data["customField5"];
            if (data["orgRelations"] && data["orgRelations"].constructor === Array) {
                this.orgRelations = [];
                for (let item of data["orgRelations"])
                    this.orgRelations.push(PersonOrgRelationShortInfo.fromJS(item));
            }
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.userId = data["userId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryAddressId = data["primaryAddressId"];
            this.primaryPhoto = data["primaryPhoto"];
            this.details = data["details"] ? ContactInfoDetailsDto.fromJS(data["details"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): PersonContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["orgRelationId"] = this.orgRelationId;
        data["xref"] = this.xref;
        data["userEmailAddress"] = this.userEmailAddress;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        if (this.orgRelations && this.orgRelations.constructor === Array) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IPersonContactInfoDto {
    person: PersonInfoDto | undefined;
    jobTitle: string | undefined;
    orgRelationId: number | undefined;
    xref: string | undefined;
    userEmailAddress: string | undefined;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
    orgRelations: PersonOrgRelationShortInfo[] | undefined;
    id: number | undefined;
    fullName: string | undefined;
    userId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export enum AffiliateServiceStatus {
    Unavailable = "Unavailable", 
    Available = "Available", 
    FullAccess = "FullAccess", 
}

export class ContactInfoDto implements IContactInfoDto {
    id!: number | undefined;
    typeId!: string | undefined;
    groups!: ContactGroupInfo[] | undefined;
    assignedContactId!: number | undefined;
    assignedUserId!: number | undefined;
    assignedUserName!: string | undefined;
    assignedUserPicturePublicId!: string | undefined;
    creatorContactId!: number | undefined;
    creatorUserId!: number | undefined;
    creatorUserName!: string | undefined;
    creatorUserPicturePublicId!: string | undefined;
    starId!: number | undefined;
    ratingId!: number | undefined;
    tags!: number[] | undefined;
    lists!: number[] | undefined;
    personContactInfo!: PersonContactInfoDto | undefined;
    primaryOrganizationContactId!: number | undefined;
    affiliateCode!: string | undefined;
    affiliateIsAdvisor!: boolean | undefined;
    affiliateRate!: number | undefined;
    affiliateRateTier2!: number | undefined;
    affiliateServiceStatus!: AffiliateServiceStatus | undefined;
    parentId!: number | undefined;
    parentName!: string | undefined;
    contactDate!: moment.Moment | undefined;
    affiliateContactId!: number | undefined;
    affiliateContactName!: string | undefined;
    subContactsCount!: number | undefined;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            if (data["groups"] && data["groups"].constructor === Array) {
                this.groups = [];
                for (let item of data["groups"])
                    this.groups.push(ContactGroupInfo.fromJS(item));
            }
            this.assignedContactId = data["assignedContactId"];
            this.assignedUserId = data["assignedUserId"];
            this.assignedUserName = data["assignedUserName"];
            this.assignedUserPicturePublicId = data["assignedUserPicturePublicId"];
            this.creatorContactId = data["creatorContactId"];
            this.creatorUserId = data["creatorUserId"];
            this.creatorUserName = data["creatorUserName"];
            this.creatorUserPicturePublicId = data["creatorUserPicturePublicId"];
            this.starId = data["starId"];
            this.ratingId = data["ratingId"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(item);
            }
            this.personContactInfo = data["personContactInfo"] ? PersonContactInfoDto.fromJS(data["personContactInfo"]) : <any>undefined;
            this.primaryOrganizationContactId = data["primaryOrganizationContactId"];
            this.affiliateCode = data["affiliateCode"];
            this.affiliateIsAdvisor = data["affiliateIsAdvisor"];
            this.affiliateRate = data["affiliateRate"];
            this.affiliateRateTier2 = data["affiliateRateTier2"];
            this.affiliateServiceStatus = data["affiliateServiceStatus"];
            this.parentId = data["parentId"];
            this.parentName = data["parentName"];
            this.contactDate = data["contactDate"] ? moment(data["contactDate"].toString()) : <any>undefined;
            this.affiliateContactId = data["affiliateContactId"];
            this.affiliateContactName = data["affiliateContactName"];
            this.subContactsCount = data["subContactsCount"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        if (this.groups && this.groups.constructor === Array) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["assignedContactId"] = this.assignedContactId;
        data["assignedUserId"] = this.assignedUserId;
        data["assignedUserName"] = this.assignedUserName;
        data["assignedUserPicturePublicId"] = this.assignedUserPicturePublicId;
        data["creatorContactId"] = this.creatorContactId;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creatorUserPicturePublicId"] = this.creatorUserPicturePublicId;
        data["starId"] = this.starId;
        data["ratingId"] = this.ratingId;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        data["personContactInfo"] = this.personContactInfo ? this.personContactInfo.toJSON() : <any>undefined;
        data["primaryOrganizationContactId"] = this.primaryOrganizationContactId;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateIsAdvisor"] = this.affiliateIsAdvisor;
        data["affiliateRate"] = this.affiliateRate;
        data["affiliateRateTier2"] = this.affiliateRateTier2;
        data["affiliateServiceStatus"] = this.affiliateServiceStatus;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["contactDate"] = this.contactDate ? this.contactDate.toISOString() : <any>undefined;
        data["affiliateContactId"] = this.affiliateContactId;
        data["affiliateContactName"] = this.affiliateContactName;
        data["subContactsCount"] = this.subContactsCount;
        return data; 
    }
}

export interface IContactInfoDto {
    id: number | undefined;
    typeId: string | undefined;
    groups: ContactGroupInfo[] | undefined;
    assignedContactId: number | undefined;
    assignedUserId: number | undefined;
    assignedUserName: string | undefined;
    assignedUserPicturePublicId: string | undefined;
    creatorContactId: number | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creatorUserPicturePublicId: string | undefined;
    starId: number | undefined;
    ratingId: number | undefined;
    tags: number[] | undefined;
    lists: number[] | undefined;
    personContactInfo: PersonContactInfoDto | undefined;
    primaryOrganizationContactId: number | undefined;
    affiliateCode: string | undefined;
    affiliateIsAdvisor: boolean | undefined;
    affiliateRate: number | undefined;
    affiliateRateTier2: number | undefined;
    affiliateServiceStatus: AffiliateServiceStatus | undefined;
    parentId: number | undefined;
    parentName: string | undefined;
    contactDate: moment.Moment | undefined;
    affiliateContactId: number | undefined;
    affiliateContactName: string | undefined;
    subContactsCount: number | undefined;
}

export class GetAffiliateInfoOutput implements IGetAffiliateInfoOutput {
    id!: number | undefined;
    typeId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    affiliateCode!: string | undefined;
    userId!: number | undefined;
    photoUrl!: string | undefined;
    organizationUnitName!: string | undefined;
    organizationUnitLogoUrl!: string | undefined;

    constructor(data?: IGetAffiliateInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.affiliateCode = data["affiliateCode"];
            this.userId = data["userId"];
            this.photoUrl = data["photoUrl"];
            this.organizationUnitName = data["organizationUnitName"];
            this.organizationUnitLogoUrl = data["organizationUnitLogoUrl"];
        }
    }

    static fromJS(data: any): GetAffiliateInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAffiliateInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["affiliateCode"] = this.affiliateCode;
        data["userId"] = this.userId;
        data["photoUrl"] = this.photoUrl;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitLogoUrl"] = this.organizationUnitLogoUrl;
        return data; 
    }
}

export interface IGetAffiliateInfoOutput {
    id: number | undefined;
    typeId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    affiliateCode: string | undefined;
    userId: number | undefined;
    photoUrl: string | undefined;
    organizationUnitName: string | undefined;
    organizationUnitLogoUrl: string | undefined;
}

export class ContactLastModificationInfoDto implements IContactLastModificationInfoDto {
    date!: moment.Moment | undefined;
    contactId!: number | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IContactLastModificationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.contactId = data["contactId"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.photoPublicId = data["photoPublicId"];
        }
    }

    static fromJS(data: any): ContactLastModificationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLastModificationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["contactId"] = this.contactId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["photoPublicId"] = this.photoPublicId;
        return data; 
    }
}

export interface IContactLastModificationInfoDto {
    date: moment.Moment | undefined;
    contactId: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    photoPublicId: string | undefined;
}

export class ContactDetailsDto implements IContactDetailsDto {
    firstName!: string | undefined;
    lastName!: string | undefined;
    primaryOrgRelationId!: number | undefined;
    orgRelations!: PersonOrgRelationShortInfo[] | undefined;
    emails!: ContactEmailDto[] | undefined;
    phones!: ContactPhoneDto[] | undefined;
    addresses!: ContactAddressDto[] | undefined;

    constructor(data?: IContactDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.primaryOrgRelationId = data["primaryOrgRelationId"];
            if (data["orgRelations"] && data["orgRelations"].constructor === Array) {
                this.orgRelations = [];
                for (let item of data["orgRelations"])
                    this.orgRelations.push(PersonOrgRelationShortInfo.fromJS(item));
            }
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["primaryOrgRelationId"] = this.primaryOrgRelationId;
        if (this.orgRelations && this.orgRelations.constructor === Array) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactDetailsDto {
    firstName: string | undefined;
    lastName: string | undefined;
    primaryOrgRelationId: number | undefined;
    orgRelations: PersonOrgRelationShortInfo[] | undefined;
    emails: ContactEmailDto[] | undefined;
    phones: ContactPhoneDto[] | undefined;
    addresses: ContactAddressDto[] | undefined;
}

export class ContactPhotoInfo implements IContactPhotoInfo {
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IContactPhotoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): ContactPhotoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IContactPhotoInfo {
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
}

export class ContactShortInfo implements IContactShortInfo {
    id!: number | undefined;
    fullName!: string | undefined;
    photo!: ContactPhotoInfo | undefined;
    ratingId!: number | undefined;

    constructor(data?: IContactShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.photo = data["photo"] ? ContactPhotoInfo.fromJS(data["photo"]) : <any>undefined;
            this.ratingId = data["ratingId"];
        }
    }

    static fromJS(data: any): ContactShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["ratingId"] = this.ratingId;
        return data; 
    }
}

export interface IContactShortInfo {
    id: number | undefined;
    fullName: string | undefined;
    photo: ContactPhotoInfo | undefined;
    ratingId: number | undefined;
}

export class ContactEmailInfo implements IContactEmailInfo {
    id!: number | undefined;
    emailAddress!: string | undefined;
    usageTypeId!: string | undefined;
    isPrimary!: boolean | undefined;

    constructor(data?: IContactEmailInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.usageTypeId = data["usageTypeId"];
            this.isPrimary = data["isPrimary"];
        }
    }

    static fromJS(data: any): ContactEmailInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["usageTypeId"] = this.usageTypeId;
        data["isPrimary"] = this.isPrimary;
        return data; 
    }
}

export interface IContactEmailInfo {
    id: number | undefined;
    emailAddress: string | undefined;
    usageTypeId: string | undefined;
    isPrimary: boolean | undefined;
}

export class ContactPhoneInfo implements IContactPhoneInfo {
    id!: number | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    usageTypeId!: string | undefined;
    isPrimary!: boolean | undefined;

    constructor(data?: IContactPhoneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.usageTypeId = data["usageTypeId"];
            this.isPrimary = data["isPrimary"];
        }
    }

    static fromJS(data: any): ContactPhoneInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["usageTypeId"] = this.usageTypeId;
        data["isPrimary"] = this.isPrimary;
        return data; 
    }
}

export interface IContactPhoneInfo {
    id: number | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    usageTypeId: string | undefined;
    isPrimary: boolean | undefined;
}

export class ContactAddressInfo implements IContactAddressInfo {
    id!: number | undefined;
    usageTypeId!: string | undefined;
    startDate!: moment.Moment | undefined;
    ownershipTypeId!: string | undefined;
    isPrimary!: boolean | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;

    constructor(data?: IContactAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.usageTypeId = data["usageTypeId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.ownershipTypeId = data["ownershipTypeId"];
            this.isPrimary = data["isPrimary"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
        }
    }

    static fromJS(data: any): ContactAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["usageTypeId"] = this.usageTypeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["isPrimary"] = this.isPrimary;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data; 
    }
}

export interface IContactAddressInfo {
    id: number | undefined;
    usageTypeId: string | undefined;
    startDate: moment.Moment | undefined;
    ownershipTypeId: string | undefined;
    isPrimary: boolean | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
}

export class ContactInfoForMerge implements IContactInfoForMerge {
    id!: number | undefined;
    fullName!: string | undefined;
    contactDate!: moment.Moment | undefined;
    groupIds!: string[] | undefined;
    typeId!: string | undefined;
    parentId!: number | undefined;
    affiliateCode!: string | undefined;
    xref!: string | undefined;
    userId!: number | undefined;
    userEmailAddress!: string | undefined;
    userIsActive!: boolean | undefined;
    userLastLoginTime!: moment.Moment | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    gender!: Gender | undefined;
    contactEmails!: ContactEmailInfo[] | undefined;
    contactPhones!: ContactPhoneInfo[] | undefined;
    contactAddresses!: ContactAddressInfo[] | undefined;
    photoPublicId!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    assignedToUserId!: number | undefined;
    assignedToUserName!: string | undefined;
    bankCode!: string | undefined;
    bankCodeDate!: moment.Moment | undefined;
    orderCount!: number | undefined;

    constructor(data?: IContactInfoForMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.contactDate = data["contactDate"] ? moment(data["contactDate"].toString()) : <any>undefined;
            if (data["groupIds"] && data["groupIds"].constructor === Array) {
                this.groupIds = [];
                for (let item of data["groupIds"])
                    this.groupIds.push(item);
            }
            this.typeId = data["typeId"];
            this.parentId = data["parentId"];
            this.affiliateCode = data["affiliateCode"];
            this.xref = data["xref"];
            this.userId = data["userId"];
            this.userEmailAddress = data["userEmailAddress"];
            this.userIsActive = data["userIsActive"];
            this.userLastLoginTime = data["userLastLoginTime"] ? moment(data["userLastLoginTime"].toString()) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            if (data["contactEmails"] && data["contactEmails"].constructor === Array) {
                this.contactEmails = [];
                for (let item of data["contactEmails"])
                    this.contactEmails.push(ContactEmailInfo.fromJS(item));
            }
            if (data["contactPhones"] && data["contactPhones"].constructor === Array) {
                this.contactPhones = [];
                for (let item of data["contactPhones"])
                    this.contactPhones.push(ContactPhoneInfo.fromJS(item));
            }
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddressInfo.fromJS(item));
            }
            this.photoPublicId = data["photoPublicId"];
            this.companyName = data["companyName"];
            this.jobTitle = data["jobTitle"];
            this.assignedToUserId = data["assignedToUserId"];
            this.assignedToUserName = data["assignedToUserName"];
            this.bankCode = data["bankCode"];
            this.bankCodeDate = data["bankCodeDate"] ? moment(data["bankCodeDate"].toString()) : <any>undefined;
            this.orderCount = data["orderCount"];
        }
    }

    static fromJS(data: any): ContactInfoForMerge {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoForMerge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["contactDate"] = this.contactDate ? this.contactDate.toISOString() : <any>undefined;
        if (this.groupIds && this.groupIds.constructor === Array) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["typeId"] = this.typeId;
        data["parentId"] = this.parentId;
        data["affiliateCode"] = this.affiliateCode;
        data["xref"] = this.xref;
        data["userId"] = this.userId;
        data["userEmailAddress"] = this.userEmailAddress;
        data["userIsActive"] = this.userIsActive;
        data["userLastLoginTime"] = this.userLastLoginTime ? this.userLastLoginTime.toISOString() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        if (this.contactEmails && this.contactEmails.constructor === Array) {
            data["contactEmails"] = [];
            for (let item of this.contactEmails)
                data["contactEmails"].push(item.toJSON());
        }
        if (this.contactPhones && this.contactPhones.constructor === Array) {
            data["contactPhones"] = [];
            for (let item of this.contactPhones)
                data["contactPhones"].push(item.toJSON());
        }
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["photoPublicId"] = this.photoPublicId;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["assignedToUserId"] = this.assignedToUserId;
        data["assignedToUserName"] = this.assignedToUserName;
        data["bankCode"] = this.bankCode;
        data["bankCodeDate"] = this.bankCodeDate ? this.bankCodeDate.toISOString() : <any>undefined;
        data["orderCount"] = this.orderCount;
        return data; 
    }
}

export interface IContactInfoForMerge {
    id: number | undefined;
    fullName: string | undefined;
    contactDate: moment.Moment | undefined;
    groupIds: string[] | undefined;
    typeId: string | undefined;
    parentId: number | undefined;
    affiliateCode: string | undefined;
    xref: string | undefined;
    userId: number | undefined;
    userEmailAddress: string | undefined;
    userIsActive: boolean | undefined;
    userLastLoginTime: moment.Moment | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    gender: Gender | undefined;
    contactEmails: ContactEmailInfo[] | undefined;
    contactPhones: ContactPhoneInfo[] | undefined;
    contactAddresses: ContactAddressInfo[] | undefined;
    photoPublicId: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    assignedToUserId: number | undefined;
    assignedToUserName: string | undefined;
    bankCode: string | undefined;
    bankCodeDate: moment.Moment | undefined;
    orderCount: number | undefined;
}

export class LeadInfoForMerge implements ILeadInfoForMerge {
    id!: number | undefined;
    typeId!: number | undefined;
    contactGroupId!: string | undefined;
    contactId!: number | undefined;
    stage!: string | undefined;
    sourceContactId!: number | undefined;
    sourceContactName!: string | undefined;
    sourceOrganizationUnitId!: number | undefined;
    sourceOrganizationUnitName!: string | undefined;
    leadDate!: moment.Moment | undefined;
    dateCompleted!: moment.Moment | undefined;
    leadCancellationReasonId!: string | undefined;

    constructor(data?: ILeadInfoForMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.contactGroupId = data["contactGroupId"];
            this.contactId = data["contactId"];
            this.stage = data["stage"];
            this.sourceContactId = data["sourceContactId"];
            this.sourceContactName = data["sourceContactName"];
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
            this.sourceOrganizationUnitName = data["sourceOrganizationUnitName"];
            this.leadDate = data["leadDate"] ? moment(data["leadDate"].toString()) : <any>undefined;
            this.dateCompleted = data["dateCompleted"] ? moment(data["dateCompleted"].toString()) : <any>undefined;
            this.leadCancellationReasonId = data["leadCancellationReasonId"];
        }
    }

    static fromJS(data: any): LeadInfoForMerge {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInfoForMerge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["contactGroupId"] = this.contactGroupId;
        data["contactId"] = this.contactId;
        data["stage"] = this.stage;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceContactName"] = this.sourceContactName;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["sourceOrganizationUnitName"] = this.sourceOrganizationUnitName;
        data["leadDate"] = this.leadDate ? this.leadDate.toISOString() : <any>undefined;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["leadCancellationReasonId"] = this.leadCancellationReasonId;
        return data; 
    }
}

export interface ILeadInfoForMerge {
    id: number | undefined;
    typeId: number | undefined;
    contactGroupId: string | undefined;
    contactId: number | undefined;
    stage: string | undefined;
    sourceContactId: number | undefined;
    sourceContactName: string | undefined;
    sourceOrganizationUnitId: number | undefined;
    sourceOrganizationUnitName: string | undefined;
    leadDate: moment.Moment | undefined;
    dateCompleted: moment.Moment | undefined;
    leadCancellationReasonId: string | undefined;
}

export class GetContactInfoForMergeOutput implements IGetContactInfoForMergeOutput {
    contactInfo!: ContactInfoForMerge | undefined;
    contactLeadInfo!: LeadInfoForMerge | undefined;
    targetContactInfo!: ContactInfoForMerge | undefined;
    targetContactLeadInfo!: LeadInfoForMerge | undefined;

    constructor(data?: IGetContactInfoForMergeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactInfo = data["contactInfo"] ? ContactInfoForMerge.fromJS(data["contactInfo"]) : <any>undefined;
            this.contactLeadInfo = data["contactLeadInfo"] ? LeadInfoForMerge.fromJS(data["contactLeadInfo"]) : <any>undefined;
            this.targetContactInfo = data["targetContactInfo"] ? ContactInfoForMerge.fromJS(data["targetContactInfo"]) : <any>undefined;
            this.targetContactLeadInfo = data["targetContactLeadInfo"] ? LeadInfoForMerge.fromJS(data["targetContactLeadInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactInfoForMergeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactInfoForMergeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactInfo"] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
        data["contactLeadInfo"] = this.contactLeadInfo ? this.contactLeadInfo.toJSON() : <any>undefined;
        data["targetContactInfo"] = this.targetContactInfo ? this.targetContactInfo.toJSON() : <any>undefined;
        data["targetContactLeadInfo"] = this.targetContactLeadInfo ? this.targetContactLeadInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetContactInfoForMergeOutput {
    contactInfo: ContactInfoForMerge | undefined;
    contactLeadInfo: LeadInfoForMerge | undefined;
    targetContactInfo: ContactInfoForMerge | undefined;
    targetContactLeadInfo: LeadInfoForMerge | undefined;
}

export class SourceContactLevelInfo implements ISourceContactLevelInfo {
    id!: number | undefined;
    name!: string | undefined;
    affiliateCode!: string | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: ISourceContactLevelInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.affiliateCode = data["affiliateCode"];
            this.photoPublicId = data["photoPublicId"];
        }
    }

    static fromJS(data: any): SourceContactLevelInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SourceContactLevelInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["affiliateCode"] = this.affiliateCode;
        data["photoPublicId"] = this.photoPublicId;
        return data; 
    }
}

export interface ISourceContactLevelInfo {
    id: number | undefined;
    name: string | undefined;
    affiliateCode: string | undefined;
    photoPublicId: string | undefined;
}

export class GetSourceContactInfoOutput implements IGetSourceContactInfoOutput {
    sourceContactLevel1!: SourceContactLevelInfo | undefined;
    sourceContactLevel2!: SourceContactLevelInfo | undefined;

    constructor(data?: IGetSourceContactInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceContactLevel1 = data["sourceContactLevel1"] ? SourceContactLevelInfo.fromJS(data["sourceContactLevel1"]) : <any>undefined;
            this.sourceContactLevel2 = data["sourceContactLevel2"] ? SourceContactLevelInfo.fromJS(data["sourceContactLevel2"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSourceContactInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSourceContactInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceContactLevel1"] = this.sourceContactLevel1 ? this.sourceContactLevel1.toJSON() : <any>undefined;
        data["sourceContactLevel2"] = this.sourceContactLevel2 ? this.sourceContactLevel2.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSourceContactInfoOutput {
    sourceContactLevel1: SourceContactLevelInfo | undefined;
    sourceContactLevel2: SourceContactLevelInfo | undefined;
}

export class SubmitQuestionnaireDto implements ISubmitQuestionnaireDto {
    xref!: string | undefined;
    name!: string | undefined;

    constructor(data?: ISubmitQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xref = data["xref"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SubmitQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISubmitQuestionnaireDto {
    xref: string | undefined;
    name: string | undefined;
}

export enum QuestionType {
    QuestionWithOptions = "QuestionWithOptions", 
}

export class SubmitQuestionDto implements ISubmitQuestionDto {
    xref!: string | undefined;
    type!: QuestionType | undefined;
    text!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ISubmitQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xref = data["xref"];
            this.type = data["type"];
            this.text = data["text"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): SubmitQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["type"] = this.type;
        data["text"] = this.text;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ISubmitQuestionDto {
    xref: string | undefined;
    type: QuestionType | undefined;
    text: string | undefined;
    sortOrder: number | undefined;
}

export class SubmitAnswerDto implements ISubmitAnswerDto {
    xref!: string | undefined;
    sortOrder!: number | undefined;
    text!: string | undefined;

    constructor(data?: ISubmitAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xref = data["xref"];
            this.sortOrder = data["sortOrder"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): SubmitAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xref"] = this.xref;
        data["sortOrder"] = this.sortOrder;
        data["text"] = this.text;
        return data; 
    }
}

export interface ISubmitAnswerDto {
    xref: string | undefined;
    sortOrder: number | undefined;
    text: string | undefined;
}

export class SubmitQuestionAndAnswersDto implements ISubmitQuestionAndAnswersDto {
    question!: SubmitQuestionDto | undefined;
    answers!: SubmitAnswerDto[] | undefined;

    constructor(data?: ISubmitQuestionAndAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.question = data["question"] ? SubmitQuestionDto.fromJS(data["question"]) : <any>undefined;
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(SubmitAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionAndAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionAndAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubmitQuestionAndAnswersDto {
    question: SubmitQuestionDto | undefined;
    answers: SubmitAnswerDto[] | undefined;
}

export class SubmitQuestionsAndAnswersDtoWithoutCheck implements ISubmitQuestionsAndAnswersDtoWithoutCheck {
    questionnaire!: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers!: SubmitQuestionAndAnswersDto[] | undefined;

    constructor(data?: ISubmitQuestionsAndAnswersDtoWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionnaire = data["questionnaire"] ? SubmitQuestionnaireDto.fromJS(data["questionnaire"]) : <any>undefined;
            if (data["questionsAndAnswers"] && data["questionsAndAnswers"].constructor === Array) {
                this.questionsAndAnswers = [];
                for (let item of data["questionsAndAnswers"])
                    this.questionsAndAnswers.push(SubmitQuestionAndAnswersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionsAndAnswersDtoWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionsAndAnswersDtoWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        if (this.questionsAndAnswers && this.questionsAndAnswers.constructor === Array) {
            data["questionsAndAnswers"] = [];
            for (let item of this.questionsAndAnswers)
                data["questionsAndAnswers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubmitQuestionsAndAnswersDtoWithoutCheck {
    questionnaire: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers: SubmitQuestionAndAnswersDto[] | undefined;
}

export class CreateContactLinkInputWithoutCheck implements ICreateContactLinkInputWithoutCheck {
    contactId!: number | undefined;
    isConfirmed!: boolean | undefined;
    isCompany!: boolean | undefined;
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateContactLinkInputWithoutCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.isConfirmed = data["isConfirmed"];
            this.isCompany = data["isCompany"];
            this.url = data["url"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateContactLinkInputWithoutCheck {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkInputWithoutCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface ICreateContactLinkInputWithoutCheck {
    contactId: number | undefined;
    isConfirmed: boolean | undefined;
    isCompany: boolean | undefined;
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class ContactPhotoInput implements IContactPhotoInput {
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactPhotoInput {
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class ContactTagInput implements IContactTagInput {
    name!: string;

    constructor(data?: IContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactTagInput {
    name: string;
}

export class ContactListInput implements IContactListInput {
    name!: string;

    constructor(data?: IContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactListInput {
    name: string;
}

export class TrackingInfo implements ITrackingInfo {
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    userAgent!: string | undefined;
    clientIp!: string | undefined;

    constructor(data?: ITrackingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceCode = data["sourceCode"];
            this.channelCode = data["channelCode"];
            this.affiliateCode = data["affiliateCode"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.userAgent = data["userAgent"];
            this.clientIp = data["clientIp"];
        }
    }

    static fromJS(data: any): TrackingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["userAgent"] = this.userAgent;
        data["clientIp"] = this.clientIp;
        return data; 
    }
}

export interface ITrackingInfo {
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    userAgent: string | undefined;
    clientIp: string | undefined;
}

export class CreateContactAddressInput implements ICreateContactAddressInput {
    contactId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateContactAddressInput {
    contactId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class PropertyInput implements IPropertyInput {
    propertyId!: number | undefined;
    name!: string | undefined;
    address!: CreateContactAddressInput | undefined;
    note!: string | undefined;

    constructor(data?: IPropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyId = data["propertyId"];
            this.name = data["name"];
            this.address = data["address"] ? CreateContactAddressInput.fromJS(data["address"]) : <any>undefined;
            this.note = data["note"];
        }
    }

    static fromJS(data: any): PropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["note"] = this.note;
        return data; 
    }
}

export interface IPropertyInput {
    propertyId: number | undefined;
    name: string | undefined;
    address: CreateContactAddressInput | undefined;
    note: string | undefined;
}

export class CreateOrUpdateContactInput implements ICreateOrUpdateContactInput {
    matchExisting!: boolean | undefined;
    parentContactId!: number | undefined;
    questionnaireAnswers!: SubmitQuestionsAndAnswersDtoWithoutCheck | undefined;
    contactId!: number | undefined;
    contactXRef!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers!: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses!: CreateContactAddressInputWithoutCheck[] | undefined;
    links!: CreateContactLinkInputWithoutCheck[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    sourceContactId!: number | undefined;
    sourceOrganizationUnitId!: number | undefined;
    personAffiliateCode!: string | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    isActive!: boolean | undefined;
    isProspective!: boolean | undefined;
    statusId!: string | undefined;
    partnerTypeName!: string | undefined;
    leadTypeId!: number | undefined;
    leadTypeSysId!: string | undefined;
    stageId!: number | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;
    followUpDate!: moment.Moment | undefined;
    trackingInfo!: TrackingInfo | undefined;
    inviteUser!: boolean | undefined;
    generateAutoLoginLink!: boolean | undefined;
    newUserPassword!: string | undefined;
    changeNewUserPasswordOnNextLogin!: boolean | undefined;
    noWelcomeEmail!: boolean | undefined;
    welcomeEmailTemplateRef!: string | undefined;
    propertyInfo!: PropertyInput | undefined;
    bypassValidation!: boolean | undefined;

    constructor(data?: ICreateOrUpdateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.matchExisting = data["matchExisting"];
            this.parentContactId = data["parentContactId"];
            this.questionnaireAnswers = data["questionnaireAnswers"] ? SubmitQuestionsAndAnswersDtoWithoutCheck.fromJS(data["questionnaireAnswers"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contactXRef = data["contactXRef"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(CreateContactEmailInputWithoutCheck.fromJS(item));
            }
            if (data["phoneNumbers"] && data["phoneNumbers"].constructor === Array) {
                this.phoneNumbers = [];
                for (let item of data["phoneNumbers"])
                    this.phoneNumbers.push(CreateContactPhoneInputWithoutCheck.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(CreateContactAddressInputWithoutCheck.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(CreateContactLinkInputWithoutCheck.fromJS(item));
            }
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.bankCode = data["bankCode"];
            this.bankCodeSource = data["bankCodeSource"];
            this.gender = data["gender"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.note = data["note"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.companyName = data["companyName"];
            this.industry = data["industry"];
            this.photo = data["photo"] ? ContactPhotoInput.fromJS(data["photo"]) : <any>undefined;
            this.sourceContactId = data["sourceContactId"];
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
            this.personAffiliateCode = data["personAffiliateCode"];
            this.title = data["title"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.contactGroupId = data["contactGroupId"];
            this.isActive = data["isActive"];
            this.isProspective = data["isProspective"];
            this.statusId = data["statusId"];
            this.partnerTypeName = data["partnerTypeName"];
            this.leadTypeId = data["leadTypeId"];
            this.leadTypeSysId = data["leadTypeSysId"];
            this.stageId = data["stageId"];
            this.dealAmount = data["dealAmount"];
            this.installmentAmount = data["installmentAmount"];
            this.followUpDate = data["followUpDate"] ? moment(data["followUpDate"].toString()) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
            this.inviteUser = data["inviteUser"];
            this.generateAutoLoginLink = data["generateAutoLoginLink"];
            this.newUserPassword = data["newUserPassword"];
            this.changeNewUserPasswordOnNextLogin = data["changeNewUserPasswordOnNextLogin"];
            this.noWelcomeEmail = data["noWelcomeEmail"];
            this.welcomeEmailTemplateRef = data["welcomeEmailTemplateRef"];
            this.propertyInfo = data["propertyInfo"] ? PropertyInput.fromJS(data["propertyInfo"]) : <any>undefined;
            this.bypassValidation = data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateOrUpdateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchExisting"] = this.matchExisting;
        data["parentContactId"] = this.parentContactId;
        data["questionnaireAnswers"] = this.questionnaireAnswers ? this.questionnaireAnswers.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contactXRef"] = this.contactXRef;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (this.phoneNumbers && this.phoneNumbers.constructor === Array) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["personAffiliateCode"] = this.personAffiliateCode;
        data["title"] = this.title;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        data["statusId"] = this.statusId;
        data["partnerTypeName"] = this.partnerTypeName;
        data["leadTypeId"] = this.leadTypeId;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["stageId"] = this.stageId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        data["inviteUser"] = this.inviteUser;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        data["newUserPassword"] = this.newUserPassword;
        data["changeNewUserPasswordOnNextLogin"] = this.changeNewUserPasswordOnNextLogin;
        data["noWelcomeEmail"] = this.noWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["bypassValidation"] = this.bypassValidation;
        return data; 
    }
}

export interface ICreateOrUpdateContactInput {
    matchExisting: boolean | undefined;
    parentContactId: number | undefined;
    questionnaireAnswers: SubmitQuestionsAndAnswersDtoWithoutCheck | undefined;
    contactId: number | undefined;
    contactXRef: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses: CreateContactAddressInputWithoutCheck[] | undefined;
    links: CreateContactLinkInputWithoutCheck[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    sourceContactId: number | undefined;
    sourceOrganizationUnitId: number | undefined;
    personAffiliateCode: string | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    isActive: boolean | undefined;
    isProspective: boolean | undefined;
    statusId: string | undefined;
    partnerTypeName: string | undefined;
    leadTypeId: number | undefined;
    leadTypeSysId: string | undefined;
    stageId: number | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
    followUpDate: moment.Moment | undefined;
    trackingInfo: TrackingInfo | undefined;
    inviteUser: boolean | undefined;
    generateAutoLoginLink: boolean | undefined;
    newUserPassword: string | undefined;
    changeNewUserPasswordOnNextLogin: boolean | undefined;
    noWelcomeEmail: boolean | undefined;
    welcomeEmailTemplateRef: string | undefined;
    propertyInfo: PropertyInput | undefined;
    bypassValidation: boolean | undefined;
}

export class CreateOrUpdateContactOutput implements ICreateOrUpdateContactOutput {
    contactId!: number | undefined;
    leadId!: number | undefined;
    userId!: number | undefined;
    userKey!: string | undefined;
    userEmailAddress!: string | undefined;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateOrUpdateContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.leadId = data["leadId"];
            this.userId = data["userId"];
            this.userKey = data["userKey"];
            this.userEmailAddress = data["userEmailAddress"];
            this.autoLoginLink = data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateOrUpdateContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        data["userId"] = this.userId;
        data["userKey"] = this.userKey;
        data["userEmailAddress"] = this.userEmailAddress;
        data["autoLoginLink"] = this.autoLoginLink;
        return data; 
    }
}

export interface ICreateOrUpdateContactOutput {
    contactId: number | undefined;
    leadId: number | undefined;
    userId: number | undefined;
    userKey: string | undefined;
    userEmailAddress: string | undefined;
    autoLoginLink: string | undefined;
}

export enum PreferredProperties {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
}

export class ContactMergeOptions implements IContactMergeOptions {
    emailIdsToIgnore!: number[] | undefined;
    phoneIdsToIgnore!: number[] | undefined;
    addressIdsToIgnore!: number[] | undefined;
    preferredProperties!: PreferredProperties | undefined;

    constructor(data?: IContactMergeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["emailIdsToIgnore"] && data["emailIdsToIgnore"].constructor === Array) {
                this.emailIdsToIgnore = [];
                for (let item of data["emailIdsToIgnore"])
                    this.emailIdsToIgnore.push(item);
            }
            if (data["phoneIdsToIgnore"] && data["phoneIdsToIgnore"].constructor === Array) {
                this.phoneIdsToIgnore = [];
                for (let item of data["phoneIdsToIgnore"])
                    this.phoneIdsToIgnore.push(item);
            }
            if (data["addressIdsToIgnore"] && data["addressIdsToIgnore"].constructor === Array) {
                this.addressIdsToIgnore = [];
                for (let item of data["addressIdsToIgnore"])
                    this.addressIdsToIgnore.push(item);
            }
            this.preferredProperties = data["preferredProperties"];
        }
    }

    static fromJS(data: any): ContactMergeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ContactMergeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.emailIdsToIgnore && this.emailIdsToIgnore.constructor === Array) {
            data["emailIdsToIgnore"] = [];
            for (let item of this.emailIdsToIgnore)
                data["emailIdsToIgnore"].push(item);
        }
        if (this.phoneIdsToIgnore && this.phoneIdsToIgnore.constructor === Array) {
            data["phoneIdsToIgnore"] = [];
            for (let item of this.phoneIdsToIgnore)
                data["phoneIdsToIgnore"].push(item);
        }
        if (this.addressIdsToIgnore && this.addressIdsToIgnore.constructor === Array) {
            data["addressIdsToIgnore"] = [];
            for (let item of this.addressIdsToIgnore)
                data["addressIdsToIgnore"].push(item);
        }
        data["preferredProperties"] = this.preferredProperties;
        return data; 
    }
}

export interface IContactMergeOptions {
    emailIdsToIgnore: number[] | undefined;
    phoneIdsToIgnore: number[] | undefined;
    addressIdsToIgnore: number[] | undefined;
    preferredProperties: PreferredProperties | undefined;
}

export class TargetContactMergeOptions implements ITargetContactMergeOptions {
    emailIdsToRemove!: number[] | undefined;
    phoneIdsToRemove!: number[] | undefined;
    addressIdsToRemove!: number[] | undefined;

    constructor(data?: ITargetContactMergeOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["emailIdsToRemove"] && data["emailIdsToRemove"].constructor === Array) {
                this.emailIdsToRemove = [];
                for (let item of data["emailIdsToRemove"])
                    this.emailIdsToRemove.push(item);
            }
            if (data["phoneIdsToRemove"] && data["phoneIdsToRemove"].constructor === Array) {
                this.phoneIdsToRemove = [];
                for (let item of data["phoneIdsToRemove"])
                    this.phoneIdsToRemove.push(item);
            }
            if (data["addressIdsToRemove"] && data["addressIdsToRemove"].constructor === Array) {
                this.addressIdsToRemove = [];
                for (let item of data["addressIdsToRemove"])
                    this.addressIdsToRemove.push(item);
            }
        }
    }

    static fromJS(data: any): TargetContactMergeOptions {
        data = typeof data === 'object' ? data : {};
        let result = new TargetContactMergeOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.emailIdsToRemove && this.emailIdsToRemove.constructor === Array) {
            data["emailIdsToRemove"] = [];
            for (let item of this.emailIdsToRemove)
                data["emailIdsToRemove"].push(item);
        }
        if (this.phoneIdsToRemove && this.phoneIdsToRemove.constructor === Array) {
            data["phoneIdsToRemove"] = [];
            for (let item of this.phoneIdsToRemove)
                data["phoneIdsToRemove"].push(item);
        }
        if (this.addressIdsToRemove && this.addressIdsToRemove.constructor === Array) {
            data["addressIdsToRemove"] = [];
            for (let item of this.addressIdsToRemove)
                data["addressIdsToRemove"].push(item);
        }
        return data; 
    }
}

export interface ITargetContactMergeOptions {
    emailIdsToRemove: number[] | undefined;
    phoneIdsToRemove: number[] | undefined;
    addressIdsToRemove: number[] | undefined;
}

export class PrimaryContactInfo implements IPrimaryContactInfo {
    primaryEmailId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;

    constructor(data?: IPrimaryContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.primaryEmailId = data["primaryEmailId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryAddressId = data["primaryAddressId"];
        }
    }

    static fromJS(data: any): PrimaryContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PrimaryContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primaryEmailId"] = this.primaryEmailId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        return data; 
    }
}

export interface IPrimaryContactInfo {
    primaryEmailId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
}

export enum MergeLeadMode {
    KeepSource = "KeepSource", 
    KeepTarget = "KeepTarget", 
    KeepBoth = "KeepBoth", 
}

export class MergeContactInput implements IMergeContactInput {
    contactId!: number;
    contactLeadId!: number | undefined;
    contactMergeOptions!: ContactMergeOptions | undefined;
    targetContactId!: number;
    targetContactLeadId!: number | undefined;
    targetContactMergeOptions!: TargetContactMergeOptions | undefined;
    primaryContactInfo!: PrimaryContactInfo | undefined;
    mergeLeadMode!: MergeLeadMode | undefined;

    constructor(data?: IMergeContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.contactLeadId = data["contactLeadId"];
            this.contactMergeOptions = data["contactMergeOptions"] ? ContactMergeOptions.fromJS(data["contactMergeOptions"]) : <any>undefined;
            this.targetContactId = data["targetContactId"];
            this.targetContactLeadId = data["targetContactLeadId"];
            this.targetContactMergeOptions = data["targetContactMergeOptions"] ? TargetContactMergeOptions.fromJS(data["targetContactMergeOptions"]) : <any>undefined;
            this.primaryContactInfo = data["primaryContactInfo"] ? PrimaryContactInfo.fromJS(data["primaryContactInfo"]) : <any>undefined;
            this.mergeLeadMode = data["mergeLeadMode"];
        }
    }

    static fromJS(data: any): MergeContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactLeadId"] = this.contactLeadId;
        data["contactMergeOptions"] = this.contactMergeOptions ? this.contactMergeOptions.toJSON() : <any>undefined;
        data["targetContactId"] = this.targetContactId;
        data["targetContactLeadId"] = this.targetContactLeadId;
        data["targetContactMergeOptions"] = this.targetContactMergeOptions ? this.targetContactMergeOptions.toJSON() : <any>undefined;
        data["primaryContactInfo"] = this.primaryContactInfo ? this.primaryContactInfo.toJSON() : <any>undefined;
        data["mergeLeadMode"] = this.mergeLeadMode;
        return data; 
    }
}

export interface IMergeContactInput {
    contactId: number;
    contactLeadId: number | undefined;
    contactMergeOptions: ContactMergeOptions | undefined;
    targetContactId: number;
    targetContactLeadId: number | undefined;
    targetContactMergeOptions: TargetContactMergeOptions | undefined;
    primaryContactInfo: PrimaryContactInfo | undefined;
    mergeLeadMode: MergeLeadMode | undefined;
}

export class SimilarContactOutput implements ISimilarContactOutput {
    id!: number | undefined;
    parentId!: number | undefined;
    name!: string | undefined;
    photo!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    score!: number | undefined;

    constructor(data?: ISimilarContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.photo = data["photo"];
            this.companyName = data["companyName"];
            this.jobTitle = data["jobTitle"];
            this.ratingId = data["ratingId"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): SimilarContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SimilarContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["photo"] = this.photo;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["score"] = this.score;
        return data; 
    }
}

export interface ISimilarContactOutput {
    id: number | undefined;
    parentId: number | undefined;
    name: string | undefined;
    photo: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    score: number | undefined;
}

export class SourceContactInfo implements ISourceContactInfo {
    id!: number | undefined;
    typeId!: string | undefined;
    affiliateCode!: string | undefined;
    companyName!: string | undefined;
    personName!: string | undefined;
    jobTitle!: string | undefined;

    constructor(data?: ISourceContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.affiliateCode = data["affiliateCode"];
            this.companyName = data["companyName"];
            this.personName = data["personName"];
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): SourceContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SourceContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["affiliateCode"] = this.affiliateCode;
        data["companyName"] = this.companyName;
        data["personName"] = this.personName;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface ISourceContactInfo {
    id: number | undefined;
    typeId: string | undefined;
    affiliateCode: string | undefined;
    companyName: string | undefined;
    personName: string | undefined;
    jobTitle: string | undefined;
}

export class EntityAddressInfo implements IEntityAddressInfo {
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    country!: string | undefined;
    zip!: string | undefined;

    constructor(data?: IEntityAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.country = data["country"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): EntityAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["country"] = this.country;
        data["zip"] = this.zip;
        return data; 
    }
}

export interface IEntityAddressInfo {
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    country: string | undefined;
    zip: string | undefined;
}

export class EntityContactInfo implements IEntityContactInfo {
    id!: number | undefined;
    name!: string | undefined;
    email!: string | undefined;
    userId!: number | undefined;
    address!: EntityAddressInfo | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IEntityContactInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.email = data["email"];
            this.userId = data["userId"];
            this.address = data["address"] ? EntityAddressInfo.fromJS(data["address"]) : <any>undefined;
            this.photoPublicId = data["photoPublicId"];
        }
    }

    static fromJS(data: any): EntityContactInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntityContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["photoPublicId"] = this.photoPublicId;
        return data; 
    }
}

export interface IEntityContactInfo {
    id: number | undefined;
    name: string | undefined;
    email: string | undefined;
    userId: number | undefined;
    address: EntityAddressInfo | undefined;
    photoPublicId: string | undefined;
}

export class UpdateContactStatusInput implements IUpdateContactStatusInput {
    contactId!: number;
    notifyUser!: boolean | undefined;
    groupId!: string;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateContactStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.notifyUser = data["notifyUser"];
            this.groupId = data["groupId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateContactStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["notifyUser"] = this.notifyUser;
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateContactStatusInput {
    contactId: number;
    notifyUser: boolean | undefined;
    groupId: string;
    isActive: boolean | undefined;
}

export class UpdateContactStatusesInput implements IUpdateContactStatusesInput {
    contactIds!: number[];
    notifyUsers!: boolean | undefined;
    groupId!: string;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateContactStatusesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.notifyUsers = data["notifyUsers"];
            this.groupId = data["groupId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateContactStatusesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["notifyUsers"] = this.notifyUsers;
        data["groupId"] = this.groupId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateContactStatusesInput {
    contactIds: number[];
    notifyUsers: boolean | undefined;
    groupId: string;
    isActive: boolean | undefined;
}

export class ContactGroupDto implements IContactGroupDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IContactGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactGroupDto {
    id: string | undefined;
    name: string | undefined;
}

export class AffiliateInfoHistoryInfo implements IAffiliateInfoHistoryInfo {
    affiliateContactId!: number | undefined;
    affiliateContactName!: string | undefined;
    affiliateContactAffiliateCode!: string | undefined;
    affiliateContactPhotoPublicId!: string | undefined;
    affiliateCode!: string | undefined;
    affiliateRate!: number | undefined;
    affiliateRateTier2!: number | undefined;
    dateTime!: moment.Moment | undefined;
    userId!: number | undefined;
    userName!: string | undefined;
    userPhotoPublicId!: string | undefined;

    constructor(data?: IAffiliateInfoHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.affiliateContactId = data["affiliateContactId"];
            this.affiliateContactName = data["affiliateContactName"];
            this.affiliateContactAffiliateCode = data["affiliateContactAffiliateCode"];
            this.affiliateContactPhotoPublicId = data["affiliateContactPhotoPublicId"];
            this.affiliateCode = data["affiliateCode"];
            this.affiliateRate = data["affiliateRate"];
            this.affiliateRateTier2 = data["affiliateRateTier2"];
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userPhotoPublicId = data["userPhotoPublicId"];
        }
    }

    static fromJS(data: any): AffiliateInfoHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AffiliateInfoHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affiliateContactId"] = this.affiliateContactId;
        data["affiliateContactName"] = this.affiliateContactName;
        data["affiliateContactAffiliateCode"] = this.affiliateContactAffiliateCode;
        data["affiliateContactPhotoPublicId"] = this.affiliateContactPhotoPublicId;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateRate"] = this.affiliateRate;
        data["affiliateRateTier2"] = this.affiliateRateTier2;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userPhotoPublicId"] = this.userPhotoPublicId;
        return data; 
    }
}

export interface IAffiliateInfoHistoryInfo {
    affiliateContactId: number | undefined;
    affiliateContactName: string | undefined;
    affiliateContactAffiliateCode: string | undefined;
    affiliateContactPhotoPublicId: string | undefined;
    affiliateCode: string | undefined;
    affiliateRate: number | undefined;
    affiliateRateTier2: number | undefined;
    dateTime: moment.Moment | undefined;
    userId: number | undefined;
    userName: string | undefined;
    userPhotoPublicId: string | undefined;
}

export class AssignUserInput implements IAssignUserInput {
    id!: number;
    userId!: number | undefined;

    constructor(data?: IAssignUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AssignUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IAssignUserInput {
    id: number;
    userId: number | undefined;
}

export class AssignUserForEachInput implements IAssignUserForEachInput {
    ids!: number[];
    userId!: number | undefined;

    constructor(data?: IAssignUserForEachInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AssignUserForEachInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserForEachInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IAssignUserForEachInput {
    ids: number[];
    userId: number | undefined;
}

export class UpdateContactAffiliateCodeInput implements IUpdateContactAffiliateCodeInput {
    contactId!: number;
    affiliateCode!: string | undefined;

    constructor(data?: IUpdateContactAffiliateCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): UpdateContactAffiliateCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAffiliateCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IUpdateContactAffiliateCodeInput {
    contactId: number;
    affiliateCode: string | undefined;
}

export enum CommissionTier {
    Tier1 = "Tier1", 
    Tier2 = "Tier2", 
}

export class UpdateContactAffiliateRateInput implements IUpdateContactAffiliateRateInput {
    contactId!: number;
    affiliateRate!: number | undefined;
    updatePendingCommissions!: boolean | undefined;
    commissionTier!: CommissionTier | undefined;

    constructor(data?: IUpdateContactAffiliateRateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.affiliateRate = data["affiliateRate"];
            this.updatePendingCommissions = data["updatePendingCommissions"];
            this.commissionTier = data["commissionTier"];
        }
    }

    static fromJS(data: any): UpdateContactAffiliateRateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAffiliateRateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateRate"] = this.affiliateRate;
        data["updatePendingCommissions"] = this.updatePendingCommissions;
        data["commissionTier"] = this.commissionTier;
        return data; 
    }
}

export interface IUpdateContactAffiliateRateInput {
    contactId: number;
    affiliateRate: number | undefined;
    updatePendingCommissions: boolean | undefined;
    commissionTier: CommissionTier | undefined;
}

export class UpdateAffiliateIsAdvisorInput implements IUpdateAffiliateIsAdvisorInput {
    contactId!: number;
    isAdvisor!: boolean;

    constructor(data?: IUpdateAffiliateIsAdvisorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.isAdvisor = data["isAdvisor"];
        }
    }

    static fromJS(data: any): UpdateAffiliateIsAdvisorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAffiliateIsAdvisorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isAdvisor"] = this.isAdvisor;
        return data; 
    }
}

export interface IUpdateAffiliateIsAdvisorInput {
    contactId: number;
    isAdvisor: boolean;
}

export class UpdateContactXrefInput implements IUpdateContactXrefInput {
    contactId!: number;
    xref!: string | undefined;

    constructor(data?: IUpdateContactXrefInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.xref = data["xref"];
        }
    }

    static fromJS(data: any): UpdateContactXrefInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactXrefInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["xref"] = this.xref;
        return data; 
    }
}

export interface IUpdateContactXrefInput {
    contactId: number;
    xref: string | undefined;
}

export class UpdateContactCustomFieldsInput implements IUpdateContactCustomFieldsInput {
    contactId!: number;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;

    constructor(data?: IUpdateContactCustomFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.customField1 = data["customField1"];
            this.customField2 = data["customField2"];
            this.customField3 = data["customField3"];
            this.customField4 = data["customField4"];
            this.customField5 = data["customField5"];
        }
    }

    static fromJS(data: any): UpdateContactCustomFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactCustomFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        return data; 
    }
}

export interface IUpdateContactCustomFieldsInput {
    contactId: number;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
}

export class UpdateAffiliateContactInput implements IUpdateAffiliateContactInput {
    contactId!: number;
    affiliateContactId!: number | undefined;
    updatePendingCommissions!: boolean | undefined;

    constructor(data?: IUpdateAffiliateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.affiliateContactId = data["affiliateContactId"];
            this.updatePendingCommissions = data["updatePendingCommissions"];
        }
    }

    static fromJS(data: any): UpdateAffiliateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAffiliateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["affiliateContactId"] = this.affiliateContactId;
        data["updatePendingCommissions"] = this.updatePendingCommissions;
        return data; 
    }
}

export interface IUpdateAffiliateContactInput {
    contactId: number;
    affiliateContactId: number | undefined;
    updatePendingCommissions: boolean | undefined;
}

export class CreateContactAddressOutput implements ICreateContactAddressOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactAddressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactAddressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactAddressOutput {
    id: number | undefined;
}

export class UpdateContactAddressInput implements IUpdateContactAddressInput {
    id!: number;
    contactId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IUpdateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): UpdateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IUpdateContactAddressInput {
    id: number;
    contactId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    comment: string | undefined;
}

export class AddressUsageTypeDto implements IAddressUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): AddressUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IAddressUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class AddressUsageTypeDtoListResultDto implements IAddressUsageTypeDtoListResultDto {
    items!: AddressUsageTypeDto[] | undefined;

    constructor(data?: IAddressUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddressUsageTypeDtoListResultDto {
    items: AddressUsageTypeDto[] | undefined;
}

export class AddressOwnershipTypeDto implements IAddressOwnershipTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAddressOwnershipTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class AddressOwnershipTypeDtoListResultDto implements IAddressOwnershipTypeDtoListResultDto {
    items!: AddressOwnershipTypeDto[] | undefined;

    constructor(data?: IAddressOwnershipTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressOwnershipTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddressOwnershipTypeDtoListResultDto {
    items: AddressOwnershipTypeDto[] | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    name!: string | undefined;
    size!: number | undefined;
    fileId!: string | undefined;
    id!: string | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.size = data["size"];
            this.fileId = data["fileId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["fileId"] = this.fileId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAttachmentDto {
    name: string | undefined;
    size: number | undefined;
    fileId: string | undefined;
    id: string | undefined;
}

export enum CommunicationMessageDeliveryType {
    Email = "Email", 
    SMS = "SMS", 
}

export enum CommunicationMessageSendingStatus {
    Draft = "Draft", 
    Pending = "Pending", 
    Failed = "Failed", 
    Sent = "Sent", 
}

export enum CommunicationMessageDeliveryStatus {
    Delivered = "Delivered", 
    Bounce = "Bounce", 
    Blocked = "Blocked", 
    Dropped = "Dropped", 
    Failed = "Failed", 
}

export class RecepientInfo implements IRecepientInfo {
    recipient!: string | undefined;
    deliveryStatus!: CommunicationMessageDeliveryStatus | undefined;
    deliveryDate!: moment.Moment | undefined;
    openDate!: moment.Moment | undefined;

    constructor(data?: IRecepientInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"];
            this.deliveryStatus = data["deliveryStatus"];
            this.deliveryDate = data["deliveryDate"] ? moment(data["deliveryDate"].toString()) : <any>undefined;
            this.openDate = data["openDate"] ? moment(data["openDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecepientInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RecepientInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient;
        data["deliveryStatus"] = this.deliveryStatus;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["openDate"] = this.openDate ? this.openDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecepientInfo {
    recipient: string | undefined;
    deliveryStatus: CommunicationMessageDeliveryStatus | undefined;
    deliveryDate: moment.Moment | undefined;
    openDate: moment.Moment | undefined;
}

export class MessageDto implements IMessageDto {
    body!: string | undefined;
    attachments!: AttachmentDto[] | undefined;
    parentId!: number | undefined;
    fromUserId!: number | undefined;
    fromUserName!: string | undefined;
    fromUserContactPhotoPublicId!: string | undefined;
    from!: string | undefined;
    to!: string | undefined;
    replyTo!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    creationTime!: moment.Moment | undefined;
    deliveryType!: CommunicationMessageDeliveryType | undefined;
    status!: CommunicationMessageSendingStatus | undefined;
    recepients!: RecepientInfo[] | undefined;
    hasChildren!: boolean | undefined;
    hasAttachments!: boolean | undefined;
    isInbound!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            if (data["attachments"] && data["attachments"].constructor === Array) {
                this.attachments = [];
                for (let item of data["attachments"])
                    this.attachments.push(AttachmentDto.fromJS(item));
            }
            this.parentId = data["parentId"];
            this.fromUserId = data["fromUserId"];
            this.fromUserName = data["fromUserName"];
            this.fromUserContactPhotoPublicId = data["fromUserContactPhotoPublicId"];
            this.from = data["from"];
            this.to = data["to"];
            this.replyTo = data["replyTo"];
            this.cc = data["cc"];
            this.bcc = data["bcc"];
            this.subject = data["subject"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.deliveryType = data["deliveryType"];
            this.status = data["status"];
            if (data["recepients"] && data["recepients"].constructor === Array) {
                this.recepients = [];
                for (let item of data["recepients"])
                    this.recepients.push(RecepientInfo.fromJS(item));
            }
            this.hasChildren = data["hasChildren"];
            this.hasAttachments = data["hasAttachments"];
            this.isInbound = data["isInbound"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        if (this.attachments && this.attachments.constructor === Array) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["fromUserId"] = this.fromUserId;
        data["fromUserName"] = this.fromUserName;
        data["fromUserContactPhotoPublicId"] = this.fromUserContactPhotoPublicId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["replyTo"] = this.replyTo;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["deliveryType"] = this.deliveryType;
        data["status"] = this.status;
        if (this.recepients && this.recepients.constructor === Array) {
            data["recepients"] = [];
            for (let item of this.recepients)
                data["recepients"].push(item.toJSON());
        }
        data["hasChildren"] = this.hasChildren;
        data["hasAttachments"] = this.hasAttachments;
        data["isInbound"] = this.isInbound;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMessageDto {
    body: string | undefined;
    attachments: AttachmentDto[] | undefined;
    parentId: number | undefined;
    fromUserId: number | undefined;
    fromUserName: string | undefined;
    fromUserContactPhotoPublicId: string | undefined;
    from: string | undefined;
    to: string | undefined;
    replyTo: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    creationTime: moment.Moment | undefined;
    deliveryType: CommunicationMessageDeliveryType | undefined;
    status: CommunicationMessageSendingStatus | undefined;
    recepients: RecepientInfo[] | undefined;
    hasChildren: boolean | undefined;
    hasAttachments: boolean | undefined;
    isInbound: boolean | undefined;
    id: number | undefined;
}

export class MessageListDto implements IMessageListDto {
    parentId!: number | undefined;
    fromUserId!: number | undefined;
    fromUserName!: string | undefined;
    fromUserContactPhotoPublicId!: string | undefined;
    from!: string | undefined;
    to!: string | undefined;
    replyTo!: string | undefined;
    cc!: string | undefined;
    bcc!: string | undefined;
    subject!: string | undefined;
    creationTime!: moment.Moment | undefined;
    deliveryType!: CommunicationMessageDeliveryType | undefined;
    status!: CommunicationMessageSendingStatus | undefined;
    recepients!: RecepientInfo[] | undefined;
    hasChildren!: boolean | undefined;
    hasAttachments!: boolean | undefined;
    isInbound!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IMessageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.fromUserId = data["fromUserId"];
            this.fromUserName = data["fromUserName"];
            this.fromUserContactPhotoPublicId = data["fromUserContactPhotoPublicId"];
            this.from = data["from"];
            this.to = data["to"];
            this.replyTo = data["replyTo"];
            this.cc = data["cc"];
            this.bcc = data["bcc"];
            this.subject = data["subject"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.deliveryType = data["deliveryType"];
            this.status = data["status"];
            if (data["recepients"] && data["recepients"].constructor === Array) {
                this.recepients = [];
                for (let item of data["recepients"])
                    this.recepients.push(RecepientInfo.fromJS(item));
            }
            this.hasChildren = data["hasChildren"];
            this.hasAttachments = data["hasAttachments"];
            this.isInbound = data["isInbound"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MessageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["fromUserId"] = this.fromUserId;
        data["fromUserName"] = this.fromUserName;
        data["fromUserContactPhotoPublicId"] = this.fromUserContactPhotoPublicId;
        data["from"] = this.from;
        data["to"] = this.to;
        data["replyTo"] = this.replyTo;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["deliveryType"] = this.deliveryType;
        data["status"] = this.status;
        if (this.recepients && this.recepients.constructor === Array) {
            data["recepients"] = [];
            for (let item of this.recepients)
                data["recepients"].push(item.toJSON());
        }
        data["hasChildren"] = this.hasChildren;
        data["hasAttachments"] = this.hasAttachments;
        data["isInbound"] = this.isInbound;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMessageListDto {
    parentId: number | undefined;
    fromUserId: number | undefined;
    fromUserName: string | undefined;
    fromUserContactPhotoPublicId: string | undefined;
    from: string | undefined;
    to: string | undefined;
    replyTo: string | undefined;
    cc: string | undefined;
    bcc: string | undefined;
    subject: string | undefined;
    creationTime: moment.Moment | undefined;
    deliveryType: CommunicationMessageDeliveryType | undefined;
    status: CommunicationMessageSendingStatus | undefined;
    recepients: RecepientInfo[] | undefined;
    hasChildren: boolean | undefined;
    hasAttachments: boolean | undefined;
    isInbound: boolean | undefined;
    id: number | undefined;
}

export class MessageListDtoPagedResultDto implements IMessageListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: MessageListDto[] | undefined;

    constructor(data?: IMessageListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MessageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MessageListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMessageListDtoPagedResultDto {
    totalCount: number | undefined;
    items: MessageListDto[] | undefined;
}

export enum EmailSettingsSource {
    Tenant = "Tenant", 
    User = "User", 
}

export class EmailFromInfo implements IEmailFromInfo {
    emailSettingsSource!: EmailSettingsSource | undefined;
    emailAddress!: string | undefined;
    ccEmailAddress!: string | undefined;

    constructor(data?: IEmailFromInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailSettingsSource = data["emailSettingsSource"];
            this.emailAddress = data["emailAddress"];
            this.ccEmailAddress = data["ccEmailAddress"];
        }
    }

    static fromJS(data: any): EmailFromInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EmailFromInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailSettingsSource"] = this.emailSettingsSource;
        data["emailAddress"] = this.emailAddress;
        data["ccEmailAddress"] = this.ccEmailAddress;
        return data; 
    }
}

export interface IEmailFromInfo {
    emailSettingsSource: EmailSettingsSource | undefined;
    emailAddress: string | undefined;
    ccEmailAddress: string | undefined;
}

export class Attachment implements IAttachment {
    id!: string | undefined;
    size!: number | undefined;
    name!: string | undefined;
    url!: string | undefined;

    constructor(data?: IAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.size = data["size"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["size"] = this.size;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAttachment {
    id: string | undefined;
    size: number | undefined;
    name: string | undefined;
    url: string | undefined;
}

export class GetEmailDataOutput implements IGetEmailDataOutput {
    from!: EmailFromInfo[] | undefined;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string | undefined;
    attachments!: Attachment[] | undefined;
    tags!: { [key: string] : string; } | undefined;

    constructor(data?: IGetEmailDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["from"] && data["from"].constructor === Array) {
                this.from = [];
                for (let item of data["from"])
                    this.from.push(EmailFromInfo.fromJS(item));
            }
            this.subject = data["subject"];
            if (data["cc"] && data["cc"].constructor === Array) {
                this.cc = [];
                for (let item of data["cc"])
                    this.cc.push(item);
            }
            if (data["bcc"] && data["bcc"].constructor === Array) {
                this.bcc = [];
                for (let item of data["bcc"])
                    this.bcc.push(item);
            }
            this.body = data["body"];
            if (data["attachments"] && data["attachments"].constructor === Array) {
                this.attachments = [];
                for (let item of data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
            if (data["tags"]) {
                this.tags = {};
                for (let key in data["tags"]) {
                    if (data["tags"].hasOwnProperty(key))
                        this.tags[key] = data["tags"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetEmailDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.from && this.from.constructor === Array) {
            data["from"] = [];
            for (let item of this.from)
                data["from"].push(item.toJSON());
        }
        data["subject"] = this.subject;
        if (this.cc && this.cc.constructor === Array) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (this.bcc && this.bcc.constructor === Array) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        if (this.attachments && this.attachments.constructor === Array) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (this.tags) {
            data["tags"] = {};
            for (let key in this.tags) {
                if (this.tags.hasOwnProperty(key))
                    data["tags"][key] = this.tags[key];
            }
        }
        return data; 
    }
}

export interface IGetEmailDataOutput {
    from: EmailFromInfo[] | undefined;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string | undefined;
    attachments: Attachment[] | undefined;
    tags: { [key: string] : string; } | undefined;
}

export class FileInfo implements IFileInfo {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IFileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): FileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IFileInfo {
    id: string | undefined;
    name: string | undefined;
}

export class SendEmailInput implements ISendEmailInput {
    contactId!: number;
    replyToId!: number | undefined;
    emailSettingsSource!: EmailSettingsSource;
    to!: string[];
    replyTo!: string[] | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    subject!: string;
    body!: string;
    saveAttachmentsToDocuments!: boolean | undefined;
    attachments!: FileInfo[] | undefined;

    constructor(data?: ISendEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.to = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.replyToId = data["replyToId"];
            this.emailSettingsSource = data["emailSettingsSource"];
            if (data["to"] && data["to"].constructor === Array) {
                this.to = [];
                for (let item of data["to"])
                    this.to.push(item);
            }
            if (data["replyTo"] && data["replyTo"].constructor === Array) {
                this.replyTo = [];
                for (let item of data["replyTo"])
                    this.replyTo.push(item);
            }
            if (data["cc"] && data["cc"].constructor === Array) {
                this.cc = [];
                for (let item of data["cc"])
                    this.cc.push(item);
            }
            if (data["bcc"] && data["bcc"].constructor === Array) {
                this.bcc = [];
                for (let item of data["bcc"])
                    this.bcc.push(item);
            }
            this.subject = data["subject"];
            this.body = data["body"];
            this.saveAttachmentsToDocuments = data["saveAttachmentsToDocuments"];
            if (data["attachments"] && data["attachments"].constructor === Array) {
                this.attachments = [];
                for (let item of data["attachments"])
                    this.attachments.push(FileInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["replyToId"] = this.replyToId;
        data["emailSettingsSource"] = this.emailSettingsSource;
        if (this.to && this.to.constructor === Array) {
            data["to"] = [];
            for (let item of this.to)
                data["to"].push(item);
        }
        if (this.replyTo && this.replyTo.constructor === Array) {
            data["replyTo"] = [];
            for (let item of this.replyTo)
                data["replyTo"].push(item);
        }
        if (this.cc && this.cc.constructor === Array) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (this.bcc && this.bcc.constructor === Array) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["saveAttachmentsToDocuments"] = this.saveAttachmentsToDocuments;
        if (this.attachments && this.attachments.constructor === Array) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISendEmailInput {
    contactId: number;
    replyToId: number | undefined;
    emailSettingsSource: EmailSettingsSource;
    to: string[];
    replyTo: string[] | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    subject: string;
    body: string;
    saveAttachmentsToDocuments: boolean | undefined;
    attachments: FileInfo[] | undefined;
}

export class SendSMSInput implements ISendSMSInput {
    contactId!: number;
    parentId!: number | undefined;
    phoneNumber!: string;
    message!: string | undefined;

    constructor(data?: ISendSMSInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.parentId = data["parentId"];
            this.phoneNumber = data["phoneNumber"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): SendSMSInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendSMSInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["parentId"] = this.parentId;
        data["phoneNumber"] = this.phoneNumber;
        data["message"] = this.message;
        return data; 
    }
}

export interface ISendSMSInput {
    contactId: number;
    parentId: number | undefined;
    phoneNumber: string;
    message: string | undefined;
}

export class CreateContactEmailInput implements ICreateContactEmailInput {
    contactId!: number | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactEmailInput {
    contactId: number | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactEmailOutput implements ICreateContactEmailOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactEmailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactEmailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactEmailOutput {
    id: number | undefined;
}

export class UpdateContactEmailInput implements IUpdateContactEmailInput {
    id!: number;
    contactId!: number | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactEmailInput {
    id: number;
    contactId: number | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class EmailUsageTypeDto implements IEmailUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): EmailUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IEmailUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class EmailUsageTypeDtoListResultDto implements IEmailUsageTypeDtoListResultDto {
    items!: EmailUsageTypeDto[] | undefined;

    constructor(data?: IEmailUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EmailUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmailUsageTypeDtoListResultDto {
    items: EmailUsageTypeDto[] | undefined;
}

export class CreateContactLinkInput implements ICreateContactLinkInput {
    contactId!: number | undefined;
    isConfirmed!: boolean | undefined;
    isCompany!: boolean | undefined;
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.isConfirmed = data["isConfirmed"];
            this.isCompany = data["isCompany"];
            this.url = data["url"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface ICreateContactLinkInput {
    contactId: number | undefined;
    isConfirmed: boolean | undefined;
    isCompany: boolean | undefined;
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class CreateContactLinkOutput implements ICreateContactLinkOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactLinkOutput {
    id: number | undefined;
}

export class UpdateContactLinkInput implements IUpdateContactLinkInput {
    id!: number;
    contactId!: number | undefined;
    isConfirmed!: boolean | undefined;
    isCompany!: boolean | undefined;
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: IUpdateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.isConfirmed = data["isConfirmed"];
            this.isCompany = data["isCompany"];
            this.url = data["url"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["isConfirmed"] = this.isConfirmed;
        data["isCompany"] = this.isCompany;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface IUpdateContactLinkInput {
    id: number;
    contactId: number | undefined;
    isConfirmed: boolean | undefined;
    isCompany: boolean | undefined;
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class ContactLinkTypeDto implements IContactLinkTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isSocialNetwork!: boolean | undefined;

    constructor(data?: IContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isSocialNetwork = data["isSocialNetwork"];
        }
    }

    static fromJS(data: any): ContactLinkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSocialNetwork"] = this.isSocialNetwork;
        return data; 
    }
}

export interface IContactLinkTypeDto {
    id: string | undefined;
    name: string | undefined;
    isSocialNetwork: boolean | undefined;
}

export class ContactLinkTypeDtoListResultDto implements IContactLinkTypeDtoListResultDto {
    items!: ContactLinkTypeDto[] | undefined;

    constructor(data?: IContactLinkTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactLinkTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactLinkTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactLinkTypeDtoListResultDto {
    items: ContactLinkTypeDto[] | undefined;
}

export class UpdateContactListsInput implements IUpdateContactListsInput {
    contactId!: number;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IUpdateContactListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateContactListsInput {
    contactId: number;
    lists: ContactListInput[] | undefined;
}

export class AddContactsToListsInput implements IAddContactsToListsInput {
    contactIds!: number[] | undefined;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IAddContactsToListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddContactsToListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactsToListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddContactsToListsInput {
    contactIds: number[] | undefined;
    lists: ContactListInput[] | undefined;
}

export class UpdateContactListInput implements IUpdateContactListInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateContactListInput {
    id: number;
    name: string;
}

export class CreateContactPhoneInput implements ICreateContactPhoneInput {
    contactId!: number | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactPhoneInput {
    contactId: number | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactPhoneOutput implements ICreateContactPhoneOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactPhoneOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactPhoneOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactPhoneOutput {
    id: number | undefined;
}

export class UpdateContactPhoneInput implements IUpdateContactPhoneInput {
    id!: number;
    contactId!: number | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactPhoneInput {
    id: number;
    contactId: number | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class PhoneUsageTypeDto implements IPhoneUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): PhoneUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IPhoneUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class PhoneUsageTypeDtoListResultDto implements IPhoneUsageTypeDtoListResultDto {
    items!: PhoneUsageTypeDto[] | undefined;

    constructor(data?: IPhoneUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhoneUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhoneUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPhoneUsageTypeDtoListResultDto {
    items: PhoneUsageTypeDto[] | undefined;
}

export class CreateContactPhotoInput implements ICreateContactPhotoInput {
    contactId!: number;
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateContactPhotoInput {
    contactId: number;
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class ContactRatingInfoDto implements IContactRatingInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactRatingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactRatingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRatingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactRatingInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class RateContactInput implements IRateContactInput {
    contactId!: number;
    ratingId!: number | undefined;

    constructor(data?: IRateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.ratingId = data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["ratingId"] = this.ratingId;
        return data; 
    }
}

export interface IRateContactInput {
    contactId: number;
    ratingId: number | undefined;
}

export class RateContactsInput implements IRateContactsInput {
    contactIds!: number[] | undefined;
    ratingId!: number | undefined;

    constructor(data?: IRateContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.ratingId = data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["ratingId"] = this.ratingId;
        return data; 
    }
}

export interface IRateContactsInput {
    contactIds: number[] | undefined;
    ratingId: number | undefined;
}

export class MarkContactInput implements IMarkContactInput {
    contactId!: number;
    starId!: number | undefined;

    constructor(data?: IMarkContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.starId = data["starId"];
        }
    }

    static fromJS(data: any): MarkContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["starId"] = this.starId;
        return data; 
    }
}

export interface IMarkContactInput {
    contactId: number;
    starId: number | undefined;
}

export class MarkContactsInput implements IMarkContactsInput {
    contactIds!: number[] | undefined;
    starId!: number | undefined;

    constructor(data?: IMarkContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.starId = data["starId"];
        }
    }

    static fromJS(data: any): MarkContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["starId"] = this.starId;
        return data; 
    }
}

export interface IMarkContactsInput {
    contactIds: number[] | undefined;
    starId: number | undefined;
}

export class UpdateContactTagsInput implements IUpdateContactTagsInput {
    contactId!: number;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: IUpdateContactTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateContactTagsInput {
    contactId: number;
    tags: ContactTagInput[] | undefined;
}

export class TagContactsInput implements ITagContactsInput {
    contactIds!: number[] | undefined;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: ITagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new TagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagContactsInput {
    contactIds: number[] | undefined;
    tags: ContactTagInput[] | undefined;
}

export class UntagContactsInput implements IUntagContactsInput {
    contactIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUntagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["tagIds"] && data["tagIds"].constructor === Array) {
                this.tagIds = [];
                for (let item of data["tagIds"])
                    this.tagIds.push(item);
            }
        }
    }

    static fromJS(data: any): UntagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UntagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.tagIds && this.tagIds.constructor === Array) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUntagContactsInput {
    contactIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateContactTagInput implements IUpdateContactTagInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateContactTagInput {
    id: number;
    name: string;
}

export class CountryDto implements ICountryDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryDto {
    code: string | undefined;
    name: string | undefined;
}

export class CountryStateDto implements ICountryStateDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryStateDto {
    code: string | undefined;
    name: string | undefined;
}

export enum Bureau {
    TransUnion = "TransUnion", 
    Experian = "Experian", 
    Equifax = "Equifax", 
}

export enum CreditScoreRank {
    Poor = "Poor", 
    Fair = "Fair", 
    Good = "Good", 
    Excellent = "Excellent", 
}

export class CreditScoreDto implements ICreditScoreDto {
    score!: number | undefined;
    scoreRank!: CreditScoreRank | undefined;
    populationRank!: number | undefined;
    qualitativeRank!: number | undefined;
    scoreDate!: moment.Moment | undefined;
    nextUpdate!: number | undefined;

    constructor(data?: ICreditScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.score = data["score"];
            this.scoreRank = data["scoreRank"];
            this.populationRank = data["populationRank"];
            this.qualitativeRank = data["qualitativeRank"];
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.nextUpdate = data["nextUpdate"];
        }
    }

    static fromJS(data: any): CreditScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["scoreRank"] = this.scoreRank;
        data["populationRank"] = this.populationRank;
        data["qualitativeRank"] = this.qualitativeRank;
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["nextUpdate"] = this.nextUpdate;
        return data; 
    }
}

export interface ICreditScoreDto {
    score: number | undefined;
    scoreRank: CreditScoreRank | undefined;
    populationRank: number | undefined;
    qualitativeRank: number | undefined;
    scoreDate: moment.Moment | undefined;
    nextUpdate: number | undefined;
}

export class CreditSummaryDto implements ICreditSummaryDto {
    totalAccounts!: number | undefined;
    openAccounts!: number | undefined;
    closedAccounts!: number | undefined;
    deliquent!: number | undefined;
    derogatory!: number | undefined;
    balances!: number | undefined;
    payments!: number | undefined;
    publicRecords!: number | undefined;
    inquiries2Years!: number | undefined;

    constructor(data?: ICreditSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalAccounts = data["totalAccounts"];
            this.openAccounts = data["openAccounts"];
            this.closedAccounts = data["closedAccounts"];
            this.deliquent = data["deliquent"];
            this.derogatory = data["derogatory"];
            this.balances = data["balances"];
            this.payments = data["payments"];
            this.publicRecords = data["publicRecords"];
            this.inquiries2Years = data["inquiries2Years"];
        }
    }

    static fromJS(data: any): CreditSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAccounts"] = this.totalAccounts;
        data["openAccounts"] = this.openAccounts;
        data["closedAccounts"] = this.closedAccounts;
        data["deliquent"] = this.deliquent;
        data["derogatory"] = this.derogatory;
        data["balances"] = this.balances;
        data["payments"] = this.payments;
        data["publicRecords"] = this.publicRecords;
        data["inquiries2Years"] = this.inquiries2Years;
        return data; 
    }
}

export interface ICreditSummaryDto {
    totalAccounts: number | undefined;
    openAccounts: number | undefined;
    closedAccounts: number | undefined;
    deliquent: number | undefined;
    derogatory: number | undefined;
    balances: number | undefined;
    payments: number | undefined;
    publicRecords: number | undefined;
    inquiries2Years: number | undefined;
}

export class AddressDto implements IAddressDto {
    line1!: string | undefined;
    line2!: string | undefined;
    line3!: string | undefined;
    line4!: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.line3 = data["line3"];
            this.line4 = data["line4"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        return data; 
    }
}

export interface IAddressDto {
    line1: string | undefined;
    line2: string | undefined;
    line3: string | undefined;
    line4: string | undefined;
}

export class EmployerDto implements IEmployerDto {
    name!: string | undefined;
    date!: moment.Moment | undefined;
    type!: string | undefined;

    constructor(data?: IEmployerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): EmployerDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEmployerDto {
    name: string | undefined;
    date: moment.Moment | undefined;
    type: string | undefined;
}

export class PersonalInfoDto implements IPersonalInfoDto {
    name!: string | undefined;
    doB!: moment.Moment | undefined;
    currentAddress!: AddressDto | undefined;
    previousAddresses!: AddressDto[] | undefined;
    employers!: EmployerDto[] | undefined;

    constructor(data?: IPersonalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.currentAddress = data["currentAddress"] ? AddressDto.fromJS(data["currentAddress"]) : <any>undefined;
            if (data["previousAddresses"] && data["previousAddresses"].constructor === Array) {
                this.previousAddresses = [];
                for (let item of data["previousAddresses"])
                    this.previousAddresses.push(AddressDto.fromJS(item));
            }
            if (data["employers"] && data["employers"].constructor === Array) {
                this.employers = [];
                for (let item of data["employers"])
                    this.employers.push(EmployerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["currentAddress"] = this.currentAddress ? this.currentAddress.toJSON() : <any>undefined;
        if (this.previousAddresses && this.previousAddresses.constructor === Array) {
            data["previousAddresses"] = [];
            for (let item of this.previousAddresses)
                data["previousAddresses"].push(item.toJSON());
        }
        if (this.employers && this.employers.constructor === Array) {
            data["employers"] = [];
            for (let item of this.employers)
                data["employers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalInfoDto {
    name: string | undefined;
    doB: moment.Moment | undefined;
    currentAddress: AddressDto | undefined;
    previousAddresses: AddressDto[] | undefined;
    employers: EmployerDto[] | undefined;
}

export class InquiryDto implements IInquiryDto {
    creditorName!: string | undefined;
    industry!: string | undefined;
    dateOfInquiry!: moment.Moment | undefined;

    constructor(data?: IInquiryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditorName = data["creditorName"];
            this.industry = data["industry"];
            this.dateOfInquiry = data["dateOfInquiry"] ? moment(data["dateOfInquiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InquiryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquiryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditorName"] = this.creditorName;
        data["industry"] = this.industry;
        data["dateOfInquiry"] = this.dateOfInquiry ? this.dateOfInquiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IInquiryDto {
    creditorName: string | undefined;
    industry: string | undefined;
    dateOfInquiry: moment.Moment | undefined;
}

export class ScoreFactorDto implements IScoreFactorDto {
    isPositive!: boolean | undefined;
    text!: string | undefined;

    constructor(data?: IScoreFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isPositive = data["isPositive"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): ScoreFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPositive"] = this.isPositive;
        data["text"] = this.text;
        return data; 
    }
}

export interface IScoreFactorDto {
    isPositive: boolean | undefined;
    text: string | undefined;
}

export class CreditBureauReportDto implements ICreditBureauReportDto {
    bureau!: Bureau | undefined;
    creditScore!: CreditScoreDto | undefined;
    creditSummary!: CreditSummaryDto | undefined;
    personalInfo!: PersonalInfoDto | undefined;
    inquiries!: InquiryDto[] | undefined;
    scoreFactors!: ScoreFactorDto[] | undefined;

    constructor(data?: ICreditBureauReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.creditScore = data["creditScore"] ? CreditScoreDto.fromJS(data["creditScore"]) : <any>undefined;
            this.creditSummary = data["creditSummary"] ? CreditSummaryDto.fromJS(data["creditSummary"]) : <any>undefined;
            this.personalInfo = data["personalInfo"] ? PersonalInfoDto.fromJS(data["personalInfo"]) : <any>undefined;
            if (data["inquiries"] && data["inquiries"].constructor === Array) {
                this.inquiries = [];
                for (let item of data["inquiries"])
                    this.inquiries.push(InquiryDto.fromJS(item));
            }
            if (data["scoreFactors"] && data["scoreFactors"].constructor === Array) {
                this.scoreFactors = [];
                for (let item of data["scoreFactors"])
                    this.scoreFactors.push(ScoreFactorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditBureauReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditBureauReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["creditScore"] = this.creditScore ? this.creditScore.toJSON() : <any>undefined;
        data["creditSummary"] = this.creditSummary ? this.creditSummary.toJSON() : <any>undefined;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        if (this.inquiries && this.inquiries.constructor === Array) {
            data["inquiries"] = [];
            for (let item of this.inquiries)
                data["inquiries"].push(item.toJSON());
        }
        if (this.scoreFactors && this.scoreFactors.constructor === Array) {
            data["scoreFactors"] = [];
            for (let item of this.scoreFactors)
                data["scoreFactors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditBureauReportDto {
    bureau: Bureau | undefined;
    creditScore: CreditScoreDto | undefined;
    creditSummary: CreditSummaryDto | undefined;
    personalInfo: PersonalInfoDto | undefined;
    inquiries: InquiryDto[] | undefined;
    scoreFactors: ScoreFactorDto[] | undefined;
}

export enum AccountState {
    _0 = 0, 
    _1 = 1, 
}

export enum AccountStatus {
    _0 = 0, 
    _1 = 1, 
}

export enum AccountCreditHistoryStatusDto {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
}

export class AccountCreditHistoryDto implements IAccountCreditHistoryDto {
    year!: number | undefined;
    month!: number | undefined;
    status!: string | undefined;
    isPositiveStatus!: boolean | undefined;
    statusType!: AccountCreditHistoryStatusDto | undefined;

    constructor(data?: IAccountCreditHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.year = data["year"];
            this.month = data["month"];
            this.status = data["status"];
            this.isPositiveStatus = data["isPositiveStatus"];
            this.statusType = data["statusType"];
        }
    }

    static fromJS(data: any): AccountCreditHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCreditHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["status"] = this.status;
        data["isPositiveStatus"] = this.isPositiveStatus;
        data["statusType"] = this.statusType;
        return data; 
    }
}

export interface IAccountCreditHistoryDto {
    year: number | undefined;
    month: number | undefined;
    status: string | undefined;
    isPositiveStatus: boolean | undefined;
    statusType: AccountCreditHistoryStatusDto | undefined;
}

export class AccountInfoDto implements IAccountInfoDto {
    bureau!: Bureau | undefined;
    status!: AccountStatus | undefined;
    totalCreditLimit!: number | undefined;
    availableCredit!: number | undefined;
    creditUtilization!: number | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    balance!: number | undefined;
    pastDue!: number | undefined;
    dateOpened!: moment.Moment | undefined;
    moPayment!: number | undefined;
    paymentStatus!: string | undefined;
    terms!: string | undefined;
    comment!: string | undefined;
    maxAccountHistoryDate!: moment.Moment | undefined;
    twoYearHistory!: AccountCreditHistoryDto[] | undefined;

    constructor(data?: IAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.status = data["status"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.availableCredit = data["availableCredit"];
            this.creditUtilization = data["creditUtilization"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.balance = data["balance"];
            this.pastDue = data["pastDue"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.moPayment = data["moPayment"];
            this.paymentStatus = data["paymentStatus"];
            this.terms = data["terms"];
            this.comment = data["comment"];
            this.maxAccountHistoryDate = data["maxAccountHistoryDate"] ? moment(data["maxAccountHistoryDate"].toString()) : <any>undefined;
            if (data["twoYearHistory"] && data["twoYearHistory"].constructor === Array) {
                this.twoYearHistory = [];
                for (let item of data["twoYearHistory"])
                    this.twoYearHistory.push(AccountCreditHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["status"] = this.status;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["availableCredit"] = this.availableCredit;
        data["creditUtilization"] = this.creditUtilization;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["balance"] = this.balance;
        data["pastDue"] = this.pastDue;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["moPayment"] = this.moPayment;
        data["paymentStatus"] = this.paymentStatus;
        data["terms"] = this.terms;
        data["comment"] = this.comment;
        data["maxAccountHistoryDate"] = this.maxAccountHistoryDate ? this.maxAccountHistoryDate.toISOString() : <any>undefined;
        if (this.twoYearHistory && this.twoYearHistory.constructor === Array) {
            data["twoYearHistory"] = [];
            for (let item of this.twoYearHistory)
                data["twoYearHistory"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountInfoDto {
    bureau: Bureau | undefined;
    status: AccountStatus | undefined;
    totalCreditLimit: number | undefined;
    availableCredit: number | undefined;
    creditUtilization: number | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    balance: number | undefined;
    pastDue: number | undefined;
    dateOpened: moment.Moment | undefined;
    moPayment: number | undefined;
    paymentStatus: string | undefined;
    terms: string | undefined;
    comment: string | undefined;
    maxAccountHistoryDate: moment.Moment | undefined;
    twoYearHistory: AccountCreditHistoryDto[] | undefined;
}

export class AccountDto implements IAccountDto {
    accountIds!: number[] | undefined;
    accountName!: string | undefined;
    state!: AccountState | undefined;
    creditLimit!: number | undefined;
    availableCredit!: number | undefined;
    outstandingBalance!: number | undefined;
    ratio!: number | undefined;
    dateOpened!: moment.Moment | undefined;
    accountDetails!: AccountInfoDto[] | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            this.accountName = data["accountName"];
            this.state = data["state"];
            this.creditLimit = data["creditLimit"];
            this.availableCredit = data["availableCredit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.ratio = data["ratio"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            if (data["accountDetails"] && data["accountDetails"].constructor === Array) {
                this.accountDetails = [];
                for (let item of data["accountDetails"])
                    this.accountDetails.push(AccountInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["creditLimit"] = this.creditLimit;
        data["availableCredit"] = this.availableCredit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["ratio"] = this.ratio;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        if (this.accountDetails && this.accountDetails.constructor === Array) {
            data["accountDetails"] = [];
            for (let item of this.accountDetails)
                data["accountDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountDto {
    accountIds: number[] | undefined;
    accountName: string | undefined;
    state: AccountState | undefined;
    creditLimit: number | undefined;
    availableCredit: number | undefined;
    outstandingBalance: number | undefined;
    ratio: number | undefined;
    dateOpened: moment.Moment | undefined;
    accountDetails: AccountInfoDto[] | undefined;
}

export enum AlertType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export class AlertDto implements IAlertDto {
    type!: AlertType | undefined;
    bureau!: Bureau | undefined;
    date!: moment.Moment | undefined;
    text!: string | undefined;

    constructor(data?: IAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.text = data["text"];
        }
    }

    static fromJS(data: any): AlertDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data; 
    }
}

export interface IAlertDto {
    type: AlertType | undefined;
    bureau: Bureau | undefined;
    date: moment.Moment | undefined;
    text: string | undefined;
}

export class RecommendationDto implements IRecommendationDto {
    header!: string | undefined;
    text!: string | undefined;
    isPositive!: boolean | undefined;

    constructor(data?: IRecommendationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.header = data["header"];
            this.text = data["text"];
            this.isPositive = data["isPositive"];
        }
    }

    static fromJS(data: any): RecommendationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["text"] = this.text;
        data["isPositive"] = this.isPositive;
        return data; 
    }
}

export interface IRecommendationDto {
    header: string | undefined;
    text: string | undefined;
    isPositive: boolean | undefined;
}

export class CreditorContactDto implements ICreditorContactDto {
    name!: string | undefined;
    address!: AddressDto | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: ICreditorContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"] ? AddressDto.fromJS(data["address"]) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreditorContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditorContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ICreditorContactDto {
    name: string | undefined;
    address: AddressDto | undefined;
    phoneNumber: string | undefined;
}

export class ConsumerStatementDto implements IConsumerStatementDto {
    bureau!: Bureau | undefined;
    date!: moment.Moment | undefined;
    statement!: string | undefined;

    constructor(data?: IConsumerStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.statement = data["statement"];
        }
    }

    static fromJS(data: any): ConsumerStatementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerStatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statement"] = this.statement;
        return data; 
    }
}

export interface IConsumerStatementDto {
    bureau: Bureau | undefined;
    date: moment.Moment | undefined;
    statement: string | undefined;
}

export class PublicRecordBureauInfoDto implements IPublicRecordBureauInfoDto {
    bureau!: Bureau | undefined;
    title!: string | undefined;
    type!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateFiledOrReported!: moment.Moment | undefined;
    referenceNo!: string | undefined;
    court!: string | undefined;
    dateVerified!: moment.Moment | undefined;
    dateUpdated!: moment.Moment | undefined;
    dateReleased!: moment.Moment | undefined;
    remarks!: string | undefined;

    constructor(data?: IPublicRecordBureauInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.title = data["title"];
            this.type = data["type"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateFiledOrReported = data["dateFiledOrReported"] ? moment(data["dateFiledOrReported"].toString()) : <any>undefined;
            this.referenceNo = data["referenceNo"];
            this.court = data["court"];
            this.dateVerified = data["dateVerified"] ? moment(data["dateVerified"].toString()) : <any>undefined;
            this.dateUpdated = data["dateUpdated"] ? moment(data["dateUpdated"].toString()) : <any>undefined;
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
        }
    }

    static fromJS(data: any): PublicRecordBureauInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordBureauInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["title"] = this.title;
        data["type"] = this.type;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateFiledOrReported"] = this.dateFiledOrReported ? this.dateFiledOrReported.toISOString() : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["court"] = this.court;
        data["dateVerified"] = this.dateVerified ? this.dateVerified.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface IPublicRecordBureauInfoDto {
    bureau: Bureau | undefined;
    title: string | undefined;
    type: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateFiledOrReported: moment.Moment | undefined;
    referenceNo: string | undefined;
    court: string | undefined;
    dateVerified: moment.Moment | undefined;
    dateUpdated: moment.Moment | undefined;
    dateReleased: moment.Moment | undefined;
    remarks: string | undefined;
}

export class PublicRecordDto implements IPublicRecordDto {
    title!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateReleased!: moment.Moment | undefined;
    publicRecordDetails!: PublicRecordBureauInfoDto[] | undefined;

    constructor(data?: IPublicRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            if (data["publicRecordDetails"] && data["publicRecordDetails"].constructor === Array) {
                this.publicRecordDetails = [];
                for (let item of data["publicRecordDetails"])
                    this.publicRecordDetails.push(PublicRecordBureauInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublicRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        if (this.publicRecordDetails && this.publicRecordDetails.constructor === Array) {
            data["publicRecordDetails"] = [];
            for (let item of this.publicRecordDetails)
                data["publicRecordDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPublicRecordDto {
    title: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateReleased: moment.Moment | undefined;
    publicRecordDetails: PublicRecordBureauInfoDto[] | undefined;
}

export class CreditReportDto implements ICreditReportDto {
    creditReportId!: number | undefined;
    minScoreValue!: number | undefined;
    maxScoreValue!: number | undefined;
    bureauReports!: CreditBureauReportDto[] | undefined;
    accounts!: AccountDto[] | undefined;
    alerts!: AlertDto[] | undefined;
    recommendations!: RecommendationDto[] | undefined;
    creditorContacts!: CreditorContactDto[] | undefined;
    consumerStatements!: ConsumerStatementDto[] | undefined;
    publicInformation!: PublicRecordDto[] | undefined;

    constructor(data?: ICreditReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditReportId = data["creditReportId"];
            this.minScoreValue = data["minScoreValue"];
            this.maxScoreValue = data["maxScoreValue"];
            if (data["bureauReports"] && data["bureauReports"].constructor === Array) {
                this.bureauReports = [];
                for (let item of data["bureauReports"])
                    this.bureauReports.push(CreditBureauReportDto.fromJS(item));
            }
            if (data["accounts"] && data["accounts"].constructor === Array) {
                this.accounts = [];
                for (let item of data["accounts"])
                    this.accounts.push(AccountDto.fromJS(item));
            }
            if (data["alerts"] && data["alerts"].constructor === Array) {
                this.alerts = [];
                for (let item of data["alerts"])
                    this.alerts.push(AlertDto.fromJS(item));
            }
            if (data["recommendations"] && data["recommendations"].constructor === Array) {
                this.recommendations = [];
                for (let item of data["recommendations"])
                    this.recommendations.push(RecommendationDto.fromJS(item));
            }
            if (data["creditorContacts"] && data["creditorContacts"].constructor === Array) {
                this.creditorContacts = [];
                for (let item of data["creditorContacts"])
                    this.creditorContacts.push(CreditorContactDto.fromJS(item));
            }
            if (data["consumerStatements"] && data["consumerStatements"].constructor === Array) {
                this.consumerStatements = [];
                for (let item of data["consumerStatements"])
                    this.consumerStatements.push(ConsumerStatementDto.fromJS(item));
            }
            if (data["publicInformation"] && data["publicInformation"].constructor === Array) {
                this.publicInformation = [];
                for (let item of data["publicInformation"])
                    this.publicInformation.push(PublicRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditReportId"] = this.creditReportId;
        data["minScoreValue"] = this.minScoreValue;
        data["maxScoreValue"] = this.maxScoreValue;
        if (this.bureauReports && this.bureauReports.constructor === Array) {
            data["bureauReports"] = [];
            for (let item of this.bureauReports)
                data["bureauReports"].push(item.toJSON());
        }
        if (this.accounts && this.accounts.constructor === Array) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (this.alerts && this.alerts.constructor === Array) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        if (this.recommendations && this.recommendations.constructor === Array) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item.toJSON());
        }
        if (this.creditorContacts && this.creditorContacts.constructor === Array) {
            data["creditorContacts"] = [];
            for (let item of this.creditorContacts)
                data["creditorContacts"].push(item.toJSON());
        }
        if (this.consumerStatements && this.consumerStatements.constructor === Array) {
            data["consumerStatements"] = [];
            for (let item of this.consumerStatements)
                data["consumerStatements"].push(item.toJSON());
        }
        if (this.publicInformation && this.publicInformation.constructor === Array) {
            data["publicInformation"] = [];
            for (let item of this.publicInformation)
                data["publicInformation"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditReportDto {
    creditReportId: number | undefined;
    minScoreValue: number | undefined;
    maxScoreValue: number | undefined;
    bureauReports: CreditBureauReportDto[] | undefined;
    accounts: AccountDto[] | undefined;
    alerts: AlertDto[] | undefined;
    recommendations: RecommendationDto[] | undefined;
    creditorContacts: CreditorContactDto[] | undefined;
    consumerStatements: ConsumerStatementDto[] | undefined;
    publicInformation: PublicRecordDto[] | undefined;
}

export class CreditReportOutput implements ICreditReportOutput {
    memberExists!: boolean | undefined;
    uncompletedPackageId!: number | undefined;
    kbaPassed!: boolean | undefined;
    creditReport!: CreditReportDto | undefined;
    updatable!: boolean | undefined;
    isPaymentDelayed!: boolean | undefined;
    isSubscriptionCancelled!: boolean | undefined;
    previousReportExists!: boolean | undefined;
    refreshErrorMessage!: string | undefined;
    memberFullName!: string | undefined;
    providerCreatedDate!: moment.Moment | undefined;

    constructor(data?: ICreditReportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberExists = data["memberExists"];
            this.uncompletedPackageId = data["uncompletedPackageId"];
            this.kbaPassed = data["kbaPassed"];
            this.creditReport = data["creditReport"] ? CreditReportDto.fromJS(data["creditReport"]) : <any>undefined;
            this.updatable = data["updatable"];
            this.isPaymentDelayed = data["isPaymentDelayed"];
            this.isSubscriptionCancelled = data["isSubscriptionCancelled"];
            this.previousReportExists = data["previousReportExists"];
            this.refreshErrorMessage = data["refreshErrorMessage"];
            this.memberFullName = data["memberFullName"];
            this.providerCreatedDate = data["providerCreatedDate"] ? moment(data["providerCreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditReportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberExists"] = this.memberExists;
        data["uncompletedPackageId"] = this.uncompletedPackageId;
        data["kbaPassed"] = this.kbaPassed;
        data["creditReport"] = this.creditReport ? this.creditReport.toJSON() : <any>undefined;
        data["updatable"] = this.updatable;
        data["isPaymentDelayed"] = this.isPaymentDelayed;
        data["isSubscriptionCancelled"] = this.isSubscriptionCancelled;
        data["previousReportExists"] = this.previousReportExists;
        data["refreshErrorMessage"] = this.refreshErrorMessage;
        data["memberFullName"] = this.memberFullName;
        data["providerCreatedDate"] = this.providerCreatedDate ? this.providerCreatedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreditReportOutput {
    memberExists: boolean | undefined;
    uncompletedPackageId: number | undefined;
    kbaPassed: boolean | undefined;
    creditReport: CreditReportDto | undefined;
    updatable: boolean | undefined;
    isPaymentDelayed: boolean | undefined;
    isSubscriptionCancelled: boolean | undefined;
    previousReportExists: boolean | undefined;
    refreshErrorMessage: string | undefined;
    memberFullName: string | undefined;
    providerCreatedDate: moment.Moment | undefined;
}

export class ScoreHistoryDto implements IScoreHistoryDto {
    scoreDate!: moment.Moment | undefined;
    score!: number | undefined;

    constructor(data?: IScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.score = data["score"];
        }
    }

    static fromJS(data: any): ScoreHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["score"] = this.score;
        return data; 
    }
}

export interface IScoreHistoryDto {
    scoreDate: moment.Moment | undefined;
    score: number | undefined;
}

export class BureauScoreHistoryDtoListKeyValuePair implements IBureauScoreHistoryDtoListKeyValuePair {
    key!: Bureau | undefined;
    value!: ScoreHistoryDto[] | undefined;

    constructor(data?: IBureauScoreHistoryDtoListKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            if (data["value"] && data["value"].constructor === Array) {
                this.value = [];
                for (let item of data["value"])
                    this.value.push(ScoreHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BureauScoreHistoryDtoListKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new BureauScoreHistoryDtoListKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (this.value && this.value.constructor === Array) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBureauScoreHistoryDtoListKeyValuePair {
    key: Bureau | undefined;
    value: ScoreHistoryDto[] | undefined;
}

export enum MemberSimulatorAccessStatus {
    Ok = "Ok", 
    NoMember = "NoMember", 
    MemberIsCancelled = "MemberIsCancelled", 
    KbaIsNotPassed = "KbaIsNotPassed", 
    UnsupportedPackage = "UnsupportedPackage", 
    NoPayment = "NoPayment", 
}

export class ScoreSimulatorInfoDto implements IScoreSimulatorInfoDto {
    initialScore!: number | undefined;
    totalCreditLimit!: number | undefined;
    outstandingBalance!: number | undefined;
    isDemoPackage!: boolean | undefined;
    accessStatus!: MemberSimulatorAccessStatus | undefined;

    constructor(data?: IScoreSimulatorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.initialScore = data["initialScore"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.isDemoPackage = data["isDemoPackage"];
            this.accessStatus = data["accessStatus"];
        }
    }

    static fromJS(data: any): ScoreSimulatorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialScore"] = this.initialScore;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["isDemoPackage"] = this.isDemoPackage;
        data["accessStatus"] = this.accessStatus;
        return data; 
    }
}

export interface IScoreSimulatorInfoDto {
    initialScore: number | undefined;
    totalCreditLimit: number | undefined;
    outstandingBalance: number | undefined;
    isDemoPackage: boolean | undefined;
    accessStatus: MemberSimulatorAccessStatus | undefined;
}

export class ScoreSimulatorDto implements IScoreSimulatorDto {
    onTimePayment!: number | undefined;
    closeOldestCreditCard!: boolean | undefined;
    oneAccountPastDue!: number | undefined;
    allAccountsPastDue!: number | undefined;
    increaseCreditBalance!: number | undefined;
    decreaseCreditBalance!: number | undefined;
    increaseCreditCardLimit!: number | undefined;
    moveOneAccountToCollection!: boolean | undefined;
    addTaxLienPublicRecord!: boolean | undefined;
    addForeClosurePublicRecord!: boolean | undefined;
    addChildSupportPublicRecord!: boolean | undefined;
    addWageGarnishmentPublicRecord!: boolean | undefined;
    declareBankruptcy!: boolean | undefined;
    payOffAllCreditCards!: boolean | undefined;
    applyForCreditCard!: number | undefined;
    obtainCreditCard!: number | undefined;
    obtainMortgage!: number | undefined;
    obtainAutoLoan!: number | undefined;
    obtainPersonalLoan!: number | undefined;
    transferCreditBalances!: number | undefined;

    constructor(data?: IScoreSimulatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.onTimePayment = data["onTimePayment"];
            this.closeOldestCreditCard = data["closeOldestCreditCard"];
            this.oneAccountPastDue = data["oneAccountPastDue"];
            this.allAccountsPastDue = data["allAccountsPastDue"];
            this.increaseCreditBalance = data["increaseCreditBalance"];
            this.decreaseCreditBalance = data["decreaseCreditBalance"];
            this.increaseCreditCardLimit = data["increaseCreditCardLimit"];
            this.moveOneAccountToCollection = data["moveOneAccountToCollection"];
            this.addTaxLienPublicRecord = data["addTaxLienPublicRecord"];
            this.addForeClosurePublicRecord = data["addForeClosurePublicRecord"];
            this.addChildSupportPublicRecord = data["addChildSupportPublicRecord"];
            this.addWageGarnishmentPublicRecord = data["addWageGarnishmentPublicRecord"];
            this.declareBankruptcy = data["declareBankruptcy"];
            this.payOffAllCreditCards = data["payOffAllCreditCards"];
            this.applyForCreditCard = data["applyForCreditCard"];
            this.obtainCreditCard = data["obtainCreditCard"];
            this.obtainMortgage = data["obtainMortgage"];
            this.obtainAutoLoan = data["obtainAutoLoan"];
            this.obtainPersonalLoan = data["obtainPersonalLoan"];
            this.transferCreditBalances = data["transferCreditBalances"];
        }
    }

    static fromJS(data: any): ScoreSimulatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTimePayment"] = this.onTimePayment;
        data["closeOldestCreditCard"] = this.closeOldestCreditCard;
        data["oneAccountPastDue"] = this.oneAccountPastDue;
        data["allAccountsPastDue"] = this.allAccountsPastDue;
        data["increaseCreditBalance"] = this.increaseCreditBalance;
        data["decreaseCreditBalance"] = this.decreaseCreditBalance;
        data["increaseCreditCardLimit"] = this.increaseCreditCardLimit;
        data["moveOneAccountToCollection"] = this.moveOneAccountToCollection;
        data["addTaxLienPublicRecord"] = this.addTaxLienPublicRecord;
        data["addForeClosurePublicRecord"] = this.addForeClosurePublicRecord;
        data["addChildSupportPublicRecord"] = this.addChildSupportPublicRecord;
        data["addWageGarnishmentPublicRecord"] = this.addWageGarnishmentPublicRecord;
        data["declareBankruptcy"] = this.declareBankruptcy;
        data["payOffAllCreditCards"] = this.payOffAllCreditCards;
        data["applyForCreditCard"] = this.applyForCreditCard;
        data["obtainCreditCard"] = this.obtainCreditCard;
        data["obtainMortgage"] = this.obtainMortgage;
        data["obtainAutoLoan"] = this.obtainAutoLoan;
        data["obtainPersonalLoan"] = this.obtainPersonalLoan;
        data["transferCreditBalances"] = this.transferCreditBalances;
        return data; 
    }
}

export interface IScoreSimulatorDto {
    onTimePayment: number | undefined;
    closeOldestCreditCard: boolean | undefined;
    oneAccountPastDue: number | undefined;
    allAccountsPastDue: number | undefined;
    increaseCreditBalance: number | undefined;
    decreaseCreditBalance: number | undefined;
    increaseCreditCardLimit: number | undefined;
    moveOneAccountToCollection: boolean | undefined;
    addTaxLienPublicRecord: boolean | undefined;
    addForeClosurePublicRecord: boolean | undefined;
    addChildSupportPublicRecord: boolean | undefined;
    addWageGarnishmentPublicRecord: boolean | undefined;
    declareBankruptcy: boolean | undefined;
    payOffAllCreditCards: boolean | undefined;
    applyForCreditCard: number | undefined;
    obtainCreditCard: number | undefined;
    obtainMortgage: number | undefined;
    obtainAutoLoan: number | undefined;
    obtainPersonalLoan: number | undefined;
    transferCreditBalances: number | undefined;
}

export class CurrencyInfo implements ICurrencyInfo {
    id!: string | undefined;
    name!: string | undefined;
    symbol!: string | undefined;

    constructor(data?: ICurrencyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.symbol = data["symbol"];
        }
    }

    static fromJS(data: any): CurrencyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        return data; 
    }
}

export interface ICurrencyInfo {
    id: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
}

export class AccountTotals implements IAccountTotals {
    bankAccountCount!: number | undefined;
    totalNetWorth!: number | undefined;
    totalPending!: number | undefined;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountCount = data["bankAccountCount"];
            this.totalNetWorth = data["totalNetWorth"];
            this.totalPending = data["totalPending"];
        }
    }

    static fromJS(data: any): AccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountCount"] = this.bankAccountCount;
        data["totalNetWorth"] = this.totalNetWorth;
        data["totalPending"] = this.totalPending;
        return data; 
    }
}

export interface IAccountTotals {
    bankAccountCount: number | undefined;
    totalNetWorth: number | undefined;
    totalPending: number | undefined;
}

export class CategorizationStatus implements ICategorizationStatus {
    classifiedTransactionCount!: number | undefined;
    classifiedTransactionPercent!: number | undefined;
    unclassifiedTransactionCount!: number | undefined;
    unclassifiedTransactionPercent!: number | undefined;

    constructor(data?: ICategorizationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classifiedTransactionCount = data["classifiedTransactionCount"];
            this.classifiedTransactionPercent = data["classifiedTransactionPercent"];
            this.unclassifiedTransactionCount = data["unclassifiedTransactionCount"];
            this.unclassifiedTransactionPercent = data["unclassifiedTransactionPercent"];
        }
    }

    static fromJS(data: any): CategorizationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CategorizationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedTransactionCount"] = this.classifiedTransactionCount;
        data["classifiedTransactionPercent"] = this.classifiedTransactionPercent;
        data["unclassifiedTransactionCount"] = this.unclassifiedTransactionCount;
        data["unclassifiedTransactionPercent"] = this.unclassifiedTransactionPercent;
        return data; 
    }
}

export interface ICategorizationStatus {
    classifiedTransactionCount: number | undefined;
    classifiedTransactionPercent: number | undefined;
    unclassifiedTransactionCount: number | undefined;
    unclassifiedTransactionPercent: number | undefined;
}

export class GetDailyBalanceStatsOutput implements IGetDailyBalanceStatsOutput {
    minBalance!: number | undefined;
    avarageBalance!: number | undefined;
    maxBalance!: number | undefined;
    count!: number | undefined;

    constructor(data?: IGetDailyBalanceStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minBalance = data["minBalance"];
            this.avarageBalance = data["avarageBalance"];
            this.maxBalance = data["maxBalance"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetDailyBalanceStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailyBalanceStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minBalance"] = this.minBalance;
        data["avarageBalance"] = this.avarageBalance;
        data["maxBalance"] = this.maxBalance;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetDailyBalanceStatsOutput {
    minBalance: number | undefined;
    avarageBalance: number | undefined;
    maxBalance: number | undefined;
    count: number | undefined;
}

export class GetSpendingCategoriesOutput implements IGetSpendingCategoriesOutput {
    id!: number | undefined;
    name!: string | undefined;
    fullName!: string | undefined;
    amount!: number | undefined;

    constructor(data?: IGetSpendingCategoriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.fullName = data["fullName"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetSpendingCategoriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSpendingCategoriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetSpendingCategoriesOutput {
    id: number | undefined;
    name: string | undefined;
    fullName: string | undefined;
    amount: number | undefined;
}

export class GetTotalsOutput implements IGetTotalsOutput {
    newLeadCount!: number | undefined;
    newClientCount!: number | undefined;
    newOrderAmount!: number | undefined;
    totalLeadCount!: number | undefined;
    totalClientCount!: number | undefined;
    totalOrderAmount!: number | undefined;

    constructor(data?: IGetTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newLeadCount = data["newLeadCount"];
            this.newClientCount = data["newClientCount"];
            this.newOrderAmount = data["newOrderAmount"];
            this.totalLeadCount = data["totalLeadCount"];
            this.totalClientCount = data["totalClientCount"];
            this.totalOrderAmount = data["totalOrderAmount"];
        }
    }

    static fromJS(data: any): GetTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newLeadCount"] = this.newLeadCount;
        data["newClientCount"] = this.newClientCount;
        data["newOrderAmount"] = this.newOrderAmount;
        data["totalLeadCount"] = this.totalLeadCount;
        data["totalClientCount"] = this.totalClientCount;
        data["totalOrderAmount"] = this.totalOrderAmount;
        return data; 
    }
}

export interface IGetTotalsOutput {
    newLeadCount: number | undefined;
    newClientCount: number | undefined;
    newOrderAmount: number | undefined;
    totalLeadCount: number | undefined;
    totalClientCount: number | undefined;
    totalOrderAmount: number | undefined;
}

export class GetCustomerAndLeadStatsOutput implements IGetCustomerAndLeadStatsOutput {
    date!: moment.Moment | undefined;
    customerCount!: number | undefined;
    leadTotalCount!: number | undefined;
    leadStageCount!: { [key: string] : number; } | undefined;

    constructor(data?: IGetCustomerAndLeadStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.customerCount = data["customerCount"];
            this.leadTotalCount = data["leadTotalCount"];
            if (data["leadStageCount"]) {
                this.leadStageCount = {};
                for (let key in data["leadStageCount"]) {
                    if (data["leadStageCount"].hasOwnProperty(key))
                        this.leadStageCount[key] = data["leadStageCount"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetCustomerAndLeadStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerAndLeadStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerCount"] = this.customerCount;
        data["leadTotalCount"] = this.leadTotalCount;
        if (this.leadStageCount) {
            data["leadStageCount"] = {};
            for (let key in this.leadStageCount) {
                if (this.leadStageCount.hasOwnProperty(key))
                    data["leadStageCount"][key] = this.leadStageCount[key];
            }
        }
        return data; 
    }
}

export interface IGetCustomerAndLeadStatsOutput {
    date: moment.Moment | undefined;
    customerCount: number | undefined;
    leadTotalCount: number | undefined;
    leadStageCount: { [key: string] : number; } | undefined;
}

export class GetRecentlyCreatedCustomersOutput implements IGetRecentlyCreatedCustomersOutput {
    contactId!: number | undefined;
    fullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IGetRecentlyCreatedCustomersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.bankCode = data["bankCode"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentlyCreatedCustomersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentlyCreatedCustomersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRecentlyCreatedCustomersOutput {
    contactId: number | undefined;
    fullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetRecentlyCreatedLeadsOutput implements IGetRecentlyCreatedLeadsOutput {
    leadId!: number | undefined;
    contactId!: number | undefined;
    fullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    bankCode!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IGetRecentlyCreatedLeadsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.bankCode = data["bankCode"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentlyCreatedLeadsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentlyCreatedLeadsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["bankCode"] = this.bankCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRecentlyCreatedLeadsOutput {
    leadId: number | undefined;
    contactId: number | undefined;
    fullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    bankCode: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetContactsByCompanySizeOutput implements IGetContactsByCompanySizeOutput {
    contactCount!: number | undefined;
    companySizeRange!: string | undefined;

    constructor(data?: IGetContactsByCompanySizeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactCount = data["contactCount"];
            this.companySizeRange = data["companySizeRange"];
        }
    }

    static fromJS(data: any): GetContactsByCompanySizeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactsByCompanySizeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactCount"] = this.contactCount;
        data["companySizeRange"] = this.companySizeRange;
        return data; 
    }
}

export interface IGetContactsByCompanySizeOutput {
    contactCount: number | undefined;
    companySizeRange: string | undefined;
}

export class GetContactsByRegionOutput implements IGetContactsByRegionOutput {
    countryId!: string | undefined;
    stateId!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetContactsByRegionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetContactsByRegionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactsByRegionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetContactsByRegionOutput {
    countryId: string | undefined;
    stateId: string | undefined;
    count: number | undefined;
}

export enum LeadAgeRange {
    UpTo30Days = "UpTo30Days", 
    UpTo60Days = "UpTo60Days", 
    UpTo90Days = "UpTo90Days", 
    UpTo6Months = "UpTo6Months", 
    UpTo12Months = "UpTo12Months", 
    MoreThanYear = "MoreThanYear", 
}

export class LeadAgeRangeGetCountOutput implements ILeadAgeRangeGetCountOutput {
    key!: LeadAgeRange | undefined;
    count!: number | undefined;

    constructor(data?: ILeadAgeRangeGetCountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): LeadAgeRangeGetCountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LeadAgeRangeGetCountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface ILeadAgeRangeGetCountOutput {
    key: LeadAgeRange | undefined;
    count: number | undefined;
}

export class GetCountOutput implements IGetCountOutput {
    key!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetCountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetCountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetCountOutput {
    key: string | undefined;
    count: number | undefined;
}

export enum ContactStarColorType {
    Green = "Green", 
    Blue = "Blue", 
    Yellow = "Yellow", 
    Red = "Red", 
    Purple = "Purple", 
    Gradient1 = "Gradient1", 
    Gradient2 = "Gradient2", 
    Gradient3 = "Gradient3", 
    Gradient4 = "Gradient4", 
    Gradient5 = "Gradient5", 
    Blueprint = "Blueprint", 
    Action = "Action", 
    Nurturing = "Nurturing", 
    Knowledge = "Knowledge", 
    Unknown = "Unknown", 
}

export class GetCountByStarOutput implements IGetCountByStarOutput {
    colorType!: ContactStarColorType | undefined;
    key!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetCountByStarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.colorType = data["colorType"];
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetCountByStarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountByStarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colorType"] = this.colorType;
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetCountByStarOutput {
    colorType: ContactStarColorType | undefined;
    key: string | undefined;
    count: number | undefined;
}

export class GetContactInfoStatsByStarOutput implements IGetContactInfoStatsByStarOutput {
    countWithEmail!: number | undefined;
    countWithName!: number | undefined;
    countWithPhone!: number | undefined;
    countWithCountry!: number | undefined;
    countWithNameAndEmail!: number | undefined;
    key!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetContactInfoStatsByStarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countWithEmail = data["countWithEmail"];
            this.countWithName = data["countWithName"];
            this.countWithPhone = data["countWithPhone"];
            this.countWithCountry = data["countWithCountry"];
            this.countWithNameAndEmail = data["countWithNameAndEmail"];
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetContactInfoStatsByStarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactInfoStatsByStarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countWithEmail"] = this.countWithEmail;
        data["countWithName"] = this.countWithName;
        data["countWithPhone"] = this.countWithPhone;
        data["countWithCountry"] = this.countWithCountry;
        data["countWithNameAndEmail"] = this.countWithNameAndEmail;
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetContactInfoStatsByStarOutput {
    countWithEmail: number | undefined;
    countWithName: number | undefined;
    countWithPhone: number | undefined;
    countWithCountry: number | undefined;
    countWithNameAndEmail: number | undefined;
    key: string | undefined;
    count: number | undefined;
}

export class ContactsStatsByStarInfo implements IContactsStatsByStarInfo {
    date!: moment.Moment | undefined;
    totalCount!: number | undefined;
    starCount!: { [key: string] : number; } | undefined;

    constructor(data?: IContactsStatsByStarInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            if (data["starCount"]) {
                this.starCount = {};
                for (let key in data["starCount"]) {
                    if (data["starCount"].hasOwnProperty(key))
                        this.starCount[key] = data["starCount"][key];
                }
            }
        }
    }

    static fromJS(data: any): ContactsStatsByStarInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactsStatsByStarInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        if (this.starCount) {
            data["starCount"] = {};
            for (let key in this.starCount) {
                if (this.starCount.hasOwnProperty(key))
                    data["starCount"][key] = this.starCount[key];
            }
        }
        return data; 
    }
}

export interface IContactsStatsByStarInfo {
    date: moment.Moment | undefined;
    totalCount: number | undefined;
    starCount: { [key: string] : number; } | undefined;
}

export class GetCRMStatusOutput implements IGetCRMStatusOutput {
    hasData!: boolean | undefined;

    constructor(data?: IGetCRMStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hasData = data["hasData"];
        }
    }

    static fromJS(data: any): GetCRMStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCRMStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasData"] = this.hasData;
        return data; 
    }
}

export interface IGetCRMStatusOutput {
    hasData: boolean | undefined;
}

export class PartnerTypeDto implements IPartnerTypeDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IPartnerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PartnerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPartnerTypeDto {
    id: number | undefined;
    name: string | undefined;
}

export class ContactStarInfoDto implements IContactStarInfoDto {
    id!: number | undefined;
    name!: string | undefined;
    colorType!: ContactStarColorType | undefined;

    constructor(data?: IContactStarInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.colorType = data["colorType"];
        }
    }

    static fromJS(data: any): ContactStarInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStarInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["colorType"] = this.colorType;
        return data; 
    }
}

export interface IContactStarInfoDto {
    id: number | undefined;
    name: string | undefined;
    colorType: ContactStarColorType | undefined;
}

export class ContactTagInfoDto implements IContactTagInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactTagInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactTagInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactTagInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class ContactListInfoDto implements IContactListInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactListInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactListInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactListInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class OrganizationTypeDto implements IOrganizationTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IOrganizationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): OrganizationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IOrganizationTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class OrganizationUnitShortDto implements IOrganizationUnitShortDto {
    id!: number | undefined;
    displayName!: string | undefined;
    parentId!: number | undefined;

    constructor(data?: IOrganizationUnitShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data; 
    }
}

export interface IOrganizationUnitShortDto {
    id: number | undefined;
    displayName: string | undefined;
    parentId: number | undefined;
}

export class DocumentInfo implements IDocumentInfo {
    id!: string | undefined;
    typeId!: number | undefined;
    typeName!: string | undefined;
    fileId!: string | undefined;
    fileName!: string | undefined;
    size!: string | undefined;
    creationTime!: moment.Moment | undefined;
    isViewSupportedByWopi!: boolean | undefined;
    isEditSupportedByWopi!: boolean | undefined;

    constructor(data?: IDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.fileId = data["fileId"];
            this.fileName = data["fileName"];
            this.size = data["size"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isViewSupportedByWopi = data["isViewSupportedByWopi"];
            this.isEditSupportedByWopi = data["isEditSupportedByWopi"];
        }
    }

    static fromJS(data: any): DocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["fileId"] = this.fileId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isViewSupportedByWopi"] = this.isViewSupportedByWopi;
        data["isEditSupportedByWopi"] = this.isEditSupportedByWopi;
        return data; 
    }
}

export interface IDocumentInfo {
    id: string | undefined;
    typeId: number | undefined;
    typeName: string | undefined;
    fileId: string | undefined;
    fileName: string | undefined;
    size: string | undefined;
    creationTime: moment.Moment | undefined;
    isViewSupportedByWopi: boolean | undefined;
    isEditSupportedByWopi: boolean | undefined;
}

export class GetUrlOutput implements IGetUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IGetUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IGetUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class UploadDocumentInput implements IUploadDocumentInput {
    typeId!: number | undefined;
    contactId!: number;
    fileName!: string;
    size!: number;
    file!: string;

    constructor(data?: IUploadDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.contactId = data["contactId"];
            this.fileName = data["fileName"];
            this.size = data["size"];
            this.file = data["file"];
        }
    }

    static fromJS(data: any): UploadDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["contactId"] = this.contactId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["file"] = this.file;
        return data; 
    }
}

export interface IUploadDocumentInput {
    typeId: number | undefined;
    contactId: number;
    fileName: string;
    size: number;
    file: string;
}

export class UpdateTypeInput implements IUpdateTypeInput {
    documentId!: string;
    typeId!: number | undefined;

    constructor(data?: IUpdateTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): UpdateTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IUpdateTypeInput {
    documentId: string;
    typeId: number | undefined;
}

export class CopyTemplateInput implements ICopyTemplateInput {
    contactId!: number;
    files!: FileInfo[] | undefined;

    constructor(data?: ICopyTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(FileInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CopyTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CopyTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICopyTemplateInput {
    contactId: number;
    files: FileInfo[] | undefined;
}

export class WopiRequestOutcoming implements IWopiRequestOutcoming {
    accessToken!: string | undefined;
    accessTokenTtl!: number | undefined;
    wopiUrlsrc!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IWopiRequestOutcoming) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.accessTokenTtl = data["accessTokenTtl"];
            this.wopiUrlsrc = data["wopiUrlsrc"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): WopiRequestOutcoming {
        data = typeof data === 'object' ? data : {};
        let result = new WopiRequestOutcoming();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenTtl"] = this.accessTokenTtl;
        data["wopiUrlsrc"] = this.wopiUrlsrc;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IWopiRequestOutcoming {
    accessToken: string | undefined;
    accessTokenTtl: number | undefined;
    wopiUrlsrc: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class GetFileUrlDto implements IGetFileUrlDto {
    url!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IGetFileUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetFileUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IGetFileUrlDto {
    url: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class DocumentTypeInfo implements IDocumentTypeInfo {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IDocumentTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): DocumentTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDocumentTypeInfo {
    id: number | undefined;
    name: string | undefined;
}

export class CreateDocumentTypeInput implements ICreateDocumentTypeInput {
    name!: string;

    constructor(data?: ICreateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateDocumentTypeInput {
    name: string;
}

export class UpdateDocumentTypeInput implements IUpdateDocumentTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateDocumentTypeInput {
    id: number;
    name: string;
}

export enum ModuleType {
    CFO = "CFO", 
    CRM = "CRM", 
    CFO_CRM = "CFO_CRM", 
    PFM = "PFM", 
    CFO_Partner = "CFO_Partner", 
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment | undefined;
    module!: ModuleType | undefined;
    packageName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.module = data["module"];
            this.packageName = data["packageName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["module"] = this.module;
        data["packageName"] = this.packageName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    module: ModuleType | undefined;
    packageName: string | undefined;
    id: number | undefined;
}

export class EditionListDtoListResultDto implements IEditionListDtoListResultDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IEditionListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionListDtoListResultDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class IValueValidator implements IIValueValidator {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class EmailFromSettings implements IEmailFromSettings {
    emailAddress!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IEmailFromSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EmailFromSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailFromSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmailFromSettings {
    emailAddress: string | undefined;
    displayName: string | undefined;
}

export class EmailSmtpSettings implements IEmailSmtpSettings {
    host!: string | undefined;
    port!: number | undefined;
    enableSsl!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: IEmailSmtpSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.host = data["host"];
            this.port = data["port"];
            this.enableSsl = data["enableSsl"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): EmailSmtpSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSmtpSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        data["enableSsl"] = this.enableSsl;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IEmailSmtpSettings {
    host: string | undefined;
    port: number | undefined;
    enableSsl: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;
    from!: EmailFromSettings | undefined;
    smtp!: EmailSmtpSettings | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.from = data["from"] ? EmailFromSettings.fromJS(data["from"]) : <any>undefined;
            this.smtp = data["smtp"] ? EmailSmtpSettings.fromJS(data["smtp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["smtp"] = this.smtp ? this.smtp.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
    from: EmailFromSettings | undefined;
    smtp: EmailSmtpSettings | undefined;
}

export enum EmailTemplateType {
    Invoice = "Invoice", 
    Contact = "Contact", 
    WelcomeEmail = "WelcomeEmail", 
}

export class GetTemplatesResponse implements IGetTemplatesResponse {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IGetTemplatesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetTemplatesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplatesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetTemplatesResponse {
    id: number | undefined;
    name: string | undefined;
}

export class GetTemplateReponse implements IGetTemplateReponse {
    name!: string | undefined;
    type!: EmailTemplateType | undefined;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string | undefined;

    constructor(data?: IGetTemplateReponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.subject = data["subject"];
            if (data["cc"] && data["cc"].constructor === Array) {
                this.cc = [];
                for (let item of data["cc"])
                    this.cc.push(item);
            }
            if (data["bcc"] && data["bcc"].constructor === Array) {
                this.bcc = [];
                for (let item of data["bcc"])
                    this.bcc.push(item);
            }
            this.body = data["body"];
        }
    }

    static fromJS(data: any): GetTemplateReponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplateReponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (this.cc && this.cc.constructor === Array) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (this.bcc && this.bcc.constructor === Array) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data; 
    }
}

export interface IGetTemplateReponse {
    name: string | undefined;
    type: EmailTemplateType | undefined;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string | undefined;
}

export class CreateEmailTemplateRequest implements ICreateEmailTemplateRequest {
    name!: string;
    type!: EmailTemplateType;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string;

    constructor(data?: ICreateEmailTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.subject = data["subject"];
            if (data["cc"] && data["cc"].constructor === Array) {
                this.cc = [];
                for (let item of data["cc"])
                    this.cc.push(item);
            }
            if (data["bcc"] && data["bcc"].constructor === Array) {
                this.bcc = [];
                for (let item of data["bcc"])
                    this.bcc.push(item);
            }
            this.body = data["body"];
        }
    }

    static fromJS(data: any): CreateEmailTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmailTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (this.cc && this.cc.constructor === Array) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (this.bcc && this.bcc.constructor === Array) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data; 
    }
}

export interface ICreateEmailTemplateRequest {
    name: string;
    type: EmailTemplateType;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string;
}

export class UpdateEmailTemplateRequest implements IUpdateEmailTemplateRequest {
    id!: number;
    name!: string;
    type!: EmailTemplateType;
    subject!: string | undefined;
    cc!: string[] | undefined;
    bcc!: string[] | undefined;
    body!: string;

    constructor(data?: IUpdateEmailTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.type = data["type"];
            this.subject = data["subject"];
            if (data["cc"] && data["cc"].constructor === Array) {
                this.cc = [];
                for (let item of data["cc"])
                    this.cc.push(item);
            }
            if (data["bcc"] && data["bcc"].constructor === Array) {
                this.bcc = [];
                for (let item of data["bcc"])
                    this.bcc.push(item);
            }
            this.body = data["body"];
        }
    }

    static fromJS(data: any): UpdateEmailTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["subject"] = this.subject;
        if (this.cc && this.cc.constructor === Array) {
            data["cc"] = [];
            for (let item of this.cc)
                data["cc"].push(item);
        }
        if (this.bcc && this.bcc.constructor === Array) {
            data["bcc"] = [];
            for (let item of this.bcc)
                data["bcc"].push(item);
        }
        data["body"] = this.body;
        return data; 
    }
}

export interface IUpdateEmailTemplateRequest {
    id: number;
    name: string;
    type: EmailTemplateType;
    subject: string | undefined;
    cc: string[] | undefined;
    bcc: string[] | undefined;
    body: string;
}

export class EventSubscriptionDto implements IEventSubscriptionDto {
    id!: number | undefined;
    appEvent!: string | undefined;
    targetUrl!: string | undefined;
    creatorUserId!: number | undefined;
    creatorUserName!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IEventSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appEvent = data["appEvent"];
            this.targetUrl = data["targetUrl"];
            this.creatorUserId = data["creatorUserId"];
            this.creatorUserName = data["creatorUserName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EventSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appEvent"] = this.appEvent;
        data["targetUrl"] = this.targetUrl;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IEventSubscriptionDto {
    id: number | undefined;
    appEvent: string | undefined;
    targetUrl: string | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class EventJobExecutionDto implements IEventJobExecutionDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    requestBody!: string | undefined;
    responseStatus!: string | undefined;
    httpStatusCode!: number | undefined;
    httpStatusName!: string | undefined;
    responseContent!: string | undefined;
    responseErrorMessage!: string | undefined;

    constructor(data?: IEventJobExecutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.requestBody = data["requestBody"];
            this.responseStatus = data["responseStatus"];
            this.httpStatusCode = data["httpStatusCode"];
            this.httpStatusName = data["httpStatusName"];
            this.responseContent = data["responseContent"];
            this.responseErrorMessage = data["responseErrorMessage"];
        }
    }

    static fromJS(data: any): EventJobExecutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventJobExecutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["requestBody"] = this.requestBody;
        data["responseStatus"] = this.responseStatus;
        data["httpStatusCode"] = this.httpStatusCode;
        data["httpStatusName"] = this.httpStatusName;
        data["responseContent"] = this.responseContent;
        data["responseErrorMessage"] = this.responseErrorMessage;
        return data; 
    }
}

export interface IEventJobExecutionDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    requestBody: string | undefined;
    responseStatus: string | undefined;
    httpStatusCode: number | undefined;
    httpStatusName: string | undefined;
    responseContent: string | undefined;
    responseErrorMessage: string | undefined;
}

export class SubscribeForEventInput implements ISubscribeForEventInput {
    eventName!: string;
    targetUrl!: string;

    constructor(data?: ISubscribeForEventInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventName = data["eventName"];
            this.targetUrl = data["targetUrl"];
        }
    }

    static fromJS(data: any): SubscribeForEventInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeForEventInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventName"] = this.eventName;
        data["targetUrl"] = this.targetUrl;
        return data; 
    }
}

export interface ISubscribeForEventInput {
    eventName: string;
    targetUrl: string;
}

export class SubscribeForEventOutput implements ISubscribeForEventOutput {
    id!: number | undefined;

    constructor(data?: ISubscribeForEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscribeForEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribeForEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscribeForEventOutput {
    id: number | undefined;
}

export class ExtensionCategoryDto implements IExtensionCategoryDto {
    id!: number | undefined;
    name!: string | undefined;
    count!: number | undefined;

    constructor(data?: IExtensionCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): ExtensionCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["count"] = this.count;
        return data; 
    }
}

export interface IExtensionCategoryDto {
    id: number | undefined;
    name: string | undefined;
    count: number | undefined;
}

export class ExtensionDto implements IExtensionDto {
    id!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    categoryId!: number | undefined;
    logo!: string | undefined;
    url!: string | undefined;
    rank!: number | undefined;

    constructor(data?: IExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.categoryId = data["categoryId"];
            this.logo = data["logo"];
            this.url = data["url"];
            this.rank = data["rank"];
        }
    }

    static fromJS(data: any): ExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["logo"] = this.logo;
        data["url"] = this.url;
        data["rank"] = this.rank;
        return data; 
    }
}

export interface IExtensionDto {
    id: number | undefined;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    categoryId: number | undefined;
    logo: string | undefined;
    url: string | undefined;
    rank: number | undefined;
}

export class ImportExtensionDto implements IImportExtensionDto {
    code!: string;
    name!: string;
    description!: string | undefined;
    category!: string;
    logo!: string | undefined;
    url!: string | undefined;
    rank!: number | undefined;

    constructor(data?: IImportExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.category = data["category"];
            this.logo = data["logo"];
            this.url = data["url"];
            this.rank = data["rank"];
        }
    }

    static fromJS(data: any): ImportExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["category"] = this.category;
        data["logo"] = this.logo;
        data["url"] = this.url;
        data["rank"] = this.rank;
        return data; 
    }
}

export interface IImportExtensionDto {
    code: string;
    name: string;
    description: string | undefined;
    category: string;
    logo: string | undefined;
    url: string | undefined;
    rank: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export enum ChartDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    defaultCountryCode!: string | undefined;
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;
    zendeskAccountUrl!: string | undefined;
    publicPhone!: string | undefined;
    publicSiteUrl!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultCountryCode = data["defaultCountryCode"];
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
            this.zendeskAccountUrl = data["zendeskAccountUrl"];
            this.publicPhone = data["publicPhone"];
            this.publicSiteUrl = data["publicSiteUrl"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultCountryCode"] = this.defaultCountryCode;
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        data["zendeskAccountUrl"] = this.zendeskAccountUrl;
        data["publicPhone"] = this.publicPhone;
        data["publicSiteUrl"] = this.publicSiteUrl;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    defaultCountryCode: string | undefined;
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
    zendeskAccountUrl: string | undefined;
    publicPhone: string | undefined;
    publicSiteUrl: string | undefined;
}

export class CustomWelcomeTemplate implements ICustomWelcomeTemplate {
    groupId!: string | undefined;
    templateId!: number | undefined;

    constructor(data?: ICustomWelcomeTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.templateId = data["templateId"];
        }
    }

    static fromJS(data: any): CustomWelcomeTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomWelcomeTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["templateId"] = this.templateId;
        return data; 
    }
}

export interface ICustomWelcomeTemplate {
    groupId: string | undefined;
    templateId: number | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    customWelcomeEmailTemplates!: CustomWelcomeTemplate[] | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            if (data["customWelcomeEmailTemplates"] && data["customWelcomeEmailTemplates"].constructor === Array) {
                this.customWelcomeEmailTemplates = [];
                for (let item of data["customWelcomeEmailTemplates"])
                    this.customWelcomeEmailTemplates.push(CustomWelcomeTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        if (this.customWelcomeEmailTemplates && this.customWelcomeEmailTemplates.constructor === Array) {
            data["customWelcomeEmailTemplates"] = [];
            for (let item of this.customWelcomeEmailTemplates)
                data["customWelcomeEmailTemplates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    customWelcomeEmailTemplates: CustomWelcomeTemplate[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpDomain!: string | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    isImapEnabled!: boolean | undefined;
    imapHost!: string | undefined;
    imapPort!: number | undefined;
    imapUseSsl!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.isImapEnabled = data["isImapEnabled"];
            this.imapHost = data["imapHost"];
            this.imapPort = data["imapPort"];
            this.imapUseSsl = data["imapUseSsl"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["isImapEnabled"] = this.isImapEnabled;
        data["imapHost"] = this.imapHost;
        data["imapPort"] = this.imapPort;
        data["imapUseSsl"] = this.imapUseSsl;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpDomain: string | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    isImapEnabled: boolean | undefined;
    imapHost: string | undefined;
    imapPort: number | undefined;
    imapUseSsl: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class BugsnagSettingsDto implements IBugsnagSettingsDto {
    appApiKey!: string | undefined;
    uiApiKey!: string | undefined;

    constructor(data?: IBugsnagSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appApiKey = data["appApiKey"];
            this.uiApiKey = data["uiApiKey"];
        }
    }

    static fromJS(data: any): BugsnagSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugsnagSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appApiKey"] = this.appApiKey;
        data["uiApiKey"] = this.uiApiKey;
        return data; 
    }
}

export interface IBugsnagSettingsDto {
    appApiKey: string | undefined;
    uiApiKey: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    bugsnag!: BugsnagSettingsDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.bugsnag = data["bugsnag"] ? BugsnagSettingsDto.fromJS(data["bugsnag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["bugsnag"] = this.bugsnag ? this.bugsnag.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    bugsnag: BugsnagSettingsDto | undefined;
}

export class YTelSettingsEditDto implements IYTelSettingsEditDto {
    isEnabled!: boolean | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    from!: string | undefined;
    inboundSmsKey!: string | undefined;

    constructor(data?: IYTelSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.from = data["from"];
            this.inboundSmsKey = data["inboundSmsKey"];
        }
    }

    static fromJS(data: any): YTelSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new YTelSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["from"] = this.from;
        data["inboundSmsKey"] = this.inboundSmsKey;
        return data; 
    }
}

export interface IYTelSettingsEditDto {
    isEnabled: boolean | undefined;
    userName: string | undefined;
    password: string | undefined;
    from: string | undefined;
    inboundSmsKey: string | undefined;
}

export class ImportFullName implements IImportFullName {
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;

    constructor(data?: IImportFullName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
        }
    }

    static fromJS(data: any): ImportFullName {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFullName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        return data; 
    }
}

export interface IImportFullName {
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
}

export class ImportAddressInput implements IImportAddressInput {
    street!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    stateName!: string | undefined;
    stateId!: string | undefined;
    neighborhood!: string | undefined;
    zip!: string | undefined;
    countryName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IImportAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.street = data["street"];
            this.addressLine2 = data["addressLine2"];
            this.city = data["city"];
            this.stateName = data["stateName"];
            this.stateId = data["stateId"];
            this.neighborhood = data["neighborhood"];
            this.zip = data["zip"];
            this.countryName = data["countryName"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): ImportAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["stateName"] = this.stateName;
        data["stateId"] = this.stateId;
        data["neighborhood"] = this.neighborhood;
        data["zip"] = this.zip;
        data["countryName"] = this.countryName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IImportAddressInput {
    street: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    stateName: string | undefined;
    stateId: string | undefined;
    neighborhood: string | undefined;
    zip: string | undefined;
    countryName: string | undefined;
    countryId: string | undefined;
}

export class CustomFieldsInput implements ICustomFieldsInput {
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;

    constructor(data?: ICustomFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customField1 = data["customField1"];
            this.customField2 = data["customField2"];
            this.customField3 = data["customField3"];
            this.customField4 = data["customField4"];
            this.customField5 = data["customField5"];
        }
    }

    static fromJS(data: any): CustomFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        return data; 
    }
}

export interface ICustomFieldsInput {
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
}

export class ImportPersonalInput implements IImportPersonalInput {
    fullName!: ImportFullName | undefined;
    doB!: moment.Moment | undefined;
    mobilePhone!: string | undefined;
    mobilePhoneExt!: string | undefined;
    homePhone!: string | undefined;
    homePhoneExt!: string | undefined;
    phone1!: string | undefined;
    phoneExt1!: string | undefined;
    phone2!: string | undefined;
    phoneExt2!: string | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    email1!: string | undefined;
    email2!: string | undefined;
    email3!: string | undefined;
    email4!: string | undefined;
    email5!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    gender!: string | undefined;
    fullAddress!: ImportAddressInput | undefined;
    fullAddress2!: ImportAddressInput | undefined;
    fullAddress3!: ImportAddressInput | undefined;
    isUSCitizen!: boolean | undefined;
    webSiteUrl!: string | undefined;
    facebookUrl!: string | undefined;
    linkedInUrl!: string | undefined;
    instagramUrl!: string | undefined;
    twitterUrl!: string | undefined;
    googlePlusUrl!: string | undefined;
    angelListUrl!: string | undefined;
    zoomUrl!: string | undefined;
    otherLinkUrl!: string | undefined;
    photoUrl!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    interests!: string[] | undefined;
    affiliateCode!: string | undefined;
    isActive!: boolean | undefined;
    customFields!: CustomFieldsInput | undefined;

    constructor(data?: IImportPersonalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"] ? ImportFullName.fromJS(data["fullName"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.mobilePhone = data["mobilePhone"];
            this.mobilePhoneExt = data["mobilePhoneExt"];
            this.homePhone = data["homePhone"];
            this.homePhoneExt = data["homePhoneExt"];
            this.phone1 = data["phone1"];
            this.phoneExt1 = data["phoneExt1"];
            this.phone2 = data["phone2"];
            this.phoneExt2 = data["phoneExt2"];
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.email1 = data["email1"];
            this.email2 = data["email2"];
            this.email3 = data["email3"];
            this.email4 = data["email4"];
            this.email5 = data["email5"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            this.gender = data["gender"];
            this.fullAddress = data["fullAddress"] ? ImportAddressInput.fromJS(data["fullAddress"]) : <any>undefined;
            this.fullAddress2 = data["fullAddress2"] ? ImportAddressInput.fromJS(data["fullAddress2"]) : <any>undefined;
            this.fullAddress3 = data["fullAddress3"] ? ImportAddressInput.fromJS(data["fullAddress3"]) : <any>undefined;
            this.isUSCitizen = data["isUSCitizen"];
            this.webSiteUrl = data["webSiteUrl"];
            this.facebookUrl = data["facebookUrl"];
            this.linkedInUrl = data["linkedInUrl"];
            this.instagramUrl = data["instagramUrl"];
            this.twitterUrl = data["twitterUrl"];
            this.googlePlusUrl = data["googlePlusUrl"];
            this.angelListUrl = data["angelListUrl"];
            this.zoomUrl = data["zoomUrl"];
            this.otherLinkUrl = data["otherLinkUrl"];
            this.photoUrl = data["photoUrl"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.affiliateCode = data["affiliateCode"];
            this.isActive = data["isActive"];
            this.customFields = data["customFields"] ? CustomFieldsInput.fromJS(data["customFields"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportPersonalInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPersonalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName ? this.fullName.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["mobilePhoneExt"] = this.mobilePhoneExt;
        data["homePhone"] = this.homePhone;
        data["homePhoneExt"] = this.homePhoneExt;
        data["phone1"] = this.phone1;
        data["phoneExt1"] = this.phoneExt1;
        data["phone2"] = this.phone2;
        data["phoneExt2"] = this.phoneExt2;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["email1"] = this.email1;
        data["email2"] = this.email2;
        data["email3"] = this.email3;
        data["email4"] = this.email4;
        data["email5"] = this.email5;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        data["gender"] = this.gender;
        data["fullAddress"] = this.fullAddress ? this.fullAddress.toJSON() : <any>undefined;
        data["fullAddress2"] = this.fullAddress2 ? this.fullAddress2.toJSON() : <any>undefined;
        data["fullAddress3"] = this.fullAddress3 ? this.fullAddress3.toJSON() : <any>undefined;
        data["isUSCitizen"] = this.isUSCitizen;
        data["webSiteUrl"] = this.webSiteUrl;
        data["facebookUrl"] = this.facebookUrl;
        data["linkedInUrl"] = this.linkedInUrl;
        data["instagramUrl"] = this.instagramUrl;
        data["twitterUrl"] = this.twitterUrl;
        data["googlePlusUrl"] = this.googlePlusUrl;
        data["angelListUrl"] = this.angelListUrl;
        data["zoomUrl"] = this.zoomUrl;
        data["otherLinkUrl"] = this.otherLinkUrl;
        data["photoUrl"] = this.photoUrl;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["affiliateCode"] = this.affiliateCode;
        data["isActive"] = this.isActive;
        data["customFields"] = this.customFields ? this.customFields.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportPersonalInput {
    fullName: ImportFullName | undefined;
    doB: moment.Moment | undefined;
    mobilePhone: string | undefined;
    mobilePhoneExt: string | undefined;
    homePhone: string | undefined;
    homePhoneExt: string | undefined;
    phone1: string | undefined;
    phoneExt1: string | undefined;
    phone2: string | undefined;
    phoneExt2: string | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    email1: string | undefined;
    email2: string | undefined;
    email3: string | undefined;
    email4: string | undefined;
    email5: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    gender: string | undefined;
    fullAddress: ImportAddressInput | undefined;
    fullAddress2: ImportAddressInput | undefined;
    fullAddress3: ImportAddressInput | undefined;
    isUSCitizen: boolean | undefined;
    webSiteUrl: string | undefined;
    facebookUrl: string | undefined;
    linkedInUrl: string | undefined;
    instagramUrl: string | undefined;
    twitterUrl: string | undefined;
    googlePlusUrl: string | undefined;
    angelListUrl: string | undefined;
    zoomUrl: string | undefined;
    otherLinkUrl: string | undefined;
    photoUrl: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    interests: string[] | undefined;
    affiliateCode: string | undefined;
    isActive: boolean | undefined;
    customFields: CustomFieldsInput | undefined;
}

export class ImportBusinessInput implements IImportBusinessInput {
    companyName!: string | undefined;
    organizationType!: string | undefined;
    jobTitle!: string | undefined;
    isEmployed!: boolean | undefined;
    employmentStartDate!: moment.Moment | undefined;
    employeeCount!: number | undefined;
    dateFounded!: moment.Moment | undefined;
    ein!: string | undefined;
    annualRevenue!: number | undefined;
    industry!: string | undefined;
    companyPhone!: string | undefined;
    companyPhoneExt!: string | undefined;
    companyFaxNumber!: string | undefined;
    companyEmail!: string | undefined;
    companyFullAddress!: ImportAddressInput | undefined;
    companyWebSiteUrl!: string | undefined;
    companyFacebookUrl!: string | undefined;
    companyLinkedInUrl!: string | undefined;
    companyInstagramUrl!: string | undefined;
    companyTwitterUrl!: string | undefined;
    companyGooglePlusUrl!: string | undefined;
    companyCrunchbaseUrl!: string | undefined;
    companyBBBUrl!: string | undefined;
    companyPinterestUrl!: string | undefined;
    companyDomainUrl!: string | undefined;
    companyAlexaUrl!: string | undefined;
    companyOpenCorporatesUrl!: string | undefined;
    companyGlassDoorUrl!: string | undefined;
    companyTrustpilotUrl!: string | undefined;
    companyFollowersUrl!: string | undefined;
    companyYoutubeUrl!: string | undefined;
    companyYelpUrl!: string | undefined;
    companyRSSUrl!: string | undefined;
    companyNavUrl!: string | undefined;
    companyAngelListUrl!: string | undefined;
    companyCalendlyUrl!: string | undefined;
    companyZoomUrl!: string | undefined;
    companyOtherLinkUrl!: string | undefined;
    companyLogoUrl!: string | undefined;
    workPhone1!: string | undefined;
    workPhone1Ext!: string | undefined;
    workPhone2!: string | undefined;
    workPhone2Ext!: string | undefined;
    workEmail1!: string | undefined;
    workEmail2!: string | undefined;
    workEmail3!: string | undefined;
    workFullAddress!: ImportAddressInput | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IImportBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.organizationType = data["organizationType"];
            this.jobTitle = data["jobTitle"];
            this.isEmployed = data["isEmployed"];
            this.employmentStartDate = data["employmentStartDate"] ? moment(data["employmentStartDate"].toString()) : <any>undefined;
            this.employeeCount = data["employeeCount"];
            this.dateFounded = data["dateFounded"] ? moment(data["dateFounded"].toString()) : <any>undefined;
            this.ein = data["ein"];
            this.annualRevenue = data["annualRevenue"];
            this.industry = data["industry"];
            this.companyPhone = data["companyPhone"];
            this.companyPhoneExt = data["companyPhoneExt"];
            this.companyFaxNumber = data["companyFaxNumber"];
            this.companyEmail = data["companyEmail"];
            this.companyFullAddress = data["companyFullAddress"] ? ImportAddressInput.fromJS(data["companyFullAddress"]) : <any>undefined;
            this.companyWebSiteUrl = data["companyWebSiteUrl"];
            this.companyFacebookUrl = data["companyFacebookUrl"];
            this.companyLinkedInUrl = data["companyLinkedInUrl"];
            this.companyInstagramUrl = data["companyInstagramUrl"];
            this.companyTwitterUrl = data["companyTwitterUrl"];
            this.companyGooglePlusUrl = data["companyGooglePlusUrl"];
            this.companyCrunchbaseUrl = data["companyCrunchbaseUrl"];
            this.companyBBBUrl = data["companyBBBUrl"];
            this.companyPinterestUrl = data["companyPinterestUrl"];
            this.companyDomainUrl = data["companyDomainUrl"];
            this.companyAlexaUrl = data["companyAlexaUrl"];
            this.companyOpenCorporatesUrl = data["companyOpenCorporatesUrl"];
            this.companyGlassDoorUrl = data["companyGlassDoorUrl"];
            this.companyTrustpilotUrl = data["companyTrustpilotUrl"];
            this.companyFollowersUrl = data["companyFollowersUrl"];
            this.companyYoutubeUrl = data["companyYoutubeUrl"];
            this.companyYelpUrl = data["companyYelpUrl"];
            this.companyRSSUrl = data["companyRSSUrl"];
            this.companyNavUrl = data["companyNavUrl"];
            this.companyAngelListUrl = data["companyAngelListUrl"];
            this.companyCalendlyUrl = data["companyCalendlyUrl"];
            this.companyZoomUrl = data["companyZoomUrl"];
            this.companyOtherLinkUrl = data["companyOtherLinkUrl"];
            this.companyLogoUrl = data["companyLogoUrl"];
            this.workPhone1 = data["workPhone1"];
            this.workPhone1Ext = data["workPhone1Ext"];
            this.workPhone2 = data["workPhone2"];
            this.workPhone2Ext = data["workPhone2Ext"];
            this.workEmail1 = data["workEmail1"];
            this.workEmail2 = data["workEmail2"];
            this.workEmail3 = data["workEmail3"];
            this.workFullAddress = data["workFullAddress"] ? ImportAddressInput.fromJS(data["workFullAddress"]) : <any>undefined;
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): ImportBusinessInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["organizationType"] = this.organizationType;
        data["jobTitle"] = this.jobTitle;
        data["isEmployed"] = this.isEmployed;
        data["employmentStartDate"] = this.employmentStartDate ? this.employmentStartDate.toISOString() : <any>undefined;
        data["employeeCount"] = this.employeeCount;
        data["dateFounded"] = this.dateFounded ? this.dateFounded.toISOString() : <any>undefined;
        data["ein"] = this.ein;
        data["annualRevenue"] = this.annualRevenue;
        data["industry"] = this.industry;
        data["companyPhone"] = this.companyPhone;
        data["companyPhoneExt"] = this.companyPhoneExt;
        data["companyFaxNumber"] = this.companyFaxNumber;
        data["companyEmail"] = this.companyEmail;
        data["companyFullAddress"] = this.companyFullAddress ? this.companyFullAddress.toJSON() : <any>undefined;
        data["companyWebSiteUrl"] = this.companyWebSiteUrl;
        data["companyFacebookUrl"] = this.companyFacebookUrl;
        data["companyLinkedInUrl"] = this.companyLinkedInUrl;
        data["companyInstagramUrl"] = this.companyInstagramUrl;
        data["companyTwitterUrl"] = this.companyTwitterUrl;
        data["companyGooglePlusUrl"] = this.companyGooglePlusUrl;
        data["companyCrunchbaseUrl"] = this.companyCrunchbaseUrl;
        data["companyBBBUrl"] = this.companyBBBUrl;
        data["companyPinterestUrl"] = this.companyPinterestUrl;
        data["companyDomainUrl"] = this.companyDomainUrl;
        data["companyAlexaUrl"] = this.companyAlexaUrl;
        data["companyOpenCorporatesUrl"] = this.companyOpenCorporatesUrl;
        data["companyGlassDoorUrl"] = this.companyGlassDoorUrl;
        data["companyTrustpilotUrl"] = this.companyTrustpilotUrl;
        data["companyFollowersUrl"] = this.companyFollowersUrl;
        data["companyYoutubeUrl"] = this.companyYoutubeUrl;
        data["companyYelpUrl"] = this.companyYelpUrl;
        data["companyRSSUrl"] = this.companyRSSUrl;
        data["companyNavUrl"] = this.companyNavUrl;
        data["companyAngelListUrl"] = this.companyAngelListUrl;
        data["companyCalendlyUrl"] = this.companyCalendlyUrl;
        data["companyZoomUrl"] = this.companyZoomUrl;
        data["companyOtherLinkUrl"] = this.companyOtherLinkUrl;
        data["companyLogoUrl"] = this.companyLogoUrl;
        data["workPhone1"] = this.workPhone1;
        data["workPhone1Ext"] = this.workPhone1Ext;
        data["workPhone2"] = this.workPhone2;
        data["workPhone2Ext"] = this.workPhone2Ext;
        data["workEmail1"] = this.workEmail1;
        data["workEmail2"] = this.workEmail2;
        data["workEmail3"] = this.workEmail3;
        data["workFullAddress"] = this.workFullAddress ? this.workFullAddress.toJSON() : <any>undefined;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IImportBusinessInput {
    companyName: string | undefined;
    organizationType: string | undefined;
    jobTitle: string | undefined;
    isEmployed: boolean | undefined;
    employmentStartDate: moment.Moment | undefined;
    employeeCount: number | undefined;
    dateFounded: moment.Moment | undefined;
    ein: string | undefined;
    annualRevenue: number | undefined;
    industry: string | undefined;
    companyPhone: string | undefined;
    companyPhoneExt: string | undefined;
    companyFaxNumber: string | undefined;
    companyEmail: string | undefined;
    companyFullAddress: ImportAddressInput | undefined;
    companyWebSiteUrl: string | undefined;
    companyFacebookUrl: string | undefined;
    companyLinkedInUrl: string | undefined;
    companyInstagramUrl: string | undefined;
    companyTwitterUrl: string | undefined;
    companyGooglePlusUrl: string | undefined;
    companyCrunchbaseUrl: string | undefined;
    companyBBBUrl: string | undefined;
    companyPinterestUrl: string | undefined;
    companyDomainUrl: string | undefined;
    companyAlexaUrl: string | undefined;
    companyOpenCorporatesUrl: string | undefined;
    companyGlassDoorUrl: string | undefined;
    companyTrustpilotUrl: string | undefined;
    companyFollowersUrl: string | undefined;
    companyYoutubeUrl: string | undefined;
    companyYelpUrl: string | undefined;
    companyRSSUrl: string | undefined;
    companyNavUrl: string | undefined;
    companyAngelListUrl: string | undefined;
    companyCalendlyUrl: string | undefined;
    companyZoomUrl: string | undefined;
    companyOtherLinkUrl: string | undefined;
    companyLogoUrl: string | undefined;
    workPhone1: string | undefined;
    workPhone1Ext: string | undefined;
    workPhone2: string | undefined;
    workPhone2Ext: string | undefined;
    workEmail1: string | undefined;
    workEmail2: string | undefined;
    workEmail3: string | undefined;
    workFullAddress: ImportAddressInput | undefined;
    affiliateCode: string | undefined;
}

export class ImportPropertyInput implements IImportPropertyInput {
    leadType!: string | undefined;
    name!: string | undefined;
    note!: string | undefined;
    propertyAddress!: ImportAddressInput | undefined;

    constructor(data?: IImportPropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadType = data["leadType"];
            this.name = data["name"];
            this.note = data["note"];
            this.propertyAddress = data["propertyAddress"] ? ImportAddressInput.fromJS(data["propertyAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportPropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadType"] = this.leadType;
        data["name"] = this.name;
        data["note"] = this.note;
        data["propertyAddress"] = this.propertyAddress ? this.propertyAddress.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportPropertyInput {
    leadType: string | undefined;
    name: string | undefined;
    note: string | undefined;
    propertyAddress: ImportAddressInput | undefined;
}

export enum RecurringPaymentFrequency {
    Monthly = "Monthly", 
    Annual = "Annual", 
    LifeTime = "LifeTime", 
}

export class ImportSubscriptionInput implements IImportSubscriptionInput {
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    systemType!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    level!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IImportSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productCode = data["productCode"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.systemType = data["systemType"];
            this.code = data["code"];
            this.name = data["name"];
            this.level = data["level"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): ImportSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["systemType"] = this.systemType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IImportSubscriptionInput {
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    systemType: string | undefined;
    code: string | undefined;
    name: string | undefined;
    level: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export class ImportClassificationInput implements IImportClassificationInput {
    rating!: string | undefined;
    lists!: string[] | undefined;
    tags!: string[] | undefined;
    partnerTypeName!: string | undefined;

    constructor(data?: IImportClassificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rating = data["rating"];
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(item);
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            this.partnerTypeName = data["partnerTypeName"];
        }
    }

    static fromJS(data: any): ImportClassificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportClassificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rating"] = this.rating;
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["partnerTypeName"] = this.partnerTypeName;
        return data; 
    }
}

export interface IImportClassificationInput {
    rating: string | undefined;
    lists: string[] | undefined;
    tags: string[] | undefined;
    partnerTypeName: string | undefined;
}

export class ImportItemInput implements IImportItemInput {
    contactId!: number | undefined;
    contactXref!: string | undefined;
    userPassword!: string | undefined;
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    propertyInfo!: ImportPropertyInput | undefined;
    assignedUser!: string | undefined;
    followUpDate!: moment.Moment | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadStageName!: string | undefined;
    leadSource!: string | undefined;
    leadDealAmount!: number | undefined;
    affiliateCode!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;
    requestCustomInfo!: CustomFieldsInput | undefined;
    subscription1!: ImportSubscriptionInput | undefined;
    subscription2!: ImportSubscriptionInput | undefined;
    subscription3!: ImportSubscriptionInput | undefined;
    subscription4!: ImportSubscriptionInput | undefined;
    subscription5!: ImportSubscriptionInput | undefined;
    classificationInfo!: ImportClassificationInput | undefined;

    constructor(data?: IImportItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.contactXref = data["contactXref"];
            this.userPassword = data["userPassword"];
            this.personalInfo = data["personalInfo"] ? ImportPersonalInput.fromJS(data["personalInfo"]) : <any>undefined;
            this.businessInfo = data["businessInfo"] ? ImportBusinessInput.fromJS(data["businessInfo"]) : <any>undefined;
            this.propertyInfo = data["propertyInfo"] ? ImportPropertyInput.fromJS(data["propertyInfo"]) : <any>undefined;
            this.assignedUser = data["assignedUser"];
            this.followUpDate = data["followUpDate"] ? moment(data["followUpDate"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.leadStageName = data["leadStageName"];
            this.leadSource = data["leadSource"];
            this.leadDealAmount = data["leadDealAmount"];
            this.affiliateCode = data["affiliateCode"];
            this.campaignId = data["campaignId"];
            this.channelId = data["channelId"];
            this.gclId = data["gclId"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.utmSource = data["utmSource"];
            this.utmMedium = data["utmMedium"];
            this.utmCampaign = data["utmCampaign"];
            this.utmTerm = data["utmTerm"];
            this.utmContent = data["utmContent"];
            this.utmKeyword = data["utmKeyword"];
            this.utmAdGroup = data["utmAdGroup"];
            this.utmName = data["utmName"];
            this.requestCustomInfo = data["requestCustomInfo"] ? CustomFieldsInput.fromJS(data["requestCustomInfo"]) : <any>undefined;
            this.subscription1 = data["subscription1"] ? ImportSubscriptionInput.fromJS(data["subscription1"]) : <any>undefined;
            this.subscription2 = data["subscription2"] ? ImportSubscriptionInput.fromJS(data["subscription2"]) : <any>undefined;
            this.subscription3 = data["subscription3"] ? ImportSubscriptionInput.fromJS(data["subscription3"]) : <any>undefined;
            this.subscription4 = data["subscription4"] ? ImportSubscriptionInput.fromJS(data["subscription4"]) : <any>undefined;
            this.subscription5 = data["subscription5"] ? ImportSubscriptionInput.fromJS(data["subscription5"]) : <any>undefined;
            this.classificationInfo = data["classificationInfo"] ? ImportClassificationInput.fromJS(data["classificationInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["userPassword"] = this.userPassword;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["assignedUser"] = this.assignedUser;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadStageName"] = this.leadStageName;
        data["leadSource"] = this.leadSource;
        data["leadDealAmount"] = this.leadDealAmount;
        data["affiliateCode"] = this.affiliateCode;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        data["requestCustomInfo"] = this.requestCustomInfo ? this.requestCustomInfo.toJSON() : <any>undefined;
        data["subscription1"] = this.subscription1 ? this.subscription1.toJSON() : <any>undefined;
        data["subscription2"] = this.subscription2 ? this.subscription2.toJSON() : <any>undefined;
        data["subscription3"] = this.subscription3 ? this.subscription3.toJSON() : <any>undefined;
        data["subscription4"] = this.subscription4 ? this.subscription4.toJSON() : <any>undefined;
        data["subscription5"] = this.subscription5 ? this.subscription5.toJSON() : <any>undefined;
        data["classificationInfo"] = this.classificationInfo ? this.classificationInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportItemInput {
    contactId: number | undefined;
    contactXref: string | undefined;
    userPassword: string | undefined;
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    propertyInfo: ImportPropertyInput | undefined;
    assignedUser: string | undefined;
    followUpDate: moment.Moment | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadStageName: string | undefined;
    leadSource: string | undefined;
    leadDealAmount: number | undefined;
    affiliateCode: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
    requestCustomInfo: CustomFieldsInput | undefined;
    subscription1: ImportSubscriptionInput | undefined;
    subscription2: ImportSubscriptionInput | undefined;
    subscription3: ImportSubscriptionInput | undefined;
    subscription4: ImportSubscriptionInput | undefined;
    subscription5: ImportSubscriptionInput | undefined;
    classificationInfo: ImportClassificationInput | undefined;
}

export class ImportFieldInfoDto implements IImportFieldInfoDto {
    inputFieldName!: string;
    outputFieldName!: string;

    constructor(data?: IImportFieldInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputFieldName = data["inputFieldName"];
            this.outputFieldName = data["outputFieldName"];
        }
    }

    static fromJS(data: any): ImportFieldInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFieldInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputFieldName"] = this.inputFieldName;
        data["outputFieldName"] = this.outputFieldName;
        return data; 
    }
}

export interface IImportFieldInfoDto {
    inputFieldName: string;
    outputFieldName: string;
}

export enum ImportTypeInput {
    Lead = "Lead", 
    Client = "Client", 
    Partner = "Partner", 
    Investor = "Investor", 
    Vendor = "Vendor", 
    Employee = "Employee", 
    Other = "Other", 
    Order = "Order", 
}

export class ImportInput implements IImportInput {
    items!: ImportItemInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    tags!: ContactTagInput[] | undefined;
    fields!: ImportFieldInfoDto[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    starId!: number | undefined;
    leadStageId!: number | undefined;
    importType!: ImportTypeInput | undefined;
    partnerTypeName!: string | undefined;
    fileName!: string;
    fileSize!: number;
    fileContent!: string;
    ignoreInvalidValues!: boolean | undefined;
    sendWelcomeEmail!: boolean | undefined;
    welcomeEmailTemplateRef!: string | undefined;

    constructor(data?: IImportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ImportItemInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(ImportFieldInfoDto.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.starId = data["starId"];
            this.leadStageId = data["leadStageId"];
            this.importType = data["importType"];
            this.partnerTypeName = data["partnerTypeName"];
            this.fileName = data["fileName"];
            this.fileSize = data["fileSize"];
            this.fileContent = data["fileContent"];
            this.ignoreInvalidValues = data["ignoreInvalidValues"];
            this.sendWelcomeEmail = data["sendWelcomeEmail"];
            this.welcomeEmailTemplateRef = data["welcomeEmailTemplateRef"];
        }
    }

    static fromJS(data: any): ImportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["starId"] = this.starId;
        data["leadStageId"] = this.leadStageId;
        data["importType"] = this.importType;
        data["partnerTypeName"] = this.partnerTypeName;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileContent"] = this.fileContent;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        return data; 
    }
}

export interface IImportInput {
    items: ImportItemInput[] | undefined;
    lists: ContactListInput[] | undefined;
    tags: ContactTagInput[] | undefined;
    fields: ImportFieldInfoDto[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    starId: number | undefined;
    leadStageId: number | undefined;
    importType: ImportTypeInput | undefined;
    partnerTypeName: string | undefined;
    fileName: string;
    fileSize: number;
    fileContent: string;
    ignoreInvalidValues: boolean | undefined;
    sendWelcomeEmail: boolean | undefined;
    welcomeEmailTemplateRef: string | undefined;
}

export class GetImportStatusOutput implements IGetImportStatusOutput {
    id!: number | undefined;
    statusId!: string | undefined;
    fileName!: string | undefined;
    totalCount!: number | undefined;
    importedCount!: number | undefined;
    failedCount!: number | undefined;

    constructor(data?: IGetImportStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusId = data["statusId"];
            this.fileName = data["fileName"];
            this.totalCount = data["totalCount"];
            this.importedCount = data["importedCount"];
            this.failedCount = data["failedCount"];
        }
    }

    static fromJS(data: any): GetImportStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImportStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusId"] = this.statusId;
        data["fileName"] = this.fileName;
        data["totalCount"] = this.totalCount;
        data["importedCount"] = this.importedCount;
        data["failedCount"] = this.failedCount;
        return data; 
    }
}

export interface IGetImportStatusOutput {
    id: number | undefined;
    statusId: string | undefined;
    fileName: string | undefined;
    totalCount: number | undefined;
    importedCount: number | undefined;
    failedCount: number | undefined;
}

export class GetFileUrlOutput implements IGetFileUrlOutput {
    url!: string | undefined;
    validityPeriod!: string | undefined;

    constructor(data?: IGetFileUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriod = data["validityPeriod"];
        }
    }

    static fromJS(data: any): GetFileUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriod"] = this.validityPeriod;
        return data; 
    }
}

export interface IGetFileUrlOutput {
    url: string | undefined;
    validityPeriod: string | undefined;
}

export class ImportContactInput implements IImportContactInput {
    star!: string | undefined;
    importType!: ImportTypeInput | undefined;
    ignoreInvalidValues!: boolean | undefined;
    matchExisting!: boolean | undefined;
    overrideLists!: boolean | undefined;
    createUser!: boolean | undefined;
    sendWelcomeEmail!: boolean | undefined;
    welcomeEmailTemplateRef!: string | undefined;
    contactId!: number | undefined;
    contactXref!: string | undefined;
    userPassword!: string | undefined;
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    propertyInfo!: ImportPropertyInput | undefined;
    assignedUser!: string | undefined;
    followUpDate!: moment.Moment | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadStageName!: string | undefined;
    leadSource!: string | undefined;
    leadDealAmount!: number | undefined;
    affiliateCode!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;
    requestCustomInfo!: CustomFieldsInput | undefined;
    subscription1!: ImportSubscriptionInput | undefined;
    subscription2!: ImportSubscriptionInput | undefined;
    subscription3!: ImportSubscriptionInput | undefined;
    subscription4!: ImportSubscriptionInput | undefined;
    subscription5!: ImportSubscriptionInput | undefined;
    classificationInfo!: ImportClassificationInput | undefined;

    constructor(data?: IImportContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.overrideLists = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.star = data["star"];
            this.importType = data["importType"];
            this.ignoreInvalidValues = data["ignoreInvalidValues"];
            this.matchExisting = data["matchExisting"];
            this.overrideLists = data["overrideLists"] !== undefined ? data["overrideLists"] : false;
            this.createUser = data["createUser"];
            this.sendWelcomeEmail = data["sendWelcomeEmail"];
            this.welcomeEmailTemplateRef = data["welcomeEmailTemplateRef"];
            this.contactId = data["contactId"];
            this.contactXref = data["contactXref"];
            this.userPassword = data["userPassword"];
            this.personalInfo = data["personalInfo"] ? ImportPersonalInput.fromJS(data["personalInfo"]) : <any>undefined;
            this.businessInfo = data["businessInfo"] ? ImportBusinessInput.fromJS(data["businessInfo"]) : <any>undefined;
            this.propertyInfo = data["propertyInfo"] ? ImportPropertyInput.fromJS(data["propertyInfo"]) : <any>undefined;
            this.assignedUser = data["assignedUser"];
            this.followUpDate = data["followUpDate"] ? moment(data["followUpDate"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.leadStageName = data["leadStageName"];
            this.leadSource = data["leadSource"];
            this.leadDealAmount = data["leadDealAmount"];
            this.affiliateCode = data["affiliateCode"];
            this.campaignId = data["campaignId"];
            this.channelId = data["channelId"];
            this.gclId = data["gclId"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.utmSource = data["utmSource"];
            this.utmMedium = data["utmMedium"];
            this.utmCampaign = data["utmCampaign"];
            this.utmTerm = data["utmTerm"];
            this.utmContent = data["utmContent"];
            this.utmKeyword = data["utmKeyword"];
            this.utmAdGroup = data["utmAdGroup"];
            this.utmName = data["utmName"];
            this.requestCustomInfo = data["requestCustomInfo"] ? CustomFieldsInput.fromJS(data["requestCustomInfo"]) : <any>undefined;
            this.subscription1 = data["subscription1"] ? ImportSubscriptionInput.fromJS(data["subscription1"]) : <any>undefined;
            this.subscription2 = data["subscription2"] ? ImportSubscriptionInput.fromJS(data["subscription2"]) : <any>undefined;
            this.subscription3 = data["subscription3"] ? ImportSubscriptionInput.fromJS(data["subscription3"]) : <any>undefined;
            this.subscription4 = data["subscription4"] ? ImportSubscriptionInput.fromJS(data["subscription4"]) : <any>undefined;
            this.subscription5 = data["subscription5"] ? ImportSubscriptionInput.fromJS(data["subscription5"]) : <any>undefined;
            this.classificationInfo = data["classificationInfo"] ? ImportClassificationInput.fromJS(data["classificationInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["star"] = this.star;
        data["importType"] = this.importType;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        data["matchExisting"] = this.matchExisting;
        data["overrideLists"] = this.overrideLists;
        data["createUser"] = this.createUser;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["userPassword"] = this.userPassword;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["assignedUser"] = this.assignedUser;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadStageName"] = this.leadStageName;
        data["leadSource"] = this.leadSource;
        data["leadDealAmount"] = this.leadDealAmount;
        data["affiliateCode"] = this.affiliateCode;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        data["requestCustomInfo"] = this.requestCustomInfo ? this.requestCustomInfo.toJSON() : <any>undefined;
        data["subscription1"] = this.subscription1 ? this.subscription1.toJSON() : <any>undefined;
        data["subscription2"] = this.subscription2 ? this.subscription2.toJSON() : <any>undefined;
        data["subscription3"] = this.subscription3 ? this.subscription3.toJSON() : <any>undefined;
        data["subscription4"] = this.subscription4 ? this.subscription4.toJSON() : <any>undefined;
        data["subscription5"] = this.subscription5 ? this.subscription5.toJSON() : <any>undefined;
        data["classificationInfo"] = this.classificationInfo ? this.classificationInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportContactInput {
    star: string | undefined;
    importType: ImportTypeInput | undefined;
    ignoreInvalidValues: boolean | undefined;
    matchExisting: boolean | undefined;
    overrideLists: boolean | undefined;
    createUser: boolean | undefined;
    sendWelcomeEmail: boolean | undefined;
    welcomeEmailTemplateRef: string | undefined;
    contactId: number | undefined;
    contactXref: string | undefined;
    userPassword: string | undefined;
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    propertyInfo: ImportPropertyInput | undefined;
    assignedUser: string | undefined;
    followUpDate: moment.Moment | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadStageName: string | undefined;
    leadSource: string | undefined;
    leadDealAmount: number | undefined;
    affiliateCode: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
    requestCustomInfo: CustomFieldsInput | undefined;
    subscription1: ImportSubscriptionInput | undefined;
    subscription2: ImportSubscriptionInput | undefined;
    subscription3: ImportSubscriptionInput | undefined;
    subscription4: ImportSubscriptionInput | undefined;
    subscription5: ImportSubscriptionInput | undefined;
    classificationInfo: ImportClassificationInput | undefined;
}

export enum InstanceType {
    User = "User", 
    Main = "Main", 
}

export enum InstanceStatus {
    NotInitialized = "NotInitialized", 
    Active = "Active", 
    Inactive = "Inactive", 
}

export class GetStatusOutput implements IGetStatusOutput {
    status!: InstanceStatus | undefined;
    userId!: number | undefined;
    hasSyncAccounts!: boolean | undefined;
    hasTransactions!: boolean | undefined;
    hasAccountsAccess!: boolean | undefined;
    hasCategorizationSupported!: boolean | undefined;

    constructor(data?: IGetStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.userId = data["userId"];
            this.hasSyncAccounts = data["hasSyncAccounts"];
            this.hasTransactions = data["hasTransactions"];
            this.hasAccountsAccess = data["hasAccountsAccess"];
            this.hasCategorizationSupported = data["hasCategorizationSupported"];
        }
    }

    static fromJS(data: any): GetStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["hasSyncAccounts"] = this.hasSyncAccounts;
        data["hasTransactions"] = this.hasTransactions;
        data["hasAccountsAccess"] = this.hasAccountsAccess;
        data["hasCategorizationSupported"] = this.hasCategorizationSupported;
        return data; 
    }
}

export interface IGetStatusOutput {
    status: InstanceStatus | undefined;
    userId: number | undefined;
    hasSyncAccounts: boolean | undefined;
    hasTransactions: boolean | undefined;
    hasAccountsAccess: boolean | undefined;
    hasCategorizationSupported: boolean | undefined;
}

export enum AccountingTreeType {
    Simple = "Simple", 
    Standard = "Standard", 
}

export class SetupOutput implements ISetupOutput {
    userId!: number | undefined;
    alreadyInitialized!: boolean | undefined;

    constructor(data?: ISetupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.alreadyInitialized = data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): SetupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SetupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data; 
    }
}

export interface ISetupOutput {
    userId: number | undefined;
    alreadyInitialized: boolean | undefined;
}

export class RegisterMemberInput implements IRegisterMemberInput {
    contactId!: number;
    channelCode!: string;
    accountingTreeType!: AccountingTreeType | undefined;

    constructor(data?: IRegisterMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.channelCode = data["channelCode"];
            this.accountingTreeType = data["accountingTreeType"];
        }
    }

    static fromJS(data: any): RegisterMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["channelCode"] = this.channelCode;
        data["accountingTreeType"] = this.accountingTreeType;
        return data; 
    }
}

export interface IRegisterMemberInput {
    contactId: number;
    channelCode: string;
    accountingTreeType: AccountingTreeType | undefined;
}

export class RegisterMemberOutput implements IRegisterMemberOutput {
    userId!: number | undefined;
    alreadyInitialized!: boolean | undefined;

    constructor(data?: IRegisterMemberOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.alreadyInitialized = data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): RegisterMemberOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data; 
    }
}

export interface IRegisterMemberOutput {
    userId: number | undefined;
    alreadyInitialized: boolean | undefined;
}

export class GetUsersInfoDto implements IGetUsersInfoDto {
    userId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    startDate!: moment.Moment | undefined;

    constructor(data?: IGetUsersInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUsersInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetUsersInfoDto {
    userId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    startDate: moment.Moment | undefined;
}

export class AddUserInput implements IAddUserInput {
    userId!: number;
    sendInvitationEmail!: boolean | undefined;

    constructor(data?: IAddUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.sendInvitationEmail = data["sendInvitationEmail"];
        }
    }

    static fromJS(data: any): AddUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["sendInvitationEmail"] = this.sendInvitationEmail;
        return data; 
    }
}

export interface IAddUserInput {
    userId: number;
    sendInvitationEmail: boolean | undefined;
}

export class GetUserInstanceInfoOutput implements IGetUserInstanceInfoOutput {
    id!: number | undefined;
    status!: InstanceStatus | undefined;

    constructor(data?: IGetUserInstanceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): GetUserInstanceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserInstanceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IGetUserInstanceInfoOutput {
    id: number | undefined;
    status: InstanceStatus | undefined;
}

export enum InvoiceStatus {
    Draft = "Draft", 
    Final = "Final", 
    Sent = "Sent", 
    Paid = "Paid", 
    Canceled = "Canceled", 
    PartiallyPaid = "PartiallyPaid", 
    Refunded = "Refunded", 
}

export class InvoiceAddressInfo implements IInvoiceAddressInfo {
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    zip!: string | undefined;
    neighborhood!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    company!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    lastBillingDate!: moment.Moment | undefined;
    lastShippingDate!: moment.Moment | undefined;
    contactAddressId!: number | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IInvoiceAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.city = data["city"];
            this.zip = data["zip"];
            this.neighborhood = data["neighborhood"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.company = data["company"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.lastBillingDate = data["lastBillingDate"] ? moment(data["lastBillingDate"].toString()) : <any>undefined;
            this.lastShippingDate = data["lastShippingDate"] ? moment(data["lastShippingDate"].toString()) : <any>undefined;
            this.contactAddressId = data["contactAddressId"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): InvoiceAddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["zip"] = this.zip;
        data["neighborhood"] = this.neighborhood;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["company"] = this.company;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["lastBillingDate"] = this.lastBillingDate ? this.lastBillingDate.toISOString() : <any>undefined;
        data["lastShippingDate"] = this.lastShippingDate ? this.lastShippingDate.toISOString() : <any>undefined;
        data["contactAddressId"] = this.contactAddressId;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IInvoiceAddressInfo {
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    zip: string | undefined;
    neighborhood: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    company: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    lastBillingDate: moment.Moment | undefined;
    lastShippingDate: moment.Moment | undefined;
    contactAddressId: number | undefined;
    usageTypeId: string | undefined;
}

export enum ProductMeasurementUnit {
    Day = "Day", 
    Feet = "Feet", 
    Hour = "Hour", 
    Kilogram = "Kilogram", 
    Pound = "Pound", 
    Month = "Month", 
    Package = "Package", 
    Piece = "Piece", 
    Unit = "Unit", 
    Year = "Year", 
    Zone = "Zone", 
}

export enum ProductType {
    General = "General", 
    Subscription = "Subscription", 
}

export class InvoiceLineInfo implements IInvoiceLineInfo {
    id!: number | undefined;
    quantity!: number | undefined;
    rate!: number | undefined;
    unitId!: ProductMeasurementUnit | undefined;
    unitName!: string | undefined;
    total!: number | undefined;
    commissionableAmount!: number | undefined;
    description!: string | undefined;
    sortOrder!: number | undefined;
    productCode!: string | undefined;
    productName!: string | undefined;
    productType!: ProductType | undefined;
    subscriptionXref!: string | undefined;

    constructor(data?: IInvoiceLineInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.total = data["total"];
            this.commissionableAmount = data["commissionableAmount"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productType = data["productType"];
            this.subscriptionXref = data["subscriptionXref"];
        }
    }

    static fromJS(data: any): InvoiceLineInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productType"] = this.productType;
        data["subscriptionXref"] = this.subscriptionXref;
        return data; 
    }
}

export interface IInvoiceLineInfo {
    id: number | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    unitId: ProductMeasurementUnit | undefined;
    unitName: string | undefined;
    total: number | undefined;
    commissionableAmount: number | undefined;
    description: string | undefined;
    sortOrder: number | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productType: ProductType | undefined;
    subscriptionXref: string | undefined;
}

export class InvoiceInfo implements IInvoiceInfo {
    contactName!: string | undefined;
    orderNumber!: string | undefined;
    id!: number | undefined;
    status!: InvoiceStatus | undefined;
    number!: string | undefined;
    date!: moment.Moment | undefined;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number | undefined;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInfo | undefined;
    shippingAddress!: InvoiceAddressInfo | undefined;
    description!: string | undefined;
    note!: string | undefined;
    validationErrors!: string | undefined;
    lines!: InvoiceLineInfo[] | undefined;

    constructor(data?: IInvoiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactName = data["contactName"];
            this.orderNumber = data["orderNumber"];
            this.id = data["id"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = data["grandTotal"];
            this.discountTotal = data["discountTotal"];
            this.shippingTotal = data["shippingTotal"];
            this.taxTotal = data["taxTotal"];
            this.billingAddress = data["billingAddress"] ? InvoiceAddressInfo.fromJS(data["billingAddress"]) : <any>undefined;
            this.shippingAddress = data["shippingAddress"] ? InvoiceAddressInfo.fromJS(data["shippingAddress"]) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            this.validationErrors = data["validationErrors"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLineInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["orderNumber"] = this.orderNumber;
        data["id"] = this.id;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        data["validationErrors"] = this.validationErrors;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoiceInfo {
    contactName: string | undefined;
    orderNumber: string | undefined;
    id: number | undefined;
    status: InvoiceStatus | undefined;
    number: string | undefined;
    date: moment.Moment | undefined;
    dueDate: moment.Moment | undefined;
    grandTotal: number | undefined;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInfo | undefined;
    shippingAddress: InvoiceAddressInfo | undefined;
    description: string | undefined;
    note: string | undefined;
    validationErrors: string | undefined;
    lines: InvoiceLineInfo[] | undefined;
}

export class InvoiceAddressInput implements IInvoiceAddressInput {
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    zip!: string | undefined;
    neighborhood!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    company!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;

    constructor(data?: IInvoiceAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.city = data["city"];
            this.zip = data["zip"];
            this.neighborhood = data["neighborhood"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.company = data["company"];
            this.email = data["email"];
            this.phone = data["phone"];
        }
    }

    static fromJS(data: any): InvoiceAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["zip"] = this.zip;
        data["neighborhood"] = this.neighborhood;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["company"] = this.company;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data; 
    }
}

export interface IInvoiceAddressInput {
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    zip: string | undefined;
    neighborhood: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    company: string | undefined;
    email: string | undefined;
    phone: string | undefined;
}

export class CreateInvoiceLineInput implements ICreateInvoiceLineInput {
    quantity!: number;
    rate!: number;
    total!: number;
    commissionableAmount!: number | undefined;
    unitId!: ProductMeasurementUnit;
    productCode!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: ICreateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.total = data["total"];
            this.commissionableAmount = data["commissionableAmount"];
            this.unitId = data["unitId"];
            this.productCode = data["productCode"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["unitId"] = this.unitId;
        data["productCode"] = this.productCode;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateInvoiceLineInput {
    quantity: number;
    rate: number;
    total: number;
    commissionableAmount: number | undefined;
    unitId: ProductMeasurementUnit;
    productCode: string | undefined;
    description: string | undefined;
    sortOrder: number;
}

export class CreateInvoiceInput implements ICreateInvoiceInput {
    contactId!: number;
    groupId!: string | undefined;
    orderId!: number | undefined;
    orderNumber!: string | undefined;
    leadId!: number | undefined;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInput | undefined;
    shippingAddress!: InvoiceAddressInput | undefined;
    description!: string | undefined;
    note!: string | undefined;
    lines!: CreateInvoiceLineInput[] | undefined;
    bypassValidation!: boolean | undefined;

    constructor(data?: ICreateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.groupId = data["groupId"];
            this.orderId = data["orderId"];
            this.orderNumber = data["orderNumber"];
            this.leadId = data["leadId"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = data["grandTotal"];
            this.discountTotal = data["discountTotal"];
            this.shippingTotal = data["shippingTotal"];
            this.taxTotal = data["taxTotal"];
            this.billingAddress = data["billingAddress"] ? InvoiceAddressInput.fromJS(data["billingAddress"]) : <any>undefined;
            this.shippingAddress = data["shippingAddress"] ? InvoiceAddressInput.fromJS(data["shippingAddress"]) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(CreateInvoiceLineInput.fromJS(item));
            }
            this.bypassValidation = data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["groupId"] = this.groupId;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["leadId"] = this.leadId;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["bypassValidation"] = this.bypassValidation;
        return data; 
    }
}

export interface ICreateInvoiceInput {
    contactId: number;
    groupId: string | undefined;
    orderId: number | undefined;
    orderNumber: string | undefined;
    leadId: number | undefined;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment | undefined;
    grandTotal: number;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInput | undefined;
    shippingAddress: InvoiceAddressInput | undefined;
    description: string | undefined;
    note: string | undefined;
    lines: CreateInvoiceLineInput[] | undefined;
    bypassValidation: boolean | undefined;
}

export class UpdateInvoiceLineInput implements IUpdateInvoiceLineInput {
    id!: number | undefined;
    quantity!: number;
    rate!: number;
    total!: number;
    commissionableAmount!: number | undefined;
    unitId!: ProductMeasurementUnit;
    productCode!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: IUpdateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.total = data["total"];
            this.commissionableAmount = data["commissionableAmount"];
            this.unitId = data["unitId"];
            this.productCode = data["productCode"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["total"] = this.total;
        data["commissionableAmount"] = this.commissionableAmount;
        data["unitId"] = this.unitId;
        data["productCode"] = this.productCode;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateInvoiceLineInput {
    id: number | undefined;
    quantity: number;
    rate: number;
    total: number;
    commissionableAmount: number | undefined;
    unitId: ProductMeasurementUnit;
    productCode: string | undefined;
    description: string | undefined;
    sortOrder: number;
}

export class UpdateInvoiceInput implements IUpdateInvoiceInput {
    id!: number;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment | undefined;
    grandTotal!: number;
    discountTotal!: number | undefined;
    shippingTotal!: number | undefined;
    taxTotal!: number | undefined;
    billingAddress!: InvoiceAddressInput | undefined;
    shippingAddress!: InvoiceAddressInput | undefined;
    description!: string | undefined;
    note!: string | undefined;
    lines!: UpdateInvoiceLineInput[] | undefined;
    bypassValidation!: boolean | undefined;

    constructor(data?: IUpdateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.grandTotal = data["grandTotal"];
            this.discountTotal = data["discountTotal"];
            this.shippingTotal = data["shippingTotal"];
            this.taxTotal = data["taxTotal"];
            this.billingAddress = data["billingAddress"] ? InvoiceAddressInput.fromJS(data["billingAddress"]) : <any>undefined;
            this.shippingAddress = data["shippingAddress"] ? InvoiceAddressInput.fromJS(data["shippingAddress"]) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(UpdateInvoiceLineInput.fromJS(item));
            }
            this.bypassValidation = data["bypassValidation"];
        }
    }

    static fromJS(data: any): UpdateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["grandTotal"] = this.grandTotal;
        data["discountTotal"] = this.discountTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["taxTotal"] = this.taxTotal;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["bypassValidation"] = this.bypassValidation;
        return data; 
    }
}

export interface IUpdateInvoiceInput {
    id: number;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment | undefined;
    grandTotal: number;
    discountTotal: number | undefined;
    shippingTotal: number | undefined;
    taxTotal: number | undefined;
    billingAddress: InvoiceAddressInput | undefined;
    shippingAddress: InvoiceAddressInput | undefined;
    description: string | undefined;
    note: string | undefined;
    lines: UpdateInvoiceLineInput[] | undefined;
    bypassValidation: boolean | undefined;
}

export class UpdateInvoiceStatusInput implements IUpdateInvoiceStatusInput {
    id!: number;
    status!: InvoiceStatus;
    emailId!: number | undefined;

    constructor(data?: IUpdateInvoiceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
            this.emailId = data["emailId"];
        }
    }

    static fromJS(data: any): UpdateInvoiceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["emailId"] = this.emailId;
        return data; 
    }
}

export interface IUpdateInvoiceStatusInput {
    id: number;
    status: InvoiceStatus;
    emailId: number | undefined;
}

export class GetNewInvoiceInfoOutput implements IGetNewInvoiceInfoOutput {
    nextInvoiceNumber!: string | undefined;

    constructor(data?: IGetNewInvoiceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nextInvoiceNumber = data["nextInvoiceNumber"];
        }
    }

    static fromJS(data: any): GetNewInvoiceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNewInvoiceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextInvoiceNumber"] = this.nextInvoiceNumber;
        return data; 
    }
}

export interface IGetNewInvoiceInfoOutput {
    nextInvoiceNumber: string | undefined;
}

export enum PaymentTransactionType {
    Authorize = "Authorize", 
    Capture = "Capture", 
    Refund = "Refund", 
    Chargeback = "Chargeback", 
    Sale = "Sale", 
    Manual = "Manual", 
}

export class BankCardInput implements IBankCardInput {
    holderName!: string | undefined;
    cardNumber!: string;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingCountryCode!: string | undefined;

    constructor(data?: IBankCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingCountryCode = data["billingCountryCode"];
        }
    }

    static fromJS(data: any): BankCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingCountryCode"] = this.billingCountryCode;
        return data; 
    }
}

export interface IBankCardInput {
    holderName: string | undefined;
    cardNumber: string;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingCountryCode: string | undefined;
}

export class AddBankCardPaymentInput implements IAddBankCardPaymentInput {
    invoiceId!: number | undefined;
    invoiceNumber!: string | undefined;
    date!: moment.Moment | undefined;
    description!: string | undefined;
    orderStage!: string | undefined;
    amount!: number | undefined;
    gatewayName!: string | undefined;
    gatewayTransactionId!: string | undefined;
    gatewayOriginTransactionId!: string | undefined;
    authorizationCode!: string | undefined;
    transactionType!: PaymentTransactionType | undefined;
    bankCardInfo!: BankCardInput | undefined;
    hasRecurringBilling!: boolean | undefined;

    constructor(data?: IAddBankCardPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceId = data["invoiceId"];
            this.invoiceNumber = data["invoiceNumber"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.description = data["description"];
            this.orderStage = data["orderStage"];
            this.amount = data["amount"];
            this.gatewayName = data["gatewayName"];
            this.gatewayTransactionId = data["gatewayTransactionId"];
            this.gatewayOriginTransactionId = data["gatewayOriginTransactionId"];
            this.authorizationCode = data["authorizationCode"];
            this.transactionType = data["transactionType"];
            this.bankCardInfo = data["bankCardInfo"] ? BankCardInput.fromJS(data["bankCardInfo"]) : <any>undefined;
            this.hasRecurringBilling = data["hasRecurringBilling"];
        }
    }

    static fromJS(data: any): AddBankCardPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddBankCardPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["orderStage"] = this.orderStage;
        data["amount"] = this.amount;
        data["gatewayName"] = this.gatewayName;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["gatewayOriginTransactionId"] = this.gatewayOriginTransactionId;
        data["authorizationCode"] = this.authorizationCode;
        data["transactionType"] = this.transactionType;
        data["bankCardInfo"] = this.bankCardInfo ? this.bankCardInfo.toJSON() : <any>undefined;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        return data; 
    }
}

export interface IAddBankCardPaymentInput {
    invoiceId: number | undefined;
    invoiceNumber: string | undefined;
    date: moment.Moment | undefined;
    description: string | undefined;
    orderStage: string | undefined;
    amount: number | undefined;
    gatewayName: string | undefined;
    gatewayTransactionId: string | undefined;
    gatewayOriginTransactionId: string | undefined;
    authorizationCode: string | undefined;
    transactionType: PaymentTransactionType | undefined;
    bankCardInfo: BankCardInput | undefined;
    hasRecurringBilling: boolean | undefined;
}

export class VoidBankCardPaymentInput implements IVoidBankCardPaymentInput {
    invoiceId!: number | undefined;
    invoiceNumber!: string | undefined;
    transactionId!: number | undefined;
    gatewayName!: string | undefined;
    gatewayTransactionId!: string | undefined;

    constructor(data?: IVoidBankCardPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceId = data["invoiceId"];
            this.invoiceNumber = data["invoiceNumber"];
            this.transactionId = data["transactionId"];
            this.gatewayName = data["gatewayName"];
            this.gatewayTransactionId = data["gatewayTransactionId"];
        }
    }

    static fromJS(data: any): VoidBankCardPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new VoidBankCardPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["transactionId"] = this.transactionId;
        data["gatewayName"] = this.gatewayName;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        return data; 
    }
}

export interface IVoidBankCardPaymentInput {
    invoiceId: number | undefined;
    invoiceNumber: string | undefined;
    transactionId: number | undefined;
    gatewayName: string | undefined;
    gatewayTransactionId: string | undefined;
}

export class RequestKBAInput implements IRequestKBAInput {
    redirectUrl!: string;
    cssUrl!: string | undefined;

    constructor(data?: IRequestKBAInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.redirectUrl = data["redirectUrl"];
            this.cssUrl = data["cssUrl"];
        }
    }

    static fromJS(data: any): RequestKBAInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["cssUrl"] = this.cssUrl;
        return data; 
    }
}

export interface IRequestKBAInput {
    redirectUrl: string;
    cssUrl: string | undefined;
}

export class RequestKBAOutput implements IRequestKBAOutput {
    kbaAlreadyPassed!: boolean | undefined;
    kbaUrl!: string | undefined;

    constructor(data?: IRequestKBAOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kbaAlreadyPassed = data["kbaAlreadyPassed"];
            this.kbaUrl = data["kbaUrl"];
        }
    }

    static fromJS(data: any): RequestKBAOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kbaAlreadyPassed"] = this.kbaAlreadyPassed;
        data["kbaUrl"] = this.kbaUrl;
        return data; 
    }
}

export interface IRequestKBAOutput {
    kbaAlreadyPassed: boolean | undefined;
    kbaUrl: string | undefined;
}

export class KBAResult implements IKBAResult {
    memberId!: string;
    passed!: boolean;
    error!: string | undefined;

    constructor(data?: IKBAResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.passed = data["passed"];
            this.error = data["error"];
        }
    }

    static fromJS(data: any): KBAResult {
        data = typeof data === 'object' ? data : {};
        let result = new KBAResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["passed"] = this.passed;
        data["error"] = this.error;
        return data; 
    }
}

export interface IKBAResult {
    memberId: string;
    passed: boolean;
    error: string | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LanguageTextListDtoPagedResultDto implements ILanguageTextListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: ILanguageTextListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LanguageTextListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILanguageTextListDtoPagedResultDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class CancelLeadInput implements ICancelLeadInput {
    leadId!: number;
    cancellationReasonId!: string;
    comment!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICancelLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.cancellationReasonId = data["cancellationReasonId"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CancelLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["cancellationReasonId"] = this.cancellationReasonId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICancelLeadInput {
    leadId: number;
    cancellationReasonId: string;
    comment: string | undefined;
    sortOrder: number | undefined;
}

export class LeadCancellationReasonDto implements ILeadCancellationReasonDto {
    id!: string | undefined;
    name!: string | undefined;
    isCommentRequired!: boolean | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ILeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCommentRequired = data["isCommentRequired"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): LeadCancellationReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCommentRequired"] = this.isCommentRequired;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ILeadCancellationReasonDto {
    id: string | undefined;
    name: string | undefined;
    isCommentRequired: boolean | undefined;
    sortOrder: number | undefined;
}

export class LeadCancellationReasonDtoListResultDto implements ILeadCancellationReasonDtoListResultDto {
    items!: LeadCancellationReasonDto[] | undefined;

    constructor(data?: ILeadCancellationReasonDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LeadCancellationReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeadCancellationReasonDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReasonDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILeadCancellationReasonDtoListResultDto {
    items: LeadCancellationReasonDto[] | undefined;
}

export class CreateOrUpdateLeadInput implements ICreateOrUpdateLeadInput {
    contactId!: number | undefined;
    contactXRef!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers!: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses!: CreateContactAddressInputWithoutCheck[] | undefined;
    links!: CreateContactLinkInputWithoutCheck[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    bankCodeSource!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    sourceContactId!: number | undefined;
    sourceOrganizationUnitId!: number | undefined;
    personAffiliateCode!: string | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    isActive!: boolean | undefined;
    isProspective!: boolean | undefined;
    statusId!: string | undefined;
    partnerTypeName!: string | undefined;
    leadTypeId!: number | undefined;
    leadTypeSysId!: string | undefined;
    stageId!: number | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;
    followUpDate!: moment.Moment | undefined;
    trackingInfo!: TrackingInfo | undefined;
    inviteUser!: boolean | undefined;
    generateAutoLoginLink!: boolean | undefined;
    newUserPassword!: string | undefined;
    changeNewUserPasswordOnNextLogin!: boolean | undefined;
    noWelcomeEmail!: boolean | undefined;
    welcomeEmailTemplateRef!: string | undefined;
    propertyInfo!: PropertyInput | undefined;
    bypassValidation!: boolean | undefined;

    constructor(data?: ICreateOrUpdateLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.contactXRef = data["contactXRef"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(CreateContactEmailInputWithoutCheck.fromJS(item));
            }
            if (data["phoneNumbers"] && data["phoneNumbers"].constructor === Array) {
                this.phoneNumbers = [];
                for (let item of data["phoneNumbers"])
                    this.phoneNumbers.push(CreateContactPhoneInputWithoutCheck.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(CreateContactAddressInputWithoutCheck.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(CreateContactLinkInputWithoutCheck.fromJS(item));
            }
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.bankCode = data["bankCode"];
            this.bankCodeSource = data["bankCodeSource"];
            this.gender = data["gender"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.note = data["note"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.companyName = data["companyName"];
            this.industry = data["industry"];
            this.photo = data["photo"] ? ContactPhotoInput.fromJS(data["photo"]) : <any>undefined;
            this.sourceContactId = data["sourceContactId"];
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
            this.personAffiliateCode = data["personAffiliateCode"];
            this.title = data["title"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.contactGroupId = data["contactGroupId"];
            this.isActive = data["isActive"];
            this.isProspective = data["isProspective"];
            this.statusId = data["statusId"];
            this.partnerTypeName = data["partnerTypeName"];
            this.leadTypeId = data["leadTypeId"];
            this.leadTypeSysId = data["leadTypeSysId"];
            this.stageId = data["stageId"];
            this.dealAmount = data["dealAmount"];
            this.installmentAmount = data["installmentAmount"];
            this.followUpDate = data["followUpDate"] ? moment(data["followUpDate"].toString()) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
            this.inviteUser = data["inviteUser"];
            this.generateAutoLoginLink = data["generateAutoLoginLink"];
            this.newUserPassword = data["newUserPassword"];
            this.changeNewUserPasswordOnNextLogin = data["changeNewUserPasswordOnNextLogin"];
            this.noWelcomeEmail = data["noWelcomeEmail"];
            this.welcomeEmailTemplateRef = data["welcomeEmailTemplateRef"];
            this.propertyInfo = data["propertyInfo"] ? PropertyInput.fromJS(data["propertyInfo"]) : <any>undefined;
            this.bypassValidation = data["bypassValidation"];
        }
    }

    static fromJS(data: any): CreateOrUpdateLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXRef"] = this.contactXRef;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (this.phoneNumbers && this.phoneNumbers.constructor === Array) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["bankCodeSource"] = this.bankCodeSource;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["personAffiliateCode"] = this.personAffiliateCode;
        data["title"] = this.title;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["isActive"] = this.isActive;
        data["isProspective"] = this.isProspective;
        data["statusId"] = this.statusId;
        data["partnerTypeName"] = this.partnerTypeName;
        data["leadTypeId"] = this.leadTypeId;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["stageId"] = this.stageId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        data["followUpDate"] = this.followUpDate ? this.followUpDate.toISOString() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        data["inviteUser"] = this.inviteUser;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        data["newUserPassword"] = this.newUserPassword;
        data["changeNewUserPasswordOnNextLogin"] = this.changeNewUserPasswordOnNextLogin;
        data["noWelcomeEmail"] = this.noWelcomeEmail;
        data["welcomeEmailTemplateRef"] = this.welcomeEmailTemplateRef;
        data["propertyInfo"] = this.propertyInfo ? this.propertyInfo.toJSON() : <any>undefined;
        data["bypassValidation"] = this.bypassValidation;
        return data; 
    }
}

export interface ICreateOrUpdateLeadInput {
    contactId: number | undefined;
    contactXRef: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInputWithoutCheck[] | undefined;
    phoneNumbers: CreateContactPhoneInputWithoutCheck[] | undefined;
    addresses: CreateContactAddressInputWithoutCheck[] | undefined;
    links: CreateContactLinkInputWithoutCheck[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    bankCodeSource: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    sourceContactId: number | undefined;
    sourceOrganizationUnitId: number | undefined;
    personAffiliateCode: string | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    isActive: boolean | undefined;
    isProspective: boolean | undefined;
    statusId: string | undefined;
    partnerTypeName: string | undefined;
    leadTypeId: number | undefined;
    leadTypeSysId: string | undefined;
    stageId: number | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
    followUpDate: moment.Moment | undefined;
    trackingInfo: TrackingInfo | undefined;
    inviteUser: boolean | undefined;
    generateAutoLoginLink: boolean | undefined;
    newUserPassword: string | undefined;
    changeNewUserPasswordOnNextLogin: boolean | undefined;
    noWelcomeEmail: boolean | undefined;
    welcomeEmailTemplateRef: string | undefined;
    propertyInfo: PropertyInput | undefined;
    bypassValidation: boolean | undefined;
}

export class CreateOrUpdateLeadOutput implements ICreateOrUpdateLeadOutput {
    contactId!: number | undefined;
    leadId!: number | undefined;
    userId!: number | undefined;
    userKey!: string | undefined;
    userEmailAddress!: string | undefined;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateOrUpdateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.leadId = data["leadId"];
            this.userId = data["userId"];
            this.userKey = data["userKey"];
            this.userEmailAddress = data["userEmailAddress"];
            this.autoLoginLink = data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateOrUpdateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["leadId"] = this.leadId;
        data["userId"] = this.userId;
        data["userKey"] = this.userKey;
        data["userEmailAddress"] = this.userEmailAddress;
        data["autoLoginLink"] = this.autoLoginLink;
        return data; 
    }
}

export interface ICreateOrUpdateLeadOutput {
    contactId: number | undefined;
    leadId: number | undefined;
    userId: number | undefined;
    userKey: string | undefined;
    userEmailAddress: string | undefined;
    autoLoginLink: string | undefined;
}

export enum PaymentPeriodType {
    Monthly = "Monthly", 
    Annual = "Annual", 
    LifeTime = "LifeTime", 
}

export class PackageInfoDto implements IPackageInfoDto {
    module!: ModuleType;
    packageName!: string;
    seatCount!: number;

    constructor(data?: IPackageInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.module = data["module"];
            this.packageName = data["packageName"];
            this.seatCount = data["seatCount"];
        }
    }

    static fromJS(data: any): PackageInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["packageName"] = this.packageName;
        data["seatCount"] = this.seatCount;
        return data; 
    }
}

export interface IPackageInfoDto {
    module: ModuleType;
    packageName: string;
    seatCount: number;
}

export class SubmitTenancyRequestInput implements ISubmitTenancyRequestInput {
    companyName!: string | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    packages!: PackageInfoDto[] | undefined;
    website!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    stage!: string | undefined;
    tag!: string | undefined;
    leadRequestXref!: string | undefined;
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    phoneExt!: string | undefined;
    comments!: string | undefined;
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    isHelpNeeded!: boolean | undefined;

    constructor(data?: ISubmitTenancyRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["packages"] && data["packages"].constructor === Array) {
                this.packages = [];
                for (let item of data["packages"])
                    this.packages.push(PackageInfoDto.fromJS(item));
            }
            this.website = data["website"];
            this.city = data["city"];
            this.state = data["state"];
            this.stage = data["stage"];
            this.tag = data["tag"];
            this.leadRequestXref = data["leadRequestXref"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.phoneExt = data["phoneExt"];
            this.comments = data["comments"];
            this.sourceCode = data["sourceCode"];
            this.channelCode = data["channelCode"];
            this.affiliateCode = data["affiliateCode"];
            this.isHelpNeeded = data["isHelpNeeded"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.packages && this.packages.constructor === Array) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        data["website"] = this.website;
        data["city"] = this.city;
        data["state"] = this.state;
        data["stage"] = this.stage;
        data["tag"] = this.tag;
        data["leadRequestXref"] = this.leadRequestXref;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["isHelpNeeded"] = this.isHelpNeeded;
        return data; 
    }
}

export interface ISubmitTenancyRequestInput {
    companyName: string | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    packages: PackageInfoDto[] | undefined;
    website: string | undefined;
    city: string | undefined;
    state: string | undefined;
    stage: string | undefined;
    tag: string | undefined;
    leadRequestXref: string | undefined;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    phoneExt: string | undefined;
    comments: string | undefined;
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    isHelpNeeded: boolean | undefined;
}

export class SubmitTenancyRequestOutput implements ISubmitTenancyRequestOutput {
    leadRequestXref!: string | undefined;
    contactId!: number | undefined;

    constructor(data?: ISubmitTenancyRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.contactId = data["contactId"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["contactId"] = this.contactId;
        return data; 
    }
}

export interface ISubmitTenancyRequestOutput {
    leadRequestXref: string | undefined;
    contactId: number | undefined;
}

export class SubmitFreeTrialRequestInput implements ISubmitFreeTrialRequestInput {
    contactGroupId!: string | undefined;
    email!: string;
    tag!: string | undefined;

    constructor(data?: ISubmitFreeTrialRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactGroupId = data["contactGroupId"];
            this.email = data["email"];
            this.tag = data["tag"];
        }
    }

    static fromJS(data: any): SubmitFreeTrialRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitFreeTrialRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactGroupId"] = this.contactGroupId;
        data["email"] = this.email;
        data["tag"] = this.tag;
        return data; 
    }
}

export interface ISubmitFreeTrialRequestInput {
    contactGroupId: string | undefined;
    email: string;
    tag: string | undefined;
}

export class SubmitClientRequestInput implements ISubmitClientRequestInput {
    tenancyName!: string;
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;
    countryName!: string | undefined;
    zip!: string | undefined;
    customContactInfo!: CustomFieldsInput | undefined;
    customRequestInfo!: CustomFieldsInput | undefined;
    leadRequestXref!: string | undefined;
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    phoneExt!: string | undefined;
    comments!: string | undefined;
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    isHelpNeeded!: boolean | undefined;

    constructor(data?: ISubmitClientRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.countryId = data["countryId"];
            this.countryName = data["countryName"];
            this.zip = data["zip"];
            this.customContactInfo = data["customContactInfo"] ? CustomFieldsInput.fromJS(data["customContactInfo"]) : <any>undefined;
            this.customRequestInfo = data["customRequestInfo"] ? CustomFieldsInput.fromJS(data["customRequestInfo"]) : <any>undefined;
            this.leadRequestXref = data["leadRequestXref"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.phoneExt = data["phoneExt"];
            this.comments = data["comments"];
            this.sourceCode = data["sourceCode"];
            this.channelCode = data["channelCode"];
            this.affiliateCode = data["affiliateCode"];
            this.isHelpNeeded = data["isHelpNeeded"];
        }
    }

    static fromJS(data: any): SubmitClientRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitClientRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["zip"] = this.zip;
        data["customContactInfo"] = this.customContactInfo ? this.customContactInfo.toJSON() : <any>undefined;
        data["customRequestInfo"] = this.customRequestInfo ? this.customRequestInfo.toJSON() : <any>undefined;
        data["leadRequestXref"] = this.leadRequestXref;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["isHelpNeeded"] = this.isHelpNeeded;
        return data; 
    }
}

export interface ISubmitClientRequestInput {
    tenancyName: string;
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
    countryName: string | undefined;
    zip: string | undefined;
    customContactInfo: CustomFieldsInput | undefined;
    customRequestInfo: CustomFieldsInput | undefined;
    leadRequestXref: string | undefined;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    phoneExt: string | undefined;
    comments: string | undefined;
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    isHelpNeeded: boolean | undefined;
}

export class UpdateLeadStageInput implements IUpdateLeadStageInput {
    leadId!: number;
    stageId!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean | undefined;
    allowPipelineChange!: boolean | undefined;

    constructor(data?: IUpdateLeadStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
            this.ignoreChecklist = data["ignoreChecklist"];
            this.allowPipelineChange = data["allowPipelineChange"];
        }
    }

    static fromJS(data: any): UpdateLeadStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        data["allowPipelineChange"] = this.allowPipelineChange;
        return data; 
    }
}

export interface IUpdateLeadStageInput {
    leadId: number;
    stageId: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean | undefined;
    allowPipelineChange: boolean | undefined;
}

export class UpdateLeadStagePointInput implements IUpdateLeadStagePointInput {
    leadId!: number;
    pointId!: number;
    isDone!: boolean;

    constructor(data?: IUpdateLeadStagePointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.pointId = data["pointId"];
            this.isDone = data["isDone"];
        }
    }

    static fromJS(data: any): UpdateLeadStagePointInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadStagePointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["pointId"] = this.pointId;
        data["isDone"] = this.isDone;
        return data; 
    }
}

export interface IUpdateLeadStagePointInput {
    leadId: number;
    pointId: number;
    isDone: boolean;
}

export class ProcessLeadInput implements IProcessLeadInput {
    leadId!: number;
    orderStageId!: number | undefined;
    amount!: number | undefined;
    comment!: string | undefined;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean | undefined;

    constructor(data?: IProcessLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.orderStageId = data["orderStageId"];
            this.amount = data["amount"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
            this.ignoreChecklist = data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): ProcessLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["orderStageId"] = this.orderStageId;
        data["amount"] = this.amount;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data; 
    }
}

export interface IProcessLeadInput {
    leadId: number;
    orderStageId: number | undefined;
    amount: number | undefined;
    comment: string | undefined;
    sortOrder: number | undefined;
    ignoreChecklist: boolean | undefined;
}

export class LeadInfoDto implements ILeadInfoDto {
    id!: number | undefined;
    contactGroupId!: string | undefined;
    typeId!: number | undefined;
    typeName!: string | undefined;
    typeSysId!: string | undefined;
    pipelineId!: number | undefined;
    stageId!: number | undefined;
    stage!: string | undefined;
    dealAmount!: number | undefined;
    creationDate!: moment.Moment | undefined;
    modificationDate!: moment.Moment | undefined;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    comments!: string | undefined;
    clientIp!: string | undefined;
    userAgent!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    clickId!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    primaryLeadRequestId!: number | undefined;
    sourceContactId!: number | undefined;
    sourceContactName!: string | undefined;
    sourceContactAffiliateCode!: string | undefined;
    sourceContactPhotoPublicId!: string | undefined;
    sourceOrganizationUnitId!: number | undefined;
    customField1!: string | undefined;
    customField2!: string | undefined;
    customField3!: string | undefined;
    customField4!: string | undefined;
    customField5!: string | undefined;
    importId!: number | undefined;
    importFileName!: string | undefined;
    propertyId!: number | undefined;

    constructor(data?: ILeadInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactGroupId = data["contactGroupId"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.typeSysId = data["typeSysId"];
            this.pipelineId = data["pipelineId"];
            this.stageId = data["stageId"];
            this.stage = data["stage"];
            this.dealAmount = data["dealAmount"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = data["modificationDate"] ? moment(data["modificationDate"].toString()) : <any>undefined;
            this.sourceCode = data["sourceCode"];
            this.campaignCode = data["campaignCode"];
            this.affiliateCode = data["affiliateCode"];
            this.channelCode = data["channelCode"];
            this.comments = data["comments"];
            this.clientIp = data["clientIp"];
            this.userAgent = data["userAgent"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.clickId = data["clickId"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.primaryLeadRequestId = data["primaryLeadRequestId"];
            this.sourceContactId = data["sourceContactId"];
            this.sourceContactName = data["sourceContactName"];
            this.sourceContactAffiliateCode = data["sourceContactAffiliateCode"];
            this.sourceContactPhotoPublicId = data["sourceContactPhotoPublicId"];
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
            this.customField1 = data["customField1"];
            this.customField2 = data["customField2"];
            this.customField3 = data["customField3"];
            this.customField4 = data["customField4"];
            this.customField5 = data["customField5"];
            this.importId = data["importId"];
            this.importFileName = data["importFileName"];
            this.propertyId = data["propertyId"];
        }
    }

    static fromJS(data: any): LeadInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactGroupId"] = this.contactGroupId;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["typeSysId"] = this.typeSysId;
        data["pipelineId"] = this.pipelineId;
        data["stageId"] = this.stageId;
        data["stage"] = this.stage;
        data["dealAmount"] = this.dealAmount;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["comments"] = this.comments;
        data["clientIp"] = this.clientIp;
        data["userAgent"] = this.userAgent;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["clickId"] = this.clickId;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["primaryLeadRequestId"] = this.primaryLeadRequestId;
        data["sourceContactId"] = this.sourceContactId;
        data["sourceContactName"] = this.sourceContactName;
        data["sourceContactAffiliateCode"] = this.sourceContactAffiliateCode;
        data["sourceContactPhotoPublicId"] = this.sourceContactPhotoPublicId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        data["customField1"] = this.customField1;
        data["customField2"] = this.customField2;
        data["customField3"] = this.customField3;
        data["customField4"] = this.customField4;
        data["customField5"] = this.customField5;
        data["importId"] = this.importId;
        data["importFileName"] = this.importFileName;
        data["propertyId"] = this.propertyId;
        return data; 
    }
}

export interface ILeadInfoDto {
    id: number | undefined;
    contactGroupId: string | undefined;
    typeId: number | undefined;
    typeName: string | undefined;
    typeSysId: string | undefined;
    pipelineId: number | undefined;
    stageId: number | undefined;
    stage: string | undefined;
    dealAmount: number | undefined;
    creationDate: moment.Moment | undefined;
    modificationDate: moment.Moment | undefined;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    comments: string | undefined;
    clientIp: string | undefined;
    userAgent: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    clickId: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    primaryLeadRequestId: number | undefined;
    sourceContactId: number | undefined;
    sourceContactName: string | undefined;
    sourceContactAffiliateCode: string | undefined;
    sourceContactPhotoPublicId: string | undefined;
    sourceOrganizationUnitId: number | undefined;
    customField1: string | undefined;
    customField2: string | undefined;
    customField3: string | undefined;
    customField4: string | undefined;
    customField5: string | undefined;
    importId: number | undefined;
    importFileName: string | undefined;
    propertyId: number | undefined;
}

export class UpdateLeadInfoInput implements IUpdateLeadInfoInput {
    id!: number;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    dealAmount!: number | undefined;
    comments!: string | undefined;

    constructor(data?: IUpdateLeadInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sourceCode = data["sourceCode"];
            this.campaignCode = data["campaignCode"];
            this.affiliateCode = data["affiliateCode"];
            this.channelCode = data["channelCode"];
            this.dealAmount = data["dealAmount"];
            this.comments = data["comments"];
        }
    }

    static fromJS(data: any): UpdateLeadInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["dealAmount"] = this.dealAmount;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IUpdateLeadInfoInput {
    id: number;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    dealAmount: number | undefined;
    comments: string | undefined;
}

export class UpdateLeadSourceContactInput implements IUpdateLeadSourceContactInput {
    leadId!: number;
    sourceContactId!: number | undefined;

    constructor(data?: IUpdateLeadSourceContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.sourceContactId = data["sourceContactId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["sourceContactId"] = this.sourceContactId;
        return data; 
    }
}

export interface IUpdateLeadSourceContactInput {
    leadId: number;
    sourceContactId: number | undefined;
}

export class UpdateLeadSourceContactOutput implements IUpdateLeadSourceContactOutput {
    newSourceOrganizationUnitId!: number | undefined;

    constructor(data?: IUpdateLeadSourceContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newSourceOrganizationUnitId = data["newSourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newSourceOrganizationUnitId"] = this.newSourceOrganizationUnitId;
        return data; 
    }
}

export interface IUpdateLeadSourceContactOutput {
    newSourceOrganizationUnitId: number | undefined;
}

export class UpdateLeadSourceContactsInput implements IUpdateLeadSourceContactsInput {
    leadIds!: number[];
    sourceContactId!: number | undefined;
    applyCurrentAffiliateCode!: boolean | undefined;

    constructor(data?: IUpdateLeadSourceContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leadIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["leadIds"] && data["leadIds"].constructor === Array) {
                this.leadIds = [];
                for (let item of data["leadIds"])
                    this.leadIds.push(item);
            }
            this.sourceContactId = data["sourceContactId"];
            this.applyCurrentAffiliateCode = data["applyCurrentAffiliateCode"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.leadIds && this.leadIds.constructor === Array) {
            data["leadIds"] = [];
            for (let item of this.leadIds)
                data["leadIds"].push(item);
        }
        data["sourceContactId"] = this.sourceContactId;
        data["applyCurrentAffiliateCode"] = this.applyCurrentAffiliateCode;
        return data; 
    }
}

export interface IUpdateLeadSourceContactsInput {
    leadIds: number[];
    sourceContactId: number | undefined;
    applyCurrentAffiliateCode: boolean | undefined;
}

export class UpdateLeadSourceOrganizationUnitInput implements IUpdateLeadSourceOrganizationUnitInput {
    leadId!: number;
    sourceOrganizationUnitId!: number;

    constructor(data?: IUpdateLeadSourceOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        return data; 
    }
}

export interface IUpdateLeadSourceOrganizationUnitInput {
    leadId: number;
    sourceOrganizationUnitId: number;
}

export class UpdateLeadSourceOrganizationUnitsInput implements IUpdateLeadSourceOrganizationUnitsInput {
    leadIds!: number[];
    sourceOrganizationUnitId!: number;

    constructor(data?: IUpdateLeadSourceOrganizationUnitsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.leadIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["leadIds"] && data["leadIds"].constructor === Array) {
                this.leadIds = [];
                for (let item of data["leadIds"])
                    this.leadIds.push(item);
            }
            this.sourceOrganizationUnitId = data["sourceOrganizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateLeadSourceOrganizationUnitsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadSourceOrganizationUnitsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.leadIds && this.leadIds.constructor === Array) {
            data["leadIds"] = [];
            for (let item of this.leadIds)
                data["leadIds"].push(item);
        }
        data["sourceOrganizationUnitId"] = this.sourceOrganizationUnitId;
        return data; 
    }
}

export interface IUpdateLeadSourceOrganizationUnitsInput {
    leadIds: number[];
    sourceOrganizationUnitId: number;
}

export class StageChecklistPointInfoOutput implements IStageChecklistPointInfoOutput {
    stageId!: number | undefined;
    id!: number | undefined;
    name!: string | undefined;
    sortOrder!: number | undefined;
    isDone!: boolean | undefined;
    completionTime!: moment.Moment | undefined;
    completedByUserId!: number | undefined;

    constructor(data?: IStageChecklistPointInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stageId = data["stageId"];
            this.id = data["id"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
            this.isDone = data["isDone"];
            this.completionTime = data["completionTime"] ? moment(data["completionTime"].toString()) : <any>undefined;
            this.completedByUserId = data["completedByUserId"];
        }
    }

    static fromJS(data: any): StageChecklistPointInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StageChecklistPointInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stageId"] = this.stageId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        data["isDone"] = this.isDone;
        data["completionTime"] = this.completionTime ? this.completionTime.toISOString() : <any>undefined;
        data["completedByUserId"] = this.completedByUserId;
        return data; 
    }
}

export interface IStageChecklistPointInfoOutput {
    stageId: number | undefined;
    id: number | undefined;
    name: string | undefined;
    sortOrder: number | undefined;
    isDone: boolean | undefined;
    completionTime: moment.Moment | undefined;
    completedByUserId: number | undefined;
}

export class UpdateLeadDealInfoInput implements IUpdateLeadDealInfoInput {
    leadId!: number;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;

    constructor(data?: IUpdateLeadDealInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.dealAmount = data["dealAmount"];
            this.installmentAmount = data["installmentAmount"];
        }
    }

    static fromJS(data: any): UpdateLeadDealInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadDealInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        return data; 
    }
}

export interface IUpdateLeadDealInfoInput {
    leadId: number;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
}

export class LeadTypeDto implements ILeadTypeDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: ILeadTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): LeadTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILeadTypeDto {
    id: number | undefined;
    name: string | undefined;
}

export class MemberServiceAssignmentInfoOutput implements IMemberServiceAssignmentInfoOutput {
    memberServiceLevelIds!: number[] | undefined;
    memberServiceId!: number | undefined;

    constructor(data?: IMemberServiceAssignmentInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberServiceLevelIds"] && data["memberServiceLevelIds"].constructor === Array) {
                this.memberServiceLevelIds = [];
                for (let item of data["memberServiceLevelIds"])
                    this.memberServiceLevelIds.push(item);
            }
            this.memberServiceId = data["memberServiceId"];
        }
    }

    static fromJS(data: any): MemberServiceAssignmentInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceAssignmentInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberServiceLevelIds && this.memberServiceLevelIds.constructor === Array) {
            data["memberServiceLevelIds"] = [];
            for (let item of this.memberServiceLevelIds)
                data["memberServiceLevelIds"].push(item);
        }
        data["memberServiceId"] = this.memberServiceId;
        return data; 
    }
}

export interface IMemberServiceAssignmentInfoOutput {
    memberServiceLevelIds: number[] | undefined;
    memberServiceId: number | undefined;
}

export enum LearningResourceType {
    Link = "Link", 
    Video = "Video", 
    Audio = "Audio", 
    Image = "Image", 
    File = "File", 
}

export class LearningResourceInfoOutput implements ILearningResourceInfoOutput {
    id!: number | undefined;
    imageUrl!: string | undefined;
    isParent!: boolean | undefined;
    parentId!: number | undefined;
    memberServiceAssignments!: MemberServiceAssignmentInfoOutput[] | undefined;
    children!: LearningResourceInfoOutput[] | undefined;
    type!: LearningResourceType | undefined;
    name!: string | undefined;
    url!: string | undefined;

    constructor(data?: ILearningResourceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.imageUrl = data["imageUrl"];
            this.isParent = data["isParent"];
            this.parentId = data["parentId"];
            if (data["memberServiceAssignments"] && data["memberServiceAssignments"].constructor === Array) {
                this.memberServiceAssignments = [];
                for (let item of data["memberServiceAssignments"])
                    this.memberServiceAssignments.push(MemberServiceAssignmentInfoOutput.fromJS(item));
            }
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(LearningResourceInfoOutput.fromJS(item));
            }
            this.type = data["type"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): LearningResourceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LearningResourceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["isParent"] = this.isParent;
        data["parentId"] = this.parentId;
        if (this.memberServiceAssignments && this.memberServiceAssignments.constructor === Array) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface ILearningResourceInfoOutput {
    id: number | undefined;
    imageUrl: string | undefined;
    isParent: boolean | undefined;
    parentId: number | undefined;
    memberServiceAssignments: MemberServiceAssignmentInfoOutput[] | undefined;
    children: LearningResourceInfoOutput[] | undefined;
    type: LearningResourceType | undefined;
    name: string | undefined;
    url: string | undefined;
}

export class LearningResourceGroupInfoOutput implements ILearningResourceGroupInfoOutput {
    groupId!: number | undefined;
    groupName!: string | undefined;
    groupImageUrl!: string | undefined;
    groupHtmlColor!: string | undefined;
    groupSortOrder!: number | undefined;
    resources!: LearningResourceInfoOutput[] | undefined;

    constructor(data?: ILearningResourceGroupInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.groupName = data["groupName"];
            this.groupImageUrl = data["groupImageUrl"];
            this.groupHtmlColor = data["groupHtmlColor"];
            this.groupSortOrder = data["groupSortOrder"];
            if (data["resources"] && data["resources"].constructor === Array) {
                this.resources = [];
                for (let item of data["resources"])
                    this.resources.push(LearningResourceInfoOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LearningResourceGroupInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LearningResourceGroupInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupImageUrl"] = this.groupImageUrl;
        data["groupHtmlColor"] = this.groupHtmlColor;
        data["groupSortOrder"] = this.groupSortOrder;
        if (this.resources && this.resources.constructor === Array) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILearningResourceGroupInfoOutput {
    groupId: number | undefined;
    groupName: string | undefined;
    groupImageUrl: string | undefined;
    groupHtmlColor: string | undefined;
    groupSortOrder: number | undefined;
    resources: LearningResourceInfoOutput[] | undefined;
}

export class MemberServiceAssignmentInput implements IMemberServiceAssignmentInput {
    memberServiceId!: number;
    memberServiceLevelId!: number | undefined;

    constructor(data?: IMemberServiceAssignmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberServiceId = data["memberServiceId"];
            this.memberServiceLevelId = data["memberServiceLevelId"];
        }
    }

    static fromJS(data: any): MemberServiceAssignmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceAssignmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberServiceId"] = this.memberServiceId;
        data["memberServiceLevelId"] = this.memberServiceLevelId;
        return data; 
    }
}

export interface IMemberServiceAssignmentInput {
    memberServiceId: number;
    memberServiceLevelId: number | undefined;
}

export class CreateLearningResourceInput implements ICreateLearningResourceInput {
    groupId!: number;
    isParent!: boolean | undefined;
    parentId!: number | undefined;
    type!: LearningResourceType | undefined;
    name!: string;
    url!: string | undefined;
    fileName!: string | undefined;
    fileSize!: number | undefined;
    file!: string | undefined;
    memberServiceAssignments!: MemberServiceAssignmentInput[] | undefined;

    constructor(data?: ICreateLearningResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.isParent = data["isParent"];
            this.parentId = data["parentId"];
            this.type = data["type"];
            this.name = data["name"];
            this.url = data["url"];
            this.fileName = data["fileName"];
            this.fileSize = data["fileSize"];
            this.file = data["file"];
            if (data["memberServiceAssignments"] && data["memberServiceAssignments"].constructor === Array) {
                this.memberServiceAssignments = [];
                for (let item of data["memberServiceAssignments"])
                    this.memberServiceAssignments.push(MemberServiceAssignmentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateLearningResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLearningResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["isParent"] = this.isParent;
        data["parentId"] = this.parentId;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["file"] = this.file;
        if (this.memberServiceAssignments && this.memberServiceAssignments.constructor === Array) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateLearningResourceInput {
    groupId: number;
    isParent: boolean | undefined;
    parentId: number | undefined;
    type: LearningResourceType | undefined;
    name: string;
    url: string | undefined;
    fileName: string | undefined;
    fileSize: number | undefined;
    file: string | undefined;
    memberServiceAssignments: MemberServiceAssignmentInput[] | undefined;
}

export class UpdateLearningResourceInput implements IUpdateLearningResourceInput {
    id!: number;
    type!: LearningResourceType | undefined;
    name!: string;
    url!: string | undefined;
    fileName!: string | undefined;
    fileSize!: number | undefined;
    file!: string | undefined;
    memberServiceAssignments!: MemberServiceAssignmentInput[] | undefined;

    constructor(data?: IUpdateLearningResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.name = data["name"];
            this.url = data["url"];
            this.fileName = data["fileName"];
            this.fileSize = data["fileSize"];
            this.file = data["file"];
            if (data["memberServiceAssignments"] && data["memberServiceAssignments"].constructor === Array) {
                this.memberServiceAssignments = [];
                for (let item of data["memberServiceAssignments"])
                    this.memberServiceAssignments.push(MemberServiceAssignmentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateLearningResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLearningResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["file"] = this.file;
        if (this.memberServiceAssignments && this.memberServiceAssignments.constructor === Array) {
            data["memberServiceAssignments"] = [];
            for (let item of this.memberServiceAssignments)
                data["memberServiceAssignments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateLearningResourceInput {
    id: number;
    type: LearningResourceType | undefined;
    name: string;
    url: string | undefined;
    fileName: string | undefined;
    fileSize: number | undefined;
    file: string | undefined;
    memberServiceAssignments: MemberServiceAssignmentInput[] | undefined;
}

export class SetLearningResourceImageInput implements ISetLearningResourceImageInput {
    id!: number;
    image!: string | undefined;

    constructor(data?: ISetLearningResourceImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.image = data["image"];
        }
    }

    static fromJS(data: any): SetLearningResourceImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetLearningResourceImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image"] = this.image;
        return data; 
    }
}

export interface ISetLearningResourceImageInput {
    id: number;
    image: string | undefined;
}

export class LinkTrackingOutput implements ILinkTrackingOutput {
    id!: number | undefined;
    url!: string | undefined;
    created!: moment.Moment | undefined;

    constructor(data?: ILinkTrackingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.url = data["url"];
            this.created = data["created"] ? moment(data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LinkTrackingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkTrackingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ILinkTrackingOutput {
    id: number | undefined;
    url: string | undefined;
    created: moment.Moment | undefined;
}

export class LocalizationSourceDto implements ILocalizationSourceDto {
    values!: { [key: string] : string; } | undefined;
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: ILocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {};
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key];
                }
            }
            this.name = data["name"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): LocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface ILocalizationSourceDto {
    values: { [key: string] : string; } | undefined;
    name: string | undefined;
    type: string | undefined;
}

export class MemberAddressDto implements IMemberAddressDto {
    streetAddress!: string | undefined;
    neighborhood!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IMemberAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.streetAddress = data["streetAddress"];
            this.neighborhood = data["neighborhood"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): MemberAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["neighborhood"] = this.neighborhood;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IMemberAddressDto {
    streetAddress: string | undefined;
    neighborhood: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    countryId: string | undefined;
}

export class UTMParameterInfo implements IUTMParameterInfo {
    source!: string;
    medium!: string | undefined;
    campaign!: string | undefined;
    term!: string | undefined;
    content!: string | undefined;
    keyword!: string | undefined;
    adGroup!: string | undefined;
    name!: string | undefined;

    constructor(data?: IUTMParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"];
            this.medium = data["medium"];
            this.campaign = data["campaign"];
            this.term = data["term"];
            this.content = data["content"];
            this.keyword = data["keyword"];
            this.adGroup = data["adGroup"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UTMParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UTMParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["medium"] = this.medium;
        data["campaign"] = this.campaign;
        data["term"] = this.term;
        data["content"] = this.content;
        data["keyword"] = this.keyword;
        data["adGroup"] = this.adGroup;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUTMParameterInfo {
    source: string;
    medium: string | undefined;
    campaign: string | undefined;
    term: string | undefined;
    content: string | undefined;
    keyword: string | undefined;
    adGroup: string | undefined;
    name: string | undefined;
}

export class MemberInfoDto implements IMemberInfoDto {
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberInfoDto {
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class SelectPackageResponseDto implements ISelectPackageResponseDto {
    registrationId!: string | undefined;
    memberInfo!: MemberInfoDto | undefined;
    paymentAuthorizationRequired!: boolean | undefined;

    constructor(data?: ISelectPackageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.memberInfo = data["memberInfo"] ? MemberInfoDto.fromJS(data["memberInfo"]) : <any>undefined;
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SelectPackageResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectPackageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISelectPackageResponseDto {
    registrationId: string | undefined;
    memberInfo: MemberInfoDto | undefined;
    paymentAuthorizationRequired: boolean | undefined;
}

export class SubmitMemberInfoResultDto implements ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired!: boolean | undefined;

    constructor(data?: ISubmitMemberInfoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SubmitMemberInfoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitMemberInfoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired: boolean | undefined;
}

export enum PaymentInfoType {
    BankCard = "BankCard", 
    ACH = "ACH", 
    PayPal = "PayPal", 
}

export class BankCardDto implements IBankCardDto {
    holderName!: string;
    cardNumber!: string;
    expirationMonth!: string;
    expirationYear!: string;
    cvv!: string;
    billingAddress!: string;
    billingZip!: string;
    billingCity!: string;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.cvv = data["cvv"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingState = data["billingState"];
            this.billingCountryCode = data["billingCountryCode"];
            this.billingCountry = data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data; 
    }
}

export interface IBankCardDto {
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    cvv: string;
    billingAddress: string;
    billingZip: string;
    billingCity: string;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string;
    billingCountry: string | undefined;
}

export class ACHCustomerDto implements IACHCustomerDto {
    customerRoutingNo!: string;
    customerAcctNo!: string;

    constructor(data?: IACHCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerRoutingNo = data["customerRoutingNo"];
            this.customerAcctNo = data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data; 
    }
}

export interface IACHCustomerDto {
    customerRoutingNo: string;
    customerAcctNo: string;
}

export class PayPalDto implements IPayPalDto {
    paymentId!: string;
    payerId!: string;

    constructor(data?: IPayPalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
        }
    }

    static fromJS(data: any): PayPalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data; 
    }
}

export interface IPayPalDto {
    paymentId: string;
    payerId: string;
}

export class MemberPaymentAuthorizeRequestDto implements IMemberPaymentAuthorizeRequestDto {
    registrationId!: string;
    packageId!: number | undefined;
    paymentInfoType!: PaymentInfoType | undefined;
    bankCard!: BankCardDto | undefined;
    achCustomer!: ACHCustomerDto | undefined;
    payPal!: PayPalDto | undefined;

    constructor(data?: IMemberPaymentAuthorizeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.packageId = data["packageId"];
            this.paymentInfoType = data["paymentInfoType"];
            this.bankCard = data["bankCard"] ? BankCardDto.fromJS(data["bankCard"]) : <any>undefined;
            this.achCustomer = data["achCustomer"] ? ACHCustomerDto.fromJS(data["achCustomer"]) : <any>undefined;
            this.payPal = data["payPal"] ? PayPalDto.fromJS(data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberPaymentAuthorizeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPaymentAuthorizeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["packageId"] = this.packageId;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberPaymentAuthorizeRequestDto {
    registrationId: string;
    packageId: number | undefined;
    paymentInfoType: PaymentInfoType | undefined;
    bankCard: BankCardDto | undefined;
    achCustomer: ACHCustomerDto | undefined;
    payPal: PayPalDto | undefined;
}

export class PaymentAuthorizeResponseDto implements IPaymentAuthorizeResponseDto {
    success!: boolean | undefined;
    errors!: string[] | undefined;

    constructor(data?: IPaymentAuthorizeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(item);
            }
        }
    }

    static fromJS(data: any): PaymentAuthorizeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAuthorizeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IPaymentAuthorizeResponseDto {
    success: boolean | undefined;
    errors: string[] | undefined;
}

export class RegisterMemberRequest implements IRegisterMemberRequest {
    password!: string;
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IRegisterMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterMemberRequest {
    password: string;
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class MemberServiceLevelDto implements IMemberServiceLevelDto {
    name!: string;
    monthlyFee!: number | undefined;
    activationTime!: moment.Moment | undefined;
    deactivationTime!: moment.Moment | undefined;
    features!: { [key: string] : string; } | undefined;
    id!: number | undefined;
    code!: string;

    constructor(data?: IMemberServiceLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.monthlyFee = data["monthlyFee"];
            this.activationTime = data["activationTime"] ? moment(data["activationTime"].toString()) : <any>undefined;
            this.deactivationTime = data["deactivationTime"] ? moment(data["deactivationTime"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
            this.id = data["id"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): MemberServiceLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["monthlyFee"] = this.monthlyFee;
        data["activationTime"] = this.activationTime ? this.activationTime.toISOString() : <any>undefined;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        data["id"] = this.id;
        data["code"] = this.code;
        return data; 
    }
}

export interface IMemberServiceLevelDto {
    name: string;
    monthlyFee: number | undefined;
    activationTime: moment.Moment | undefined;
    deactivationTime: moment.Moment | undefined;
    features: { [key: string] : string; } | undefined;
    id: number | undefined;
    code: string;
}

export class MemberServiceDto implements IMemberServiceDto {
    id!: number | undefined;
    systemType!: string;
    code!: string;
    name!: string;
    monthlyFee!: number | undefined;
    activationTime!: moment.Moment | undefined;
    deactivationTime!: moment.Moment | undefined;
    features!: { [key: string] : string; } | undefined;
    memberServiceLevels!: MemberServiceLevelDto[] | undefined;

    constructor(data?: IMemberServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.systemType = data["systemType"];
            this.code = data["code"];
            this.name = data["name"];
            this.monthlyFee = data["monthlyFee"];
            this.activationTime = data["activationTime"] ? moment(data["activationTime"].toString()) : <any>undefined;
            this.deactivationTime = data["deactivationTime"] ? moment(data["deactivationTime"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
            if (data["memberServiceLevels"] && data["memberServiceLevels"].constructor === Array) {
                this.memberServiceLevels = [];
                for (let item of data["memberServiceLevels"])
                    this.memberServiceLevels.push(MemberServiceLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemType"] = this.systemType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["monthlyFee"] = this.monthlyFee;
        data["activationTime"] = this.activationTime ? this.activationTime.toISOString() : <any>undefined;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        if (this.memberServiceLevels && this.memberServiceLevels.constructor === Array) {
            data["memberServiceLevels"] = [];
            for (let item of this.memberServiceLevels)
                data["memberServiceLevels"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberServiceDto {
    id: number | undefined;
    systemType: string;
    code: string;
    name: string;
    monthlyFee: number | undefined;
    activationTime: moment.Moment | undefined;
    deactivationTime: moment.Moment | undefined;
    features: { [key: string] : string; } | undefined;
    memberServiceLevels: MemberServiceLevelDto[] | undefined;
}

export class SystemTypeDto implements ISystemTypeDto {
    code!: string | undefined;

    constructor(data?: ISystemTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): SystemTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface ISystemTypeDto {
    code: string | undefined;
}

export class MemberServiceLevelBaseDto implements IMemberServiceLevelBaseDto {
    id!: number | undefined;
    code!: string;

    constructor(data?: IMemberServiceLevelBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): MemberServiceLevelBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberServiceLevelBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        return data; 
    }
}

export interface IMemberServiceLevelBaseDto {
    id: number | undefined;
    code: string;
}

export class CreateOrUpdateMemberServiceOutput implements ICreateOrUpdateMemberServiceOutput {
    id!: number | undefined;
    memberServiceLevels!: MemberServiceLevelBaseDto[] | undefined;

    constructor(data?: ICreateOrUpdateMemberServiceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["memberServiceLevels"] && data["memberServiceLevels"].constructor === Array) {
                this.memberServiceLevels = [];
                for (let item of data["memberServiceLevels"])
                    this.memberServiceLevels.push(MemberServiceLevelBaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateMemberServiceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMemberServiceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.memberServiceLevels && this.memberServiceLevels.constructor === Array) {
            data["memberServiceLevels"] = [];
            for (let item of this.memberServiceLevels)
                data["memberServiceLevels"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateMemberServiceOutput {
    id: number | undefined;
    memberServiceLevels: MemberServiceLevelBaseDto[] | undefined;
}

export class UpdateUserAffiliateCodeDto implements IUpdateUserAffiliateCodeDto {
    affiliateCode!: string | undefined;

    constructor(data?: IUpdateUserAffiliateCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): UpdateUserAffiliateCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserAffiliateCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IUpdateUserAffiliateCodeDto {
    affiliateCode: string | undefined;
}

export class BANKCodeSelfAssessmentDto implements IBANKCodeSelfAssessmentDto {
    b!: number | undefined;
    a!: number | undefined;
    n!: number | undefined;
    k!: number | undefined;

    constructor(data?: IBANKCodeSelfAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.b = data["b"];
            this.a = data["a"];
            this.n = data["n"];
            this.k = data["k"];
        }
    }

    static fromJS(data: any): BANKCodeSelfAssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BANKCodeSelfAssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["b"] = this.b;
        data["a"] = this.a;
        data["n"] = this.n;
        data["k"] = this.k;
        return data; 
    }
}

export interface IBANKCodeSelfAssessmentDto {
    b: number | undefined;
    a: number | undefined;
    n: number | undefined;
    k: number | undefined;
}

export class UpdateUserBANKCodeDto implements IUpdateUserBANKCodeDto {
    bankCode!: string;
    source!: string | undefined;
    bankCodeSelfAssessmentDto!: BANKCodeSelfAssessmentDto | undefined;

    constructor(data?: IUpdateUserBANKCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankCode = data["bankCode"];
            this.source = data["source"];
            this.bankCodeSelfAssessmentDto = data["bankCodeSelfAssessmentDto"] ? BANKCodeSelfAssessmentDto.fromJS(data["bankCodeSelfAssessmentDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserBANKCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserBANKCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCode"] = this.bankCode;
        data["source"] = this.source;
        data["bankCodeSelfAssessmentDto"] = this.bankCodeSelfAssessmentDto ? this.bankCodeSelfAssessmentDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateUserBANKCodeDto {
    bankCode: string;
    source: string | undefined;
    bankCodeSelfAssessmentDto: BANKCodeSelfAssessmentDto | undefined;
}

export class SubscriptionShortInfoOutput implements ISubscriptionShortInfoOutput {
    serviceType!: string | undefined;
    serviceTypeId!: string | undefined;
    serviceName!: string | undefined;
    serviceId!: string | undefined;
    endDate!: moment.Moment | undefined;
    gracePeriodDayCount!: number | undefined;
    hasRecurringBilling!: boolean | undefined;
    finalEndDate!: moment.Moment | undefined;

    constructor(data?: ISubscriptionShortInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceType = data["serviceType"];
            this.serviceTypeId = data["serviceTypeId"];
            this.serviceName = data["serviceName"];
            this.serviceId = data["serviceId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.gracePeriodDayCount = data["gracePeriodDayCount"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.finalEndDate = data["finalEndDate"] ? moment(data["finalEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionShortInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionShortInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceType"] = this.serviceType;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceName"] = this.serviceName;
        data["serviceId"] = this.serviceId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["finalEndDate"] = this.finalEndDate ? this.finalEndDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISubscriptionShortInfoOutput {
    serviceType: string | undefined;
    serviceTypeId: string | undefined;
    serviceName: string | undefined;
    serviceId: string | undefined;
    endDate: moment.Moment | undefined;
    gracePeriodDayCount: number | undefined;
    hasRecurringBilling: boolean | undefined;
    finalEndDate: moment.Moment | undefined;
}

export class GetMemberInfoOutput implements IGetMemberInfoOutput {
    subscriptions!: SubscriptionShortInfoOutput[] | undefined;
    userKey!: string | undefined;
    monthlyGoal!: number | undefined;

    constructor(data?: IGetMemberInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["subscriptions"] && data["subscriptions"].constructor === Array) {
                this.subscriptions = [];
                for (let item of data["subscriptions"])
                    this.subscriptions.push(SubscriptionShortInfoOutput.fromJS(item));
            }
            this.userKey = data["userKey"];
            this.monthlyGoal = data["monthlyGoal"];
        }
    }

    static fromJS(data: any): GetMemberInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.subscriptions && this.subscriptions.constructor === Array) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        data["userKey"] = this.userKey;
        data["monthlyGoal"] = this.monthlyGoal;
        return data; 
    }
}

export interface IGetMemberInfoOutput {
    subscriptions: SubscriptionShortInfoOutput[] | undefined;
    userKey: string | undefined;
    monthlyGoal: number | undefined;
}

export enum NoteType {
    Note = "Note", 
    IncomingCall = "IncomingCall", 
    OutcomingCall = "OutcomingCall", 
}

export class NoteInfoDto implements INoteInfoDto {
    contactId!: number | undefined;
    id!: number | undefined;
    text!: string | undefined;
    dateTime!: moment.Moment | undefined;
    noteType!: NoteType | undefined;
    noteTypeName!: string | undefined;
    contactPhoneId!: number | undefined;
    contactPhoneNumber!: string | undefined;
    contactName!: string | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    followUpDateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;
    addedByUserName!: string | undefined;
    addedByUserPhotoPublicId!: string | undefined;
    pinnedByUserName!: string | undefined;
    pinnedDateTime!: moment.Moment | undefined;

    constructor(data?: INoteInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.text = data["text"];
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.noteType = data["noteType"];
            this.noteTypeName = data["noteTypeName"];
            this.contactPhoneId = data["contactPhoneId"];
            this.contactPhoneNumber = data["contactPhoneNumber"];
            this.contactName = data["contactName"];
            this.orderId = data["orderId"];
            this.leadId = data["leadId"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
            this.addedByUserName = data["addedByUserName"];
            this.addedByUserPhotoPublicId = data["addedByUserPhotoPublicId"];
            this.pinnedByUserName = data["pinnedByUserName"];
            this.pinnedDateTime = data["pinnedDateTime"] ? moment(data["pinnedDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NoteInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoteInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["noteType"] = this.noteType;
        data["noteTypeName"] = this.noteTypeName;
        data["contactPhoneId"] = this.contactPhoneId;
        data["contactPhoneNumber"] = this.contactPhoneNumber;
        data["contactName"] = this.contactName;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        data["addedByUserName"] = this.addedByUserName;
        data["addedByUserPhotoPublicId"] = this.addedByUserPhotoPublicId;
        data["pinnedByUserName"] = this.pinnedByUserName;
        data["pinnedDateTime"] = this.pinnedDateTime ? this.pinnedDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface INoteInfoDto {
    contactId: number | undefined;
    id: number | undefined;
    text: string | undefined;
    dateTime: moment.Moment | undefined;
    noteType: NoteType | undefined;
    noteTypeName: string | undefined;
    contactPhoneId: number | undefined;
    contactPhoneNumber: string | undefined;
    contactName: string | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    followUpDateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
    addedByUserName: string | undefined;
    addedByUserPhotoPublicId: string | undefined;
    pinnedByUserName: string | undefined;
    pinnedDateTime: moment.Moment | undefined;
}

export class CreateNoteInput implements ICreateNoteInput {
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: ICreateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.text = data["text"];
            this.contactPhoneId = data["contactPhoneId"];
            this.orderId = data["orderId"];
            this.leadId = data["leadId"];
            this.noteType = data["noteType"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
        }
    }

    static fromJS(data: any): CreateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data; 
    }
}

export interface ICreateNoteInput {
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export class CreateNoteOutput implements ICreateNoteOutput {
    id!: number | undefined;

    constructor(data?: ICreateNoteOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateNoteOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateNoteOutput {
    id: number | undefined;
}

export class UpdateNoteInput implements IUpdateNoteInput {
    id!: number;
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    leadId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: IUpdateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.text = data["text"];
            this.contactPhoneId = data["contactPhoneId"];
            this.orderId = data["orderId"];
            this.leadId = data["leadId"];
            this.noteType = data["noteType"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
        }
    }

    static fromJS(data: any): UpdateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["leadId"] = this.leadId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data; 
    }
}

export interface IUpdateNoteInput {
    id: number;
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    leadId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export class PinNoteInput implements IPinNoteInput {
    contactId!: number;
    noteId!: number;

    constructor(data?: IPinNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.noteId = data["noteId"];
        }
    }

    static fromJS(data: any): PinNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new PinNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["noteId"] = this.noteId;
        return data; 
    }
}

export interface IPinNoteInput {
    contactId: number;
    noteId: number;
}

export class UnpinNoteInput implements IUnpinNoteInput {
    contactId!: number;
    noteId!: number;

    constructor(data?: IUnpinNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.noteId = data["noteId"];
        }
    }

    static fromJS(data: any): UnpinNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnpinNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["noteId"] = this.noteId;
        return data; 
    }
}

export interface IUnpinNoteInput {
    contactId: number;
    noteId: number;
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export class NotificationData implements INotificationData {
    type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
}

export class TenantNotificationDto implements ITenantNotificationDto {
    id!: string | undefined;
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityTypeName!: string | undefined;
    entityId!: string | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: ITenantNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITenantNotificationDto {
    id: string | undefined;
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityTypeName: string | undefined;
    entityId: string | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
}

export class UserNotificationDto implements IUserNotificationDto {
    id!: string | undefined;
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotificationDto | undefined;

    constructor(data?: IUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotificationDto.fromJS(data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserNotificationDto {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotificationDto | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    items!: UserNotificationDto[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    items: UserNotificationDto[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id!: string | undefined;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IGuidEntityDto {
    id: string | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;
    group!: string | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        data["group"] = this.group;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
    group: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;
    group!: string | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        data["group"] = this.group;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
    group: string | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export enum CampaignCategory {
    PaydayLoans = "PaydayLoans", 
    PersonalLoans = "PersonalLoans", 
    Beauty = "Beauty", 
    InstallmentLoans = "InstallmentLoans", 
    AutoLoans = "AutoLoans", 
    Legal = "Legal", 
    CreditRepair = "CreditRepair", 
    CreditScore = "CreditScore", 
    Travel = "Travel", 
    Jobs = "Jobs", 
    BusinessLoans = "BusinessLoans", 
    DebtConsolidation = "DebtConsolidation", 
    CreditCards = "CreditCards", 
    MerchantServices = "MerchantServices", 
    Dating = "Dating", 
    Miscellaneous = "Miscellaneous", 
    Crypto = "Crypto", 
    CreditMonitoring = "CreditMonitoring", 
}

export enum CampaignType {
    MultiOfferSinglePage = "MultiOfferSinglePage", 
    TrafficDistribution = "TrafficDistribution", 
    DirectPost = "DirectPost", 
    Carrier = "Carrier", 
}

export enum OfferCollection {
    Best = "Best", 
    BalanceTransfer = "BalanceTransfer", 
    CashBack = "CashBack", 
    RewardPoints = "RewardPoints", 
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases", 
    TravelAirlineHotel = "TravelAirlineHotel", 
    SecuredOrPrepaid = "SecuredOrPrepaid", 
    BusinessCards = "BusinessCards", 
    NoAnnualFees = "NoAnnualFees", 
    Excellent = "Excellent", 
    Good = "Good", 
    Fair = "Fair", 
    Bad = "Bad", 
    NoCredit = "NoCredit", 
    Newest = "Newest", 
    SpecialDeals = "SpecialDeals", 
}

export enum CardNetwork {
    AmEx = "AmEx", 
    Discover = "Discover", 
    Mastercard = "Mastercard", 
    Visa = "Visa", 
    Store = "Store", 
}

export enum CardType {
    Credit = "Credit", 
    Debit = "Debit", 
}

export enum SecuringType {
    Unsecured = "Unsecured", 
    Secured = "Secured", 
    Prepaid = "Prepaid", 
}

export enum TargetAudience {
    Consumer = "Consumer", 
    Business = "Business", 
    Students = "Students", 
}

export enum SortOrderType {
    Best = "Best", 
    Newest = "Newest", 
}

export class GetAllInput implements IGetAllInput {
    testMode!: boolean;
    category!: CampaignCategory | undefined;
    type!: CampaignType | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    sortOrderType!: SortOrderType | undefined;
    topCount!: number | undefined;
    strictMatch!: boolean | undefined;

    constructor(data?: IGetAllInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.testMode = data["testMode"];
            this.category = data["category"];
            this.type = data["type"];
            this.country = data["country"];
            this.state = data["state"];
            this.creditScore = data["creditScore"];
            this.isOfferCollection = data["isOfferCollection"];
            this.itemOfOfferCollection = data["itemOfOfferCollection"];
            this.loanAmount = data["loanAmount"];
            if (data["cardNetworks"] && data["cardNetworks"].constructor === Array) {
                this.cardNetworks = [];
                for (let item of data["cardNetworks"])
                    this.cardNetworks.push(item);
            }
            this.cardType = data["cardType"];
            this.securingType = data["securingType"];
            this.targetAudience = data["targetAudience"];
            this.annualIncome = data["annualIncome"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            if (data["campaignIds"] && data["campaignIds"].constructor === Array) {
                this.campaignIds = [];
                for (let item of data["campaignIds"])
                    this.campaignIds.push(item);
            }
            this.sortOrderType = data["sortOrderType"];
            this.topCount = data["topCount"];
            this.strictMatch = data["strictMatch"];
        }
    }

    static fromJS(data: any): GetAllInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testMode"] = this.testMode;
        data["category"] = this.category;
        data["type"] = this.type;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (this.cardNetworks && this.cardNetworks.constructor === Array) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (this.campaignIds && this.campaignIds.constructor === Array) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        data["sortOrderType"] = this.sortOrderType;
        data["topCount"] = this.topCount;
        data["strictMatch"] = this.strictMatch;
        return data; 
    }
}

export interface IGetAllInput {
    testMode: boolean;
    category: CampaignCategory | undefined;
    type: CampaignType | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    sortOrderType: SortOrderType | undefined;
    topCount: number | undefined;
    strictMatch: boolean | undefined;
}

export enum CampaignProviderType {
    CreditLand = "CreditLand", 
}

export class OfferDto implements IOfferDto {
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.redirectUrl = data["redirectUrl"];
            this.logoUrl = data["logoUrl"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            this.annualFee = data["annualFee"];
            this.rewardsRate = data["rewardsRate"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.regularAPR = data["regularAPR"];
            this.offerCollection = data["offerCollection"];
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.campaignProviderType = data["campaignProviderType"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data; 
    }
}

export interface IOfferDto {
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class OfferDetailsDto implements IOfferDetailsDto {
    description!: string | undefined;
    introAPR!: string | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.introAPR = data["introAPR"];
            if (data["creditScores"] && data["creditScores"].constructor === Array) {
                this.creditScores = [];
                for (let item of data["creditScores"])
                    this.creditScores.push(item);
            }
            if (data["pros"] && data["pros"].constructor === Array) {
                this.pros = [];
                for (let item of data["pros"])
                    this.pros.push(item);
            }
            if (data["cons"] && data["cons"].constructor === Array) {
                this.cons = [];
                for (let item of data["cons"])
                    this.cons.push(item);
            }
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.redirectUrl = data["redirectUrl"];
            this.logoUrl = data["logoUrl"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            this.annualFee = data["annualFee"];
            this.rewardsRate = data["rewardsRate"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.regularAPR = data["regularAPR"];
            this.offerCollection = data["offerCollection"];
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.campaignProviderType = data["campaignProviderType"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["introAPR"] = this.introAPR;
        if (this.creditScores && this.creditScores.constructor === Array) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (this.pros && this.pros.constructor === Array) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (this.cons && this.cons.constructor === Array) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data; 
    }
}

export interface IOfferDetailsDto {
    description: string | undefined;
    introAPR: string | undefined;
    creditScores: CreditScoreRating[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class GetApplicationDetailsOutput implements IGetApplicationDetailsOutput {
    systemType!: OfferProviderType | undefined;
    campaignId!: number | undefined;
    clickId!: string | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IGetApplicationDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.campaignId = data["campaignId"];
            this.clickId = data["clickId"];
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApplicationDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["clickId"] = this.clickId;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetApplicationDetailsOutput {
    systemType: OfferProviderType | undefined;
    campaignId: number | undefined;
    clickId: string | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class OfferApplicationGroup implements IOfferApplicationGroup {
    date!: moment.Moment | undefined;
    count!: number | undefined;

    constructor(data?: IOfferApplicationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.count = data["count"];
        }
    }

    static fromJS(data: any): OfferApplicationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["count"] = this.count;
        return data; 
    }
}

export interface IOfferApplicationGroup {
    date: moment.Moment | undefined;
    count: number | undefined;
}

export class SubmitRequestInput implements ISubmitRequestInput {
    systemType!: OfferProviderType;
    campaignId!: number;
    xref!: string;
    redirectUrl!: string | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    zipCode!: string | undefined;
    monthsAtAddress!: number | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;

    constructor(data?: ISubmitRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.campaignId = data["campaignId"];
            this.xref = data["xref"];
            this.redirectUrl = data["redirectUrl"];
            this.clickId = data["clickId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.countryCode = data["countryCode"];
            this.zipCode = data["zipCode"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.creditScore = data["creditScore"];
        }
    }

    static fromJS(data: any): SubmitRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["xref"] = this.xref;
        data["redirectUrl"] = this.redirectUrl;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["zipCode"] = this.zipCode;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        return data; 
    }
}

export interface ISubmitRequestInput {
    systemType: OfferProviderType;
    campaignId: number;
    xref: string;
    redirectUrl: string | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    zipCode: string | undefined;
    monthsAtAddress: number | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
}

export class SubmitRequestOutput implements ISubmitRequestOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
            this.applicationId = data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data; 
    }
}

export interface ISubmitRequestOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export class SubmitApplicationInput implements ISubmitApplicationInput {
    campaignId!: number | undefined;
    systemType!: OfferProviderType;
    personalInformation!: PersonalInformation;
    debtInformation!: DebtInformation;
    loanInformation!: LoanInformation;
    employmentInformation!: EmploymentInformation;
    bankInformation!: BankInformation;
    legalInformation!: LegalInformation;

    constructor(data?: ISubmitApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personalInformation = new PersonalInformation();
            this.debtInformation = new DebtInformation();
            this.loanInformation = new LoanInformation();
            this.employmentInformation = new EmploymentInformation();
            this.bankInformation = new BankInformation();
            this.legalInformation = new LegalInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.systemType = data["systemType"];
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : new PersonalInformation();
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : new DebtInformation();
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : new LoanInformation();
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : new EmploymentInformation();
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : new BankInformation();
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : new LegalInformation();
        }
    }

    static fromJS(data: any): SubmitApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["systemType"] = this.systemType;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISubmitApplicationInput {
    campaignId: number | undefined;
    systemType: OfferProviderType;
    personalInformation: PersonalInformation;
    debtInformation: DebtInformation;
    loanInformation: LoanInformation;
    employmentInformation: EmploymentInformation;
    bankInformation: BankInformation;
    legalInformation: LegalInformation;
}

export class SubmitApplicationOutput implements ISubmitApplicationOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitApplicationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
            this.applicationId = data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitApplicationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data; 
    }
}

export interface ISubmitApplicationOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export enum FinalizeApplicationStatus {
    Approved = "Approved", 
    Declined = "Declined", 
    Finalizing = "Finalizing", 
}

export class FinalizeApplicationResponse implements IFinalizeApplicationResponse {
    status!: FinalizeApplicationStatus | undefined;
    redirectUrl!: string | undefined;

    constructor(data?: IFinalizeApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
        }
    }

    static fromJS(data: any): FinalizeApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FinalizeApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        return data; 
    }
}

export interface IFinalizeApplicationResponse {
    status: FinalizeApplicationStatus | undefined;
    redirectUrl: string | undefined;
}

export class GetMemberInfoResponse implements IGetMemberInfoResponse {
    applicantId!: string | undefined;
    incompleteApplicationId!: number | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    zipCode!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;
    testMode!: boolean | undefined;
    profileSubmissionDate!: moment.Moment | undefined;

    constructor(data?: IGetMemberInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicantId = data["applicantId"];
            this.incompleteApplicationId = data["incompleteApplicationId"];
            this.clickId = data["clickId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.zipCode = data["zipCode"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.countryCode = data["countryCode"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.creditScore = data["creditScore"];
            this.testMode = data["testMode"];
            this.profileSubmissionDate = data["profileSubmissionDate"] ? moment(data["profileSubmissionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMemberInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantId"] = this.applicantId;
        data["incompleteApplicationId"] = this.incompleteApplicationId;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["zipCode"] = this.zipCode;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        data["testMode"] = this.testMode;
        data["profileSubmissionDate"] = this.profileSubmissionDate ? this.profileSubmissionDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetMemberInfoResponse {
    applicantId: string | undefined;
    incompleteApplicationId: number | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    zipCode: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
    testMode: boolean | undefined;
    profileSubmissionDate: moment.Moment | undefined;
}

export class RankRequest implements IRankRequest {
    ids!: number[];
    rank!: number;

    constructor(data?: IRankRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
            this.rank = data["rank"];
        }
    }

    static fromJS(data: any): RankRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RankRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["rank"] = this.rank;
        return data; 
    }
}

export interface IRankRequest {
    ids: number[];
    rank: number;
}

export enum MailSenderType {
    EPCVIP = "EPCVIP", 
    IAge = "IAge", 
    Ongage = "Ongage", 
    Platform = "Platform", 
}

export class SendAnnouncementRequest implements ISendAnnouncementRequest {
    campaignId!: number;
    offerDetailsLink!: string;
    serviceName!: MailSenderType;
    contactListName!: string | undefined;
    emailAddresses!: string[] | undefined;

    constructor(data?: ISendAnnouncementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.offerDetailsLink = data["offerDetailsLink"];
            this.serviceName = data["serviceName"];
            this.contactListName = data["contactListName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(item);
            }
        }
    }

    static fromJS(data: any): SendAnnouncementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendAnnouncementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["offerDetailsLink"] = this.offerDetailsLink;
        data["serviceName"] = this.serviceName;
        data["contactListName"] = this.contactListName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        return data; 
    }
}

export interface ISendAnnouncementRequest {
    campaignId: number;
    offerDetailsLink: string;
    serviceName: MailSenderType;
    contactListName: string | undefined;
    emailAddresses: string[] | undefined;
}

export enum CampaignTrafficSource {
    PPC_Default = "PPC_Default", 
    Email = "Email", 
    SEO = "SEO", 
    SMS = "SMS", 
    Decline = "Decline", 
    Reject = "Reject", 
    Display = "Display", 
    Mixed = "Mixed", 
    TypeIn = "TypeIn", 
    QualityControl = "QualityControl", 
    PPC_Email = "PPC_Email", 
    PPC_SEO = "PPC_SEO", 
    PPC_Decline = "PPC_Decline", 
    PPC_Reject = "PPC_Reject", 
    PPC_Display = "PPC_Display", 
}

export class OfferCategoryDto implements IOfferCategoryDto {
    name!: string | undefined;
    category!: CampaignCategory | undefined;

    constructor(data?: IOfferCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.category = data["category"];
        }
    }

    static fromJS(data: any): OfferCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data; 
    }
}

export interface IOfferCategoryDto {
    name: string | undefined;
    category: CampaignCategory | undefined;
}

export enum ParameterHandlerType {
    Default = "Default", 
}

export class ExtendOfferDto implements IExtendOfferDto {
    customName!: string | undefined;
    subId!: string | undefined;
    isPublished!: boolean | undefined;
    overallRating!: number | undefined;
    interestRating!: number | undefined;
    feesRating!: number | undefined;
    benefitsRating!: number | undefined;
    rewardsRating!: number | undefined;
    serviceRating!: number | undefined;
    cardNetwork!: CardNetwork | undefined;
    cardType!: CardType | undefined;
    targetAudience!: TargetAudience | undefined;
    securingType!: SecuringType | undefined;
    regularAPR!: string | undefined;
    introAPR!: string | undefined;
    balanceTransferFee!: string | undefined;
    annualFee!: string | undefined;
    monthlyFee!: string | undefined;
    activationFee!: string | undefined;
    introRewardsBonus!: string | undefined;
    rewardsRate!: string | undefined;
    durationForZeroPercentagePurchasesInMonths!: number | undefined;
    zeroPercentageInterestTransfers!: string | undefined;
    durationForZeroPercentageTransfersInMonths!: number | undefined;
    issuingBank!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    details!: string[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    minLoanTermMonths!: number | undefined;
    maxLoanTermMonths!: number | undefined;
    minAnnualIncome!: number | undefined;
    maxAnnualIncome!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    parameterHandlerType!: ParameterHandlerType | undefined;
    flags!: Flags | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    states!: string[] | undefined;

    constructor(data?: IExtendOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customName = data["customName"];
            this.subId = data["subId"];
            this.isPublished = data["isPublished"];
            this.overallRating = data["overallRating"];
            this.interestRating = data["interestRating"];
            this.feesRating = data["feesRating"];
            this.benefitsRating = data["benefitsRating"];
            this.rewardsRating = data["rewardsRating"];
            this.serviceRating = data["serviceRating"];
            this.cardNetwork = data["cardNetwork"];
            this.cardType = data["cardType"];
            this.targetAudience = data["targetAudience"];
            this.securingType = data["securingType"];
            this.regularAPR = data["regularAPR"];
            this.introAPR = data["introAPR"];
            this.balanceTransferFee = data["balanceTransferFee"];
            this.annualFee = data["annualFee"];
            this.monthlyFee = data["monthlyFee"];
            this.activationFee = data["activationFee"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.rewardsRate = data["rewardsRate"];
            this.durationForZeroPercentagePurchasesInMonths = data["durationForZeroPercentagePurchasesInMonths"];
            this.zeroPercentageInterestTransfers = data["zeroPercentageInterestTransfers"];
            this.durationForZeroPercentageTransfersInMonths = data["durationForZeroPercentageTransfersInMonths"];
            this.issuingBank = data["issuingBank"];
            this.offerCollection = data["offerCollection"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
            if (data["pros"] && data["pros"].constructor === Array) {
                this.pros = [];
                for (let item of data["pros"])
                    this.pros.push(item);
            }
            if (data["cons"] && data["cons"].constructor === Array) {
                this.cons = [];
                for (let item of data["cons"])
                    this.cons.push(item);
            }
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.minLoanTermMonths = data["minLoanTermMonths"];
            this.maxLoanTermMonths = data["maxLoanTermMonths"];
            this.minAnnualIncome = data["minAnnualIncome"];
            this.maxAnnualIncome = data["maxAnnualIncome"];
            this.campaignProviderType = data["campaignProviderType"];
            this.parameterHandlerType = data["parameterHandlerType"];
            this.flags = data["flags"] ? Flags.fromJS(data["flags"]) : <any>undefined;
            if (data["creditScores"] && data["creditScores"].constructor === Array) {
                this.creditScores = [];
                for (let item of data["creditScores"])
                    this.creditScores.push(item);
            }
            if (data["states"] && data["states"].constructor === Array) {
                this.states = [];
                for (let item of data["states"])
                    this.states.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customName"] = this.customName;
        data["subId"] = this.subId;
        data["isPublished"] = this.isPublished;
        data["overallRating"] = this.overallRating;
        data["interestRating"] = this.interestRating;
        data["feesRating"] = this.feesRating;
        data["benefitsRating"] = this.benefitsRating;
        data["rewardsRating"] = this.rewardsRating;
        data["serviceRating"] = this.serviceRating;
        data["cardNetwork"] = this.cardNetwork;
        data["cardType"] = this.cardType;
        data["targetAudience"] = this.targetAudience;
        data["securingType"] = this.securingType;
        data["regularAPR"] = this.regularAPR;
        data["introAPR"] = this.introAPR;
        data["balanceTransferFee"] = this.balanceTransferFee;
        data["annualFee"] = this.annualFee;
        data["monthlyFee"] = this.monthlyFee;
        data["activationFee"] = this.activationFee;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["rewardsRate"] = this.rewardsRate;
        data["durationForZeroPercentagePurchasesInMonths"] = this.durationForZeroPercentagePurchasesInMonths;
        data["zeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["durationForZeroPercentageTransfersInMonths"] = this.durationForZeroPercentageTransfersInMonths;
        data["issuingBank"] = this.issuingBank;
        data["offerCollection"] = this.offerCollection;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        if (this.pros && this.pros.constructor === Array) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (this.cons && this.cons.constructor === Array) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["minLoanTermMonths"] = this.minLoanTermMonths;
        data["maxLoanTermMonths"] = this.maxLoanTermMonths;
        data["minAnnualIncome"] = this.minAnnualIncome;
        data["maxAnnualIncome"] = this.maxAnnualIncome;
        data["campaignProviderType"] = this.campaignProviderType;
        data["parameterHandlerType"] = this.parameterHandlerType;
        data["flags"] = this.flags ? this.flags.toJSON() : <any>undefined;
        if (this.creditScores && this.creditScores.constructor === Array) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (this.states && this.states.constructor === Array) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item);
        }
        return data; 
    }
}

export interface IExtendOfferDto {
    customName: string | undefined;
    subId: string | undefined;
    isPublished: boolean | undefined;
    overallRating: number | undefined;
    interestRating: number | undefined;
    feesRating: number | undefined;
    benefitsRating: number | undefined;
    rewardsRating: number | undefined;
    serviceRating: number | undefined;
    cardNetwork: CardNetwork | undefined;
    cardType: CardType | undefined;
    targetAudience: TargetAudience | undefined;
    securingType: SecuringType | undefined;
    regularAPR: string | undefined;
    introAPR: string | undefined;
    balanceTransferFee: string | undefined;
    annualFee: string | undefined;
    monthlyFee: string | undefined;
    activationFee: string | undefined;
    introRewardsBonus: string | undefined;
    rewardsRate: string | undefined;
    durationForZeroPercentagePurchasesInMonths: number | undefined;
    zeroPercentageInterestTransfers: string | undefined;
    durationForZeroPercentageTransfersInMonths: number | undefined;
    issuingBank: string | undefined;
    offerCollection: OfferCollection | undefined;
    details: string[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    minLoanTermMonths: number | undefined;
    maxLoanTermMonths: number | undefined;
    minAnnualIncome: number | undefined;
    maxAnnualIncome: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    parameterHandlerType: ParameterHandlerType | undefined;
    flags: Flags | undefined;
    creditScores: CreditScoreRating[] | undefined;
    states: string[] | undefined;
}

export enum CampaignStatus {
    PendingReview = "PendingReview", 
    Active = "Active", 
    Denied = "Denied", 
    Suspended = "Suspended", 
    SuspendedRisk = "SuspendedRisk", 
    Inactive = "Inactive", 
    Dormant = "Dormant", 
    Deleted = "Deleted", 
}

export class OfferDetailsForEditDto implements IOfferDetailsForEditDto {
    daysOfWeekAvailability!: string | undefined;
    effectiveTimeOfDay!: string | undefined;
    expireTimeOfDay!: string | undefined;
    termsOfService!: string | undefined;
    trafficSource!: CampaignTrafficSource | undefined;
    categories!: OfferCategoryDto[] | undefined;
    description!: string | undefined;
    countries!: string[] | undefined;
    extendedInfo!: ExtendOfferDto | undefined;
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    campaignUrl!: string | undefined;
    logoUrl!: string | undefined;
    status!: CampaignStatus | undefined;
    type!: CampaignType | undefined;
    isPublished!: boolean | undefined;

    constructor(data?: IOfferDetailsForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.daysOfWeekAvailability = data["daysOfWeekAvailability"];
            this.effectiveTimeOfDay = data["effectiveTimeOfDay"];
            this.expireTimeOfDay = data["expireTimeOfDay"];
            this.termsOfService = data["termsOfService"];
            this.trafficSource = data["trafficSource"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(OfferCategoryDto.fromJS(item));
            }
            this.description = data["description"];
            if (data["countries"] && data["countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["countries"])
                    this.countries.push(item);
            }
            this.extendedInfo = data["extendedInfo"] ? ExtendOfferDto.fromJS(data["extendedInfo"]) : <any>undefined;
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.campaignUrl = data["campaignUrl"];
            this.logoUrl = data["logoUrl"];
            this.status = data["status"];
            this.type = data["type"];
            this.isPublished = data["isPublished"];
        }
    }

    static fromJS(data: any): OfferDetailsForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysOfWeekAvailability"] = this.daysOfWeekAvailability;
        data["effectiveTimeOfDay"] = this.effectiveTimeOfDay;
        data["expireTimeOfDay"] = this.expireTimeOfDay;
        data["termsOfService"] = this.termsOfService;
        data["trafficSource"] = this.trafficSource;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (this.countries && this.countries.constructor === Array) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item);
        }
        data["extendedInfo"] = this.extendedInfo ? this.extendedInfo.toJSON() : <any>undefined;
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["campaignUrl"] = this.campaignUrl;
        data["logoUrl"] = this.logoUrl;
        data["status"] = this.status;
        data["type"] = this.type;
        data["isPublished"] = this.isPublished;
        return data; 
    }
}

export interface IOfferDetailsForEditDto {
    daysOfWeekAvailability: string | undefined;
    effectiveTimeOfDay: string | undefined;
    expireTimeOfDay: string | undefined;
    termsOfService: string | undefined;
    trafficSource: CampaignTrafficSource | undefined;
    categories: OfferCategoryDto[] | undefined;
    description: string | undefined;
    countries: string[] | undefined;
    extendedInfo: ExtendOfferDto | undefined;
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    campaignUrl: string | undefined;
    logoUrl: string | undefined;
    status: CampaignStatus | undefined;
    type: CampaignType | undefined;
    isPublished: boolean | undefined;
}

export enum OfferAttributeType {
    SubId = "SubId", 
    IsPublished = "IsPublished", 
    OverallRating = "OverallRating", 
    IssuingBank = "IssuingBank", 
    AnnualFee = "AnnualFee", 
    RewardsRate = "RewardsRate", 
    IntroRewardsBonus = "IntroRewardsBonus", 
    RegularAPR = "RegularAPR", 
    CampaignProviderType = "CampaignProviderType", 
    OfferCollection = "OfferCollection", 
    MinLoanAmount = "MinLoanAmount", 
    MaxLoanAmount = "MaxLoanAmount", 
    MinLoanTermMonths = "MinLoanTermMonths", 
    MaxLoanTermMonths = "MaxLoanTermMonths", 
    MinAnnualIncome = "MinAnnualIncome", 
    MaxAnnualIncome = "MaxAnnualIncome", 
    States = "States", 
    ParameterHandlerType = "ParameterHandlerType", 
}

export class OfferFilter implements IOfferFilter {
    status!: CampaignStatus | undefined;
    type!: CampaignType | undefined;
    category!: CampaignCategory | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    campaignUrls!: string[] | undefined;
    strictMatch!: boolean | undefined;

    constructor(data?: IOfferFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.type = data["type"];
            this.category = data["category"];
            this.country = data["country"];
            this.state = data["state"];
            this.creditScore = data["creditScore"];
            this.isOfferCollection = data["isOfferCollection"];
            this.itemOfOfferCollection = data["itemOfOfferCollection"];
            this.loanAmount = data["loanAmount"];
            if (data["cardNetworks"] && data["cardNetworks"].constructor === Array) {
                this.cardNetworks = [];
                for (let item of data["cardNetworks"])
                    this.cardNetworks.push(item);
            }
            this.cardType = data["cardType"];
            this.securingType = data["securingType"];
            this.targetAudience = data["targetAudience"];
            this.annualIncome = data["annualIncome"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            if (data["campaignIds"] && data["campaignIds"].constructor === Array) {
                this.campaignIds = [];
                for (let item of data["campaignIds"])
                    this.campaignIds.push(item);
            }
            if (data["campaignUrls"] && data["campaignUrls"].constructor === Array) {
                this.campaignUrls = [];
                for (let item of data["campaignUrls"])
                    this.campaignUrls.push(item);
            }
            this.strictMatch = data["strictMatch"];
        }
    }

    static fromJS(data: any): OfferFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OfferFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["type"] = this.type;
        data["category"] = this.category;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (this.cardNetworks && this.cardNetworks.constructor === Array) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (this.campaignIds && this.campaignIds.constructor === Array) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        if (this.campaignUrls && this.campaignUrls.constructor === Array) {
            data["campaignUrls"] = [];
            for (let item of this.campaignUrls)
                data["campaignUrls"].push(item);
        }
        data["strictMatch"] = this.strictMatch;
        return data; 
    }
}

export interface IOfferFilter {
    status: CampaignStatus | undefined;
    type: CampaignType | undefined;
    category: CampaignCategory | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    campaignUrls: string[] | undefined;
    strictMatch: boolean | undefined;
}

export enum OfferFlagType {
    Choice = "Choice", 
    Best = "Best", 
    TravelAndAirlineMiles = "TravelAndAirlineMiles", 
    DinigRewards = "DinigRewards", 
    GasRewards = "GasRewards", 
    CashBackRewards = "CashBackRewards", 
    InstantDecision = "InstantDecision", 
    InstantResponse = "InstantResponse", 
    NoCreditCheck = "NoCreditCheck", 
    GuaranteedApproval = "GuaranteedApproval", 
    RebuildCredit = "RebuildCredit", 
    ChipCard = "ChipCard", 
    ApplePay = "ApplePay", 
    GroceryRewards = "GroceryRewards", 
    EntertainmentRewards = "EntertainmentRewards", 
    HotelRewards = "HotelRewards", 
    HasNoRewards = "HasNoRewards", 
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases", 
    ZeroPercentageInterestTransfers = "ZeroPercentageInterestTransfers", 
    Special = "Special", 
    Newest = "Newest", 
}

export class ExtendFromCSVOutput implements IExtendFromCSVOutput {
    notMatchedUrls!: string[] | undefined;

    constructor(data?: IExtendFromCSVOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["notMatchedUrls"] && data["notMatchedUrls"].constructor === Array) {
                this.notMatchedUrls = [];
                for (let item of data["notMatchedUrls"])
                    this.notMatchedUrls.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendFromCSVOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendFromCSVOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.notMatchedUrls && this.notMatchedUrls.constructor === Array) {
            data["notMatchedUrls"] = [];
            for (let item of this.notMatchedUrls)
                data["notMatchedUrls"].push(item);
        }
        return data; 
    }
}

export interface IExtendFromCSVOutput {
    notMatchedUrls: string[] | undefined;
}

export class OrderHistoryInfo implements IOrderHistoryInfo {
    time!: moment.Moment | undefined;
    type!: string | undefined;
    userId!: number | undefined;
    userFullName!: string | undefined;
    action!: string | undefined;
    stage!: string | undefined;

    constructor(data?: IOrderHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? moment(data["time"].toString()) : <any>undefined;
            this.type = data["type"];
            this.userId = data["userId"];
            this.userFullName = data["userFullName"];
            this.action = data["action"];
            this.stage = data["stage"];
        }
    }

    static fromJS(data: any): OrderHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrderHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["userId"] = this.userId;
        data["userFullName"] = this.userFullName;
        data["action"] = this.action;
        data["stage"] = this.stage;
        return data; 
    }
}

export interface IOrderHistoryInfo {
    time: moment.Moment | undefined;
    type: string | undefined;
    userId: number | undefined;
    userFullName: string | undefined;
    action: string | undefined;
    stage: string | undefined;
}

export class SetAmountInfo implements ISetAmountInfo {
    orderId!: number;
    amount!: number;

    constructor(data?: ISetAmountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): SetAmountInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SetAmountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface ISetAmountInfo {
    orderId: number;
    amount: number;
}

export class UpdateOrderStageInfo implements IUpdateOrderStageInfo {
    orderId!: number;
    stageId!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean | undefined;

    constructor(data?: IUpdateOrderStageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
            this.ignoreChecklist = data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): UpdateOrderStageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data; 
    }
}

export interface IUpdateOrderStageInfo {
    orderId: number;
    stageId: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean | undefined;
}

export class UpdateOrderStagePointInput implements IUpdateOrderStagePointInput {
    orderId!: number;
    pointId!: number;
    isDone!: boolean;

    constructor(data?: IUpdateOrderStagePointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.pointId = data["pointId"];
            this.isDone = data["isDone"];
        }
    }

    static fromJS(data: any): UpdateOrderStagePointInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStagePointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["pointId"] = this.pointId;
        data["isDone"] = this.isDone;
        return data; 
    }
}

export interface IUpdateOrderStagePointInput {
    orderId: number;
    pointId: number;
    isDone: boolean;
}

export class UpdateOrderAffiliateContactInput implements IUpdateOrderAffiliateContactInput {
    orderId!: number;
    affiliateContactId!: number;
    assignToBuyerContact!: boolean | undefined;

    constructor(data?: IUpdateOrderAffiliateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.affiliateContactId = data["affiliateContactId"];
            this.assignToBuyerContact = data["assignToBuyerContact"];
        }
    }

    static fromJS(data: any): UpdateOrderAffiliateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderAffiliateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["affiliateContactId"] = this.affiliateContactId;
        data["assignToBuyerContact"] = this.assignToBuyerContact;
        return data; 
    }
}

export interface IUpdateOrderAffiliateContactInput {
    orderId: number;
    affiliateContactId: number;
    assignToBuyerContact: boolean | undefined;
}

export class ProcessOrderInfo implements IProcessOrderInfo {
    id!: number;
    sortOrder!: number | undefined;
    ignoreChecklist!: boolean | undefined;

    constructor(data?: IProcessOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.ignoreChecklist = data["ignoreChecklist"];
        }
    }

    static fromJS(data: any): ProcessOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["ignoreChecklist"] = this.ignoreChecklist;
        return data; 
    }
}

export interface IProcessOrderInfo {
    id: number;
    sortOrder: number | undefined;
    ignoreChecklist: boolean | undefined;
}

export class CancelOrderInfo implements ICancelOrderInfo {
    orderId!: number;
    comment!: string;
    sortOrder!: number | undefined;

    constructor(data?: ICancelOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CancelOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICancelOrderInfo {
    orderId: number;
    comment: string;
    sortOrder: number | undefined;
}

export class SubscriptionServiceDto implements ISubscriptionServiceDto {
    id!: number | undefined;
    systemType!: string | undefined;
    serviceCode!: string | undefined;
    serviceName!: string | undefined;
    levelCode!: string | undefined;
    levelName!: string | undefined;

    constructor(data?: ISubscriptionServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.systemType = data["systemType"];
            this.serviceCode = data["serviceCode"];
            this.serviceName = data["serviceName"];
            this.levelCode = data["levelCode"];
            this.levelName = data["levelName"];
        }
    }

    static fromJS(data: any): SubscriptionServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemType"] = this.systemType;
        data["serviceCode"] = this.serviceCode;
        data["serviceName"] = this.serviceName;
        data["levelCode"] = this.levelCode;
        data["levelName"] = this.levelName;
        return data; 
    }
}

export interface ISubscriptionServiceDto {
    id: number | undefined;
    systemType: string | undefined;
    serviceCode: string | undefined;
    serviceName: string | undefined;
    levelCode: string | undefined;
    levelName: string | undefined;
}

export enum SubscriptionPaymentType {
    OriginalPayment = "OriginalPayment", 
    Installment = "Installment", 
    Refund = "Refund", 
    Chargeback = "Chargeback", 
    RecurringBilling = "RecurringBilling", 
}

export enum SubscriptionPaymentStatus {
    Pending = "Pending", 
    Approved = "Approved", 
    Declined = "Declined", 
    Active = "Active", 
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    id!: number | undefined;
    invoiceId!: number | undefined;
    invoiceDate!: moment.Moment | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    type!: SubscriptionPaymentType | undefined;
    seqNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    fee!: number | undefined;
    paymentProvider!: string | undefined;
    paymentId!: string | undefined;
    paymentDate!: moment.Moment | undefined;
    authorizationCode!: string | undefined;
    uniqueId!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.invoiceId = data["invoiceId"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.type = data["type"];
            this.seqNo = data["seqNo"];
            this.status = data["status"];
            this.fee = data["fee"];
            this.paymentProvider = data["paymentProvider"];
            this.paymentId = data["paymentId"];
            this.paymentDate = data["paymentDate"] ? moment(data["paymentDate"].toString()) : <any>undefined;
            this.authorizationCode = data["authorizationCode"];
            this.uniqueId = data["uniqueId"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["seqNo"] = this.seqNo;
        data["status"] = this.status;
        data["fee"] = this.fee;
        data["paymentProvider"] = this.paymentProvider;
        data["paymentId"] = this.paymentId;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["authorizationCode"] = this.authorizationCode;
        data["uniqueId"] = this.uniqueId;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    id: number | undefined;
    invoiceId: number | undefined;
    invoiceDate: moment.Moment | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    type: SubscriptionPaymentType | undefined;
    seqNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    fee: number | undefined;
    paymentProvider: string | undefined;
    paymentId: string | undefined;
    paymentDate: moment.Moment | undefined;
    authorizationCode: string | undefined;
    uniqueId: number | undefined;
}

export class OrderSubscriptionDto implements IOrderSubscriptionDto {
    id!: number | undefined;
    originalStartDate!: moment.Moment | undefined;
    originalTrialEndDate!: moment.Moment | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    trialEndDate!: moment.Moment | undefined;
    gracePeriodDayCount!: number | undefined;
    gracePeriodEndDate!: moment.Moment | undefined;
    productCode!: string | undefined;
    productName!: string | undefined;
    productThumbnailUrl!: string | undefined;
    fee!: number | undefined;
    statusCode!: string | undefined;
    status!: string | undefined;
    cancelationReason!: string | undefined;
    systemType!: string | undefined;
    systemMemberId!: string | undefined;
    previousSubscriptionId!: number | undefined;
    services!: SubscriptionServiceDto[] | undefined;
    payments!: SubscriptionPaymentDto[] | undefined;

    constructor(data?: IOrderSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.originalStartDate = data["originalStartDate"] ? moment(data["originalStartDate"].toString()) : <any>undefined;
            this.originalTrialEndDate = data["originalTrialEndDate"] ? moment(data["originalTrialEndDate"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.trialEndDate = data["trialEndDate"] ? moment(data["trialEndDate"].toString()) : <any>undefined;
            this.gracePeriodDayCount = data["gracePeriodDayCount"];
            this.gracePeriodEndDate = data["gracePeriodEndDate"] ? moment(data["gracePeriodEndDate"].toString()) : <any>undefined;
            this.productCode = data["productCode"];
            this.productName = data["productName"];
            this.productThumbnailUrl = data["productThumbnailUrl"];
            this.fee = data["fee"];
            this.statusCode = data["statusCode"];
            this.status = data["status"];
            this.cancelationReason = data["cancelationReason"];
            this.systemType = data["systemType"];
            this.systemMemberId = data["systemMemberId"];
            this.previousSubscriptionId = data["previousSubscriptionId"];
            if (data["services"] && data["services"].constructor === Array) {
                this.services = [];
                for (let item of data["services"])
                    this.services.push(SubscriptionServiceDto.fromJS(item));
            }
            if (data["payments"] && data["payments"].constructor === Array) {
                this.payments = [];
                for (let item of data["payments"])
                    this.payments.push(SubscriptionPaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalStartDate"] = this.originalStartDate ? this.originalStartDate.toISOString() : <any>undefined;
        data["originalTrialEndDate"] = this.originalTrialEndDate ? this.originalTrialEndDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trialEndDate"] = this.trialEndDate ? this.trialEndDate.toISOString() : <any>undefined;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        data["gracePeriodEndDate"] = this.gracePeriodEndDate ? this.gracePeriodEndDate.toISOString() : <any>undefined;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["productThumbnailUrl"] = this.productThumbnailUrl;
        data["fee"] = this.fee;
        data["statusCode"] = this.statusCode;
        data["status"] = this.status;
        data["cancelationReason"] = this.cancelationReason;
        data["systemType"] = this.systemType;
        data["systemMemberId"] = this.systemMemberId;
        data["previousSubscriptionId"] = this.previousSubscriptionId;
        if (this.services && this.services.constructor === Array) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (this.payments && this.payments.constructor === Array) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderSubscriptionDto {
    id: number | undefined;
    originalStartDate: moment.Moment | undefined;
    originalTrialEndDate: moment.Moment | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    trialEndDate: moment.Moment | undefined;
    gracePeriodDayCount: number | undefined;
    gracePeriodEndDate: moment.Moment | undefined;
    productCode: string | undefined;
    productName: string | undefined;
    productThumbnailUrl: string | undefined;
    fee: number | undefined;
    statusCode: string | undefined;
    status: string | undefined;
    cancelationReason: string | undefined;
    systemType: string | undefined;
    systemMemberId: string | undefined;
    previousSubscriptionId: number | undefined;
    services: SubscriptionServiceDto[] | undefined;
    payments: SubscriptionPaymentDto[] | undefined;
}

export class SubscriptionInput implements ISubscriptionInput {
    code!: string;
    name!: string;
    level!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: ISubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.level = data["level"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): SubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface ISubscriptionInput {
    code: string;
    name: string;
    level: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export class UpdateOrderSubscriptionProductInfo implements IUpdateOrderSubscriptionProductInfo {
    productId!: number | undefined;
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    hasRecurringBilling!: boolean | undefined;
    endDate!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderSubscriptionProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateOrderSubscriptionProductInfo {
    productId: number | undefined;
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    hasRecurringBilling: boolean | undefined;
    endDate: moment.Moment | undefined;
}

export class UpdateOrderSubscriptionInput implements IUpdateOrderSubscriptionInput {
    contactId!: number | undefined;
    contactXref!: string | undefined;
    leadId!: number | undefined;
    orderNumber!: string | undefined;
    subscriptions!: SubscriptionInput[] | undefined;
    products!: UpdateOrderSubscriptionProductInfo[] | undefined;
    productId!: number | undefined;
    productCode!: string | undefined;
    paymentPeriodType!: RecurringPaymentFrequency | undefined;
    hasRecurringBilling!: boolean | undefined;
    skipExisting!: boolean | undefined;

    constructor(data?: IUpdateOrderSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.contactXref = data["contactXref"];
            this.leadId = data["leadId"];
            this.orderNumber = data["orderNumber"];
            if (data["subscriptions"] && data["subscriptions"].constructor === Array) {
                this.subscriptions = [];
                for (let item of data["subscriptions"])
                    this.subscriptions.push(SubscriptionInput.fromJS(item));
            }
            if (data["products"] && data["products"].constructor === Array) {
                this.products = [];
                for (let item of data["products"])
                    this.products.push(UpdateOrderSubscriptionProductInfo.fromJS(item));
            }
            this.productId = data["productId"];
            this.productCode = data["productCode"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.skipExisting = data["skipExisting"];
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        data["leadId"] = this.leadId;
        data["orderNumber"] = this.orderNumber;
        if (this.subscriptions && this.subscriptions.constructor === Array) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        if (this.products && this.products.constructor === Array) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["skipExisting"] = this.skipExisting;
        return data; 
    }
}

export interface IUpdateOrderSubscriptionInput {
    contactId: number | undefined;
    contactXref: string | undefined;
    leadId: number | undefined;
    orderNumber: string | undefined;
    subscriptions: SubscriptionInput[] | undefined;
    products: UpdateOrderSubscriptionProductInfo[] | undefined;
    productId: number | undefined;
    productCode: string | undefined;
    paymentPeriodType: RecurringPaymentFrequency | undefined;
    hasRecurringBilling: boolean | undefined;
    skipExisting: boolean | undefined;
}

export class UpdateOrderSubscriptionPeriodInput implements IUpdateOrderSubscriptionPeriodInput {
    subscriptionId!: number;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;

    constructor(data?: IUpdateOrderSubscriptionPeriodInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionId = data["subscriptionId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateOrderSubscriptionPeriodInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderSubscriptionPeriodInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateOrderSubscriptionPeriodInput {
    subscriptionId: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
}

export class CancelOrderSubscriptionInput implements ICancelOrderSubscriptionInput {
    subscriptionId!: number;
    cancelationReason!: string | undefined;

    constructor(data?: ICancelOrderSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionId = data["subscriptionId"];
            this.cancelationReason = data["cancelationReason"];
        }
    }

    static fromJS(data: any): CancelOrderSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["cancelationReason"] = this.cancelationReason;
        return data; 
    }
}

export interface ICancelOrderSubscriptionInput {
    subscriptionId: number;
    cancelationReason: string | undefined;
}

export class CancelAllInput implements ICancelAllInput {
    contactId!: number;
    productCodes!: string[] | undefined;
    serviceCodes!: string[] | undefined;
    cancelationReason!: string | undefined;

    constructor(data?: ICancelAllInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["productCodes"] && data["productCodes"].constructor === Array) {
                this.productCodes = [];
                for (let item of data["productCodes"])
                    this.productCodes.push(item);
            }
            if (data["serviceCodes"] && data["serviceCodes"].constructor === Array) {
                this.serviceCodes = [];
                for (let item of data["serviceCodes"])
                    this.serviceCodes.push(item);
            }
            this.cancelationReason = data["cancelationReason"];
        }
    }

    static fromJS(data: any): CancelAllInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelAllInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.productCodes && this.productCodes.constructor === Array) {
            data["productCodes"] = [];
            for (let item of this.productCodes)
                data["productCodes"].push(item);
        }
        if (this.serviceCodes && this.serviceCodes.constructor === Array) {
            data["serviceCodes"] = [];
            for (let item of this.serviceCodes)
                data["serviceCodes"].push(item);
        }
        data["cancelationReason"] = this.cancelationReason;
        return data; 
    }
}

export interface ICancelAllInput {
    contactId: number;
    productCodes: string[] | undefined;
    serviceCodes: string[] | undefined;
    cancelationReason: string | undefined;
}

export class OrganizationInfoDto implements IOrganizationInfoDto {
    rootOrganizationUnitId!: number | undefined;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: IOrganizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rootOrganizationUnitId = data["rootOrganizationUnitId"];
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.affiliateCode = data["affiliateCode"];
            this.departmentCode = data["departmentCode"];
        }
    }

    static fromJS(data: any): OrganizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootOrganizationUnitId"] = this.rootOrganizationUnitId;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data; 
    }
}

export interface IOrganizationInfoDto {
    rootOrganizationUnitId: number | undefined;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class PersonShortInfoDto implements IPersonShortInfoDto {
    id!: number | undefined;
    fullName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    photoPublicId!: string | undefined;

    constructor(data?: IPersonShortInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.jobTitle = data["jobTitle"];
            this.ratingId = data["ratingId"];
            this.photoPublicId = data["photoPublicId"];
        }
    }

    static fromJS(data: any): PersonShortInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonShortInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["photoPublicId"] = this.photoPublicId;
        return data; 
    }
}

export interface IPersonShortInfoDto {
    id: number | undefined;
    fullName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    photoPublicId: string | undefined;
}

export class OrganizationContactInfoDto implements IOrganizationContactInfoDto {
    organization!: OrganizationInfoDto | undefined;
    contactPersons!: PersonShortInfoDto[] | undefined;
    isUpdatable!: boolean | undefined;
    id!: number | undefined;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IOrganizationContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"] ? OrganizationInfoDto.fromJS(data["organization"]) : <any>undefined;
            if (data["contactPersons"] && data["contactPersons"].constructor === Array) {
                this.contactPersons = [];
                for (let item of data["contactPersons"])
                    this.contactPersons.push(PersonShortInfoDto.fromJS(item));
            }
            this.isUpdatable = data["isUpdatable"];
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.userId = data["userId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryAddressId = data["primaryAddressId"];
            this.primaryPhoto = data["primaryPhoto"];
            this.details = data["details"] ? ContactInfoDetailsDto.fromJS(data["details"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): OrganizationContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (this.contactPersons && this.contactPersons.constructor === Array) {
            data["contactPersons"] = [];
            for (let item of this.contactPersons)
                data["contactPersons"].push(item.toJSON());
        }
        data["isUpdatable"] = this.isUpdatable;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IOrganizationContactInfoDto {
    organization: OrganizationInfoDto | undefined;
    contactPersons: PersonShortInfoDto[] | undefined;
    isUpdatable: boolean | undefined;
    id: number | undefined;
    fullName: string | undefined;
    userId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export class CreateOrganizationInput implements ICreateOrganizationInput {
    relatedContactId!: number;
    relationTypeId!: string;
    createRootOrganizationUnit!: boolean | undefined;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: ICreateOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.relatedContactId = data["relatedContactId"];
            this.relationTypeId = data["relationTypeId"];
            this.createRootOrganizationUnit = data["createRootOrganizationUnit"];
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.affiliateCode = data["affiliateCode"];
            this.departmentCode = data["departmentCode"];
        }
    }

    static fromJS(data: any): CreateOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedContactId"] = this.relatedContactId;
        data["relationTypeId"] = this.relationTypeId;
        data["createRootOrganizationUnit"] = this.createRootOrganizationUnit;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data; 
    }
}

export interface ICreateOrganizationInput {
    relatedContactId: number;
    relationTypeId: string;
    createRootOrganizationUnit: boolean | undefined;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class CreateOrganizationOutput implements ICreateOrganizationOutput {
    id!: number | undefined;

    constructor(data?: ICreateOrganizationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrganizationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrganizationOutput {
    id: number | undefined;
}

export class CreateOrgUnitForOrganizationInput implements ICreateOrgUnitForOrganizationInput {
    organizationId!: number | undefined;
    organizationName!: string | undefined;

    constructor(data?: ICreateOrgUnitForOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
        }
    }

    static fromJS(data: any): CreateOrgUnitForOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrgUnitForOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        return data; 
    }
}

export interface ICreateOrgUnitForOrganizationInput {
    organizationId: number | undefined;
    organizationName: string | undefined;
}

export class CreateOrgUnitForOrganizationOutput implements ICreateOrgUnitForOrganizationOutput {
    organizationUnitId!: number | undefined;

    constructor(data?: ICreateOrgUnitForOrganizationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateOrgUnitForOrganizationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrgUnitForOrganizationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateOrgUnitForOrganizationOutput {
    organizationUnitId: number | undefined;
}

export class UpdateOrganizationInfoInput implements IUpdateOrganizationInfoInput {
    id!: number;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    affiliateCode!: string | undefined;
    departmentCode!: string | undefined;

    constructor(data?: IUpdateOrganizationInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.affiliateCode = data["affiliateCode"];
            this.departmentCode = data["departmentCode"];
        }
    }

    static fromJS(data: any): UpdateOrganizationInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["affiliateCode"] = this.affiliateCode;
        data["departmentCode"] = this.departmentCode;
        return data; 
    }
}

export interface IUpdateOrganizationInfoInput {
    id: number;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    affiliateCode: string | undefined;
    departmentCode: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PackageDto implements IPackageDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    initialPaymentAmount!: number | undefined;
    trialPeriodDays!: number | undefined;
    monthlyPaymentAmount!: number | undefined;
    isActive!: boolean | undefined;
    isDemo!: boolean | undefined;
    isSimulatorEnabled!: boolean | undefined;

    constructor(data?: IPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.initialPaymentAmount = data["initialPaymentAmount"];
            this.trialPeriodDays = data["trialPeriodDays"];
            this.monthlyPaymentAmount = data["monthlyPaymentAmount"];
            this.isActive = data["isActive"];
            this.isDemo = data["isDemo"];
            this.isSimulatorEnabled = data["isSimulatorEnabled"];
        }
    }

    static fromJS(data: any): PackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["initialPaymentAmount"] = this.initialPaymentAmount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["monthlyPaymentAmount"] = this.monthlyPaymentAmount;
        data["isActive"] = this.isActive;
        data["isDemo"] = this.isDemo;
        data["isSimulatorEnabled"] = this.isSimulatorEnabled;
        return data; 
    }
}

export interface IPackageDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    initialPaymentAmount: number | undefined;
    trialPeriodDays: number | undefined;
    monthlyPaymentAmount: number | undefined;
    isActive: boolean | undefined;
    isDemo: boolean | undefined;
    isSimulatorEnabled: boolean | undefined;
}

export class PackageDtoListResultDto implements IPackageDtoListResultDto {
    items!: PackageDto[] | undefined;

    constructor(data?: IPackageDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageDtoListResultDto {
    items: PackageDto[] | undefined;
}

export class ModuleSubscriptionInfoExtended implements IModuleSubscriptionInfoExtended {
    isTrial!: boolean | undefined;
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfoExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isTrial = data["isTrial"];
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
            this.frequency = data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoExtended {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTrial"] = this.isTrial;
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data; 
    }
}

export interface IModuleSubscriptionInfoExtended {
    isTrial: boolean | undefined;
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export class LocalizableString implements ILocalizableString {
    sourceName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ILocalizableString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceName = data["sourceName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): LocalizableString {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILocalizableString {
    sourceName: string | undefined;
    name: string | undefined;
}

export enum MeasurementUnit {
    GB = "GB", 
}

export class PricingTableFeatureDefinition implements IPricingTableFeatureDefinition {
    name!: string | undefined;
    displayName!: LocalizableString | undefined;
    isVariable!: boolean | undefined;
    sortOrder!: number | undefined;
    isStatic!: boolean | undefined;
    measurementUnit!: MeasurementUnit | undefined;
    isCommon!: boolean | undefined;

    constructor(data?: IPricingTableFeatureDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"] ? LocalizableString.fromJS(data["displayName"]) : <any>undefined;
            this.isVariable = data["isVariable"];
            this.sortOrder = data["sortOrder"];
            this.isStatic = data["isStatic"];
            this.measurementUnit = data["measurementUnit"];
            this.isCommon = data["isCommon"];
        }
    }

    static fromJS(data: any): PricingTableFeatureDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new PricingTableFeatureDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["isVariable"] = this.isVariable;
        data["sortOrder"] = this.sortOrder;
        data["isStatic"] = this.isStatic;
        data["measurementUnit"] = this.measurementUnit;
        data["isCommon"] = this.isCommon;
        return data; 
    }
}

export interface IPricingTableFeatureDefinition {
    name: string | undefined;
    displayName: LocalizableString | undefined;
    isVariable: boolean | undefined;
    sortOrder: number | undefined;
    isStatic: boolean | undefined;
    measurementUnit: MeasurementUnit | undefined;
    isCommon: boolean | undefined;
}

export class PackageEditionConfigFeatureDto implements IPackageEditionConfigFeatureDto {
    definition!: PricingTableFeatureDefinition | undefined;
    value!: string | undefined;

    constructor(data?: IPackageEditionConfigFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.definition = data["definition"] ? PricingTableFeatureDefinition.fromJS(data["definition"]) : <any>undefined;
            this.value = data["value"];
        }
    }

    static fromJS(data: any): PackageEditionConfigFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definition"] = this.definition ? this.definition.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPackageEditionConfigFeatureDto {
    definition: PricingTableFeatureDefinition | undefined;
    value: string | undefined;
}

export class PackageEditionConfigDto implements IPackageEditionConfigDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    maxUserCount!: number | undefined;
    features!: PackageEditionConfigFeatureDto[] | undefined;

    constructor(data?: IPackageEditionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.maxUserCount = data["maxUserCount"];
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(PackageEditionConfigFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageEditionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["maxUserCount"] = this.maxUserCount;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageEditionConfigDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    maxUserCount: number | undefined;
    features: PackageEditionConfigFeatureDto[] | undefined;
}

export class PackageConfigDto implements IPackageConfigDto {
    id!: number | undefined;
    module!: ModuleType | undefined;
    moduleName!: string | undefined;
    name!: string | undefined;
    bestValue!: boolean | undefined;
    sortOrder!: number | undefined;
    editions!: PackageEditionConfigDto[] | undefined;

    constructor(data?: IPackageConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.module = data["module"];
            this.moduleName = data["moduleName"];
            this.name = data["name"];
            this.bestValue = data["bestValue"];
            this.sortOrder = data["sortOrder"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(PackageEditionConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["moduleName"] = this.moduleName;
        data["name"] = this.name;
        data["bestValue"] = this.bestValue;
        data["sortOrder"] = this.sortOrder;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageConfigDto {
    id: number | undefined;
    module: ModuleType | undefined;
    moduleName: string | undefined;
    name: string | undefined;
    bestValue: boolean | undefined;
    sortOrder: number | undefined;
    editions: PackageEditionConfigDto[] | undefined;
}

export class GetPackagesConfigOutput implements IGetPackagesConfigOutput {
    currentSubscriptionInfo!: ModuleSubscriptionInfoExtended | undefined;
    packages!: PackageConfigDto[] | undefined;

    constructor(data?: IGetPackagesConfigOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentSubscriptionInfo = data["currentSubscriptionInfo"] ? ModuleSubscriptionInfoExtended.fromJS(data["currentSubscriptionInfo"]) : <any>undefined;
            if (data["packages"] && data["packages"].constructor === Array) {
                this.packages = [];
                for (let item of data["packages"])
                    this.packages.push(PackageConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPackagesConfigOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesConfigOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentSubscriptionInfo"] = this.currentSubscriptionInfo ? this.currentSubscriptionInfo.toJSON() : <any>undefined;
        if (this.packages && this.packages.constructor === Array) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPackagesConfigOutput {
    currentSubscriptionInfo: ModuleSubscriptionInfoExtended | undefined;
    packages: PackageConfigDto[] | undefined;
}

export class PartnerInfoDto implements IPartnerInfoDto {
    typeId!: number | undefined;

    constructor(data?: IPartnerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): PartnerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IPartnerInfoDto {
    typeId: number | undefined;
}

export class UpdatePartnerTypeInput implements IUpdatePartnerTypeInput {
    partnerId!: number;
    typeName!: string | undefined;

    constructor(data?: IUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.partnerId = data["partnerId"];
            this.typeName = data["typeName"];
        }
    }

    static fromJS(data: any): UpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        data["typeName"] = this.typeName;
        return data; 
    }
}

export interface IUpdatePartnerTypeInput {
    partnerId: number;
    typeName: string | undefined;
}

export class BulkUpdatePartnerTypeInput implements IBulkUpdatePartnerTypeInput {
    partnerIds!: number[];
    typeName!: string | undefined;

    constructor(data?: IBulkUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.partnerIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["partnerIds"] && data["partnerIds"].constructor === Array) {
                this.partnerIds = [];
                for (let item of data["partnerIds"])
                    this.partnerIds.push(item);
            }
            this.typeName = data["typeName"];
        }
    }

    static fromJS(data: any): BulkUpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.partnerIds && this.partnerIds.constructor === Array) {
            data["partnerIds"] = [];
            for (let item of this.partnerIds)
                data["partnerIds"].push(item);
        }
        data["typeName"] = this.typeName;
        return data; 
    }
}

export interface IBulkUpdatePartnerTypeInput {
    partnerIds: number[];
    typeName: string | undefined;
}

export class RenamePartnerTypeInput implements IRenamePartnerTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IRenamePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenamePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenamePartnerTypeInput {
    id: number;
    name: string;
}

export class ShortPaymentInfo implements IShortPaymentInfo {
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IShortPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): ShortPaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ShortPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IShortPaymentInfo {
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class GetPaymentsDto implements IGetPaymentsDto {
    totalPaymentAmount!: number | undefined;
    hasRecurringBilling!: boolean | undefined;
    payments!: ShortPaymentInfo[] | undefined;

    constructor(data?: IGetPaymentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalPaymentAmount = data["totalPaymentAmount"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            if (data["payments"] && data["payments"].constructor === Array) {
                this.payments = [];
                for (let item of data["payments"])
                    this.payments.push(ShortPaymentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPaymentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaymentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPaymentAmount"] = this.totalPaymentAmount;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        if (this.payments && this.payments.constructor === Array) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPaymentsDto {
    totalPaymentAmount: number | undefined;
    hasRecurringBilling: boolean | undefined;
    payments: ShortPaymentInfo[] | undefined;
}

export enum CustomerAccountingType {
    _0 = 0, 
    _1 = 1, 
}

export class ACHCustomerShortInfo implements IACHCustomerShortInfo {
    firstName!: string | undefined;
    lastName!: string | undefined;
    customerAcctType!: CustomerAccountingType | undefined;

    constructor(data?: IACHCustomerShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.customerAcctType = data["customerAcctType"];
        }
    }

    static fromJS(data: any): ACHCustomerShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["customerAcctType"] = this.customerAcctType;
        return data; 
    }
}

export interface IACHCustomerShortInfo {
    firstName: string | undefined;
    lastName: string | undefined;
    customerAcctType: CustomerAccountingType | undefined;
}

export class BankCardShortInfo implements IBankCardShortInfo {
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;

    constructor(data?: IBankCardShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
        }
    }

    static fromJS(data: any): BankCardShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        return data; 
    }
}

export interface IBankCardShortInfo {
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
}

export class PaymentMethodInfo implements IPaymentMethodInfo {
    type!: PaymentInfoType | undefined;
    achCustomerInfo!: ACHCustomerShortInfo | undefined;
    bankCardInfo!: BankCardShortInfo | undefined;

    constructor(data?: IPaymentMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.achCustomerInfo = data["achCustomerInfo"] ? ACHCustomerShortInfo.fromJS(data["achCustomerInfo"]) : <any>undefined;
            this.bankCardInfo = data["bankCardInfo"] ? BankCardShortInfo.fromJS(data["bankCardInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentMethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["achCustomerInfo"] = this.achCustomerInfo ? this.achCustomerInfo.toJSON() : <any>undefined;
        data["bankCardInfo"] = this.bankCardInfo ? this.bankCardInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaymentMethodInfo {
    type: PaymentInfoType | undefined;
    achCustomerInfo: ACHCustomerShortInfo | undefined;
    bankCardInfo: BankCardShortInfo | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class FlatPermissionWithLevelDtoListResultDto implements IFlatPermissionWithLevelDtoListResultDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IFlatPermissionWithLevelDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class UpdatePersonInfoInput implements IUpdatePersonInfoInput {
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.id = data["id"];
            this.bankCode = data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data; 
    }
}

export interface IUpdatePersonInfoInput {
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonBANKCodeInput implements IUpdatePersonBANKCodeInput {
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonBANKCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankCode = data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonBANKCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonBANKCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data; 
    }
}

export interface IUpdatePersonBANKCodeInput {
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonNameInput implements IUpdatePersonNameInput {
    id!: number;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;

    constructor(data?: IUpdatePersonNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        return data; 
    }
}

export interface IUpdatePersonNameInput {
    id: number;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
}

export class UpdatePersonNameOutput implements IUpdatePersonNameOutput {
    fullName!: string | undefined;

    constructor(data?: IUpdatePersonNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUpdatePersonNameOutput {
    fullName: string | undefined;
}

export class CreateUserForContactInput implements ICreateUserForContactInput {
    contactId!: number;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    changePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    generateAutoLoginLink!: boolean | undefined;
    assignedRoleNames!: string[] | undefined;
    organizationUnitIds!: number[] | undefined;

    constructor(data?: ICreateUserForContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.changePasswordOnNextLogin = data["changePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.generateAutoLoginLink = data["generateAutoLoginLink"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            if (data["organizationUnitIds"] && data["organizationUnitIds"].constructor === Array) {
                this.organizationUnitIds = [];
                for (let item of data["organizationUnitIds"])
                    this.organizationUnitIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserForContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserForContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["changePasswordOnNextLogin"] = this.changePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["generateAutoLoginLink"] = this.generateAutoLoginLink;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        if (this.organizationUnitIds && this.organizationUnitIds.constructor === Array) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateUserForContactInput {
    contactId: number;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    changePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    generateAutoLoginLink: boolean | undefined;
    assignedRoleNames: string[] | undefined;
    organizationUnitIds: number[] | undefined;
}

export class CreateUserForContactOutput implements ICreateUserForContactOutput {
    userId!: number | undefined;
    autoLoginLink!: string | undefined;

    constructor(data?: ICreateUserForContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.autoLoginLink = data["autoLoginLink"];
        }
    }

    static fromJS(data: any): CreateUserForContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserForContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["autoLoginLink"] = this.autoLoginLink;
        return data; 
    }
}

export interface ICreateUserForContactOutput {
    userId: number | undefined;
    autoLoginLink: string | undefined;
}

export class PersonHistoryDto implements IPersonHistoryDto {
    id!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    creatorUserName!: string | undefined;
    creatorUserPhotoPublicId!: string | undefined;
    source!: string | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    monthlyGoal!: number | undefined;

    constructor(data?: IPersonHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.creatorUserName = data["creatorUserName"];
            this.creatorUserPhotoPublicId = data["creatorUserPhotoPublicId"];
            this.source = data["source"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            this.monthlyGoal = data["monthlyGoal"];
        }
    }

    static fromJS(data: any): PersonHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUserName"] = this.creatorUserName;
        data["creatorUserPhotoPublicId"] = this.creatorUserPhotoPublicId;
        data["source"] = this.source;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        data["monthlyGoal"] = this.monthlyGoal;
        return data; 
    }
}

export interface IPersonHistoryDto {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    creatorUserName: string | undefined;
    creatorUserPhotoPublicId: string | undefined;
    source: string | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    monthlyGoal: number | undefined;
}

export class CreatePersonOrgRelationInput implements ICreatePersonOrgRelationInput {
    personId!: number;
    organizationId!: number | undefined;
    organizationName!: string | undefined;
    relationshipType!: string;
    jobTitle!: string | undefined;

    constructor(data?: ICreatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.relationshipType = data["relationshipType"];
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface ICreatePersonOrgRelationInput {
    personId: number;
    organizationId: number | undefined;
    organizationName: string | undefined;
    relationshipType: string;
    jobTitle: string | undefined;
}

export class CreatePersonOrgRelationOutput implements ICreatePersonOrgRelationOutput {
    id!: number | undefined;
    organizationId!: number | undefined;

    constructor(data?: ICreatePersonOrgRelationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationId = data["organizationId"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface ICreatePersonOrgRelationOutput {
    id: number | undefined;
    organizationId: number | undefined;
}

export class UpdatePersonOrgRelationInput implements IUpdatePersonOrgRelationInput {
    id!: number;
    relationshipType!: string;
    jobTitle!: string | undefined;

    constructor(data?: IUpdatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.relationshipType = data["relationshipType"];
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): UpdatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface IUpdatePersonOrgRelationInput {
    id: number;
    relationshipType: string;
    jobTitle: string | undefined;
}

export class ActionDto implements IActionDto {
    id!: number | undefined;
    name!: string | undefined;
    sysId!: string | undefined;
    targetStageId!: number | undefined;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            this.targetStageId = data["targetStageId"];
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        data["targetStageId"] = this.targetStageId;
        return data; 
    }
}

export interface IActionDto {
    id: number | undefined;
    name: string | undefined;
    sysId: string | undefined;
    targetStageId: number | undefined;
}

export class StageChecklistPointDto implements IStageChecklistPointDto {
    id!: number | undefined;
    name!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IStageChecklistPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): StageChecklistPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageChecklistPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IStageChecklistPointDto {
    id: number | undefined;
    name: string | undefined;
    sortOrder: number | undefined;
}

export class StageDto implements IStageDto {
    id!: number | undefined;
    name!: string | undefined;
    sortOrder!: number | undefined;
    color!: string | undefined;
    isFinal!: boolean | undefined;
    accessibleActions!: ActionDto[] | undefined;
    checklistPoints!: StageChecklistPointDto[] | undefined;

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
            this.color = data["color"];
            this.isFinal = data["isFinal"];
            if (data["accessibleActions"] && data["accessibleActions"].constructor === Array) {
                this.accessibleActions = [];
                for (let item of data["accessibleActions"])
                    this.accessibleActions.push(ActionDto.fromJS(item));
            }
            if (data["checklistPoints"] && data["checklistPoints"].constructor === Array) {
                this.checklistPoints = [];
                for (let item of data["checklistPoints"])
                    this.checklistPoints.push(StageChecklistPointDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        data["color"] = this.color;
        data["isFinal"] = this.isFinal;
        if (this.accessibleActions && this.accessibleActions.constructor === Array) {
            data["accessibleActions"] = [];
            for (let item of this.accessibleActions)
                data["accessibleActions"].push(item.toJSON());
        }
        if (this.checklistPoints && this.checklistPoints.constructor === Array) {
            data["checklistPoints"] = [];
            for (let item of this.checklistPoints)
                data["checklistPoints"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStageDto {
    id: number | undefined;
    name: string | undefined;
    sortOrder: number | undefined;
    color: string | undefined;
    isFinal: boolean | undefined;
    accessibleActions: ActionDto[] | undefined;
    checklistPoints: StageChecklistPointDto[] | undefined;
}

export class PipelineDto implements IPipelineDto {
    id!: number | undefined;
    name!: string | undefined;
    purposeId!: string | undefined;
    purpose!: string | undefined;
    contactGroupId!: string | undefined;
    entityTypeId!: number | undefined;
    entityTypeSysId!: string | undefined;
    stages!: StageDto[] | undefined;

    constructor(data?: IPipelineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.purposeId = data["purposeId"];
            this.purpose = data["purpose"];
            this.contactGroupId = data["contactGroupId"];
            this.entityTypeId = data["entityTypeId"];
            this.entityTypeSysId = data["entityTypeSysId"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(StageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["purposeId"] = this.purposeId;
        data["purpose"] = this.purpose;
        data["contactGroupId"] = this.contactGroupId;
        data["entityTypeId"] = this.entityTypeId;
        data["entityTypeSysId"] = this.entityTypeSysId;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPipelineDto {
    id: number | undefined;
    name: string | undefined;
    purposeId: string | undefined;
    purpose: string | undefined;
    contactGroupId: string | undefined;
    entityTypeId: number | undefined;
    entityTypeSysId: string | undefined;
    stages: StageDto[] | undefined;
}

export class UpdateSortOrderInput implements IUpdateSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateSortOrderInput {
    id: number;
    sortOrder: number;
}

export class PipelineCreateInput implements IPipelineCreateInput {
    name!: string | undefined;
    purposeId!: string;
    contactGroupId!: string;
    entityTypeId!: number | undefined;

    constructor(data?: IPipelineCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.purposeId = data["purposeId"];
            this.contactGroupId = data["contactGroupId"];
            this.entityTypeId = data["entityTypeId"];
        }
    }

    static fromJS(data: any): PipelineCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["purposeId"] = this.purposeId;
        data["contactGroupId"] = this.contactGroupId;
        data["entityTypeId"] = this.entityTypeId;
        return data; 
    }
}

export interface IPipelineCreateInput {
    name: string | undefined;
    purposeId: string;
    contactGroupId: string;
    entityTypeId: number | undefined;
}

export class PipelineRenameInput implements IPipelineRenameInput {
    id!: number;
    name!: string;

    constructor(data?: IPipelineRenameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PipelineRenameInput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineRenameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPipelineRenameInput {
    id: number;
    name: string;
}

export class ProductServiceInfo implements IProductServiceInfo {
    memberServiceId!: number | undefined;
    memberServiceLevelId!: number | undefined;

    constructor(data?: IProductServiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberServiceId = data["memberServiceId"];
            this.memberServiceLevelId = data["memberServiceLevelId"];
        }
    }

    static fromJS(data: any): ProductServiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductServiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberServiceId"] = this.memberServiceId;
        data["memberServiceLevelId"] = this.memberServiceLevelId;
        return data; 
    }
}

export interface IProductServiceInfo {
    memberServiceId: number | undefined;
    memberServiceLevelId: number | undefined;
}

export class ProductSubscriptionOptionInfo implements IProductSubscriptionOptionInfo {
    frequency!: RecurringPaymentFrequency | undefined;
    signupFee!: number | undefined;
    commissionableSignupFeeAmount!: number | undefined;
    fee!: number | undefined;
    commissionableFeeAmount!: number | undefined;
    trialDayCount!: number | undefined;
    gracePeriodDayCount!: number | undefined;

    constructor(data?: IProductSubscriptionOptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frequency = data["frequency"];
            this.signupFee = data["signupFee"];
            this.commissionableSignupFeeAmount = data["commissionableSignupFeeAmount"];
            this.fee = data["fee"];
            this.commissionableFeeAmount = data["commissionableFeeAmount"];
            this.trialDayCount = data["trialDayCount"];
            this.gracePeriodDayCount = data["gracePeriodDayCount"];
        }
    }

    static fromJS(data: any): ProductSubscriptionOptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSubscriptionOptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frequency"] = this.frequency;
        data["signupFee"] = this.signupFee;
        data["commissionableSignupFeeAmount"] = this.commissionableSignupFeeAmount;
        data["fee"] = this.fee;
        data["commissionableFeeAmount"] = this.commissionableFeeAmount;
        data["trialDayCount"] = this.trialDayCount;
        data["gracePeriodDayCount"] = this.gracePeriodDayCount;
        return data; 
    }
}

export interface IProductSubscriptionOptionInfo {
    frequency: RecurringPaymentFrequency | undefined;
    signupFee: number | undefined;
    commissionableSignupFeeAmount: number | undefined;
    fee: number | undefined;
    commissionableFeeAmount: number | undefined;
    trialDayCount: number | undefined;
    gracePeriodDayCount: number | undefined;
}

export class ProductInfo implements IProductInfo {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    groupId!: number | undefined;
    type!: ProductType | undefined;
    price!: number | undefined;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    imageUrl!: string | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: IProductInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.groupId = data["groupId"];
            this.type = data["type"];
            this.price = data["price"];
            this.commissionableAmount = data["commissionableAmount"];
            this.maxCommissionRate = data["maxCommissionRate"];
            this.maxCommissionRateTier2 = data["maxCommissionRateTier2"];
            this.unit = data["unit"];
            this.imageUrl = data["imageUrl"];
            if (data["productServices"] && data["productServices"].constructor === Array) {
                this.productServices = [];
                for (let item of data["productServices"])
                    this.productServices.push(ProductServiceInfo.fromJS(item));
            }
            if (data["productSubscriptionOptions"] && data["productSubscriptionOptions"].constructor === Array) {
                this.productSubscriptionOptions = [];
                for (let item of data["productSubscriptionOptions"])
                    this.productSubscriptionOptions.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        data["imageUrl"] = this.imageUrl;
        if (this.productServices && this.productServices.constructor === Array) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (this.productSubscriptionOptions && this.productSubscriptionOptions.constructor === Array) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductInfo {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    groupId: number | undefined;
    type: ProductType | undefined;
    price: number | undefined;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    imageUrl: string | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export class ProductDto implements IProductDto {
    id!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    group!: string | undefined;
    paymentPeriodTypes!: RecurringPaymentFrequency[] | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.group = data["group"];
            if (data["paymentPeriodTypes"] && data["paymentPeriodTypes"].constructor === Array) {
                this.paymentPeriodTypes = [];
                for (let item of data["paymentPeriodTypes"])
                    this.paymentPeriodTypes.push(item);
            }
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["group"] = this.group;
        if (this.paymentPeriodTypes && this.paymentPeriodTypes.constructor === Array) {
            data["paymentPeriodTypes"] = [];
            for (let item of this.paymentPeriodTypes)
                data["paymentPeriodTypes"].push(item);
        }
        return data; 
    }
}

export interface IProductDto {
    id: number | undefined;
    code: string | undefined;
    name: string | undefined;
    group: string | undefined;
    paymentPeriodTypes: RecurringPaymentFrequency[] | undefined;
}

export class ProductPaymentOptionInfo implements IProductPaymentOptionInfo {
    unitId!: ProductMeasurementUnit | undefined;
    unitName!: string | undefined;
    price!: number | undefined;

    constructor(data?: IProductPaymentOptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): ProductPaymentOptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPaymentOptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["price"] = this.price;
        return data; 
    }
}

export interface IProductPaymentOptionInfo {
    unitId: ProductMeasurementUnit | undefined;
    unitName: string | undefined;
    price: number | undefined;
}

export class ProductPaymentOptionsInfo implements IProductPaymentOptionsInfo {
    id!: number | undefined;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    type!: ProductType | undefined;
    paymentOptions!: ProductPaymentOptionInfo[] | undefined;

    constructor(data?: IProductPaymentOptionsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.type = data["type"];
            if (data["paymentOptions"] && data["paymentOptions"].constructor === Array) {
                this.paymentOptions = [];
                for (let item of data["paymentOptions"])
                    this.paymentOptions.push(ProductPaymentOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPaymentOptionsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPaymentOptionsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (this.paymentOptions && this.paymentOptions.constructor === Array) {
            data["paymentOptions"] = [];
            for (let item of this.paymentOptions)
                data["paymentOptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductPaymentOptionsInfo {
    id: number | undefined;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    type: ProductType | undefined;
    paymentOptions: ProductPaymentOptionInfo[] | undefined;
}

export class ProductShortInfo implements IProductShortInfo {
    description!: string | undefined;
    unitId!: ProductMeasurementUnit | undefined;
    rate!: number | undefined;

    constructor(data?: IProductShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.unitId = data["unitId"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): ProductShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["unitId"] = this.unitId;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IProductShortInfo {
    description: string | undefined;
    unitId: ProductMeasurementUnit | undefined;
    rate: number | undefined;
}

export class CreateProductInput implements ICreateProductInput {
    code!: string;
    name!: string;
    description!: string | undefined;
    groupId!: number | undefined;
    groupName!: string | undefined;
    type!: ProductType;
    price!: number | undefined;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: ICreateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.groupId = data["groupId"];
            this.groupName = data["groupName"];
            this.type = data["type"];
            this.price = data["price"];
            this.commissionableAmount = data["commissionableAmount"];
            this.maxCommissionRate = data["maxCommissionRate"];
            this.maxCommissionRateTier2 = data["maxCommissionRateTier2"];
            this.unit = data["unit"];
            if (data["productServices"] && data["productServices"].constructor === Array) {
                this.productServices = [];
                for (let item of data["productServices"])
                    this.productServices.push(ProductServiceInfo.fromJS(item));
            }
            if (data["productSubscriptionOptions"] && data["productSubscriptionOptions"].constructor === Array) {
                this.productSubscriptionOptions = [];
                for (let item of data["productSubscriptionOptions"])
                    this.productSubscriptionOptions.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        if (this.productServices && this.productServices.constructor === Array) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (this.productSubscriptionOptions && this.productSubscriptionOptions.constructor === Array) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateProductInput {
    code: string;
    name: string;
    description: string | undefined;
    groupId: number | undefined;
    groupName: string | undefined;
    type: ProductType;
    price: number | undefined;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export class CreateProductOutput implements ICreateProductOutput {
    productId!: number | undefined;

    constructor(data?: ICreateProductOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
        }
    }

    static fromJS(data: any): CreateProductOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        return data; 
    }
}

export interface ICreateProductOutput {
    productId: number | undefined;
}

export class UpdateProductInput implements IUpdateProductInput {
    id!: number;
    code!: string;
    name!: string;
    description!: string | undefined;
    groupId!: number | undefined;
    groupName!: string | undefined;
    type!: ProductType;
    price!: number | undefined;
    commissionableAmount!: number | undefined;
    maxCommissionRate!: number | undefined;
    maxCommissionRateTier2!: number | undefined;
    unit!: ProductMeasurementUnit | undefined;
    productServices!: ProductServiceInfo[] | undefined;
    productSubscriptionOptions!: ProductSubscriptionOptionInfo[] | undefined;

    constructor(data?: IUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.groupId = data["groupId"];
            this.groupName = data["groupName"];
            this.type = data["type"];
            this.price = data["price"];
            this.commissionableAmount = data["commissionableAmount"];
            this.maxCommissionRate = data["maxCommissionRate"];
            this.maxCommissionRateTier2 = data["maxCommissionRateTier2"];
            this.unit = data["unit"];
            if (data["productServices"] && data["productServices"].constructor === Array) {
                this.productServices = [];
                for (let item of data["productServices"])
                    this.productServices.push(ProductServiceInfo.fromJS(item));
            }
            if (data["productSubscriptionOptions"] && data["productSubscriptionOptions"].constructor === Array) {
                this.productSubscriptionOptions = [];
                for (let item of data["productSubscriptionOptions"])
                    this.productSubscriptionOptions.push(ProductSubscriptionOptionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["type"] = this.type;
        data["price"] = this.price;
        data["commissionableAmount"] = this.commissionableAmount;
        data["maxCommissionRate"] = this.maxCommissionRate;
        data["maxCommissionRateTier2"] = this.maxCommissionRateTier2;
        data["unit"] = this.unit;
        if (this.productServices && this.productServices.constructor === Array) {
            data["productServices"] = [];
            for (let item of this.productServices)
                data["productServices"].push(item.toJSON());
        }
        if (this.productSubscriptionOptions && this.productSubscriptionOptions.constructor === Array) {
            data["productSubscriptionOptions"] = [];
            for (let item of this.productSubscriptionOptions)
                data["productSubscriptionOptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateProductInput {
    id: number;
    code: string;
    name: string;
    description: string | undefined;
    groupId: number | undefined;
    groupName: string | undefined;
    type: ProductType;
    price: number | undefined;
    commissionableAmount: number | undefined;
    maxCommissionRate: number | undefined;
    maxCommissionRateTier2: number | undefined;
    unit: ProductMeasurementUnit | undefined;
    productServices: ProductServiceInfo[] | undefined;
    productSubscriptionOptions: ProductSubscriptionOptionInfo[] | undefined;
}

export class SetProductImageInput implements ISetProductImageInput {
    productId!: number;
    image!: string | undefined;

    constructor(data?: ISetProductImageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.image = data["image"];
        }
    }

    static fromJS(data: any): SetProductImageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductImageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["image"] = this.image;
        return data; 
    }
}

export interface ISetProductImageInput {
    productId: number;
    image: string | undefined;
}

export class UpdateProductGroupInput implements IUpdateProductGroupInput {
    code!: string;
    groupName!: string | undefined;

    constructor(data?: IUpdateProductGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.groupName = data["groupName"];
        }
    }

    static fromJS(data: any): UpdateProductGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["groupName"] = this.groupName;
        return data; 
    }
}

export interface IUpdateProductGroupInput {
    code: string;
    groupName: string | undefined;
}

export class ProductGroupInfo implements IProductGroupInfo {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IProductGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ProductGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProductGroupInfo {
    id: number | undefined;
    name: string | undefined;
}

export class GetCurrentUserProfileEditDto implements IGetCurrentUserProfileEditDto {
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;
    name!: string;
    surname!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    companyName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IGetCurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.companyName = data["companyName"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): GetCurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["companyName"] = this.companyName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IGetCurrentUserProfileEditDto {
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    companyName: string | undefined;
    countryId: string | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    companyName!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.companyName = data["companyName"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["companyName"] = this.companyName;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    companyName: string | undefined;
    countryId: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    originalImage!: string;
    thumbnail!: string;
    source!: string | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.originalImage = data["originalImage"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalImage"] = this.originalImage;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    originalImage: string;
    thumbnail: string;
    source: string | undefined;
}

export class DownloadPictureInput implements IDownloadPictureInput {
    url!: string;

    constructor(data?: IDownloadPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): DownloadPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IDownloadPictureInput {
    url: string;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class UpdateMonthlyGoalInput implements IUpdateMonthlyGoalInput {
    monthlyGoal!: number | undefined;

    constructor(data?: IUpdateMonthlyGoalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.monthlyGoal = data["monthlyGoal"];
        }
    }

    static fromJS(data: any): UpdateMonthlyGoalInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMonthlyGoalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthlyGoal"] = this.monthlyGoal;
        return data; 
    }
}

export interface IUpdateMonthlyGoalInput {
    monthlyGoal: number | undefined;
}

export class UserEmailSettings implements IUserEmailSettings {
    isUserSmtpEnabled!: boolean | undefined;
    signatureHtml!: string | undefined;
    from!: EmailFromSettings | undefined;
    smtp!: EmailSmtpSettings | undefined;

    constructor(data?: IUserEmailSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isUserSmtpEnabled = data["isUserSmtpEnabled"];
            this.signatureHtml = data["signatureHtml"];
            this.from = data["from"] ? EmailFromSettings.fromJS(data["from"]) : <any>undefined;
            this.smtp = data["smtp"] ? EmailSmtpSettings.fromJS(data["smtp"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserEmailSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserSmtpEnabled"] = this.isUserSmtpEnabled;
        data["signatureHtml"] = this.signatureHtml;
        data["from"] = this.from ? this.from.toJSON() : <any>undefined;
        data["smtp"] = this.smtp ? this.smtp.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserEmailSettings {
    isUserSmtpEnabled: boolean | undefined;
    signatureHtml: string | undefined;
    from: EmailFromSettings | undefined;
    smtp: EmailSmtpSettings | undefined;
}

export class ProfileAddressDto implements IProfileAddressDto {
    id!: number | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    zip!: string | undefined;

    constructor(data?: IProfileAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): ProfileAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        return data; 
    }
}

export interface IProfileAddressDto {
    id: number | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    zip: string | undefined;
}

export class ProfilePhoneDto implements IProfilePhoneDto {
    id!: number | undefined;
    isActive!: boolean | undefined;
    isConfirmed!: boolean | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfilePhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
            this.isConfirmed = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.isConfirmed = data["isConfirmed"] !== undefined ? data["isConfirmed"] : true;
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfilePhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IProfilePhoneDto {
    id: number | undefined;
    isActive: boolean | undefined;
    isConfirmed: boolean | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfileContactBaseDto implements IProfileContactBaseDto {
    address!: ProfileAddressDto | undefined;
    primaryPhone!: ProfilePhoneDto | undefined;
    mobilePhone!: ProfilePhoneDto | undefined;

    constructor(data?: IProfileContactBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? ProfileAddressDto.fromJS(data["address"]) : <any>undefined;
            this.primaryPhone = data["primaryPhone"] ? ProfilePhoneDto.fromJS(data["primaryPhone"]) : <any>undefined;
            this.mobilePhone = data["mobilePhone"] ? ProfilePhoneDto.fromJS(data["mobilePhone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfileContactBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileContactBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["primaryPhone"] = this.primaryPhone ? this.primaryPhone.toJSON() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone ? this.mobilePhone.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProfileContactBaseDto {
    address: ProfileAddressDto | undefined;
    primaryPhone: ProfilePhoneDto | undefined;
    mobilePhone: ProfilePhoneDto | undefined;
}

export class LinkDto implements ILinkDto {
    id!: number | undefined;
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;

    constructor(data?: ILinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): LinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ILinkDto {
    id: number | undefined;
    linkTypeId: string | undefined;
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
}

export class CreateLinkInput implements ICreateLinkInput {
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: ICreateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface ICreateLinkInput {
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class CreateLinkOutput implements ICreateLinkOutput {
    id!: number | undefined;

    constructor(data?: ICreateLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateLinkOutput {
    id: number | undefined;
}

export class UpdateLinkInput implements IUpdateLinkInput {
    id!: number;
    url!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    linkTypeId!: string | undefined;

    constructor(data?: IUpdateLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.url = data["url"];
            this.isActive = data["isActive"] !== undefined ? data["isActive"] : true;
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): UpdateLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface IUpdateLinkInput {
    id: number;
    url: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    linkTypeId: string | undefined;
}

export class UpdateLinksInput implements IUpdateLinksInput {
    createLinks!: CreateLinkInput[] | undefined;
    updateLinks!: UpdateLinkInput[] | undefined;
    deleteLinks!: number[] | undefined;

    constructor(data?: IUpdateLinksInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["createLinks"] && data["createLinks"].constructor === Array) {
                this.createLinks = [];
                for (let item of data["createLinks"])
                    this.createLinks.push(CreateLinkInput.fromJS(item));
            }
            if (data["updateLinks"] && data["updateLinks"].constructor === Array) {
                this.updateLinks = [];
                for (let item of data["updateLinks"])
                    this.updateLinks.push(UpdateLinkInput.fromJS(item));
            }
            if (data["deleteLinks"] && data["deleteLinks"].constructor === Array) {
                this.deleteLinks = [];
                for (let item of data["deleteLinks"])
                    this.deleteLinks.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateLinksInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLinksInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.createLinks && this.createLinks.constructor === Array) {
            data["createLinks"] = [];
            for (let item of this.createLinks)
                data["createLinks"].push(item.toJSON());
        }
        if (this.updateLinks && this.updateLinks.constructor === Array) {
            data["updateLinks"] = [];
            for (let item of this.updateLinks)
                data["updateLinks"].push(item.toJSON());
        }
        if (this.deleteLinks && this.deleteLinks.constructor === Array) {
            data["deleteLinks"] = [];
            for (let item of this.deleteLinks)
                data["deleteLinks"].push(item);
        }
        return data; 
    }
}

export interface IUpdateLinksInput {
    createLinks: CreateLinkInput[] | undefined;
    updateLinks: UpdateLinkInput[] | undefined;
    deleteLinks: number[] | undefined;
}

export class ProfilePhotoDto implements IProfilePhotoDto {
    id!: number | undefined;
    providerKey!: string | undefined;
    fileUrl!: string | undefined;
    thumbnailUrl!: string | undefined;
    isPublished!: boolean | undefined;

    constructor(data?: IProfilePhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.providerKey = data["providerKey"];
            this.fileUrl = data["fileUrl"];
            this.thumbnailUrl = data["thumbnailUrl"];
            this.isPublished = data["isPublished"];
        }
    }

    static fromJS(data: any): ProfilePhotoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerKey"] = this.providerKey;
        data["fileUrl"] = this.fileUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["isPublished"] = this.isPublished;
        return data; 
    }
}

export interface IProfilePhotoDto {
    id: number | undefined;
    providerKey: string | undefined;
    fileUrl: string | undefined;
    thumbnailUrl: string | undefined;
    isPublished: boolean | undefined;
}

export class CreateProfilePhotoInput implements ICreateProfilePhotoInput {
    providerKey!: string | undefined;
    fileUrl!: string | undefined;
    thumbnailUrl!: string | undefined;
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateProfilePhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.providerKey = data["providerKey"];
            this.fileUrl = data["fileUrl"];
            this.thumbnailUrl = data["thumbnailUrl"];
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateProfilePhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProfilePhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerKey"] = this.providerKey;
        data["fileUrl"] = this.fileUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateProfilePhotoInput {
    providerKey: string | undefined;
    fileUrl: string | undefined;
    thumbnailUrl: string | undefined;
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class FilestackSettingsDto implements IFilestackSettingsDto {
    apiKey!: string | undefined;
    policy!: string | undefined;
    signature!: string | undefined;

    constructor(data?: IFilestackSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.policy = data["policy"];
            this.signature = data["signature"];
        }
    }

    static fromJS(data: any): FilestackSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilestackSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["policy"] = this.policy;
        data["signature"] = this.signature;
        return data; 
    }
}

export interface IFilestackSettingsDto {
    apiKey: string | undefined;
    policy: string | undefined;
    signature: string | undefined;
}

export class ProfileEmail implements IProfileEmail {
    emailAddress!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfileEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfileEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IProfileEmail {
    emailAddress: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfileAddress implements IProfileAddress {
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    stateName!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;

    constructor(data?: IProfileAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.stateName = data["stateName"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): ProfileAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["stateName"] = this.stateName;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        return data; 
    }
}

export interface IProfileAddress {
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    stateName: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
}

export class ProfilePhone implements IProfilePhone {
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IProfilePhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): ProfilePhone {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IProfilePhone {
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    usageTypeId: string | undefined;
}

export class ProfileLink implements IProfileLink {
    linkTypeId!: string | undefined;
    url!: string | undefined;

    constructor(data?: IProfileLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ProfileLink {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        return data; 
    }
}

export interface IProfileLink {
    linkTypeId: string | undefined;
    url: string | undefined;
}

export class ProfilePhoto implements IProfilePhoto {
    fileUrl!: string | undefined;

    constructor(data?: IProfilePhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileUrl = data["fileUrl"];
        }
    }

    static fromJS(data: any): ProfilePhoto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        return data; 
    }
}

export interface IProfilePhoto {
    fileUrl: string | undefined;
}

export class PublishedPersonProfileInfo implements IPublishedPersonProfileInfo {
    fullName!: string | undefined;
    email!: string | undefined;
    profileSummary!: string | undefined;
    calendlyUrl!: string | undefined;
    emails!: ProfileEmail[] | undefined;
    addresses!: ProfileAddress[] | undefined;
    phones!: ProfilePhone[] | undefined;
    links!: ProfileLink[] | undefined;
    photos!: ProfilePhoto[] | undefined;

    constructor(data?: IPublishedPersonProfileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.profileSummary = data["profileSummary"];
            this.calendlyUrl = data["calendlyUrl"];
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ProfileEmail.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ProfileAddress.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ProfilePhone.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ProfileLink.fromJS(item));
            }
            if (data["photos"] && data["photos"].constructor === Array) {
                this.photos = [];
                for (let item of data["photos"])
                    this.photos.push(ProfilePhoto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublishedPersonProfileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedPersonProfileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["profileSummary"] = this.profileSummary;
        data["calendlyUrl"] = this.calendlyUrl;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (this.photos && this.photos.constructor === Array) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPublishedPersonProfileInfo {
    fullName: string | undefined;
    email: string | undefined;
    profileSummary: string | undefined;
    calendlyUrl: string | undefined;
    emails: ProfileEmail[] | undefined;
    addresses: ProfileAddress[] | undefined;
    phones: ProfilePhone[] | undefined;
    links: ProfileLink[] | undefined;
    photos: ProfilePhoto[] | undefined;
}

export class PublishedProfileDto implements IPublishedProfileDto {
    data!: PublishedPersonProfileInfo | undefined;
    name!: string | undefined;

    constructor(data?: IPublishedProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? PublishedPersonProfileInfo.fromJS(data["data"]) : <any>undefined;
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PublishedProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublishedProfileDto {
    data: PublishedPersonProfileInfo | undefined;
    name: string | undefined;
}

export class PublishedProfileBaseDto implements IPublishedProfileBaseDto {
    name!: string | undefined;

    constructor(data?: IPublishedProfileBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PublishedProfileBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedProfileBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublishedProfileBaseDto {
    name: string | undefined;
}

export class NameInput implements INameInput {
    name!: string;

    constructor(data?: INameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): NameInput {
        data = typeof data === 'object' ? data : {};
        let result = new NameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface INameInput {
    name: string;
}

export class NameIsAvailableDto implements INameIsAvailableDto {
    name!: string | undefined;
    isAvailable!: boolean | undefined;

    constructor(data?: INameIsAvailableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isAvailable = data["isAvailable"];
        }
    }

    static fromJS(data: any): NameIsAvailableDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameIsAvailableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data; 
    }
}

export interface INameIsAvailableDto {
    name: string | undefined;
    isAvailable: boolean | undefined;
}

export class PublishProfileInput implements IPublishProfileInput {
    fullUrl!: string | undefined;
    photoIds!: number[] | undefined;
    name!: string;

    constructor(data?: IPublishProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullUrl = data["fullUrl"];
            if (data["photoIds"] && data["photoIds"].constructor === Array) {
                this.photoIds = [];
                for (let item of data["photoIds"])
                    this.photoIds.push(item);
            }
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PublishProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullUrl"] = this.fullUrl;
        if (this.photoIds && this.photoIds.constructor === Array) {
            data["photoIds"] = [];
            for (let item of this.photoIds)
                data["photoIds"].push(item);
        }
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublishProfileInput {
    fullUrl: string | undefined;
    photoIds: number[] | undefined;
    name: string;
}

export class PropertyLinkDto implements IPropertyLinkDto {
    id!: number | undefined;
    url!: string | undefined;

    constructor(data?: IPropertyLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): PropertyLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        return data; 
    }
}

export interface IPropertyLinkDto {
    id: number | undefined;
    url: string | undefined;
}

export enum PropertyType {
    Condo = "Condo", 
    Duplex = "Duplex", 
    SFD = "SFD", 
    Townhouse = "Townhouse", 
}

export enum Appliances {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _8 = 8, 
    _16 = 16, 
    _32 = 32, 
}

export enum HeatingCoolingType {
    Electric = "Electric", 
    Gas = "Gas", 
    Water = "Water", 
}

export enum UtilityType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _8 = 8, 
}

export enum YardPatioEnum {
    Yes = "Yes", 
    No = "No", 
    Fenced = "Fenced", 
}

export enum ParkingType {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _8 = 8, 
    _16 = 16, 
}

export enum BasementStatus {
    Finished = "Finished", 
    PartiallyFinished = "PartiallyFinished", 
    Unfinished = "Unfinished", 
}

export enum PlatformDayOfWeek {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _8 = 8, 
    _16 = 16, 
    _32 = 32, 
    _64 = 64, 
}

export enum GarbageCollection {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
}

export enum FireplaceType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
}

export class PropertyDto implements IPropertyDto {
    photo!: string | undefined;
    links!: PropertyLinkDto[] | undefined;
    id!: number;
    name!: string;
    address!: CreateContactAddressInput | undefined;
    propertyType!: PropertyType | undefined;
    area!: number | undefined;
    lotSize!: number | undefined;
    yearBuilt!: number | undefined;
    floor!: number | undefined;
    numberOfLevels!: number | undefined;
    corner!: boolean | undefined;
    end!: boolean | undefined;
    bedCount!: number | undefined;
    bathCount!: number | undefined;
    den!: boolean | undefined;
    office!: boolean | undefined;
    appliances!: Appliances | undefined;
    otherAppliances!: string | undefined;
    laundryInSuite!: boolean | undefined;
    isCentralHeating!: boolean | undefined;
    heatingType!: HeatingCoolingType | undefined;
    ac!: boolean | undefined;
    monthlyHeatingCost!: number | undefined;
    isHeatIncludedInCondoFees!: boolean | undefined;
    utilityTypesIncluded!: UtilityType | undefined;
    floorVinyl!: boolean | undefined;
    floorHardwood!: boolean | undefined;
    floorTile!: boolean | undefined;
    floorCarpet!: boolean | undefined;
    floorLVP!: boolean | undefined;
    storageInSuite!: boolean | undefined;
    storageLocker!: number | undefined;
    storageLockerNumber!: number | undefined;
    storageLockerKey!: boolean | undefined;
    yard!: YardPatioEnum | undefined;
    patio!: YardPatioEnum | undefined;
    yardBalcony!: boolean | undefined;
    parking!: ParkingType | undefined;
    basement!: BasementStatus | undefined;
    dogs!: boolean | undefined;
    cats!: boolean | undefined;
    petsSizeLimit!: string | undefined;
    petsBreedRestriction!: string | undefined;
    turnoverCompanyName!: string | undefined;
    turnoverContactName!: string | undefined;
    turnoverEmail!: string | undefined;
    turnoverPhone!: string | undefined;
    condoDocuments!: boolean | undefined;
    moveInRequest!: string | undefined;
    petApplication!: boolean | undefined;
    intercomSetup!: string | undefined;
    additionalKeys!: boolean | undefined;
    numberOfSets!: number | undefined;
    frontDoorFob!: number | undefined;
    garageRemote!: boolean | undefined;
    garageRemoteNumberReceived!: number | undefined;
    garageKey!: boolean | undefined;
    garageKeyNumberReceived!: number | undefined;
    garageCode!: string | undefined;
    parkadeFob!: boolean | undefined;
    parkingStall!: number | undefined;
    visitorParkingPass!: number | undefined;
    mailbox!: number | undefined;
    mailboxKey!: boolean | undefined;
    mailboxNumberReceived!: number | undefined;
    garbageDay!: PlatformDayOfWeek | undefined;
    garbageCollection!: GarbageCollection | undefined;
    garbageKey!: boolean | undefined;
    garbageNumberReceived!: number | undefined;
    electricityProvider!: string | undefined;
    electricityAccountNo!: string | undefined;
    naturalGasProvider!: string | undefined;
    naturalGasAccountNo!: string | undefined;
    waterProvider!: string | undefined;
    waterAccountNo!: string | undefined;
    wasteProvider!: string | undefined;
    wasteAccountNo!: string | undefined;
    firepit!: boolean | undefined;
    secure!: boolean | undefined;
    onSiteManager!: boolean | undefined;
    wheelchairAccessible!: boolean | undefined;
    walkOut!: boolean | undefined;
    elevator!: boolean | undefined;
    ceilingFan!: boolean | undefined;
    fireplace!: FireplaceType | undefined;
    petPark!: boolean | undefined;
    communitySpace!: boolean | undefined;
    pool!: boolean | undefined;
    exerciseRoom!: boolean | undefined;
    partyRoom!: boolean | undefined;
    guestSuite!: boolean | undefined;
    other!: string | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.photo = data["photo"];
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(PropertyLinkDto.fromJS(item));
            }
            this.id = data["id"];
            this.name = data["name"];
            this.address = data["address"] ? CreateContactAddressInput.fromJS(data["address"]) : <any>undefined;
            this.propertyType = data["propertyType"];
            this.area = data["area"];
            this.lotSize = data["lotSize"];
            this.yearBuilt = data["yearBuilt"];
            this.floor = data["floor"];
            this.numberOfLevels = data["numberOfLevels"];
            this.corner = data["corner"];
            this.end = data["end"];
            this.bedCount = data["bedCount"];
            this.bathCount = data["bathCount"];
            this.den = data["den"];
            this.office = data["office"];
            this.appliances = data["appliances"];
            this.otherAppliances = data["otherAppliances"];
            this.laundryInSuite = data["laundryInSuite"];
            this.isCentralHeating = data["isCentralHeating"];
            this.heatingType = data["heatingType"];
            this.ac = data["ac"];
            this.monthlyHeatingCost = data["monthlyHeatingCost"];
            this.isHeatIncludedInCondoFees = data["isHeatIncludedInCondoFees"];
            this.utilityTypesIncluded = data["utilityTypesIncluded"];
            this.floorVinyl = data["floorVinyl"];
            this.floorHardwood = data["floorHardwood"];
            this.floorTile = data["floorTile"];
            this.floorCarpet = data["floorCarpet"];
            this.floorLVP = data["floorLVP"];
            this.storageInSuite = data["storageInSuite"];
            this.storageLocker = data["storageLocker"];
            this.storageLockerNumber = data["storageLockerNumber"];
            this.storageLockerKey = data["storageLockerKey"];
            this.yard = data["yard"];
            this.patio = data["patio"];
            this.yardBalcony = data["yardBalcony"];
            this.parking = data["parking"];
            this.basement = data["basement"];
            this.dogs = data["dogs"];
            this.cats = data["cats"];
            this.petsSizeLimit = data["petsSizeLimit"];
            this.petsBreedRestriction = data["petsBreedRestriction"];
            this.turnoverCompanyName = data["turnoverCompanyName"];
            this.turnoverContactName = data["turnoverContactName"];
            this.turnoverEmail = data["turnoverEmail"];
            this.turnoverPhone = data["turnoverPhone"];
            this.condoDocuments = data["condoDocuments"];
            this.moveInRequest = data["moveInRequest"];
            this.petApplication = data["petApplication"];
            this.intercomSetup = data["intercomSetup"];
            this.additionalKeys = data["additionalKeys"];
            this.numberOfSets = data["numberOfSets"];
            this.frontDoorFob = data["frontDoorFob"];
            this.garageRemote = data["garageRemote"];
            this.garageRemoteNumberReceived = data["garageRemoteNumberReceived"];
            this.garageKey = data["garageKey"];
            this.garageKeyNumberReceived = data["garageKeyNumberReceived"];
            this.garageCode = data["garageCode"];
            this.parkadeFob = data["parkadeFob"];
            this.parkingStall = data["parkingStall"];
            this.visitorParkingPass = data["visitorParkingPass"];
            this.mailbox = data["mailbox"];
            this.mailboxKey = data["mailboxKey"];
            this.mailboxNumberReceived = data["mailboxNumberReceived"];
            this.garbageDay = data["garbageDay"];
            this.garbageCollection = data["garbageCollection"];
            this.garbageKey = data["garbageKey"];
            this.garbageNumberReceived = data["garbageNumberReceived"];
            this.electricityProvider = data["electricityProvider"];
            this.electricityAccountNo = data["electricityAccountNo"];
            this.naturalGasProvider = data["naturalGasProvider"];
            this.naturalGasAccountNo = data["naturalGasAccountNo"];
            this.waterProvider = data["waterProvider"];
            this.waterAccountNo = data["waterAccountNo"];
            this.wasteProvider = data["wasteProvider"];
            this.wasteAccountNo = data["wasteAccountNo"];
            this.firepit = data["firepit"];
            this.secure = data["secure"];
            this.onSiteManager = data["onSiteManager"];
            this.wheelchairAccessible = data["wheelchairAccessible"];
            this.walkOut = data["walkOut"];
            this.elevator = data["elevator"];
            this.ceilingFan = data["ceilingFan"];
            this.fireplace = data["fireplace"];
            this.petPark = data["petPark"];
            this.communitySpace = data["communitySpace"];
            this.pool = data["pool"];
            this.exerciseRoom = data["exerciseRoom"];
            this.partyRoom = data["partyRoom"];
            this.guestSuite = data["guestSuite"];
            this.other = data["other"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photo"] = this.photo;
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["propertyType"] = this.propertyType;
        data["area"] = this.area;
        data["lotSize"] = this.lotSize;
        data["yearBuilt"] = this.yearBuilt;
        data["floor"] = this.floor;
        data["numberOfLevels"] = this.numberOfLevels;
        data["corner"] = this.corner;
        data["end"] = this.end;
        data["bedCount"] = this.bedCount;
        data["bathCount"] = this.bathCount;
        data["den"] = this.den;
        data["office"] = this.office;
        data["appliances"] = this.appliances;
        data["otherAppliances"] = this.otherAppliances;
        data["laundryInSuite"] = this.laundryInSuite;
        data["isCentralHeating"] = this.isCentralHeating;
        data["heatingType"] = this.heatingType;
        data["ac"] = this.ac;
        data["monthlyHeatingCost"] = this.monthlyHeatingCost;
        data["isHeatIncludedInCondoFees"] = this.isHeatIncludedInCondoFees;
        data["utilityTypesIncluded"] = this.utilityTypesIncluded;
        data["floorVinyl"] = this.floorVinyl;
        data["floorHardwood"] = this.floorHardwood;
        data["floorTile"] = this.floorTile;
        data["floorCarpet"] = this.floorCarpet;
        data["floorLVP"] = this.floorLVP;
        data["storageInSuite"] = this.storageInSuite;
        data["storageLocker"] = this.storageLocker;
        data["storageLockerNumber"] = this.storageLockerNumber;
        data["storageLockerKey"] = this.storageLockerKey;
        data["yard"] = this.yard;
        data["patio"] = this.patio;
        data["yardBalcony"] = this.yardBalcony;
        data["parking"] = this.parking;
        data["basement"] = this.basement;
        data["dogs"] = this.dogs;
        data["cats"] = this.cats;
        data["petsSizeLimit"] = this.petsSizeLimit;
        data["petsBreedRestriction"] = this.petsBreedRestriction;
        data["turnoverCompanyName"] = this.turnoverCompanyName;
        data["turnoverContactName"] = this.turnoverContactName;
        data["turnoverEmail"] = this.turnoverEmail;
        data["turnoverPhone"] = this.turnoverPhone;
        data["condoDocuments"] = this.condoDocuments;
        data["moveInRequest"] = this.moveInRequest;
        data["petApplication"] = this.petApplication;
        data["intercomSetup"] = this.intercomSetup;
        data["additionalKeys"] = this.additionalKeys;
        data["numberOfSets"] = this.numberOfSets;
        data["frontDoorFob"] = this.frontDoorFob;
        data["garageRemote"] = this.garageRemote;
        data["garageRemoteNumberReceived"] = this.garageRemoteNumberReceived;
        data["garageKey"] = this.garageKey;
        data["garageKeyNumberReceived"] = this.garageKeyNumberReceived;
        data["garageCode"] = this.garageCode;
        data["parkadeFob"] = this.parkadeFob;
        data["parkingStall"] = this.parkingStall;
        data["visitorParkingPass"] = this.visitorParkingPass;
        data["mailbox"] = this.mailbox;
        data["mailboxKey"] = this.mailboxKey;
        data["mailboxNumberReceived"] = this.mailboxNumberReceived;
        data["garbageDay"] = this.garbageDay;
        data["garbageCollection"] = this.garbageCollection;
        data["garbageKey"] = this.garbageKey;
        data["garbageNumberReceived"] = this.garbageNumberReceived;
        data["electricityProvider"] = this.electricityProvider;
        data["electricityAccountNo"] = this.electricityAccountNo;
        data["naturalGasProvider"] = this.naturalGasProvider;
        data["naturalGasAccountNo"] = this.naturalGasAccountNo;
        data["waterProvider"] = this.waterProvider;
        data["waterAccountNo"] = this.waterAccountNo;
        data["wasteProvider"] = this.wasteProvider;
        data["wasteAccountNo"] = this.wasteAccountNo;
        data["firepit"] = this.firepit;
        data["secure"] = this.secure;
        data["onSiteManager"] = this.onSiteManager;
        data["wheelchairAccessible"] = this.wheelchairAccessible;
        data["walkOut"] = this.walkOut;
        data["elevator"] = this.elevator;
        data["ceilingFan"] = this.ceilingFan;
        data["fireplace"] = this.fireplace;
        data["petPark"] = this.petPark;
        data["communitySpace"] = this.communitySpace;
        data["pool"] = this.pool;
        data["exerciseRoom"] = this.exerciseRoom;
        data["partyRoom"] = this.partyRoom;
        data["guestSuite"] = this.guestSuite;
        data["other"] = this.other;
        return data; 
    }
}

export interface IPropertyDto {
    photo: string | undefined;
    links: PropertyLinkDto[] | undefined;
    id: number;
    name: string;
    address: CreateContactAddressInput | undefined;
    propertyType: PropertyType | undefined;
    area: number | undefined;
    lotSize: number | undefined;
    yearBuilt: number | undefined;
    floor: number | undefined;
    numberOfLevels: number | undefined;
    corner: boolean | undefined;
    end: boolean | undefined;
    bedCount: number | undefined;
    bathCount: number | undefined;
    den: boolean | undefined;
    office: boolean | undefined;
    appliances: Appliances | undefined;
    otherAppliances: string | undefined;
    laundryInSuite: boolean | undefined;
    isCentralHeating: boolean | undefined;
    heatingType: HeatingCoolingType | undefined;
    ac: boolean | undefined;
    monthlyHeatingCost: number | undefined;
    isHeatIncludedInCondoFees: boolean | undefined;
    utilityTypesIncluded: UtilityType | undefined;
    floorVinyl: boolean | undefined;
    floorHardwood: boolean | undefined;
    floorTile: boolean | undefined;
    floorCarpet: boolean | undefined;
    floorLVP: boolean | undefined;
    storageInSuite: boolean | undefined;
    storageLocker: number | undefined;
    storageLockerNumber: number | undefined;
    storageLockerKey: boolean | undefined;
    yard: YardPatioEnum | undefined;
    patio: YardPatioEnum | undefined;
    yardBalcony: boolean | undefined;
    parking: ParkingType | undefined;
    basement: BasementStatus | undefined;
    dogs: boolean | undefined;
    cats: boolean | undefined;
    petsSizeLimit: string | undefined;
    petsBreedRestriction: string | undefined;
    turnoverCompanyName: string | undefined;
    turnoverContactName: string | undefined;
    turnoverEmail: string | undefined;
    turnoverPhone: string | undefined;
    condoDocuments: boolean | undefined;
    moveInRequest: string | undefined;
    petApplication: boolean | undefined;
    intercomSetup: string | undefined;
    additionalKeys: boolean | undefined;
    numberOfSets: number | undefined;
    frontDoorFob: number | undefined;
    garageRemote: boolean | undefined;
    garageRemoteNumberReceived: number | undefined;
    garageKey: boolean | undefined;
    garageKeyNumberReceived: number | undefined;
    garageCode: string | undefined;
    parkadeFob: boolean | undefined;
    parkingStall: number | undefined;
    visitorParkingPass: number | undefined;
    mailbox: number | undefined;
    mailboxKey: boolean | undefined;
    mailboxNumberReceived: number | undefined;
    garbageDay: PlatformDayOfWeek | undefined;
    garbageCollection: GarbageCollection | undefined;
    garbageKey: boolean | undefined;
    garbageNumberReceived: number | undefined;
    electricityProvider: string | undefined;
    electricityAccountNo: string | undefined;
    naturalGasProvider: string | undefined;
    naturalGasAccountNo: string | undefined;
    waterProvider: string | undefined;
    waterAccountNo: string | undefined;
    wasteProvider: string | undefined;
    wasteAccountNo: string | undefined;
    firepit: boolean | undefined;
    secure: boolean | undefined;
    onSiteManager: boolean | undefined;
    wheelchairAccessible: boolean | undefined;
    walkOut: boolean | undefined;
    elevator: boolean | undefined;
    ceilingFan: boolean | undefined;
    fireplace: FireplaceType | undefined;
    petPark: boolean | undefined;
    communitySpace: boolean | undefined;
    pool: boolean | undefined;
    exerciseRoom: boolean | undefined;
    partyRoom: boolean | undefined;
    guestSuite: boolean | undefined;
    other: string | undefined;
}

export enum PropertyResident {
    Owner = "Owner", 
    Tenant = "Tenant", 
    Vacant = "Vacant", 
}

export enum PestsType {
    Termites = "Termites", 
    Rodents = "Rodents", 
    Insects = "Insects", 
    Other = "Other", 
}

export enum SellPeriod {
    Immediately = "Immediately", 
    OneToThreeMonths = "OneToThreeMonths", 
    ThreeToSixMonths = "ThreeToSixMonths", 
    SixPlusMonths = "SixPlusMonths", 
}

export enum PetFeeType {
    OneTime = "OneTime", 
    Monthly = "Monthly", 
    Refundable = "Refundable", 
}

export enum InterestRate {
    Adjustable = "Adjustable", 
    Fixed = "Fixed", 
}

export enum ExitStrategy {
    Airbnb = "Airbnb", 
    Flip = "Flip", 
    JV = "JV", 
    LTR = "LTR", 
    RTO = "RTO", 
    STR = "STR", 
}

export class PropertyAcquisitionDto implements IPropertyAcquisitionDto {
    id!: number;
    ownersOnTitle!: string | undefined;
    mortgageHolder!: string | undefined;
    propertyResident!: PropertyResident | undefined;
    houseOwningTime!: number | undefined;
    annualHOACondoFees!: number | undefined;
    depositPutAmount!: number | undefined;
    isHomeListed!: boolean | undefined;
    priceListed!: number | undefined;
    listedDate!: moment.Moment | undefined;
    listingExpires!: moment.Moment | undefined;
    realtorName!: string | undefined;
    realtorContactNumber!: string | undefined;
    offersFromListing!: boolean | undefined;
    offersFromListingAmount!: number | undefined;
    anythingRecentlyUpgraded!: string | undefined;
    needRepairs!: string | undefined;
    structural!: string | undefined;
    mechanical!: string | undefined;
    waterIssues!: string | undefined;
    roof!: string | undefined;
    plumbing!: string | undefined;
    electrical!: string | undefined;
    hvac!: string | undefined;
    repairsOrIssuesPool!: string | undefined;
    landscaping!: string | undefined;
    pests!: PestsType | undefined;
    pestsResolved!: boolean | undefined;
    repairsOrIssuesOther!: string | undefined;
    whySell!: string | undefined;
    howQuicklyWantToSell!: SellPeriod | undefined;
    didntSellActions!: string | undefined;
    tenantLeaseTerm!: moment.Moment | undefined;
    tenantMonthlyRent!: number | undefined;
    tenantDepositReceived!: number | undefined;
    tenantPetAddendum!: boolean | undefined;
    tenantPetFeeType!: PetFeeType | undefined;
    tenantPetFee!: number | undefined;
    currentOwningAmount!: number | undefined;
    hasAdditionalMortgage!: boolean | undefined;
    otherLienAmount!: number | undefined;
    areMortgagePaymentsCurrent!: boolean | undefined;
    monthsBehindOnMortgage!: number | undefined;
    amountBehindOnMortgages!: number | undefined;
    backTaxes!: number | undefined;
    monthlyPrincipleMortgagePayment!: number | undefined;
    monthlyInterestMortgagePayment!: number | undefined;
    includeTaxesAndInsurance!: boolean | undefined;
    annualPropertyTaxes!: number | undefined;
    annualPropertyInsurance!: number | undefined;
    interestRateMTG1!: number | undefined;
    interestRateMTG1Type!: InterestRate | undefined;
    interestRateMTG2!: number | undefined;
    interestRateMTG2Type!: InterestRate | undefined;
    prepaymentPenalty!: number | undefined;
    mortgageLender1!: string | undefined;
    mortgageLender2!: string | undefined;
    mortgageTermRenewal1!: moment.Moment | undefined;
    mortgageTermRenewal2!: moment.Moment | undefined;
    sellerFinancing!: string | undefined;
    lastSoldPrice!: number | undefined;
    yearLastSold!: string | undefined;
    cityAssessedValue!: number | undefined;
    asIsValue!: number | undefined;
    approxRepairCost!: number | undefined;
    afterRepairValue!: number | undefined;
    walkthroughDate!: moment.Moment | undefined;
    exitStrategy!: ExitStrategy | undefined;
    exitStrategyNotes!: string | undefined;
    depositToPayToSeller!: number | undefined;
    depositToPayToSellerDate!: moment.Moment | undefined;

    constructor(data?: IPropertyAcquisitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ownersOnTitle = data["ownersOnTitle"];
            this.mortgageHolder = data["mortgageHolder"];
            this.propertyResident = data["propertyResident"];
            this.houseOwningTime = data["houseOwningTime"];
            this.annualHOACondoFees = data["annualHOACondoFees"];
            this.depositPutAmount = data["depositPutAmount"];
            this.isHomeListed = data["isHomeListed"];
            this.priceListed = data["priceListed"];
            this.listedDate = data["listedDate"] ? moment(data["listedDate"].toString()) : <any>undefined;
            this.listingExpires = data["listingExpires"] ? moment(data["listingExpires"].toString()) : <any>undefined;
            this.realtorName = data["realtorName"];
            this.realtorContactNumber = data["realtorContactNumber"];
            this.offersFromListing = data["offersFromListing"];
            this.offersFromListingAmount = data["offersFromListingAmount"];
            this.anythingRecentlyUpgraded = data["anythingRecentlyUpgraded"];
            this.needRepairs = data["needRepairs"];
            this.structural = data["structural"];
            this.mechanical = data["mechanical"];
            this.waterIssues = data["waterIssues"];
            this.roof = data["roof"];
            this.plumbing = data["plumbing"];
            this.electrical = data["electrical"];
            this.hvac = data["hvac"];
            this.repairsOrIssuesPool = data["repairsOrIssuesPool"];
            this.landscaping = data["landscaping"];
            this.pests = data["pests"];
            this.pestsResolved = data["pestsResolved"];
            this.repairsOrIssuesOther = data["repairsOrIssuesOther"];
            this.whySell = data["whySell"];
            this.howQuicklyWantToSell = data["howQuicklyWantToSell"];
            this.didntSellActions = data["didntSellActions"];
            this.tenantLeaseTerm = data["tenantLeaseTerm"] ? moment(data["tenantLeaseTerm"].toString()) : <any>undefined;
            this.tenantMonthlyRent = data["tenantMonthlyRent"];
            this.tenantDepositReceived = data["tenantDepositReceived"];
            this.tenantPetAddendum = data["tenantPetAddendum"];
            this.tenantPetFeeType = data["tenantPetFeeType"];
            this.tenantPetFee = data["tenantPetFee"];
            this.currentOwningAmount = data["currentOwningAmount"];
            this.hasAdditionalMortgage = data["hasAdditionalMortgage"];
            this.otherLienAmount = data["otherLienAmount"];
            this.areMortgagePaymentsCurrent = data["areMortgagePaymentsCurrent"];
            this.monthsBehindOnMortgage = data["monthsBehindOnMortgage"];
            this.amountBehindOnMortgages = data["amountBehindOnMortgages"];
            this.backTaxes = data["backTaxes"];
            this.monthlyPrincipleMortgagePayment = data["monthlyPrincipleMortgagePayment"];
            this.monthlyInterestMortgagePayment = data["monthlyInterestMortgagePayment"];
            this.includeTaxesAndInsurance = data["includeTaxesAndInsurance"];
            this.annualPropertyTaxes = data["annualPropertyTaxes"];
            this.annualPropertyInsurance = data["annualPropertyInsurance"];
            this.interestRateMTG1 = data["interestRateMTG1"];
            this.interestRateMTG1Type = data["interestRateMTG1Type"];
            this.interestRateMTG2 = data["interestRateMTG2"];
            this.interestRateMTG2Type = data["interestRateMTG2Type"];
            this.prepaymentPenalty = data["prepaymentPenalty"];
            this.mortgageLender1 = data["mortgageLender1"];
            this.mortgageLender2 = data["mortgageLender2"];
            this.mortgageTermRenewal1 = data["mortgageTermRenewal1"] ? moment(data["mortgageTermRenewal1"].toString()) : <any>undefined;
            this.mortgageTermRenewal2 = data["mortgageTermRenewal2"] ? moment(data["mortgageTermRenewal2"].toString()) : <any>undefined;
            this.sellerFinancing = data["sellerFinancing"];
            this.lastSoldPrice = data["lastSoldPrice"];
            this.yearLastSold = data["yearLastSold"];
            this.cityAssessedValue = data["cityAssessedValue"];
            this.asIsValue = data["asIsValue"];
            this.approxRepairCost = data["approxRepairCost"];
            this.afterRepairValue = data["afterRepairValue"];
            this.walkthroughDate = data["walkthroughDate"] ? moment(data["walkthroughDate"].toString()) : <any>undefined;
            this.exitStrategy = data["exitStrategy"];
            this.exitStrategyNotes = data["exitStrategyNotes"];
            this.depositToPayToSeller = data["depositToPayToSeller"];
            this.depositToPayToSellerDate = data["depositToPayToSellerDate"] ? moment(data["depositToPayToSellerDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyAcquisitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAcquisitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownersOnTitle"] = this.ownersOnTitle;
        data["mortgageHolder"] = this.mortgageHolder;
        data["propertyResident"] = this.propertyResident;
        data["houseOwningTime"] = this.houseOwningTime;
        data["annualHOACondoFees"] = this.annualHOACondoFees;
        data["depositPutAmount"] = this.depositPutAmount;
        data["isHomeListed"] = this.isHomeListed;
        data["priceListed"] = this.priceListed;
        data["listedDate"] = this.listedDate ? this.listedDate.toISOString() : <any>undefined;
        data["listingExpires"] = this.listingExpires ? this.listingExpires.toISOString() : <any>undefined;
        data["realtorName"] = this.realtorName;
        data["realtorContactNumber"] = this.realtorContactNumber;
        data["offersFromListing"] = this.offersFromListing;
        data["offersFromListingAmount"] = this.offersFromListingAmount;
        data["anythingRecentlyUpgraded"] = this.anythingRecentlyUpgraded;
        data["needRepairs"] = this.needRepairs;
        data["structural"] = this.structural;
        data["mechanical"] = this.mechanical;
        data["waterIssues"] = this.waterIssues;
        data["roof"] = this.roof;
        data["plumbing"] = this.plumbing;
        data["electrical"] = this.electrical;
        data["hvac"] = this.hvac;
        data["repairsOrIssuesPool"] = this.repairsOrIssuesPool;
        data["landscaping"] = this.landscaping;
        data["pests"] = this.pests;
        data["pestsResolved"] = this.pestsResolved;
        data["repairsOrIssuesOther"] = this.repairsOrIssuesOther;
        data["whySell"] = this.whySell;
        data["howQuicklyWantToSell"] = this.howQuicklyWantToSell;
        data["didntSellActions"] = this.didntSellActions;
        data["tenantLeaseTerm"] = this.tenantLeaseTerm ? this.tenantLeaseTerm.toISOString() : <any>undefined;
        data["tenantMonthlyRent"] = this.tenantMonthlyRent;
        data["tenantDepositReceived"] = this.tenantDepositReceived;
        data["tenantPetAddendum"] = this.tenantPetAddendum;
        data["tenantPetFeeType"] = this.tenantPetFeeType;
        data["tenantPetFee"] = this.tenantPetFee;
        data["currentOwningAmount"] = this.currentOwningAmount;
        data["hasAdditionalMortgage"] = this.hasAdditionalMortgage;
        data["otherLienAmount"] = this.otherLienAmount;
        data["areMortgagePaymentsCurrent"] = this.areMortgagePaymentsCurrent;
        data["monthsBehindOnMortgage"] = this.monthsBehindOnMortgage;
        data["amountBehindOnMortgages"] = this.amountBehindOnMortgages;
        data["backTaxes"] = this.backTaxes;
        data["monthlyPrincipleMortgagePayment"] = this.monthlyPrincipleMortgagePayment;
        data["monthlyInterestMortgagePayment"] = this.monthlyInterestMortgagePayment;
        data["includeTaxesAndInsurance"] = this.includeTaxesAndInsurance;
        data["annualPropertyTaxes"] = this.annualPropertyTaxes;
        data["annualPropertyInsurance"] = this.annualPropertyInsurance;
        data["interestRateMTG1"] = this.interestRateMTG1;
        data["interestRateMTG1Type"] = this.interestRateMTG1Type;
        data["interestRateMTG2"] = this.interestRateMTG2;
        data["interestRateMTG2Type"] = this.interestRateMTG2Type;
        data["prepaymentPenalty"] = this.prepaymentPenalty;
        data["mortgageLender1"] = this.mortgageLender1;
        data["mortgageLender2"] = this.mortgageLender2;
        data["mortgageTermRenewal1"] = this.mortgageTermRenewal1 ? this.mortgageTermRenewal1.toISOString() : <any>undefined;
        data["mortgageTermRenewal2"] = this.mortgageTermRenewal2 ? this.mortgageTermRenewal2.toISOString() : <any>undefined;
        data["sellerFinancing"] = this.sellerFinancing;
        data["lastSoldPrice"] = this.lastSoldPrice;
        data["yearLastSold"] = this.yearLastSold;
        data["cityAssessedValue"] = this.cityAssessedValue;
        data["asIsValue"] = this.asIsValue;
        data["approxRepairCost"] = this.approxRepairCost;
        data["afterRepairValue"] = this.afterRepairValue;
        data["walkthroughDate"] = this.walkthroughDate ? this.walkthroughDate.toISOString() : <any>undefined;
        data["exitStrategy"] = this.exitStrategy;
        data["exitStrategyNotes"] = this.exitStrategyNotes;
        data["depositToPayToSeller"] = this.depositToPayToSeller;
        data["depositToPayToSellerDate"] = this.depositToPayToSellerDate ? this.depositToPayToSellerDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPropertyAcquisitionDto {
    id: number;
    ownersOnTitle: string | undefined;
    mortgageHolder: string | undefined;
    propertyResident: PropertyResident | undefined;
    houseOwningTime: number | undefined;
    annualHOACondoFees: number | undefined;
    depositPutAmount: number | undefined;
    isHomeListed: boolean | undefined;
    priceListed: number | undefined;
    listedDate: moment.Moment | undefined;
    listingExpires: moment.Moment | undefined;
    realtorName: string | undefined;
    realtorContactNumber: string | undefined;
    offersFromListing: boolean | undefined;
    offersFromListingAmount: number | undefined;
    anythingRecentlyUpgraded: string | undefined;
    needRepairs: string | undefined;
    structural: string | undefined;
    mechanical: string | undefined;
    waterIssues: string | undefined;
    roof: string | undefined;
    plumbing: string | undefined;
    electrical: string | undefined;
    hvac: string | undefined;
    repairsOrIssuesPool: string | undefined;
    landscaping: string | undefined;
    pests: PestsType | undefined;
    pestsResolved: boolean | undefined;
    repairsOrIssuesOther: string | undefined;
    whySell: string | undefined;
    howQuicklyWantToSell: SellPeriod | undefined;
    didntSellActions: string | undefined;
    tenantLeaseTerm: moment.Moment | undefined;
    tenantMonthlyRent: number | undefined;
    tenantDepositReceived: number | undefined;
    tenantPetAddendum: boolean | undefined;
    tenantPetFeeType: PetFeeType | undefined;
    tenantPetFee: number | undefined;
    currentOwningAmount: number | undefined;
    hasAdditionalMortgage: boolean | undefined;
    otherLienAmount: number | undefined;
    areMortgagePaymentsCurrent: boolean | undefined;
    monthsBehindOnMortgage: number | undefined;
    amountBehindOnMortgages: number | undefined;
    backTaxes: number | undefined;
    monthlyPrincipleMortgagePayment: number | undefined;
    monthlyInterestMortgagePayment: number | undefined;
    includeTaxesAndInsurance: boolean | undefined;
    annualPropertyTaxes: number | undefined;
    annualPropertyInsurance: number | undefined;
    interestRateMTG1: number | undefined;
    interestRateMTG1Type: InterestRate | undefined;
    interestRateMTG2: number | undefined;
    interestRateMTG2Type: InterestRate | undefined;
    prepaymentPenalty: number | undefined;
    mortgageLender1: string | undefined;
    mortgageLender2: string | undefined;
    mortgageTermRenewal1: moment.Moment | undefined;
    mortgageTermRenewal2: moment.Moment | undefined;
    sellerFinancing: string | undefined;
    lastSoldPrice: number | undefined;
    yearLastSold: string | undefined;
    cityAssessedValue: number | undefined;
    asIsValue: number | undefined;
    approxRepairCost: number | undefined;
    afterRepairValue: number | undefined;
    walkthroughDate: moment.Moment | undefined;
    exitStrategy: ExitStrategy | undefined;
    exitStrategyNotes: string | undefined;
    depositToPayToSeller: number | undefined;
    depositToPayToSellerDate: moment.Moment | undefined;
}

export class PropertyInvestmentDto implements IPropertyInvestmentDto {
    id!: number;
    equityPaidToHomeowner!: number | undefined;
    referralFee!: number | undefined;
    renovations!: number | undefined;
    cleaning!: number | undefined;
    inspection!: number | undefined;
    legalFees!: number | undefined;
    otherPreparationFees!: number | undefined;
    purchaseTermFrom!: moment.Moment | undefined;
    purchaseTermTo!: moment.Moment | undefined;
    purchaseTermExtraYear!: boolean | undefined;
    monthlyMortgagePayments!: number | undefined;
    monthlyTaxes!: number | undefined;
    monthlyInsurance!: number | undefined;
    monthlyCondoFees!: number | undefined;
    otherMonthlyFees!: number | undefined;
    termUtilizedMonths!: number | undefined;
    rtoPurchasePrice!: number | undefined;
    rtoDeposit!: number | undefined;
    rtoMonthlyPayment!: number | undefined;
    rtoTermFrom!: moment.Moment | undefined;
    rtoTermTo!: moment.Moment | undefined;
    rtoMortgagePaydownRate!: number | undefined;

    constructor(data?: IPropertyInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.equityPaidToHomeowner = data["equityPaidToHomeowner"];
            this.referralFee = data["referralFee"];
            this.renovations = data["renovations"];
            this.cleaning = data["cleaning"];
            this.inspection = data["inspection"];
            this.legalFees = data["legalFees"];
            this.otherPreparationFees = data["otherPreparationFees"];
            this.purchaseTermFrom = data["purchaseTermFrom"] ? moment(data["purchaseTermFrom"].toString()) : <any>undefined;
            this.purchaseTermTo = data["purchaseTermTo"] ? moment(data["purchaseTermTo"].toString()) : <any>undefined;
            this.purchaseTermExtraYear = data["purchaseTermExtraYear"];
            this.monthlyMortgagePayments = data["monthlyMortgagePayments"];
            this.monthlyTaxes = data["monthlyTaxes"];
            this.monthlyInsurance = data["monthlyInsurance"];
            this.monthlyCondoFees = data["monthlyCondoFees"];
            this.otherMonthlyFees = data["otherMonthlyFees"];
            this.termUtilizedMonths = data["termUtilizedMonths"];
            this.rtoPurchasePrice = data["rtoPurchasePrice"];
            this.rtoDeposit = data["rtoDeposit"];
            this.rtoMonthlyPayment = data["rtoMonthlyPayment"];
            this.rtoTermFrom = data["rtoTermFrom"] ? moment(data["rtoTermFrom"].toString()) : <any>undefined;
            this.rtoTermTo = data["rtoTermTo"] ? moment(data["rtoTermTo"].toString()) : <any>undefined;
            this.rtoMortgagePaydownRate = data["rtoMortgagePaydownRate"];
        }
    }

    static fromJS(data: any): PropertyInvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["equityPaidToHomeowner"] = this.equityPaidToHomeowner;
        data["referralFee"] = this.referralFee;
        data["renovations"] = this.renovations;
        data["cleaning"] = this.cleaning;
        data["inspection"] = this.inspection;
        data["legalFees"] = this.legalFees;
        data["otherPreparationFees"] = this.otherPreparationFees;
        data["purchaseTermFrom"] = this.purchaseTermFrom ? this.purchaseTermFrom.toISOString() : <any>undefined;
        data["purchaseTermTo"] = this.purchaseTermTo ? this.purchaseTermTo.toISOString() : <any>undefined;
        data["purchaseTermExtraYear"] = this.purchaseTermExtraYear;
        data["monthlyMortgagePayments"] = this.monthlyMortgagePayments;
        data["monthlyTaxes"] = this.monthlyTaxes;
        data["monthlyInsurance"] = this.monthlyInsurance;
        data["monthlyCondoFees"] = this.monthlyCondoFees;
        data["otherMonthlyFees"] = this.otherMonthlyFees;
        data["termUtilizedMonths"] = this.termUtilizedMonths;
        data["rtoPurchasePrice"] = this.rtoPurchasePrice;
        data["rtoDeposit"] = this.rtoDeposit;
        data["rtoMonthlyPayment"] = this.rtoMonthlyPayment;
        data["rtoTermFrom"] = this.rtoTermFrom ? this.rtoTermFrom.toISOString() : <any>undefined;
        data["rtoTermTo"] = this.rtoTermTo ? this.rtoTermTo.toISOString() : <any>undefined;
        data["rtoMortgagePaydownRate"] = this.rtoMortgagePaydownRate;
        return data; 
    }
}

export interface IPropertyInvestmentDto {
    id: number;
    equityPaidToHomeowner: number | undefined;
    referralFee: number | undefined;
    renovations: number | undefined;
    cleaning: number | undefined;
    inspection: number | undefined;
    legalFees: number | undefined;
    otherPreparationFees: number | undefined;
    purchaseTermFrom: moment.Moment | undefined;
    purchaseTermTo: moment.Moment | undefined;
    purchaseTermExtraYear: boolean | undefined;
    monthlyMortgagePayments: number | undefined;
    monthlyTaxes: number | undefined;
    monthlyInsurance: number | undefined;
    monthlyCondoFees: number | undefined;
    otherMonthlyFees: number | undefined;
    termUtilizedMonths: number | undefined;
    rtoPurchasePrice: number | undefined;
    rtoDeposit: number | undefined;
    rtoMonthlyPayment: number | undefined;
    rtoTermFrom: moment.Moment | undefined;
    rtoTermTo: moment.Moment | undefined;
    rtoMortgagePaydownRate: number | undefined;
}

export class PropertyBaseDto implements IPropertyBaseDto {
    id!: number;
    name!: string;
    address!: CreateContactAddressInput | undefined;
    propertyType!: PropertyType | undefined;
    area!: number | undefined;
    lotSize!: number | undefined;
    yearBuilt!: number | undefined;
    floor!: number | undefined;
    numberOfLevels!: number | undefined;
    corner!: boolean | undefined;
    end!: boolean | undefined;
    bedCount!: number | undefined;
    bathCount!: number | undefined;
    den!: boolean | undefined;
    office!: boolean | undefined;
    appliances!: Appliances | undefined;
    otherAppliances!: string | undefined;
    laundryInSuite!: boolean | undefined;
    isCentralHeating!: boolean | undefined;
    heatingType!: HeatingCoolingType | undefined;
    ac!: boolean | undefined;
    monthlyHeatingCost!: number | undefined;
    isHeatIncludedInCondoFees!: boolean | undefined;
    utilityTypesIncluded!: UtilityType | undefined;
    floorVinyl!: boolean | undefined;
    floorHardwood!: boolean | undefined;
    floorTile!: boolean | undefined;
    floorCarpet!: boolean | undefined;
    floorLVP!: boolean | undefined;
    storageInSuite!: boolean | undefined;
    storageLocker!: number | undefined;
    storageLockerNumber!: number | undefined;
    storageLockerKey!: boolean | undefined;
    yard!: YardPatioEnum | undefined;
    patio!: YardPatioEnum | undefined;
    yardBalcony!: boolean | undefined;
    parking!: ParkingType | undefined;
    basement!: BasementStatus | undefined;
    dogs!: boolean | undefined;
    cats!: boolean | undefined;
    petsSizeLimit!: string | undefined;
    petsBreedRestriction!: string | undefined;
    turnoverCompanyName!: string | undefined;
    turnoverContactName!: string | undefined;
    turnoverEmail!: string | undefined;
    turnoverPhone!: string | undefined;
    condoDocuments!: boolean | undefined;
    moveInRequest!: string | undefined;
    petApplication!: boolean | undefined;
    intercomSetup!: string | undefined;
    additionalKeys!: boolean | undefined;
    numberOfSets!: number | undefined;
    frontDoorFob!: number | undefined;
    garageRemote!: boolean | undefined;
    garageRemoteNumberReceived!: number | undefined;
    garageKey!: boolean | undefined;
    garageKeyNumberReceived!: number | undefined;
    garageCode!: string | undefined;
    parkadeFob!: boolean | undefined;
    parkingStall!: number | undefined;
    visitorParkingPass!: number | undefined;
    mailbox!: number | undefined;
    mailboxKey!: boolean | undefined;
    mailboxNumberReceived!: number | undefined;
    garbageDay!: PlatformDayOfWeek | undefined;
    garbageCollection!: GarbageCollection | undefined;
    garbageKey!: boolean | undefined;
    garbageNumberReceived!: number | undefined;
    electricityProvider!: string | undefined;
    electricityAccountNo!: string | undefined;
    naturalGasProvider!: string | undefined;
    naturalGasAccountNo!: string | undefined;
    waterProvider!: string | undefined;
    waterAccountNo!: string | undefined;
    wasteProvider!: string | undefined;
    wasteAccountNo!: string | undefined;
    firepit!: boolean | undefined;
    secure!: boolean | undefined;
    onSiteManager!: boolean | undefined;
    wheelchairAccessible!: boolean | undefined;
    walkOut!: boolean | undefined;
    elevator!: boolean | undefined;
    ceilingFan!: boolean | undefined;
    fireplace!: FireplaceType | undefined;
    petPark!: boolean | undefined;
    communitySpace!: boolean | undefined;
    pool!: boolean | undefined;
    exerciseRoom!: boolean | undefined;
    partyRoom!: boolean | undefined;
    guestSuite!: boolean | undefined;
    other!: string | undefined;

    constructor(data?: IPropertyBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.address = data["address"] ? CreateContactAddressInput.fromJS(data["address"]) : <any>undefined;
            this.propertyType = data["propertyType"];
            this.area = data["area"];
            this.lotSize = data["lotSize"];
            this.yearBuilt = data["yearBuilt"];
            this.floor = data["floor"];
            this.numberOfLevels = data["numberOfLevels"];
            this.corner = data["corner"];
            this.end = data["end"];
            this.bedCount = data["bedCount"];
            this.bathCount = data["bathCount"];
            this.den = data["den"];
            this.office = data["office"];
            this.appliances = data["appliances"];
            this.otherAppliances = data["otherAppliances"];
            this.laundryInSuite = data["laundryInSuite"];
            this.isCentralHeating = data["isCentralHeating"];
            this.heatingType = data["heatingType"];
            this.ac = data["ac"];
            this.monthlyHeatingCost = data["monthlyHeatingCost"];
            this.isHeatIncludedInCondoFees = data["isHeatIncludedInCondoFees"];
            this.utilityTypesIncluded = data["utilityTypesIncluded"];
            this.floorVinyl = data["floorVinyl"];
            this.floorHardwood = data["floorHardwood"];
            this.floorTile = data["floorTile"];
            this.floorCarpet = data["floorCarpet"];
            this.floorLVP = data["floorLVP"];
            this.storageInSuite = data["storageInSuite"];
            this.storageLocker = data["storageLocker"];
            this.storageLockerNumber = data["storageLockerNumber"];
            this.storageLockerKey = data["storageLockerKey"];
            this.yard = data["yard"];
            this.patio = data["patio"];
            this.yardBalcony = data["yardBalcony"];
            this.parking = data["parking"];
            this.basement = data["basement"];
            this.dogs = data["dogs"];
            this.cats = data["cats"];
            this.petsSizeLimit = data["petsSizeLimit"];
            this.petsBreedRestriction = data["petsBreedRestriction"];
            this.turnoverCompanyName = data["turnoverCompanyName"];
            this.turnoverContactName = data["turnoverContactName"];
            this.turnoverEmail = data["turnoverEmail"];
            this.turnoverPhone = data["turnoverPhone"];
            this.condoDocuments = data["condoDocuments"];
            this.moveInRequest = data["moveInRequest"];
            this.petApplication = data["petApplication"];
            this.intercomSetup = data["intercomSetup"];
            this.additionalKeys = data["additionalKeys"];
            this.numberOfSets = data["numberOfSets"];
            this.frontDoorFob = data["frontDoorFob"];
            this.garageRemote = data["garageRemote"];
            this.garageRemoteNumberReceived = data["garageRemoteNumberReceived"];
            this.garageKey = data["garageKey"];
            this.garageKeyNumberReceived = data["garageKeyNumberReceived"];
            this.garageCode = data["garageCode"];
            this.parkadeFob = data["parkadeFob"];
            this.parkingStall = data["parkingStall"];
            this.visitorParkingPass = data["visitorParkingPass"];
            this.mailbox = data["mailbox"];
            this.mailboxKey = data["mailboxKey"];
            this.mailboxNumberReceived = data["mailboxNumberReceived"];
            this.garbageDay = data["garbageDay"];
            this.garbageCollection = data["garbageCollection"];
            this.garbageKey = data["garbageKey"];
            this.garbageNumberReceived = data["garbageNumberReceived"];
            this.electricityProvider = data["electricityProvider"];
            this.electricityAccountNo = data["electricityAccountNo"];
            this.naturalGasProvider = data["naturalGasProvider"];
            this.naturalGasAccountNo = data["naturalGasAccountNo"];
            this.waterProvider = data["waterProvider"];
            this.waterAccountNo = data["waterAccountNo"];
            this.wasteProvider = data["wasteProvider"];
            this.wasteAccountNo = data["wasteAccountNo"];
            this.firepit = data["firepit"];
            this.secure = data["secure"];
            this.onSiteManager = data["onSiteManager"];
            this.wheelchairAccessible = data["wheelchairAccessible"];
            this.walkOut = data["walkOut"];
            this.elevator = data["elevator"];
            this.ceilingFan = data["ceilingFan"];
            this.fireplace = data["fireplace"];
            this.petPark = data["petPark"];
            this.communitySpace = data["communitySpace"];
            this.pool = data["pool"];
            this.exerciseRoom = data["exerciseRoom"];
            this.partyRoom = data["partyRoom"];
            this.guestSuite = data["guestSuite"];
            this.other = data["other"];
        }
    }

    static fromJS(data: any): PropertyBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["propertyType"] = this.propertyType;
        data["area"] = this.area;
        data["lotSize"] = this.lotSize;
        data["yearBuilt"] = this.yearBuilt;
        data["floor"] = this.floor;
        data["numberOfLevels"] = this.numberOfLevels;
        data["corner"] = this.corner;
        data["end"] = this.end;
        data["bedCount"] = this.bedCount;
        data["bathCount"] = this.bathCount;
        data["den"] = this.den;
        data["office"] = this.office;
        data["appliances"] = this.appliances;
        data["otherAppliances"] = this.otherAppliances;
        data["laundryInSuite"] = this.laundryInSuite;
        data["isCentralHeating"] = this.isCentralHeating;
        data["heatingType"] = this.heatingType;
        data["ac"] = this.ac;
        data["monthlyHeatingCost"] = this.monthlyHeatingCost;
        data["isHeatIncludedInCondoFees"] = this.isHeatIncludedInCondoFees;
        data["utilityTypesIncluded"] = this.utilityTypesIncluded;
        data["floorVinyl"] = this.floorVinyl;
        data["floorHardwood"] = this.floorHardwood;
        data["floorTile"] = this.floorTile;
        data["floorCarpet"] = this.floorCarpet;
        data["floorLVP"] = this.floorLVP;
        data["storageInSuite"] = this.storageInSuite;
        data["storageLocker"] = this.storageLocker;
        data["storageLockerNumber"] = this.storageLockerNumber;
        data["storageLockerKey"] = this.storageLockerKey;
        data["yard"] = this.yard;
        data["patio"] = this.patio;
        data["yardBalcony"] = this.yardBalcony;
        data["parking"] = this.parking;
        data["basement"] = this.basement;
        data["dogs"] = this.dogs;
        data["cats"] = this.cats;
        data["petsSizeLimit"] = this.petsSizeLimit;
        data["petsBreedRestriction"] = this.petsBreedRestriction;
        data["turnoverCompanyName"] = this.turnoverCompanyName;
        data["turnoverContactName"] = this.turnoverContactName;
        data["turnoverEmail"] = this.turnoverEmail;
        data["turnoverPhone"] = this.turnoverPhone;
        data["condoDocuments"] = this.condoDocuments;
        data["moveInRequest"] = this.moveInRequest;
        data["petApplication"] = this.petApplication;
        data["intercomSetup"] = this.intercomSetup;
        data["additionalKeys"] = this.additionalKeys;
        data["numberOfSets"] = this.numberOfSets;
        data["frontDoorFob"] = this.frontDoorFob;
        data["garageRemote"] = this.garageRemote;
        data["garageRemoteNumberReceived"] = this.garageRemoteNumberReceived;
        data["garageKey"] = this.garageKey;
        data["garageKeyNumberReceived"] = this.garageKeyNumberReceived;
        data["garageCode"] = this.garageCode;
        data["parkadeFob"] = this.parkadeFob;
        data["parkingStall"] = this.parkingStall;
        data["visitorParkingPass"] = this.visitorParkingPass;
        data["mailbox"] = this.mailbox;
        data["mailboxKey"] = this.mailboxKey;
        data["mailboxNumberReceived"] = this.mailboxNumberReceived;
        data["garbageDay"] = this.garbageDay;
        data["garbageCollection"] = this.garbageCollection;
        data["garbageKey"] = this.garbageKey;
        data["garbageNumberReceived"] = this.garbageNumberReceived;
        data["electricityProvider"] = this.electricityProvider;
        data["electricityAccountNo"] = this.electricityAccountNo;
        data["naturalGasProvider"] = this.naturalGasProvider;
        data["naturalGasAccountNo"] = this.naturalGasAccountNo;
        data["waterProvider"] = this.waterProvider;
        data["waterAccountNo"] = this.waterAccountNo;
        data["wasteProvider"] = this.wasteProvider;
        data["wasteAccountNo"] = this.wasteAccountNo;
        data["firepit"] = this.firepit;
        data["secure"] = this.secure;
        data["onSiteManager"] = this.onSiteManager;
        data["wheelchairAccessible"] = this.wheelchairAccessible;
        data["walkOut"] = this.walkOut;
        data["elevator"] = this.elevator;
        data["ceilingFan"] = this.ceilingFan;
        data["fireplace"] = this.fireplace;
        data["petPark"] = this.petPark;
        data["communitySpace"] = this.communitySpace;
        data["pool"] = this.pool;
        data["exerciseRoom"] = this.exerciseRoom;
        data["partyRoom"] = this.partyRoom;
        data["guestSuite"] = this.guestSuite;
        data["other"] = this.other;
        return data; 
    }
}

export interface IPropertyBaseDto {
    id: number;
    name: string;
    address: CreateContactAddressInput | undefined;
    propertyType: PropertyType | undefined;
    area: number | undefined;
    lotSize: number | undefined;
    yearBuilt: number | undefined;
    floor: number | undefined;
    numberOfLevels: number | undefined;
    corner: boolean | undefined;
    end: boolean | undefined;
    bedCount: number | undefined;
    bathCount: number | undefined;
    den: boolean | undefined;
    office: boolean | undefined;
    appliances: Appliances | undefined;
    otherAppliances: string | undefined;
    laundryInSuite: boolean | undefined;
    isCentralHeating: boolean | undefined;
    heatingType: HeatingCoolingType | undefined;
    ac: boolean | undefined;
    monthlyHeatingCost: number | undefined;
    isHeatIncludedInCondoFees: boolean | undefined;
    utilityTypesIncluded: UtilityType | undefined;
    floorVinyl: boolean | undefined;
    floorHardwood: boolean | undefined;
    floorTile: boolean | undefined;
    floorCarpet: boolean | undefined;
    floorLVP: boolean | undefined;
    storageInSuite: boolean | undefined;
    storageLocker: number | undefined;
    storageLockerNumber: number | undefined;
    storageLockerKey: boolean | undefined;
    yard: YardPatioEnum | undefined;
    patio: YardPatioEnum | undefined;
    yardBalcony: boolean | undefined;
    parking: ParkingType | undefined;
    basement: BasementStatus | undefined;
    dogs: boolean | undefined;
    cats: boolean | undefined;
    petsSizeLimit: string | undefined;
    petsBreedRestriction: string | undefined;
    turnoverCompanyName: string | undefined;
    turnoverContactName: string | undefined;
    turnoverEmail: string | undefined;
    turnoverPhone: string | undefined;
    condoDocuments: boolean | undefined;
    moveInRequest: string | undefined;
    petApplication: boolean | undefined;
    intercomSetup: string | undefined;
    additionalKeys: boolean | undefined;
    numberOfSets: number | undefined;
    frontDoorFob: number | undefined;
    garageRemote: boolean | undefined;
    garageRemoteNumberReceived: number | undefined;
    garageKey: boolean | undefined;
    garageKeyNumberReceived: number | undefined;
    garageCode: string | undefined;
    parkadeFob: boolean | undefined;
    parkingStall: number | undefined;
    visitorParkingPass: number | undefined;
    mailbox: number | undefined;
    mailboxKey: boolean | undefined;
    mailboxNumberReceived: number | undefined;
    garbageDay: PlatformDayOfWeek | undefined;
    garbageCollection: GarbageCollection | undefined;
    garbageKey: boolean | undefined;
    garbageNumberReceived: number | undefined;
    electricityProvider: string | undefined;
    electricityAccountNo: string | undefined;
    naturalGasProvider: string | undefined;
    naturalGasAccountNo: string | undefined;
    waterProvider: string | undefined;
    waterAccountNo: string | undefined;
    wasteProvider: string | undefined;
    wasteAccountNo: string | undefined;
    firepit: boolean | undefined;
    secure: boolean | undefined;
    onSiteManager: boolean | undefined;
    wheelchairAccessible: boolean | undefined;
    walkOut: boolean | undefined;
    elevator: boolean | undefined;
    ceilingFan: boolean | undefined;
    fireplace: FireplaceType | undefined;
    petPark: boolean | undefined;
    communitySpace: boolean | undefined;
    pool: boolean | undefined;
    exerciseRoom: boolean | undefined;
    partyRoom: boolean | undefined;
    guestSuite: boolean | undefined;
    other: string | undefined;
}

export class PropertyDealInfo implements IPropertyDealInfo {
    leadId!: number | undefined;
    leadDate!: moment.Moment | undefined;
    leadTypeSysId!: string | undefined;
    leadTypeName!: string | undefined;
    leadStageName!: string | undefined;
    dealAmount!: number | undefined;
    installmentAmount!: number | undefined;

    constructor(data?: IPropertyDealInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.leadDate = data["leadDate"] ? moment(data["leadDate"].toString()) : <any>undefined;
            this.leadTypeSysId = data["leadTypeSysId"];
            this.leadTypeName = data["leadTypeName"];
            this.leadStageName = data["leadStageName"];
            this.dealAmount = data["dealAmount"];
            this.installmentAmount = data["installmentAmount"];
        }
    }

    static fromJS(data: any): PropertyDealInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDealInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["leadDate"] = this.leadDate ? this.leadDate.toISOString() : <any>undefined;
        data["leadTypeSysId"] = this.leadTypeSysId;
        data["leadTypeName"] = this.leadTypeName;
        data["leadStageName"] = this.leadStageName;
        data["dealAmount"] = this.dealAmount;
        data["installmentAmount"] = this.installmentAmount;
        return data; 
    }
}

export interface IPropertyDealInfo {
    leadId: number | undefined;
    leadDate: moment.Moment | undefined;
    leadTypeSysId: string | undefined;
    leadTypeName: string | undefined;
    leadStageName: string | undefined;
    dealAmount: number | undefined;
    installmentAmount: number | undefined;
}

export class OptionDto implements IOptionDto {
    id!: number | undefined;
    questionId!: number | undefined;
    sortOrder!: number | undefined;
    text!: string | undefined;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.questionId = data["questionId"];
            this.sortOrder = data["sortOrder"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["sortOrder"] = this.sortOrder;
        data["text"] = this.text;
        return data; 
    }
}

export interface IOptionDto {
    id: number | undefined;
    questionId: number | undefined;
    sortOrder: number | undefined;
    text: string | undefined;
}

export class QuestionDto implements IQuestionDto {
    id!: number | undefined;
    questionnaireId!: number | undefined;
    type!: QuestionType | undefined;
    text!: string | undefined;
    sortOrder!: number | undefined;
    options!: OptionDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.questionnaireId = data["questionnaireId"];
            this.type = data["type"];
            this.text = data["text"];
            this.sortOrder = data["sortOrder"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(OptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionnaireId"] = this.questionnaireId;
        data["type"] = this.type;
        data["text"] = this.text;
        data["sortOrder"] = this.sortOrder;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionDto {
    id: number | undefined;
    questionnaireId: number | undefined;
    type: QuestionType | undefined;
    text: string | undefined;
    sortOrder: number | undefined;
    options: OptionDto[] | undefined;
}

export class QuestionnaireDto implements IQuestionnaireDto {
    id!: number | undefined;
    questions!: QuestionDto[] | undefined;

    constructor(data?: IQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [];
                for (let item of data["questions"])
                    this.questions.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionnaireDto {
    id: number | undefined;
    questions: QuestionDto[] | undefined;
}

export class AnswerDto implements IAnswerDto {
    questionId!: number | undefined;
    options!: number[] | undefined;

    constructor(data?: IAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        return data; 
    }
}

export interface IAnswerDto {
    questionId: number | undefined;
    options: number[] | undefined;
}

export class QuestionnaireResponseDto implements IQuestionnaireResponseDto {
    questionnaireId!: number | undefined;
    answers!: AnswerDto[] | undefined;

    constructor(data?: IQuestionnaireResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionnaireId = data["questionnaireId"];
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaireId"] = this.questionnaireId;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionnaireResponseDto {
    questionnaireId: number | undefined;
    answers: AnswerDto[] | undefined;
}

export class SubmitQuestionsAndAnswersDto implements ISubmitQuestionsAndAnswersDto {
    questionnaire!: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers!: SubmitQuestionAndAnswersDto[] | undefined;

    constructor(data?: ISubmitQuestionsAndAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionnaire = data["questionnaire"] ? SubmitQuestionnaireDto.fromJS(data["questionnaire"]) : <any>undefined;
            if (data["questionsAndAnswers"] && data["questionsAndAnswers"].constructor === Array) {
                this.questionsAndAnswers = [];
                for (let item of data["questionsAndAnswers"])
                    this.questionsAndAnswers.push(SubmitQuestionAndAnswersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitQuestionsAndAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitQuestionsAndAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        if (this.questionsAndAnswers && this.questionsAndAnswers.constructor === Array) {
            data["questionsAndAnswers"] = [];
            for (let item of this.questionsAndAnswers)
                data["questionsAndAnswers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubmitQuestionsAndAnswersDto {
    questionnaire: SubmitQuestionnaireDto | undefined;
    questionsAndAnswers: SubmitQuestionAndAnswersDto[] | undefined;
}

export class GetRapidClientsOutput implements IGetRapidClientsOutput {
    contactId!: number | undefined;
    name!: string | undefined;
    companyName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IGetRapidClientsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.name = data["name"];
            this.companyName = data["companyName"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): GetRapidClientsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRapidClientsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["name"] = this.name;
        data["companyName"] = this.companyName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IGetRapidClientsOutput {
    contactId: number | undefined;
    name: string | undefined;
    companyName: string | undefined;
    email: string | undefined;
}

export class GetRapidTokenOutput implements IGetRapidTokenOutput {
    token!: string | undefined;
    expirationDate!: moment.Moment | undefined;

    constructor(data?: IGetRapidTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRapidTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRapidTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRapidTokenOutput {
    token: string | undefined;
    expirationDate: moment.Moment | undefined;
}

export class RefundInfo implements IRefundInfo {
    totalAmount!: number | undefined;
    count!: number | undefined;

    constructor(data?: IRefundInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalAmount = data["totalAmount"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): RefundInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RefundInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAmount"] = this.totalAmount;
        data["count"] = this.count;
        return data; 
    }
}

export interface IRefundInfo {
    totalAmount: number | undefined;
    count: number | undefined;
}

export class GetRefundsAndCancellationsOutput implements IGetRefundsAndCancellationsOutput {
    refunds!: { [key: string] : RefundInfo; } | undefined;
    cancellations!: { [key: string] : number; } | undefined;

    constructor(data?: IGetRefundsAndCancellationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["refunds"]) {
                this.refunds = {};
                for (let key in data["refunds"]) {
                    if (data["refunds"].hasOwnProperty(key))
                        this.refunds[key] = data["refunds"][key] ? RefundInfo.fromJS(data["refunds"][key]) : new RefundInfo();
                }
            }
            if (data["cancellations"]) {
                this.cancellations = {};
                for (let key in data["cancellations"]) {
                    if (data["cancellations"].hasOwnProperty(key))
                        this.cancellations[key] = data["cancellations"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetRefundsAndCancellationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRefundsAndCancellationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.refunds) {
            data["refunds"] = {};
            for (let key in this.refunds) {
                if (this.refunds.hasOwnProperty(key))
                    data["refunds"][key] = this.refunds[key];
            }
        }
        if (this.cancellations) {
            data["cancellations"] = {};
            for (let key in this.cancellations) {
                if (this.cancellations.hasOwnProperty(key))
                    data["cancellations"][key] = this.cancellations[key];
            }
        }
        return data; 
    }
}

export interface IGetRefundsAndCancellationsOutput {
    refunds: { [key: string] : RefundInfo; } | undefined;
    cancellations: { [key: string] : number; } | undefined;
}

export enum AgentDataSource {
    Sticky = "Sticky", 
    Konnective = "Konnective", 
}

export class ContactAgentInput implements IContactAgentInput {
    agentCode!: string;
    agentName!: string | undefined;
    callCenter!: string | undefined;

    constructor(data?: IContactAgentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agentCode = data["agentCode"];
            this.agentName = data["agentName"];
            this.callCenter = data["callCenter"];
        }
    }

    static fromJS(data: any): ContactAgentInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAgentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agentCode"] = this.agentCode;
        data["agentName"] = this.agentName;
        data["callCenter"] = this.callCenter;
        return data; 
    }
}

export interface IContactAgentInput {
    agentCode: string;
    agentName: string | undefined;
    callCenter: string | undefined;
}

export class CreateContactAgentsInput implements ICreateContactAgentsInput {
    contactId!: number;
    source!: AgentDataSource | undefined;
    contactAgents!: ContactAgentInput[];

    constructor(data?: ICreateContactAgentsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactAgents = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.source = data["source"];
            if (data["contactAgents"] && data["contactAgents"].constructor === Array) {
                this.contactAgents = [];
                for (let item of data["contactAgents"])
                    this.contactAgents.push(ContactAgentInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateContactAgentsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAgentsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["source"] = this.source;
        if (this.contactAgents && this.contactAgents.constructor === Array) {
            data["contactAgents"] = [];
            for (let item of this.contactAgents)
                data["contactAgents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateContactAgentsInput {
    contactId: number;
    source: AgentDataSource | undefined;
    contactAgents: ContactAgentInput[];
}

export class SubscriberDailyStatsReportInfo implements ISubscriberDailyStatsReportInfo {
    date!: moment.Moment | undefined;
    leadCount!: number | undefined;
    clientCount!: number | undefined;
    bankConnectCount!: number | undefined;
    bankConnectAmount!: number | undefined;
    bankBeyondCount!: number | undefined;
    bankBeyondAmount!: number | undefined;
    starterKitCount!: number | undefined;
    starterKitAmount!: number | undefined;
    totalCount!: number | undefined;
    totalAmount!: number | undefined;

    constructor(data?: ISubscriberDailyStatsReportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.leadCount = data["leadCount"];
            this.clientCount = data["clientCount"];
            this.bankConnectCount = data["bankConnectCount"];
            this.bankConnectAmount = data["bankConnectAmount"];
            this.bankBeyondCount = data["bankBeyondCount"];
            this.bankBeyondAmount = data["bankBeyondAmount"];
            this.starterKitCount = data["starterKitCount"];
            this.starterKitAmount = data["starterKitAmount"];
            this.totalCount = data["totalCount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): SubscriberDailyStatsReportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriberDailyStatsReportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["leadCount"] = this.leadCount;
        data["clientCount"] = this.clientCount;
        data["bankConnectCount"] = this.bankConnectCount;
        data["bankConnectAmount"] = this.bankConnectAmount;
        data["bankBeyondCount"] = this.bankBeyondCount;
        data["bankBeyondAmount"] = this.bankBeyondAmount;
        data["starterKitCount"] = this.starterKitCount;
        data["starterKitAmount"] = this.starterKitAmount;
        data["totalCount"] = this.totalCount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }
}

export interface ISubscriberDailyStatsReportInfo {
    date: moment.Moment | undefined;
    leadCount: number | undefined;
    clientCount: number | undefined;
    bankConnectCount: number | undefined;
    bankConnectAmount: number | undefined;
    bankBeyondCount: number | undefined;
    bankBeyondAmount: number | undefined;
    starterKitCount: number | undefined;
    starterKitAmount: number | undefined;
    totalCount: number | undefined;
    totalAmount: number | undefined;
}

export class GetReportUrlOutput implements IGetReportUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IGetReportUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetReportUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IGetReportUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class GenerateInput implements IGenerateInput {
    reportTemplate!: ReportTemplate | undefined;
    departments!: string[] | undefined;
    bankAccountIds!: number[] | undefined;
    from!: moment.Moment;
    to!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportTemplate = data["reportTemplate"];
            if (data["departments"] && data["departments"].constructor === Array) {
                this.departments = [];
                for (let item of data["departments"])
                    this.departments.push(item);
            }
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
            this.notificationData = data["notificationData"] ? SendReportNotificationInfo.fromJS(data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportTemplate"] = this.reportTemplate;
        if (this.departments && this.departments.constructor === Array) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item);
        }
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGenerateInput {
    reportTemplate: ReportTemplate | undefined;
    departments: string[] | undefined;
    bankAccountIds: number[] | undefined;
    from: moment.Moment;
    to: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GenerateBalanceSheetReportInput implements IGenerateBalanceSheetReportInput {
    date!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateBalanceSheetReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
            this.notificationData = data["notificationData"] ? SendReportNotificationInfo.fromJS(data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateBalanceSheetReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateBalanceSheetReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGenerateBalanceSheetReportInput {
    date: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class GenerateIncomeStatementByEntityReportInput implements IGenerateIncomeStatementByEntityReportInput {
    reportTemplate!: ReportTemplate;
    from!: moment.Moment;
    to!: moment.Moment;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    notificationData!: SendReportNotificationInfo | undefined;

    constructor(data?: IGenerateIncomeStatementByEntityReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportTemplate = data["reportTemplate"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
            this.notificationData = data["notificationData"] ? SendReportNotificationInfo.fromJS(data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateIncomeStatementByEntityReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateIncomeStatementByEntityReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportTemplate"] = this.reportTemplate;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGenerateIncomeStatementByEntityReportInput {
    reportTemplate: ReportTemplate;
    from: moment.Moment;
    to: moment.Moment;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    notificationData: SendReportNotificationInfo | undefined;
}

export class SendReportNotificationInput implements ISendReportNotificationInput {
    reportId!: string;
    recipientUserEmailAddress!: string;
    sendReportInAttachments!: boolean;

    constructor(data?: ISendReportNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportId = data["reportId"];
            this.recipientUserEmailAddress = data["recipientUserEmailAddress"];
            this.sendReportInAttachments = data["sendReportInAttachments"];
        }
    }

    static fromJS(data: any): SendReportNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendReportNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["recipientUserEmailAddress"] = this.recipientUserEmailAddress;
        data["sendReportInAttachments"] = this.sendReportInAttachments;
        return data; 
    }
}

export interface ISendReportNotificationInput {
    reportId: string;
    recipientUserEmailAddress: string;
    sendReportInAttachments: boolean;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    moduleId!: ModuleType | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.moduleId = data["moduleId"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["moduleId"] = this.moduleId;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    moduleId: ModuleType | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export enum Permissions {
    None = "None", 
    Read = "Read", 
    Write = "Write", 
    All = "All", 
}

export class BankAccountUsers implements IBankAccountUsers {
    bankAccountId!: number | undefined;
    userIds!: number[] | undefined;

    constructor(data?: IBankAccountUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountUsers {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data; 
    }
}

export interface IBankAccountUsers {
    bankAccountId: number | undefined;
    userIds: number[] | undefined;
}

export enum UserGroup {
    Employee = "Employee", 
    Member = "Member", 
    Partner = "Partner", 
    Investor = "Investor", 
    Vendor = "Vendor", 
    Other = "Other", 
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    profileThumbnailId!: string | undefined;
    bankCode!: string | undefined;
    affiliateCode!: string | undefined;
    affiliateRate!: number | undefined;
    groups!: UserGroup[] | undefined;
    contactId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.profileThumbnailId = data["profileThumbnailId"];
            this.bankCode = data["bankCode"];
            this.affiliateCode = data["affiliateCode"];
            this.affiliateRate = data["affiliateRate"];
            if (data["groups"] && data["groups"].constructor === Array) {
                this.groups = [];
                for (let item of data["groups"])
                    this.groups.push(item);
            }
            this.contactId = data["contactId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["bankCode"] = this.bankCode;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateRate"] = this.affiliateRate;
        if (this.groups && this.groups.constructor === Array) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["contactId"] = this.contactId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    profileThumbnailId: string | undefined;
    bankCode: string | undefined;
    affiliateCode: string | undefined;
    affiliateRate: number | undefined;
    groups: UserGroup[] | undefined;
    contactId: number | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export enum LayoutType {
    Default = "Default", 
    LendSpace = "LendSpace", 
    AdvicePeriod = "AdvicePeriod", 
    BankCode = "BankCode", 
    Rapid = "Rapid", 
    HOA = "HOA", 
    Sperser = "Sperser", 
    GhostDrive = "GhostDrive", 
}

export class FaviconDto implements IFaviconDto {
    name!: string | undefined;
    type!: string | undefined;
    relationship!: string | undefined;
    size!: string | undefined;

    constructor(data?: IFaviconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.relationship = data["relationship"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): FaviconDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaviconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["relationship"] = this.relationship;
        data["size"] = this.size;
        return data; 
    }
}

export interface IFaviconDto {
    name: string | undefined;
    type: string | undefined;
    relationship: string | undefined;
    size: string | undefined;
}

export class TenantCustomizationInfoDto implements ITenantCustomizationInfoDto {
    siteTitle!: string | undefined;
    faviconBaseUrl!: string | undefined;
    favicons!: FaviconDto[] | undefined;

    constructor(data?: ITenantCustomizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.siteTitle = data["siteTitle"];
            this.faviconBaseUrl = data["faviconBaseUrl"];
            if (data["favicons"] && data["favicons"].constructor === Array) {
                this.favicons = [];
                for (let item of data["favicons"])
                    this.favicons.push(FaviconDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantCustomizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCustomizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteTitle"] = this.siteTitle;
        data["faviconBaseUrl"] = this.faviconBaseUrl;
        if (this.favicons && this.favicons.constructor === Array) {
            data["favicons"] = [];
            for (let item of this.favicons)
                data["favicons"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantCustomizationInfoDto {
    siteTitle: string | undefined;
    faviconBaseUrl: string | undefined;
    favicons: FaviconDto[] | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    isWhiteLabel!: boolean | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    loginCustomCssId!: string | undefined;
    portalCustomCssId!: string | undefined;
    customToSDocumentId!: string | undefined;
    customPrivacyPolicyDocumentId!: string | undefined;
    customLayoutType!: LayoutType | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    creationTimeString!: string | undefined;
    tenantCustomizations!: TenantCustomizationInfoDto | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isWhiteLabel = data["isWhiteLabel"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.loginCustomCssId = data["loginCustomCssId"];
            this.portalCustomCssId = data["portalCustomCssId"];
            this.customToSDocumentId = data["customToSDocumentId"];
            this.customPrivacyPolicyDocumentId = data["customPrivacyPolicyDocumentId"];
            this.customLayoutType = data["customLayoutType"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.creationTimeString = data["creationTimeString"];
            this.tenantCustomizations = data["tenantCustomizations"] ? TenantCustomizationInfoDto.fromJS(data["tenantCustomizations"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isWhiteLabel"] = this.isWhiteLabel;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["loginCustomCssId"] = this.loginCustomCssId;
        data["portalCustomCssId"] = this.portalCustomCssId;
        data["customToSDocumentId"] = this.customToSDocumentId;
        data["customPrivacyPolicyDocumentId"] = this.customPrivacyPolicyDocumentId;
        data["customLayoutType"] = this.customLayoutType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["creationTimeString"] = this.creationTimeString;
        data["tenantCustomizations"] = this.tenantCustomizations ? this.tenantCustomizations.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    isWhiteLabel: boolean | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    loginCustomCssId: string | undefined;
    portalCustomCssId: string | undefined;
    customToSDocumentId: string | undefined;
    customPrivacyPolicyDocumentId: string | undefined;
    customLayoutType: LayoutType | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    creationTimeString: string | undefined;
    tenantCustomizations: TenantCustomizationInfoDto | undefined;
    id: number | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value!: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    features!: { [key: string] : AbpStringValueDto; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key] ? AbpStringValueDto.fromJS(data["features"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : AbpStringValueDto; } | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class AuthTestOutput implements IAuthTestOutput {
    tenantName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IAuthTestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): AuthTestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IAuthTestOutput {
    tenantName: string | undefined;
    userName: string | undefined;
}

export class CreateStageInput implements ICreateStageInput {
    pipelineId!: number;
    name!: string;
    sortOrder!: number;

    constructor(data?: ICreateStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelineId = data["pipelineId"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateStageInput {
    pipelineId: number;
    name: string;
    sortOrder: number;
}

export class RenameStageInput implements IRenameStageInput {
    id!: number;
    name!: string;

    constructor(data?: IRenameStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenameStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenameStageInput {
    id: number;
    name: string;
}

export class MergeStagesInput implements IMergeStagesInput {
    pipelineId!: number;
    sourceStageId!: number;
    destinationStageId!: number | undefined;

    constructor(data?: IMergeStagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelineId = data["pipelineId"];
            this.sourceStageId = data["sourceStageId"];
            this.destinationStageId = data["destinationStageId"];
        }
    }

    static fromJS(data: any): MergeStagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeStagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["sourceStageId"] = this.sourceStageId;
        data["destinationStageId"] = this.destinationStageId;
        return data; 
    }
}

export interface IMergeStagesInput {
    pipelineId: number;
    sourceStageId: number;
    destinationStageId: number | undefined;
}

export class CreateStageChecklistPointInput implements ICreateStageChecklistPointInput {
    stageId!: number;
    name!: string;

    constructor(data?: ICreateStageChecklistPointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stageId = data["stageId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateStageChecklistPointInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStageChecklistPointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stageId"] = this.stageId;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateStageChecklistPointInput {
    stageId: number;
    name: string;
}

export class CreatePointInfoOutput implements ICreatePointInfoOutput {
    id!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICreatePointInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreatePointInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePointInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreatePointInfoOutput {
    id: number | undefined;
    sortOrder: number | undefined;
}

export class RenameStageChecklistPointInput implements IRenameStageChecklistPointInput {
    id!: number;
    name!: string;

    constructor(data?: IRenameStageChecklistPointInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenameStageChecklistPointInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameStageChecklistPointInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenameStageChecklistPointInput {
    id: number;
    name: string;
}

export class UpdateStageChecklistPointSortOrderInput implements IUpdateStageChecklistPointSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateStageChecklistPointSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateStageChecklistPointSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStageChecklistPointSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateStageChecklistPointSortOrderInput {
    id: number;
    sortOrder: number;
}

export class SetupSyncUserApplicationInput implements ISetupSyncUserApplicationInput {
    syncTypeId!: string;
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: ISetupSyncUserApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncTypeId = data["syncTypeId"];
            this.clientId = data["clientId"];
            this.clientSecret = data["clientSecret"];
        }
    }

    static fromJS(data: any): SetupSyncUserApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetupSyncUserApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncTypeId"] = this.syncTypeId;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data; 
    }
}

export interface ISetupSyncUserApplicationInput {
    syncTypeId: string;
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export enum ConnectionMode {
    Create = "Create", 
    Reconnect = "Reconnect", 
    Refresh = "Refresh", 
}

export class RequestConnectionInput implements IRequestConnectionInput {
    syncTypeId!: string;
    mode!: ConnectionMode;
    syncAccountId!: number | undefined;

    constructor(data?: IRequestConnectionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncTypeId = data["syncTypeId"];
            this.mode = data["mode"];
            this.syncAccountId = data["syncAccountId"];
        }
    }

    static fromJS(data: any): RequestConnectionInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestConnectionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncTypeId"] = this.syncTypeId;
        data["mode"] = this.mode;
        data["syncAccountId"] = this.syncAccountId;
        return data; 
    }
}

export interface IRequestConnectionInput {
    syncTypeId: string;
    mode: ConnectionMode;
    syncAccountId: number | undefined;
}

export class RequestConnectionOutput implements IRequestConnectionOutput {
    connectUrl!: string | undefined;
    scope!: string[] | undefined;
    clientName!: string | undefined;
    environment!: string | undefined;
    publicKey!: string | undefined;
    webhookUrl!: string | undefined;

    constructor(data?: IRequestConnectionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectUrl = data["connectUrl"];
            if (data["scope"] && data["scope"].constructor === Array) {
                this.scope = [];
                for (let item of data["scope"])
                    this.scope.push(item);
            }
            this.clientName = data["clientName"];
            this.environment = data["environment"];
            this.publicKey = data["publicKey"];
            this.webhookUrl = data["webhookUrl"];
        }
    }

    static fromJS(data: any): RequestConnectionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestConnectionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectUrl"] = this.connectUrl;
        if (this.scope && this.scope.constructor === Array) {
            data["scope"] = [];
            for (let item of this.scope)
                data["scope"].push(item);
        }
        data["clientName"] = this.clientName;
        data["environment"] = this.environment;
        data["publicKey"] = this.publicKey;
        data["webhookUrl"] = this.webhookUrl;
        return data; 
    }
}

export interface IRequestConnectionOutput {
    connectUrl: string | undefined;
    scope: string[] | undefined;
    clientName: string | undefined;
    environment: string | undefined;
    publicKey: string | undefined;
    webhookUrl: string | undefined;
}

export class SyncAllAccountsOutput implements ISyncAllAccountsOutput {
    syncInProgressAccountsCount!: number | undefined;
    failedSyncAccountsCount!: number | undefined;

    constructor(data?: ISyncAllAccountsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncInProgressAccountsCount = data["syncInProgressAccountsCount"];
            this.failedSyncAccountsCount = data["failedSyncAccountsCount"];
        }
    }

    static fromJS(data: any): SyncAllAccountsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAllAccountsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncInProgressAccountsCount"] = this.syncInProgressAccountsCount;
        data["failedSyncAccountsCount"] = this.failedSyncAccountsCount;
        return data; 
    }
}

export interface ISyncAllAccountsOutput {
    syncInProgressAccountsCount: number | undefined;
    failedSyncAccountsCount: number | undefined;
}

export class BankAccountProgress implements IBankAccountProgress {
    id!: number | undefined;
    syncStatus!: SyncProgressStatus | undefined;
    lastSyncDate!: moment.Moment | undefined;
    lastGoodSyncDate!: moment.Moment | undefined;

    constructor(data?: IBankAccountProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.syncStatus = data["syncStatus"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            this.lastGoodSyncDate = data["lastGoodSyncDate"] ? moment(data["lastGoodSyncDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountProgress {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["syncStatus"] = this.syncStatus;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["lastGoodSyncDate"] = this.lastGoodSyncDate ? this.lastGoodSyncDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBankAccountProgress {
    id: number | undefined;
    syncStatus: SyncProgressStatus | undefined;
    lastSyncDate: moment.Moment | undefined;
    lastGoodSyncDate: moment.Moment | undefined;
}

export class SyncProgressDto implements ISyncProgressDto {
    accountId!: number | undefined;
    accountName!: string | undefined;
    syncStatusMessage!: string | undefined;
    progressPercent!: number | undefined;
    syncStatus!: SyncProgressStatus | undefined;
    lastSyncDate!: moment.Moment | undefined;
    bankAccounts!: BankAccountProgress[] | undefined;

    constructor(data?: ISyncProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.syncStatusMessage = data["syncStatusMessage"];
            this.progressPercent = data["progressPercent"];
            this.syncStatus = data["syncStatus"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountProgress.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["syncStatusMessage"] = this.syncStatusMessage;
        data["progressPercent"] = this.progressPercent;
        data["syncStatus"] = this.syncStatus;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISyncProgressDto {
    accountId: number | undefined;
    accountName: string | undefined;
    syncStatusMessage: string | undefined;
    progressPercent: number | undefined;
    syncStatus: SyncProgressStatus | undefined;
    lastSyncDate: moment.Moment | undefined;
    bankAccounts: BankAccountProgress[] | undefined;
}

export class SyncProgressOutput implements ISyncProgressOutput {
    lastSyncDate!: moment.Moment | undefined;
    totalProgress!: SyncProgressDto | undefined;
    accountProgresses!: SyncProgressDto[] | undefined;

    constructor(data?: ISyncProgressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            this.totalProgress = data["totalProgress"] ? SyncProgressDto.fromJS(data["totalProgress"]) : <any>undefined;
            if (data["accountProgresses"] && data["accountProgresses"].constructor === Array) {
                this.accountProgresses = [];
                for (let item of data["accountProgresses"])
                    this.accountProgresses.push(SyncProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["totalProgress"] = this.totalProgress ? this.totalProgress.toJSON() : <any>undefined;
        if (this.accountProgresses && this.accountProgresses.constructor === Array) {
            data["accountProgresses"] = [];
            for (let item of this.accountProgresses)
                data["accountProgresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISyncProgressOutput {
    lastSyncDate: moment.Moment | undefined;
    totalProgress: SyncProgressDto | undefined;
    accountProgresses: SyncProgressDto[] | undefined;
}

export class SyncAccountDto implements ISyncAccountDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: ISyncAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SyncAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISyncAccountDto {
    id: number | undefined;
    name: string | undefined;
}

export class CreateSyncAccountInput implements ICreateSyncAccountInput {
    typeId!: string;
    publicToken!: string | undefined;
    syncAccountRef!: string | undefined;
    isSyncBankAccountsEnabled!: boolean | undefined;

    constructor(data?: ICreateSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.publicToken = data["publicToken"];
            this.syncAccountRef = data["syncAccountRef"];
            this.isSyncBankAccountsEnabled = data["isSyncBankAccountsEnabled"];
        }
    }

    static fromJS(data: any): CreateSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["publicToken"] = this.publicToken;
        data["syncAccountRef"] = this.syncAccountRef;
        data["isSyncBankAccountsEnabled"] = this.isSyncBankAccountsEnabled;
        return data; 
    }
}

export interface ICreateSyncAccountInput {
    typeId: string;
    publicToken: string | undefined;
    syncAccountRef: string | undefined;
    isSyncBankAccountsEnabled: boolean | undefined;
}

export class RenameSyncAccountInput implements IRenameSyncAccountInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): RenameSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IRenameSyncAccountInput {
    id: number;
    newName: string;
}

export class ChangeAutoSyncInput implements IChangeAutoSyncInput {
    syncAccountIds!: number[] | undefined;
    autoSyncTime!: string | undefined;

    constructor(data?: IChangeAutoSyncInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["syncAccountIds"] && data["syncAccountIds"].constructor === Array) {
                this.syncAccountIds = [];
                for (let item of data["syncAccountIds"])
                    this.syncAccountIds.push(item);
            }
            this.autoSyncTime = data["autoSyncTime"];
        }
    }

    static fromJS(data: any): ChangeAutoSyncInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeAutoSyncInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.syncAccountIds && this.syncAccountIds.constructor === Array) {
            data["syncAccountIds"] = [];
            for (let item of this.syncAccountIds)
                data["syncAccountIds"].push(item);
        }
        data["autoSyncTime"] = this.autoSyncTime;
        return data; 
    }
}

export interface IChangeAutoSyncInput {
    syncAccountIds: number[] | undefined;
    autoSyncTime: string | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    hasOwnDatabase!: boolean | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.hasOwnDatabase = data["hasOwnDatabase"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["hasOwnDatabase"] = this.hasOwnDatabase;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    hasOwnDatabase: boolean | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class TenantListDtoPagedResultDto implements ITenantListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: ITenantListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantListDtoPagedResultDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantEditEditionDto implements ITenantEditEditionDto {
    editionId!: number;
    maxUserCount!: number | undefined;
    trialDayCount!: number | undefined;

    constructor(data?: ITenantEditEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
            this.trialDayCount = data["trialDayCount"];
        }
    }

    static fromJS(data: any): TenantEditEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["trialDayCount"] = this.trialDayCount;
        return data; 
    }
}

export interface ITenantEditEditionDto {
    editionId: number;
    maxUserCount: number | undefined;
    trialDayCount: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    adminFirstName!: string | undefined;
    adminLastName!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    azureConnectionString!: string | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.adminFirstName = data["adminFirstName"];
            this.adminLastName = data["adminLastName"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            this.azureConnectionString = data["azureConnectionString"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["adminFirstName"] = this.adminFirstName;
        data["adminLastName"] = this.adminLastName;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["azureConnectionString"] = this.azureConnectionString;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateTenantInput {
    adminEmailAddress: string;
    adminPassword: string | undefined;
    adminFirstName: string | undefined;
    adminLastName: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    azureConnectionString: string | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    id!: number;
    copyFiles!: boolean | undefined;
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    azureConnectionString!: string | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.copyFiles = data["copyFiles"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            this.azureConnectionString = data["azureConnectionString"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["copyFiles"] = this.copyFiles;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["azureConnectionString"] = this.azureConnectionString;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ITenantEditDto {
    id: number;
    copyFiles: boolean | undefined;
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    azureConnectionString: string | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export enum CustomCssType {
    Platform = "Platform", 
    Login = "Login", 
    Portal = "Portal", 
}

export class TenantAppHostOutput implements ITenantAppHostOutput {
    appHostName!: string | undefined;

    constructor(data?: ITenantAppHostOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appHostName = data["appHostName"];
        }
    }

    static fromJS(data: any): TenantAppHostOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppHostOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appHostName"] = this.appHostName;
        return data; 
    }
}

export interface ITenantAppHostOutput {
    appHostName: string | undefined;
}

export class GetPlatformAppUrlOutput implements IGetPlatformAppUrlOutput {
    url!: string | undefined;
    isCustom!: boolean | undefined;

    constructor(data?: IGetPlatformAppUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.isCustom = data["isCustom"];
        }
    }

    static fromJS(data: any): GetPlatformAppUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlatformAppUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["isCustom"] = this.isCustom;
        return data; 
    }
}

export interface IGetPlatformAppUrlOutput {
    url: string | undefined;
    isCustom: boolean | undefined;
}

export class GetMemberPortalUrlOutput implements IGetMemberPortalUrlOutput {
    url!: string | undefined;

    constructor(data?: IGetMemberPortalUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): GetMemberPortalUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberPortalUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IGetMemberPortalUrlOutput {
    url: string | undefined;
}

export enum TenantHostType {
    PlatformApp = "PlatformApp", 
    MemberPortal = "MemberPortal", 
}

export class CheckHostNameDnsMappingInput implements ICheckHostNameDnsMappingInput {
    tenantHostType!: TenantHostType | undefined;
    hostName!: string | undefined;

    constructor(data?: ICheckHostNameDnsMappingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["hostName"] = this.hostName;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingInput {
    tenantHostType: TenantHostType | undefined;
    hostName: string | undefined;
}

export class CheckHostNameDnsMappingOutput implements ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped!: boolean | undefined;

    constructor(data?: ICheckHostNameDnsMappingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hostNameDnsMapped = data["hostNameDnsMapped"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostNameDnsMapped"] = this.hostNameDnsMapped;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped: boolean | undefined;
}

export class TenantSslBindingInfo implements ITenantSslBindingInfo {
    id!: number | undefined;
    hostName!: string | undefined;
    hostType!: TenantHostType | undefined;
    isActive!: boolean | undefined;
    sslCertificateId!: number | undefined;
    sslCertificateExpiration!: moment.Moment | undefined;
    sslCertificateThumbprint!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ITenantSslBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostName = data["hostName"];
            this.hostType = data["hostType"];
            this.isActive = data["isActive"];
            this.sslCertificateId = data["sslCertificateId"];
            this.sslCertificateExpiration = data["sslCertificateExpiration"] ? moment(data["sslCertificateExpiration"].toString()) : <any>undefined;
            this.sslCertificateThumbprint = data["sslCertificateThumbprint"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): TenantSslBindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslBindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostName"] = this.hostName;
        data["hostType"] = this.hostType;
        data["isActive"] = this.isActive;
        data["sslCertificateId"] = this.sslCertificateId;
        data["sslCertificateExpiration"] = this.sslCertificateExpiration ? this.sslCertificateExpiration.toISOString() : <any>undefined;
        data["sslCertificateThumbprint"] = this.sslCertificateThumbprint;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ITenantSslBindingInfo {
    id: number | undefined;
    hostName: string | undefined;
    hostType: TenantHostType | undefined;
    isActive: boolean | undefined;
    sslCertificateId: number | undefined;
    sslCertificateExpiration: moment.Moment | undefined;
    sslCertificateThumbprint: string | undefined;
    organizationUnitId: number | undefined;
}

export class AddSslBindingInput implements IAddSslBindingInput {
    tenantHostType!: TenantHostType;
    domainName!: string | undefined;
    sslCertificateId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IAddSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.domainName = data["domainName"];
            this.sslCertificateId = data["sslCertificateId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AddSslBindingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["domainName"] = this.domainName;
        data["sslCertificateId"] = this.sslCertificateId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IAddSslBindingInput {
    tenantHostType: TenantHostType;
    domainName: string | undefined;
    sslCertificateId: number | undefined;
    organizationUnitId: number | undefined;
}

export class UpdateSslBindingInput implements IUpdateSslBindingInput {
    id!: number;
    sslCertificateId!: number | undefined;
    organizationUnitId!: number | undefined;
    isActive!: boolean;

    constructor(data?: IUpdateSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sslCertificateId = data["sslCertificateId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateSslBindingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sslCertificateId"] = this.sslCertificateId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateSslBindingInput {
    id: number;
    sslCertificateId: number | undefined;
    organizationUnitId: number | undefined;
    isActive: boolean;
}

export class IntegrationsSettings implements IIntegrationsSettings {
    googleMapsJavascriptApiKey!: string | undefined;
    googleCloudTranslationApiKey!: string | undefined;

    constructor(data?: IIntegrationsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.googleMapsJavascriptApiKey = data["googleMapsJavascriptApiKey"];
            this.googleCloudTranslationApiKey = data["googleCloudTranslationApiKey"];
        }
    }

    static fromJS(data: any): IntegrationsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapsJavascriptApiKey"] = this.googleMapsJavascriptApiKey;
        data["googleCloudTranslationApiKey"] = this.googleCloudTranslationApiKey;
        return data; 
    }
}

export interface IIntegrationsSettings {
    googleMapsJavascriptApiKey: string | undefined;
    googleCloudTranslationApiKey: string | undefined;
}

export class EPCVIPOfferProviderSettings implements IEPCVIPOfferProviderSettings {
    apiKey!: string | undefined;

    constructor(data?: IEPCVIPOfferProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
        }
    }

    static fromJS(data: any): EPCVIPOfferProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPOfferProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        return data; 
    }
}

export interface IEPCVIPOfferProviderSettings {
    apiKey: string | undefined;
}

export class BaseCommercePaymentSettings implements IBaseCommercePaymentSettings {
    userName!: string | undefined;
    password!: string | undefined;
    key!: string | undefined;
    sandBox!: boolean | undefined;

    constructor(data?: IBaseCommercePaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.key = data["key"];
            this.sandBox = data["sandBox"];
        }
    }

    static fromJS(data: any): BaseCommercePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCommercePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["key"] = this.key;
        data["sandBox"] = this.sandBox;
        return data; 
    }
}

export interface IBaseCommercePaymentSettings {
    userName: string | undefined;
    password: string | undefined;
    key: string | undefined;
    sandBox: boolean | undefined;
}

export class ACHWorksSettings implements IACHWorksSettings {
    sss!: string | undefined;
    locID!: string | undefined;
    soapUser!: string | undefined;
    soapKey!: string | undefined;

    constructor(data?: IACHWorksSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sss = data["sss"];
            this.locID = data["locID"];
            this.soapUser = data["soapUser"];
            this.soapKey = data["soapKey"];
        }
    }

    static fromJS(data: any): ACHWorksSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ACHWorksSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sss"] = this.sss;
        data["locID"] = this.locID;
        data["soapUser"] = this.soapUser;
        data["soapKey"] = this.soapKey;
        return data; 
    }
}

export interface IACHWorksSettings {
    sss: string | undefined;
    locID: string | undefined;
    soapUser: string | undefined;
    soapKey: string | undefined;
}

export class RecurlyPaymentSettings implements IRecurlyPaymentSettings {
    apiKey!: string | undefined;
    subdomain!: string | undefined;
    privateKey!: string | undefined;
    pageSize!: number | undefined;

    constructor(data?: IRecurlyPaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.subdomain = data["subdomain"];
            this.privateKey = data["privateKey"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): RecurlyPaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RecurlyPaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["subdomain"] = this.subdomain;
        data["privateKey"] = this.privateKey;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IRecurlyPaymentSettings {
    apiKey: string | undefined;
    subdomain: string | undefined;
    privateKey: string | undefined;
    pageSize: number | undefined;
}

export class PayPalSettings implements IPayPalSettings {
    environment!: string | undefined;
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IPayPalSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.environment = data["environment"];
            this.clientId = data["clientId"];
            this.clientSecret = data["clientSecret"];
        }
    }

    static fromJS(data: any): PayPalSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environment"] = this.environment;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data; 
    }
}

export interface IPayPalSettings {
    environment: string | undefined;
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class BeneficiaryInfo implements IBeneficiaryInfo {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.streetAddress = data["streetAddress"];
            this.cityAddress = data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data; 
    }
}

export interface IBeneficiaryInfo {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BankTransferSettings implements IBankTransferSettings {
    beneficiaryInfo!: BeneficiaryInfo | undefined;
    beneficiaryBank!: BeneficiaryInfo | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beneficiaryInfo = data["beneficiaryInfo"] ? BeneficiaryInfo.fromJS(data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = data["beneficiaryBank"] ? BeneficiaryInfo.fromJS(data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankRoutingNumberForACH = data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = data["swiftCodeForUSDollar"];
            this.swiftCode = data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankTransferSettings {
    beneficiaryInfo: BeneficiaryInfo | undefined;
    beneficiaryBank: BeneficiaryInfo | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class StripeSettings implements IStripeSettings {
    apiKey!: string | undefined;
    webhookSingingSecret!: string | undefined;

    constructor(data?: IStripeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.webhookSingingSecret = data["webhookSingingSecret"];
        }
    }

    static fromJS(data: any): StripeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new StripeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["webhookSingingSecret"] = this.webhookSingingSecret;
        return data; 
    }
}

export interface IStripeSettings {
    apiKey: string | undefined;
    webhookSingingSecret: string | undefined;
}

export enum Currency {
    USD = "USD", 
    CAD = "CAD", 
    EUR = "EUR", 
    GBP = "GBP", 
    AUD = "AUD", 
    NZD = "NZD", 
    SGD = "SGD", 
    HKD = "HKD", 
    UAH = "UAH", 
    INR = "INR", 
    JPY = "JPY", 
    ILS = "ILS", 
    CHF = "CHF", 
    MXN = "MXN", 
    RUB = "RUB", 
    BTC = "BTC", 
}

export enum Tier2CommissionSource {
    CommissionAmount = "CommissionAmount", 
    CommissionableValue = "CommissionableValue", 
}

export enum CommissionAffiliateAssignmentMode {
    Linear = "Linear", 
    Dynamic = "Dynamic", 
}

export class InvoiceSettingsDto implements IInvoiceSettingsDto {
    advisorName!: string | undefined;
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;
    defaultTemplateId!: number | undefined;
    attachPDF!: boolean | undefined;
    defaultNote!: string | undefined;
    currency!: Currency | undefined;
    showShippingAddress!: boolean | undefined;
    defaultAffiliateRate!: number | undefined;
    defaultAffiliateRateTier2!: number | undefined;
    defaultAdvisorContactId!: number | undefined;
    tier2CommissionSource!: Tier2CommissionSource | undefined;
    commissionAffiliateAssignmentMode!: CommissionAffiliateAssignmentMode | undefined;
    disableProlongingSubscriptionByQuantity!: boolean | undefined;

    constructor(data?: IInvoiceSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.advisorName = data["advisorName"];
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
            this.defaultTemplateId = data["defaultTemplateId"];
            this.attachPDF = data["attachPDF"];
            this.defaultNote = data["defaultNote"];
            this.currency = data["currency"];
            this.showShippingAddress = data["showShippingAddress"];
            this.defaultAffiliateRate = data["defaultAffiliateRate"];
            this.defaultAffiliateRateTier2 = data["defaultAffiliateRateTier2"];
            this.defaultAdvisorContactId = data["defaultAdvisorContactId"];
            this.tier2CommissionSource = data["tier2CommissionSource"];
            this.commissionAffiliateAssignmentMode = data["commissionAffiliateAssignmentMode"];
            this.disableProlongingSubscriptionByQuantity = data["disableProlongingSubscriptionByQuantity"];
        }
    }

    static fromJS(data: any): InvoiceSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["advisorName"] = this.advisorName;
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        data["defaultTemplateId"] = this.defaultTemplateId;
        data["attachPDF"] = this.attachPDF;
        data["defaultNote"] = this.defaultNote;
        data["currency"] = this.currency;
        data["showShippingAddress"] = this.showShippingAddress;
        data["defaultAffiliateRate"] = this.defaultAffiliateRate;
        data["defaultAffiliateRateTier2"] = this.defaultAffiliateRateTier2;
        data["defaultAdvisorContactId"] = this.defaultAdvisorContactId;
        data["tier2CommissionSource"] = this.tier2CommissionSource;
        data["commissionAffiliateAssignmentMode"] = this.commissionAffiliateAssignmentMode;
        data["disableProlongingSubscriptionByQuantity"] = this.disableProlongingSubscriptionByQuantity;
        return data; 
    }
}

export interface IInvoiceSettingsDto {
    advisorName: string | undefined;
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
    defaultTemplateId: number | undefined;
    attachPDF: boolean | undefined;
    defaultNote: string | undefined;
    currency: Currency | undefined;
    showShippingAddress: boolean | undefined;
    defaultAffiliateRate: number | undefined;
    defaultAffiliateRateTier2: number | undefined;
    defaultAdvisorContactId: number | undefined;
    tier2CommissionSource: Tier2CommissionSource | undefined;
    commissionAffiliateAssignmentMode: CommissionAffiliateAssignmentMode | undefined;
    disableProlongingSubscriptionByQuantity: boolean | undefined;
}

export class InvoiceSettings implements IInvoiceSettings {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;
    defaultTemplateId!: number | undefined;
    attachPDF!: boolean | undefined;
    defaultNote!: string | undefined;
    currency!: Currency | undefined;
    showShippingAddress!: boolean | undefined;
    defaultAffiliateRate!: number | undefined;
    defaultAffiliateRateTier2!: number | undefined;
    defaultAdvisorContactId!: number | undefined;
    tier2CommissionSource!: Tier2CommissionSource | undefined;
    commissionAffiliateAssignmentMode!: CommissionAffiliateAssignmentMode | undefined;
    disableProlongingSubscriptionByQuantity!: boolean | undefined;

    constructor(data?: IInvoiceSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
            this.defaultTemplateId = data["defaultTemplateId"];
            this.attachPDF = data["attachPDF"];
            this.defaultNote = data["defaultNote"];
            this.currency = data["currency"];
            this.showShippingAddress = data["showShippingAddress"];
            this.defaultAffiliateRate = data["defaultAffiliateRate"];
            this.defaultAffiliateRateTier2 = data["defaultAffiliateRateTier2"];
            this.defaultAdvisorContactId = data["defaultAdvisorContactId"];
            this.tier2CommissionSource = data["tier2CommissionSource"];
            this.commissionAffiliateAssignmentMode = data["commissionAffiliateAssignmentMode"];
            this.disableProlongingSubscriptionByQuantity = data["disableProlongingSubscriptionByQuantity"];
        }
    }

    static fromJS(data: any): InvoiceSettings {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        data["defaultTemplateId"] = this.defaultTemplateId;
        data["attachPDF"] = this.attachPDF;
        data["defaultNote"] = this.defaultNote;
        data["currency"] = this.currency;
        data["showShippingAddress"] = this.showShippingAddress;
        data["defaultAffiliateRate"] = this.defaultAffiliateRate;
        data["defaultAffiliateRateTier2"] = this.defaultAffiliateRateTier2;
        data["defaultAdvisorContactId"] = this.defaultAdvisorContactId;
        data["tier2CommissionSource"] = this.tier2CommissionSource;
        data["commissionAffiliateAssignmentMode"] = this.commissionAffiliateAssignmentMode;
        data["disableProlongingSubscriptionByQuantity"] = this.disableProlongingSubscriptionByQuantity;
        return data; 
    }
}

export interface IInvoiceSettings {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
    defaultTemplateId: number | undefined;
    attachPDF: boolean | undefined;
    defaultNote: string | undefined;
    currency: Currency | undefined;
    showShippingAddress: boolean | undefined;
    defaultAffiliateRate: number | undefined;
    defaultAffiliateRateTier2: number | undefined;
    defaultAdvisorContactId: number | undefined;
    tier2CommissionSource: Tier2CommissionSource | undefined;
    commissionAffiliateAssignmentMode: CommissionAffiliateAssignmentMode | undefined;
    disableProlongingSubscriptionByQuantity: boolean | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    customWelcomeEmailTemplates!: CustomWelcomeTemplate[] | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            if (data["customWelcomeEmailTemplates"] && data["customWelcomeEmailTemplates"].constructor === Array) {
                this.customWelcomeEmailTemplates = [];
                for (let item of data["customWelcomeEmailTemplates"])
                    this.customWelcomeEmailTemplates.push(CustomWelcomeTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        if (this.customWelcomeEmailTemplates && this.customWelcomeEmailTemplates.constructor === Array) {
            data["customWelcomeEmailTemplates"] = [];
            for (let item of this.customWelcomeEmailTemplates)
                data["customWelcomeEmailTemplates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    customWelcomeEmailTemplates: CustomWelcomeTemplate[] | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
}

export enum EPCVIPServer {
    AmazonSES = "AmazonSES", 
    Mailgun = "Mailgun", 
    SendGrid = "SendGrid", 
    SparkPost = "SparkPost", 
}

export class EPCVIPMailerSettingsEditDto implements IEPCVIPMailerSettingsEditDto {
    baseUrl!: string | undefined;
    apiKey!: string | undefined;
    server!: EPCVIPServer | undefined;

    constructor(data?: IEPCVIPMailerSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseUrl = data["baseUrl"];
            this.apiKey = data["apiKey"];
            this.server = data["server"];
        }
    }

    static fromJS(data: any): EPCVIPMailerSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPMailerSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["apiKey"] = this.apiKey;
        data["server"] = this.server;
        return data; 
    }
}

export interface IEPCVIPMailerSettingsEditDto {
    baseUrl: string | undefined;
    apiKey: string | undefined;
    server: EPCVIPServer | undefined;
}

export class OngageSettingsEditDto implements IOngageSettingsEditDto {
    userName!: string | undefined;
    password!: string | undefined;
    accountCode!: string | undefined;
    defaultListId!: number | undefined;
    activationEmailMessageId!: number | undefined;
    isEnabled!: boolean | undefined;
    offerAnnouncementCampaignId!: string | undefined;

    constructor(data?: IOngageSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.accountCode = data["accountCode"];
            this.defaultListId = data["defaultListId"];
            this.activationEmailMessageId = data["activationEmailMessageId"];
            this.isEnabled = data["isEnabled"];
            this.offerAnnouncementCampaignId = data["offerAnnouncementCampaignId"];
        }
    }

    static fromJS(data: any): OngageSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OngageSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["accountCode"] = this.accountCode;
        data["defaultListId"] = this.defaultListId;
        data["activationEmailMessageId"] = this.activationEmailMessageId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementCampaignId"] = this.offerAnnouncementCampaignId;
        return data; 
    }
}

export interface IOngageSettingsEditDto {
    userName: string | undefined;
    password: string | undefined;
    accountCode: string | undefined;
    defaultListId: number | undefined;
    activationEmailMessageId: number | undefined;
    isEnabled: boolean | undefined;
    offerAnnouncementCampaignId: string | undefined;
}

export class IAgeSettingsEditDto implements IIAgeSettingsEditDto {
    apiKey!: string | undefined;
    activationEmailId!: number | undefined;
    passwordResetEmailId!: number | undefined;
    isEnabled!: boolean | undefined;
    offerAnnouncementEmailId!: number | undefined;

    constructor(data?: IIAgeSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.activationEmailId = data["activationEmailId"];
            this.passwordResetEmailId = data["passwordResetEmailId"];
            this.isEnabled = data["isEnabled"];
            this.offerAnnouncementEmailId = data["offerAnnouncementEmailId"];
        }
    }

    static fromJS(data: any): IAgeSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new IAgeSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["activationEmailId"] = this.activationEmailId;
        data["passwordResetEmailId"] = this.passwordResetEmailId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementEmailId"] = this.offerAnnouncementEmailId;
        return data; 
    }
}

export interface IIAgeSettingsEditDto {
    apiKey: string | undefined;
    activationEmailId: number | undefined;
    passwordResetEmailId: number | undefined;
    isEnabled: boolean | undefined;
    offerAnnouncementEmailId: number | undefined;
}

export class SendGridSettingsDto implements ISendGridSettingsDto {
    apiKey!: string | undefined;
    rpTemplateId!: string | undefined;
    rpFromEmail!: string | undefined;
    webhookKey!: string | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;

    constructor(data?: ISendGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.rpTemplateId = data["rpTemplateId"];
            this.rpFromEmail = data["rpFromEmail"];
            this.webhookKey = data["webhookKey"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): SendGridSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["rpTemplateId"] = this.rpTemplateId;
        data["rpFromEmail"] = this.rpFromEmail;
        data["webhookKey"] = this.webhookKey;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data; 
    }
}

export interface ISendGridSettingsDto {
    apiKey: string | undefined;
    rpTemplateId: string | undefined;
    rpFromEmail: string | undefined;
    webhookKey: string | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
}

export class RapidSettingsDto implements IRapidSettingsDto {
    username!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRapidSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RapidSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RapidSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRapidSettingsDto {
    username: string | undefined;
    password: string | undefined;
}

export class PasswordComplexitySettingsEditDto implements IPasswordComplexitySettingsEditDto {
    current!: PasswordComplexitySetting | undefined;
    default!: PasswordComplexitySetting | undefined;
    isDefaultUsed!: boolean | undefined;

    constructor(data?: IPasswordComplexitySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current = data["current"] ? PasswordComplexitySetting.fromJS(data["current"]) : <any>undefined;
            this.default = data["default"] ? PasswordComplexitySetting.fromJS(data["default"]) : <any>undefined;
            this.isDefaultUsed = data["isDefaultUsed"];
        }
    }

    static fromJS(data: any): PasswordComplexitySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current"] = this.current ? this.current.toJSON() : <any>undefined;
        data["default"] = this.default ? this.default.toJSON() : <any>undefined;
        data["isDefaultUsed"] = this.isDefaultUsed;
        return data; 
    }
}

export interface IPasswordComplexitySettingsEditDto {
    current: PasswordComplexitySetting | undefined;
    default: PasswordComplexitySetting | undefined;
    isDefaultUsed: boolean | undefined;
}

export class MemberPortalSettingsDto implements IMemberPortalSettingsDto {
    url!: string | undefined;

    constructor(data?: IMemberPortalSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MemberPortalSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPortalSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IMemberPortalSettingsDto {
    url: string | undefined;
}

export class IdcsSettings implements IIdcsSettings {
    requestSource!: string | undefined;
    partnerCode!: string | undefined;
    partnerAccount!: string | undefined;
    password!: string | undefined;
    branding!: string | undefined;

    constructor(data?: IIdcsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestSource = data["requestSource"];
            this.partnerCode = data["partnerCode"];
            this.partnerAccount = data["partnerAccount"];
            this.password = data["password"];
            this.branding = data["branding"];
        }
    }

    static fromJS(data: any): IdcsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IdcsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestSource"] = this.requestSource;
        data["partnerCode"] = this.partnerCode;
        data["partnerAccount"] = this.partnerAccount;
        data["password"] = this.password;
        data["branding"] = this.branding;
        return data; 
    }
}

export interface IIdcsSettings {
    requestSource: string | undefined;
    partnerCode: string | undefined;
    partnerAccount: string | undefined;
    password: string | undefined;
    branding: string | undefined;
}

export class TenantSslCertificateInfo implements ITenantSslCertificateInfo {
    id!: number | undefined;
    hostNames!: string | undefined;
    expiration!: moment.Moment | undefined;
    thumbprint!: string | undefined;

    constructor(data?: ITenantSslCertificateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostNames = data["hostNames"];
            this.expiration = data["expiration"] ? moment(data["expiration"].toString()) : <any>undefined;
            this.thumbprint = data["thumbprint"];
        }
    }

    static fromJS(data: any): TenantSslCertificateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslCertificateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostNames"] = this.hostNames;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["thumbprint"] = this.thumbprint;
        return data; 
    }
}

export interface ITenantSslCertificateInfo {
    id: number | undefined;
    hostNames: string | undefined;
    expiration: moment.Moment | undefined;
    thumbprint: string | undefined;
}

export class AddTenantSslCertificateInput implements IAddTenantSslCertificateInput {
    base64EncodedCertificate!: string;
    password!: string | undefined;

    constructor(data?: IAddTenantSslCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base64EncodedCertificate = data["base64EncodedCertificate"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): AddTenantSslCertificateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddTenantSslCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64EncodedCertificate"] = this.base64EncodedCertificate;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAddTenantSslCertificateInput {
    base64EncodedCertificate: string;
    password: string | undefined;
}

export enum PaymentMethod {
    Recurring = "Recurring", 
    Charge = "Charge", 
    Capture = "Capture", 
    Void = "Void", 
    Manual = "Manual", 
}

export class BankCardInfoDto implements IBankCardInfoDto {
    holderName!: string | undefined;
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;
    cvv!: string | undefined;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string | undefined;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.cvv = data["cvv"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingState = data["billingState"];
            this.billingCountryCode = data["billingCountryCode"];
            this.billingCountry = data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data; 
    }
}

export interface IBankCardInfoDto {
    holderName: string | undefined;
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
    cvv: string | undefined;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string | undefined;
    billingCountry: string | undefined;
}

export class ACHCustomerInfoDto implements IACHCustomerInfoDto {
    customerRoutingNo!: string | undefined;
    customerAcctNo!: string | undefined;

    constructor(data?: IACHCustomerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerRoutingNo = data["customerRoutingNo"];
            this.customerAcctNo = data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data; 
    }
}

export interface IACHCustomerInfoDto {
    customerRoutingNo: string | undefined;
    customerAcctNo: string | undefined;
}

export class PayPalInfoDto implements IPayPalInfoDto {
    paymentId!: string | undefined;
    payerId!: string | undefined;

    constructor(data?: IPayPalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
        }
    }

    static fromJS(data: any): PayPalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data; 
    }
}

export interface IPayPalInfoDto {
    paymentId: string | undefined;
    payerId: string | undefined;
}

export class PaymentRequestInfoDto implements IPaymentRequestInfoDto {
    paymentMethod!: PaymentMethod | undefined;
    paymentInfoType!: PaymentInfoType | undefined;
    bankCard!: BankCardInfoDto | undefined;
    achCustomer!: ACHCustomerInfoDto | undefined;
    payPal!: PayPalInfoDto | undefined;

    constructor(data?: IPaymentRequestInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentMethod = data["paymentMethod"];
            this.paymentInfoType = data["paymentInfoType"];
            this.bankCard = data["bankCard"] ? BankCardInfoDto.fromJS(data["bankCard"]) : <any>undefined;
            this.achCustomer = data["achCustomer"] ? ACHCustomerInfoDto.fromJS(data["achCustomer"]) : <any>undefined;
            this.payPal = data["payPal"] ? PayPalInfoDto.fromJS(data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRequestInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaymentRequestInfoDto {
    paymentMethod: PaymentMethod | undefined;
    paymentInfoType: PaymentInfoType | undefined;
    bankCard: BankCardInfoDto | undefined;
    achCustomer: ACHCustomerInfoDto | undefined;
    payPal: PayPalInfoDto | undefined;
}

export class ModuleSubscriptionInfo implements IModuleSubscriptionInfo {
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
            this.frequency = data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data; 
    }
}

export interface IModuleSubscriptionInfo {
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export class SetupSubscriptionInfoDto implements ISetupSubscriptionInfoDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    billingInfo!: PaymentRequestInfoDto | undefined;

    constructor(data?: ISetupSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionInfo = data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(data["subscriptionInfo"]) : <any>undefined;
            this.billingInfo = data["billingInfo"] ? PaymentRequestInfoDto.fromJS(data["billingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetupSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetupSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["billingInfo"] = this.billingInfo ? this.billingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetupSubscriptionInfoDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    billingInfo: PaymentRequestInfoDto | undefined;
}

export enum RequestPaymentType {
    PayPal = "PayPal", 
    ManualBankTransfer = "ManualBankTransfer", 
}

export class RequestPaymentDto implements IRequestPaymentDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    requestType!: RequestPaymentType | undefined;

    constructor(data?: IRequestPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionInfo = data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(data["subscriptionInfo"]) : <any>undefined;
            this.requestType = data["requestType"];
        }
    }

    static fromJS(data: any): RequestPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["requestType"] = this.requestType;
        return data; 
    }
}

export interface IRequestPaymentDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    requestType: RequestPaymentType | undefined;
}

export class RequestPaymentResult implements IRequestPaymentResult {
    transactionId!: string | undefined;
    code!: string | undefined;

    constructor(data?: IRequestPaymentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): RequestPaymentResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["code"] = this.code;
        return data; 
    }
}

export interface IRequestPaymentResult {
    transactionId: string | undefined;
    code: string | undefined;
}

export class ModuleSubscriptionInfoDto implements IModuleSubscriptionInfoDto {
    module!: ModuleType | undefined;
    statusId!: string | undefined;
    endDate!: moment.Moment | undefined;
    editionName!: string | undefined;
    isTrial!: boolean | undefined;
    isLocked!: boolean | undefined;
    trackingCode!: string | undefined;
    hasRecurringBilling!: boolean | undefined;
    isUpgradable!: boolean | undefined;

    constructor(data?: IModuleSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.module = data["module"];
            this.statusId = data["statusId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.editionName = data["editionName"];
            this.isTrial = data["isTrial"];
            this.isLocked = data["isLocked"];
            this.trackingCode = data["trackingCode"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.isUpgradable = data["isUpgradable"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["statusId"] = this.statusId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["editionName"] = this.editionName;
        data["isTrial"] = this.isTrial;
        data["isLocked"] = this.isLocked;
        data["trackingCode"] = this.trackingCode;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["isUpgradable"] = this.isUpgradable;
        return data; 
    }
}

export interface IModuleSubscriptionInfoDto {
    module: ModuleType | undefined;
    statusId: string | undefined;
    endDate: moment.Moment | undefined;
    editionName: string | undefined;
    isTrial: boolean | undefined;
    isLocked: boolean | undefined;
    trackingCode: string | undefined;
    hasRecurringBilling: boolean | undefined;
    isUpgradable: boolean | undefined;
}

export class CompleteTenantRegistrationInput implements ICompleteTenantRegistrationInput {
    requestXref!: string;
    tenancyName!: string | undefined;
    tenantName!: string | undefined;
    companyName!: string | undefined;
    siteUrl!: string | undefined;
    adminPassword!: string;

    constructor(data?: ICompleteTenantRegistrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestXref = data["requestXref"];
            this.tenancyName = data["tenancyName"];
            this.tenantName = data["tenantName"];
            this.companyName = data["companyName"];
            this.siteUrl = data["siteUrl"];
            this.adminPassword = data["adminPassword"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestXref"] = this.requestXref;
        data["tenancyName"] = this.tenancyName;
        data["tenantName"] = this.tenantName;
        data["companyName"] = this.companyName;
        data["siteUrl"] = this.siteUrl;
        data["adminPassword"] = this.adminPassword;
        return data; 
    }
}

export interface ICompleteTenantRegistrationInput {
    requestXref: string;
    tenancyName: string | undefined;
    tenantName: string | undefined;
    companyName: string | undefined;
    siteUrl: string | undefined;
    adminPassword: string;
}

export class CompleteTenantRegistrationOutput implements ICompleteTenantRegistrationOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isEmailConfirmationRequired!: boolean | undefined;
    loginLink!: string | undefined;

    constructor(data?: ICompleteTenantRegistrationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
            this.loginLink = data["loginLink"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        data["loginLink"] = this.loginLink;
        return data; 
    }
}

export interface ICompleteTenantRegistrationOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isEmailConfirmationRequired: boolean | undefined;
    loginLink: string | undefined;
}

export class BeneficiaryInfoDto implements IBeneficiaryInfoDto {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.streetAddress = data["streetAddress"];
            this.cityAddress = data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data; 
    }
}

export interface IBeneficiaryInfoDto {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BankTransferSettingsDto implements IBankTransferSettingsDto {
    beneficiaryInfo!: BeneficiaryInfoDto | undefined;
    beneficiaryBank!: BeneficiaryInfoDto | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beneficiaryInfo = data["beneficiaryInfo"] ? BeneficiaryInfoDto.fromJS(data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = data["beneficiaryBank"] ? BeneficiaryInfoDto.fromJS(data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankRoutingNumberForACH = data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = data["swiftCodeForUSDollar"];
            this.swiftCode = data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankTransferSettingsDto {
    beneficiaryInfo: BeneficiaryInfoDto | undefined;
    beneficiaryBank: BeneficiaryInfoDto | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class PayPalSettingsDto implements IPayPalSettingsDto {
    clientId!: string | undefined;

    constructor(data?: IPayPalSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): PayPalSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        return data; 
    }
}

export interface IPayPalSettingsDto {
    clientId: string | undefined;
}

export enum SettingScopes {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export class NameValueDtoListResultDto implements INameValueDtoListResultDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: INameValueDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INameValueDtoListResultDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    autoDetectTenancy!: boolean | undefined;
    features!: string[] | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    autoDetectTenancy: boolean | undefined;
    features: string[] | undefined;
}

export class AuthenticateByCodeModel implements IAuthenticateByCodeModel {
    emailAddress!: string;
    code!: string;

    constructor(data?: IAuthenticateByCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): AuthenticateByCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["code"] = this.code;
        return data; 
    }
}

export interface IAuthenticateByCodeModel {
    emailAddress: string;
    code: string;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    userId!: number | undefined;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    shouldVerifyEmail!: boolean | undefined;
    userEmail!: string | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.shouldVerifyEmail = data["shouldVerifyEmail"];
            this.userEmail = data["userEmail"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["shouldVerifyEmail"] = this.shouldVerifyEmail;
        data["userEmail"] = this.userEmail;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    userId: number | undefined;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    shouldVerifyEmail: boolean | undefined;
    userEmail: string | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {};
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;
    autoRegistration!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.autoRegistration = data["autoRegistration"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["autoRegistration"] = this.autoRegistration;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
    autoRegistration: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    waitingForActivation!: boolean | undefined;
    userNotFound!: boolean | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waitingForActivation = data["waitingForActivation"];
            this.userNotFound = data["userNotFound"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waitingForActivation"] = this.waitingForActivation;
        data["userNotFound"] = this.userNotFound;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    waitingForActivation: boolean | undefined;
    userNotFound: boolean | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
}

export class StringFilterElementDto implements IStringFilterElementDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IStringFilterElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StringFilterElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringFilterElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStringFilterElementDto {
    id: string | undefined;
    name: string | undefined;
}

export class Int32FilterElementDto implements IInt32FilterElementDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IInt32FilterElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Int32FilterElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32FilterElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt32FilterElementDto {
    id: number | undefined;
    name: string | undefined;
}

export class FiltersInitialData implements IFiltersInitialData {
    banks!: BankDto[] | undefined;
    cashflowTypes!: StringFilterElementDto[] | undefined;
    currencies!: StringFilterElementDto[] | undefined;
    businessEntities!: Int32FilterElementDto[] | undefined;

    constructor(data?: IFiltersInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["cashflowTypes"] && data["cashflowTypes"].constructor === Array) {
                this.cashflowTypes = [];
                for (let item of data["cashflowTypes"])
                    this.cashflowTypes.push(StringFilterElementDto.fromJS(item));
            }
            if (data["currencies"] && data["currencies"].constructor === Array) {
                this.currencies = [];
                for (let item of data["currencies"])
                    this.currencies.push(StringFilterElementDto.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(Int32FilterElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FiltersInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new FiltersInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.cashflowTypes && this.cashflowTypes.constructor === Array) {
            data["cashflowTypes"] = [];
            for (let item of this.cashflowTypes)
                data["cashflowTypes"].push(item.toJSON());
        }
        if (this.currencies && this.currencies.constructor === Array) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFiltersInitialData {
    banks: BankDto[] | undefined;
    cashflowTypes: StringFilterElementDto[] | undefined;
    currencies: StringFilterElementDto[] | undefined;
    businessEntities: Int32FilterElementDto[] | undefined;
}

export class CounterpartyDto implements ICounterpartyDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICounterpartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICounterpartyDto {
    id: string | undefined;
    name: string | undefined;
}

export class TransactionAttributeTypeDto implements ITransactionAttributeTypeDto {
    name!: string | undefined;

    constructor(data?: ITransactionAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TransactionAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ITransactionAttributeTypeDto {
    name: string | undefined;
}

export class GetTransactionAttributeTypesOutput implements IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes!: { [key: string] : TransactionAttributeTypeDto; } | undefined;

    constructor(data?: IGetTransactionAttributeTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionAttributeTypes"]) {
                this.transactionAttributeTypes = {};
                for (let key in data["transactionAttributeTypes"]) {
                    if (data["transactionAttributeTypes"].hasOwnProperty(key))
                        this.transactionAttributeTypes[key] = data["transactionAttributeTypes"][key] ? TransactionAttributeTypeDto.fromJS(data["transactionAttributeTypes"][key]) : new TransactionAttributeTypeDto();
                }
            }
        }
    }

    static fromJS(data: any): GetTransactionAttributeTypesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionAttributeTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionAttributeTypes) {
            data["transactionAttributeTypes"] = {};
            for (let key in this.transactionAttributeTypes) {
                if (this.transactionAttributeTypes.hasOwnProperty(key))
                    data["transactionAttributeTypes"][key] = this.transactionAttributeTypes[key];
            }
        }
        return data; 
    }
}

export interface IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes: { [key: string] : TransactionAttributeTypeDto; } | undefined;
}

export enum TransactionStatus {
    Pending = "Pending", 
    Settled = "Settled", 
}

export class TransactionCommentDto implements ITransactionCommentDto {
    commentId!: number | undefined;
    text!: string | undefined;

    constructor(data?: ITransactionCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commentId = data["commentId"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TransactionCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITransactionCommentDto {
    commentId: number | undefined;
    text: string | undefined;
}

export class TransactionDetailsDto implements ITransactionDetailsDto {
    id!: number | undefined;
    bankAccountBankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankAccountName!: string | undefined;
    date!: moment.Moment | undefined;
    currency!: string | undefined;
    amount!: number | undefined;
    description!: string | undefined;
    cashFlowTypeId!: string | undefined;
    transactionStatus!: TransactionStatus | undefined;
    cashflowCategoryId!: number | undefined;
    cashflowCategory!: string | undefined;
    cashflowSubCategoryId!: number | undefined;
    cashflowSubCategory!: string | undefined;
    accountingTypeId!: number | undefined;
    accountingType!: string | undefined;
    transactionDescriptor!: string | undefined;
    isDescriptorCalculated!: boolean | undefined;
    counterpartyName!: string | undefined;
    comments!: TransactionCommentDto[] | undefined;
    attributes!: TransactionAttributeDto[] | undefined;

    constructor(data?: ITransactionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountBankName = data["bankAccountBankName"];
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankAccountName = data["bankAccountName"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.transactionStatus = data["transactionStatus"];
            this.cashflowCategoryId = data["cashflowCategoryId"];
            this.cashflowCategory = data["cashflowCategory"];
            this.cashflowSubCategoryId = data["cashflowSubCategoryId"];
            this.cashflowSubCategory = data["cashflowSubCategory"];
            this.accountingTypeId = data["accountingTypeId"];
            this.accountingType = data["accountingType"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.isDescriptorCalculated = data["isDescriptorCalculated"];
            this.counterpartyName = data["counterpartyName"];
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [];
                for (let item of data["comments"])
                    this.comments.push(TransactionCommentDto.fromJS(item));
            }
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountBankName"] = this.bankAccountBankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankAccountName"] = this.bankAccountName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["transactionStatus"] = this.transactionStatus;
        data["cashflowCategoryId"] = this.cashflowCategoryId;
        data["cashflowCategory"] = this.cashflowCategory;
        data["cashflowSubCategoryId"] = this.cashflowSubCategoryId;
        data["cashflowSubCategory"] = this.cashflowSubCategory;
        data["accountingTypeId"] = this.accountingTypeId;
        data["accountingType"] = this.accountingType;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["counterpartyName"] = this.counterpartyName;
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionDetailsDto {
    id: number | undefined;
    bankAccountBankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankAccountName: string | undefined;
    date: moment.Moment | undefined;
    currency: string | undefined;
    amount: number | undefined;
    description: string | undefined;
    cashFlowTypeId: string | undefined;
    transactionStatus: TransactionStatus | undefined;
    cashflowCategoryId: number | undefined;
    cashflowCategory: string | undefined;
    cashflowSubCategoryId: number | undefined;
    cashflowSubCategory: string | undefined;
    accountingTypeId: number | undefined;
    accountingType: string | undefined;
    transactionDescriptor: string | undefined;
    isDescriptorCalculated: boolean | undefined;
    counterpartyName: string | undefined;
    comments: TransactionCommentDto[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
}

export class GetTransactionDetailsOutput implements IGetTransactionDetailsOutput {
    transactionDetails!: TransactionDetailsDto | undefined;

    constructor(data?: IGetTransactionDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionDetails = data["transactionDetails"] ? TransactionDetailsDto.fromJS(data["transactionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionDetails"] = this.transactionDetails ? this.transactionDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTransactionDetailsOutput {
    transactionDetails: TransactionDetailsDto | undefined;
}

export class TransactionTypeDto implements ITransactionTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    categories!: string[] | undefined;

    constructor(data?: ITransactionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(item);
            }
        }
    }

    static fromJS(data: any): TransactionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data; 
    }
}

export interface ITransactionTypeDto {
    id: string | undefined;
    name: string | undefined;
    categories: string[] | undefined;
}

export class TransactionTypesAndCategoriesDto implements ITransactionTypesAndCategoriesDto {
    types!: TransactionTypeDto[] | undefined;
    categories!: StringFilterElementDto[] | undefined;

    constructor(data?: ITransactionTypesAndCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(TransactionTypeDto.fromJS(item));
            }
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(StringFilterElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionTypesAndCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypesAndCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionTypesAndCategoriesDto {
    types: TransactionTypeDto[] | undefined;
    categories: StringFilterElementDto[] | undefined;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType!: string | undefined;
    contentSkin!: string | undefined;
    theme!: string | undefined;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["theme"] = this.theme;
        return data; 
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader!: boolean | undefined;
    desktopMinimizeMode!: string | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    displaySubmenuArrowDesktop!: boolean | undefined;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        return data; 
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    allowAsideHiding!: boolean | undefined;
    defaultHiddenAside!: boolean | undefined;
    submenuToggle!: string | undefined;
    dropdownSubmenuSkin!: string | undefined;
    dropdownSubmenuArrow!: boolean | undefined;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout!: UiCustomizationLayoutSettingsEditDto | undefined;
    header!: UiCustomizationHeaderSettingsEditDto | undefined;
    menu!: UiCustomizationMenuSettingsEditDto | undefined;
    footer!: UiCustomizationFooterSettingsEditDto | undefined;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    userKey!: string | undefined;
    phoneNumber!: string | undefined;
    profileThumbnailId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    lastLoginTime!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.userKey = data["userKey"];
            this.phoneNumber = data["phoneNumber"];
            this.profileThumbnailId = data["profileThumbnailId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["userKey"] = this.userKey;
        data["phoneNumber"] = this.phoneNumber;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    userKey: string | undefined;
    phoneNumber: string | undefined;
    profileThumbnailId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListDtoListResultDto implements IUserListDtoListResultDto {
    items!: UserListDto[] | undefined;

    constructor(data?: IUserListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserListDtoListResultDto {
    items: UserListDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    group!: UserGroup | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.group = data["group"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["group"] = this.group;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    group: UserGroup | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id!: number | undefined;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IInt64EntityDto {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class UpdateUserPictureInput implements IUpdateUserPictureInput {
    userId!: number | undefined;
    image!: string | undefined;
    imageThumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IUpdateUserPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.image = data["image"];
            this.imageThumbnail = data["imageThumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): UpdateUserPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IUpdateUserPictureInput {
    userId: number | undefined;
    image: string | undefined;
    imageThumbnail: string | undefined;
    source: string | undefined;
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    profilePicture!: string | undefined;
    profileThumbnail!: string | undefined;
    pictureSource!: string | undefined;
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.profilePicture = data["profilePicture"];
            this.profileThumbnail = data["profileThumbnail"];
            this.pictureSource = data["pictureSource"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["profilePicture"] = this.profilePicture;
        data["profileThumbnail"] = this.profileThumbnail;
        data["pictureSource"] = this.pictureSource;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    profilePicture: string | undefined;
    profileThumbnail: string | undefined;
    pictureSource: string | undefined;
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class InviteUserInput implements IInviteUserInput {
    group!: UserGroup | undefined;
    name!: string;
    surname!: string;
    emailAddress!: string;
    assignedRoleNames!: string[];
    moduleType!: ModuleType | undefined;

    constructor(data?: IInviteUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.group = data["group"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.moduleType = data["moduleType"];
        }
    }

    static fromJS(data: any): InviteUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new InviteUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["moduleType"] = this.moduleType;
        return data; 
    }
}

export interface IInviteUserInput {
    group: UserGroup | undefined;
    name: string;
    surname: string;
    emailAddress: string;
    assignedRoleNames: string[];
    moduleType: ModuleType | undefined;
}

export class UpdateUserEmailDto implements IUpdateUserEmailDto {
    id!: number;
    emailAddress!: string;

    constructor(data?: IUpdateUserEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UpdateUserEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUpdateUserEmailDto {
    id: number;
    emailAddress: string;
}

export class UpdateUserPhoneDto implements IUpdateUserPhoneDto {
    id!: number;
    phoneNumber!: string;

    constructor(data?: IUpdateUserPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateUserPhoneDto {
    id: number;
    phoneNumber: string;
}

export class ResetUserPasswordDto implements IResetUserPasswordDto {
    id!: number;
    password!: string | undefined;
    setRandomPassword!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;

    constructor(data?: IResetUserPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.password = data["password"];
            this.setRandomPassword = data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
        }
    }

    static fromJS(data: any): ResetUserPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        return data; 
    }
}

export interface IResetUserPasswordDto {
    id: number;
    password: string | undefined;
    setRandomPassword: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
}

export class UpdateUserOptionsDto implements IUpdateUserOptionsDto {
    id!: number;
    isActive!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;
    notifyUser!: boolean | undefined;

    constructor(data?: IUpdateUserOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.notifyUser = data["notifyUser"];
        }
    }

    static fromJS(data: any): UpdateUserOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["notifyUser"] = this.notifyUser;
        return data; 
    }
}

export interface IUpdateUserOptionsDto {
    id: number;
    isActive: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    notifyUser: boolean | undefined;
}

export class GrantPermissionInput implements IGrantPermissionInput {
    id!: number | undefined;
    permissionName!: string;

    constructor(data?: IGrantPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.permissionName = data["permissionName"];
        }
    }

    static fromJS(data: any): GrantPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data; 
    }
}

export interface IGrantPermissionInput {
    id: number | undefined;
    permissionName: string;
}

export class ProhibitPermissionInput implements IProhibitPermissionInput {
    id!: number | undefined;
    permissionName!: string;

    constructor(data?: IProhibitPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.permissionName = data["permissionName"];
        }
    }

    static fromJS(data: any): ProhibitPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProhibitPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data; 
    }
}

export interface IProhibitPermissionInput {
    id: number | undefined;
    permissionName: string;
}

export class UpdateUserRoleInput implements IUpdateUserRoleInput {
    id!: number | undefined;
    roleName!: string;

    constructor(data?: IUpdateUserRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UpdateUserRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUpdateUserRoleInput {
    id: number | undefined;
    roleName: string;
}

export enum CommissionLedgerEntryStatus {
    Pending = "Pending", 
    Approved = "Approved", 
    Completed = "Completed", 
    Cancelled = "Cancelled", 
}

export enum CommissionLedgerEntryType {
    Earning = "Earning", 
    Withdrawal = "Withdrawal", 
}

export class CommissionLedgerEntryInfo implements ICommissionLedgerEntryInfo {
    id!: number | undefined;
    date!: moment.Moment | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    status!: CommissionLedgerEntryStatus | undefined;
    type!: CommissionLedgerEntryType | undefined;
    totalAmount!: number | undefined;
    paymentSystem!: PaymentSystem | undefined;

    constructor(data?: ICommissionLedgerEntryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.type = data["type"];
            this.totalAmount = data["totalAmount"];
            this.paymentSystem = data["paymentSystem"];
        }
    }

    static fromJS(data: any): CommissionLedgerEntryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionLedgerEntryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["totalAmount"] = this.totalAmount;
        data["paymentSystem"] = this.paymentSystem;
        return data; 
    }
}

export interface ICommissionLedgerEntryInfo {
    id: number | undefined;
    date: moment.Moment | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    status: CommissionLedgerEntryStatus | undefined;
    type: CommissionLedgerEntryType | undefined;
    totalAmount: number | undefined;
    paymentSystem: PaymentSystem | undefined;
}

export class GetLedgerOutput implements IGetLedgerOutput {
    startingEarningsBalance!: number | undefined;
    startingWithdrawalsBalance!: number | undefined;
    availableBalance!: number | undefined;
    entries!: CommissionLedgerEntryInfo[] | undefined;

    constructor(data?: IGetLedgerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startingEarningsBalance = data["startingEarningsBalance"];
            this.startingWithdrawalsBalance = data["startingWithdrawalsBalance"];
            this.availableBalance = data["availableBalance"];
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(CommissionLedgerEntryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLedgerOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLedgerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startingEarningsBalance"] = this.startingEarningsBalance;
        data["startingWithdrawalsBalance"] = this.startingWithdrawalsBalance;
        data["availableBalance"] = this.availableBalance;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLedgerOutput {
    startingEarningsBalance: number | undefined;
    startingWithdrawalsBalance: number | undefined;
    availableBalance: number | undefined;
    entries: CommissionLedgerEntryInfo[] | undefined;
}

export class GetLedgerTotalsOutput implements IGetLedgerTotalsOutput {
    earnedAmount!: number | undefined;
    withdrawnAmount!: number | undefined;
    pendingEarningsAmount!: number | undefined;
    pendingWithdrawalsAmount!: number | undefined;
    availableBalance!: number | undefined;

    constructor(data?: IGetLedgerTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.earnedAmount = data["earnedAmount"];
            this.withdrawnAmount = data["withdrawnAmount"];
            this.pendingEarningsAmount = data["pendingEarningsAmount"];
            this.pendingWithdrawalsAmount = data["pendingWithdrawalsAmount"];
            this.availableBalance = data["availableBalance"];
        }
    }

    static fromJS(data: any): GetLedgerTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLedgerTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["earnedAmount"] = this.earnedAmount;
        data["withdrawnAmount"] = this.withdrawnAmount;
        data["pendingEarningsAmount"] = this.pendingEarningsAmount;
        data["pendingWithdrawalsAmount"] = this.pendingWithdrawalsAmount;
        data["availableBalance"] = this.availableBalance;
        return data; 
    }
}

export interface IGetLedgerTotalsOutput {
    earnedAmount: number | undefined;
    withdrawnAmount: number | undefined;
    pendingEarningsAmount: number | undefined;
    pendingWithdrawalsAmount: number | undefined;
    availableBalance: number | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    lastLoginTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    id: number | undefined;
}

export class LinkedUserDtoPagedResultDto implements ILinkedUserDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: ILinkedUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILinkedUserDtoPagedResultDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDtoListResultDto implements ILinkedUserDtoListResultDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: ILinkedUserDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedUserDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILinkedUserDtoListResultDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class UserLoginAttemptDtoListResultDto implements IUserLoginAttemptDtoListResultDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IUserLoginAttemptDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLoginAttemptDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserLoginAttemptDtoListResultDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AddWorkflowRuleDto implements IAddWorkflowRuleDto {
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean | undefined;

    constructor(data?: IAddWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): AddWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IAddWorkflowRuleDto {
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean | undefined;
}

export class EditWorkflowRuleDto implements IEditWorkflowRuleDto {
    id!: number;
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean | undefined;

    constructor(data?: IEditWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): EditWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IEditWorkflowRuleDto {
    id: number;
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean | undefined;
}

export class WorkflowRuleDto implements IWorkflowRuleDto {
    id!: number | undefined;
    triggerIdentifier!: string | undefined;
    actionIdentifier!: string | undefined;
    configurationType!: string | undefined;
    configurationOptions!: string | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationType = data["configurationType"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): WorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationType"] = this.configurationType;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IWorkflowRuleDto {
    id: number | undefined;
    triggerIdentifier: string | undefined;
    actionIdentifier: string | undefined;
    configurationType: string | undefined;
    configurationOptions: string | undefined;
    isActive: boolean | undefined;
}

export class WorkflowActionDto implements IWorkflowActionDto {
    name!: string | undefined;
    configurationType!: string | undefined;

    constructor(data?: IWorkflowActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.configurationType = data["configurationType"];
        }
    }

    static fromJS(data: any): WorkflowActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["configurationType"] = this.configurationType;
        return data; 
    }
}

export interface IWorkflowActionDto {
    name: string | undefined;
    configurationType: string | undefined;
}

export class WorkflowTriggerDto implements IWorkflowTriggerDto {
    name!: string | undefined;
    supportedActions!: WorkflowActionDto[] | undefined;

    constructor(data?: IWorkflowTriggerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["supportedActions"] && data["supportedActions"].constructor === Array) {
                this.supportedActions = [];
                for (let item of data["supportedActions"])
                    this.supportedActions.push(WorkflowActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTriggerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTriggerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.supportedActions && this.supportedActions.constructor === Array) {
            data["supportedActions"] = [];
            for (let item of this.supportedActions)
                data["supportedActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowTriggerDto {
    name: string | undefined;
    supportedActions: WorkflowActionDto[] | undefined;
}

export class ChangeStageConfiguration implements IChangeStageConfiguration {
    fromStageIds!: number[];
    toStageId!: number;

    constructor(data?: IChangeStageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fromStageIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fromStageIds"] && data["fromStageIds"].constructor === Array) {
                this.fromStageIds = [];
                for (let item of data["fromStageIds"])
                    this.fromStageIds.push(item);
            }
            this.toStageId = data["toStageId"];
        }
    }

    static fromJS(data: any): ChangeStageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fromStageIds && this.fromStageIds.constructor === Array) {
            data["fromStageIds"] = [];
            for (let item of this.fromStageIds)
                data["fromStageIds"].push(item);
        }
        data["toStageId"] = this.toStageId;
        return data; 
    }
}

export interface IChangeStageConfiguration {
    fromStageIds: number[];
    toStageId: number;
}

export class ProcessLeadConfiguration implements IProcessLeadConfiguration {

    constructor(data?: IProcessLeadConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ProcessLeadConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IProcessLeadConfiguration {
}

export class SendEmailToContactConfiguration implements ISendEmailToContactConfiguration {
    emailTemplateId!: number;
    contactGroupId!: string | undefined;

    constructor(data?: ISendEmailToContactConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailTemplateId = data["emailTemplateId"];
            this.contactGroupId = data["contactGroupId"];
        }
    }

    static fromJS(data: any): SendEmailToContactConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailToContactConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateId"] = this.emailTemplateId;
        data["contactGroupId"] = this.contactGroupId;
        return data; 
    }
}

export interface ISendEmailToContactConfiguration {
    emailTemplateId: number;
    contactGroupId: string | undefined;
}

export class SendEmailToOrgUnitConfiguration implements ISendEmailToOrgUnitConfiguration {
    emailTemplateId!: number;

    constructor(data?: ISendEmailToOrgUnitConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailTemplateId = data["emailTemplateId"];
        }
    }

    static fromJS(data: any): SendEmailToOrgUnitConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailToOrgUnitConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplateId"] = this.emailTemplateId;
        return data; 
    }
}

export interface ISendEmailToOrgUnitConfiguration {
    emailTemplateId: number;
}

export class Body implements IBody {
    file!: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file = data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data; 
    }
}

export interface IBody {
    file: string;
}

export class Flags implements IFlags {
    choice!: boolean | undefined;
    best!: boolean | undefined;
    travelAndAirlineMiles!: boolean | undefined;
    dinigRewards!: boolean | undefined;
    gasRewards!: boolean | undefined;
    cashBackRewards!: boolean | undefined;
    instantDecision!: boolean | undefined;
    instantResponse!: boolean | undefined;
    noCreditCheck!: boolean | undefined;
    guaranteedApproval!: boolean | undefined;
    rebuildCredit!: boolean | undefined;
    chipCard!: boolean | undefined;
    applePay!: boolean | undefined;
    groceryRewards!: boolean | undefined;
    entertainmentRewards!: boolean | undefined;
    hotelRewards!: boolean | undefined;
    hasNoRewards!: boolean | undefined;
    zeroPercentageOnPurchases!: boolean | undefined;
    zeroPercentageInterestTransfers!: boolean | undefined;
    special!: boolean | undefined;
    newest!: boolean | undefined;

    constructor(data?: IFlags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.choice = data["Choice"];
            this.best = data["Best"];
            this.travelAndAirlineMiles = data["TravelAndAirlineMiles"];
            this.dinigRewards = data["DinigRewards"];
            this.gasRewards = data["GasRewards"];
            this.cashBackRewards = data["CashBackRewards"];
            this.instantDecision = data["InstantDecision"];
            this.instantResponse = data["InstantResponse"];
            this.noCreditCheck = data["NoCreditCheck"];
            this.guaranteedApproval = data["GuaranteedApproval"];
            this.rebuildCredit = data["RebuildCredit"];
            this.chipCard = data["ChipCard"];
            this.applePay = data["ApplePay"];
            this.groceryRewards = data["GroceryRewards"];
            this.entertainmentRewards = data["EntertainmentRewards"];
            this.hotelRewards = data["HotelRewards"];
            this.hasNoRewards = data["HasNoRewards"];
            this.zeroPercentageOnPurchases = data["ZeroPercentageOnPurchases"];
            this.zeroPercentageInterestTransfers = data["ZeroPercentageInterestTransfers"];
            this.special = data["Special"];
            this.newest = data["Newest"];
        }
    }

    static fromJS(data: any): Flags {
        data = typeof data === 'object' ? data : {};
        let result = new Flags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Choice"] = this.choice;
        data["Best"] = this.best;
        data["TravelAndAirlineMiles"] = this.travelAndAirlineMiles;
        data["DinigRewards"] = this.dinigRewards;
        data["GasRewards"] = this.gasRewards;
        data["CashBackRewards"] = this.cashBackRewards;
        data["InstantDecision"] = this.instantDecision;
        data["InstantResponse"] = this.instantResponse;
        data["NoCreditCheck"] = this.noCreditCheck;
        data["GuaranteedApproval"] = this.guaranteedApproval;
        data["RebuildCredit"] = this.rebuildCredit;
        data["ChipCard"] = this.chipCard;
        data["ApplePay"] = this.applePay;
        data["GroceryRewards"] = this.groceryRewards;
        data["EntertainmentRewards"] = this.entertainmentRewards;
        data["HotelRewards"] = this.hotelRewards;
        data["HasNoRewards"] = this.hasNoRewards;
        data["ZeroPercentageOnPurchases"] = this.zeroPercentageOnPurchases;
        data["ZeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["Special"] = this.special;
        data["Newest"] = this.newest;
        return data; 
    }
}

export interface IFlags {
    choice: boolean | undefined;
    best: boolean | undefined;
    travelAndAirlineMiles: boolean | undefined;
    dinigRewards: boolean | undefined;
    gasRewards: boolean | undefined;
    cashBackRewards: boolean | undefined;
    instantDecision: boolean | undefined;
    instantResponse: boolean | undefined;
    noCreditCheck: boolean | undefined;
    guaranteedApproval: boolean | undefined;
    rebuildCredit: boolean | undefined;
    chipCard: boolean | undefined;
    applePay: boolean | undefined;
    groceryRewards: boolean | undefined;
    entertainmentRewards: boolean | undefined;
    hotelRewards: boolean | undefined;
    hasNoRewards: boolean | undefined;
    zeroPercentageOnPurchases: boolean | undefined;
    zeroPercentageInterestTransfers: boolean | undefined;
    special: boolean | undefined;
    newest: boolean | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}