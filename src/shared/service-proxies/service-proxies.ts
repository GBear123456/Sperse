/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.7.0 (NJsonSchema v9.10.6.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIsTenantAvailable(response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>Observable.throw(response_);
        });
    }

    protected processIsTenantAvailable(response: Response): Observable<IsTenantAvailableOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegister(response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: Response): Observable<RegisterOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegisterOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput): Observable<SendPasswordResetCodeOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendPasswordResetCode(response_);
                } catch (e) {
                    return <Observable<SendPasswordResetCodeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SendPasswordResetCodeOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendPasswordResetCode(response: Response): Observable<SendPasswordResetCodeOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendPasswordResetCodeOutput.fromJS(resultData200) : new SendPasswordResetCodeOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SendPasswordResetCodeOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetPassword(response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: Response): Observable<ResetPasswordOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResetPasswordOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendEmailActivationLink(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendEmailActivationLink(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processActivateEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processActivateEmail(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processActivateEmail(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processImpersonate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImpersonate(response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>Observable.throw(response_);
        });
    }

    protected processImpersonate(response: Response): Observable<ImpersonateOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBackToImpersonator(response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>Observable.throw(response_);
        });
    }

    protected processBackToImpersonator(response: Response): Observable<ImpersonateOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ImpersonateOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSwitchToLinkedAccount(response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>Observable.throw(response_);
        });
    }

    protected processSwitchToLinkedAccount(response: Response): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SwitchToLinkedAccountOutput>(<any>null);
    }

    /**
     * @return Success
     */
    cancelUserAccount(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/CancelUserAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCancelUserAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelUserAccount(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelUserAccount(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment, endDate: moment.Moment, userName: string, serviceName: string, methodName: string, browserInfo: string, hasException: boolean, minExecutionDuration: number, maxExecutionDuration: number, sorting: string, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogs?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAuditLogs(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAuditLogs(response: Response): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment, endDate: moment.Moment, userName: string, serviceName: string, methodName: string, browserInfo: string, hasException: boolean, minExecutionDuration: number, maxExecutionDuration: number, sorting: string, maxResultCount: number, skipCount: number): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogsToExcel?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAuditLogsToExcel(response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAuditLogsToExcel(response: Response): Observable<FileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FileDto>(<any>null);
    }
}

@Injectable()
export class BankAccountsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    recalculateAllBankAccountDailyStats(instanceType: InstanceType, instanceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/RecalculateAllBankAccountDailyStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRecalculateAllBankAccountDailyStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecalculateAllBankAccountDailyStats(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRecalculateAllBankAccountDailyStats(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @forecastModelId (optional) 
     * @accounts (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @maxCount (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType2, instanceId: number, currency: string, forecastModelId: number, accounts: number[], startDate: moment.Moment, endDate: moment.Moment, maxCount: number, groupBy: GroupBy): Observable<BankAccountDailyStatDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&"; 
        if (forecastModelId !== undefined)
            url_ += "ForecastModelId=" + encodeURIComponent("" + forecastModelId) + "&"; 
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "Accounts=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (maxCount !== undefined)
            url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&"; 
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined and cannot be null.");
        else
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetStats(response_);
                } catch (e) {
                    return <Observable<BankAccountDailyStatDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankAccountDailyStatDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetStats(response: Response): Observable<BankAccountDailyStatDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankAccountDailyStatDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankAccountDailyStatDto[]>(<any>null);
    }
}

@Injectable()
export class BaseCommercePushNotificationHandlerServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @merchant_username (optional) 
     * @push_notification (optional) 
     * @return Success
     */
    handle(merchant_username: string, push_notification: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/BaseCommercePushNotificationHandler/Handle?";
        if (merchant_username !== undefined)
            url_ += "merchant_username=" + encodeURIComponent("" + merchant_username) + "&"; 
        if (push_notification !== undefined)
            url_ += "push_notification=" + encodeURIComponent("" + push_notification) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processHandle(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHandle(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processHandle(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllCaches(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllCaches(response: Response): Observable<ListResultDtoOfCacheDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processClearCache(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processClearCache(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearCache(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processClearAllCaches(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearAllCaches(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CashflowServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @filter (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType3, instanceId: number, filter: StatsFilter): Observable<CashFlowStatsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetStats(response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashFlowStatsDto>><any>Observable.throw(response_);
        });
    }

    protected processGetStats(response: Response): Observable<CashFlowStatsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowStatsDto.fromJS(resultData200) : new CashFlowStatsDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CashFlowStatsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowInitialData(instanceType: InstanceType4, instanceId: number): Observable<CashFlowInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCashFlowInitialData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCashFlowInitialData(response_);
                } catch (e) {
                    return <Observable<CashFlowInitialData>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashFlowInitialData>><any>Observable.throw(response_);
        });
    }

    protected processGetCashFlowInitialData(response: Response): Observable<CashFlowInitialData> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowInitialData.fromJS(resultData200) : new CashFlowInitialData();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CashFlowInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @filter (optional) 
     * @return Success
     */
    getStatsDetails(instanceType: InstanceType5, instanceId: number, filter: StatsDetailFilter): Observable<CashFlowStatsDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStatsDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetStatsDetails(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetStatsDetails(response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDetailDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashFlowStatsDetailDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetStatsDetails(response: Response): Observable<CashFlowStatsDetailDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashFlowStatsDetailDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CashFlowStatsDetailDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowGridSettings(instanceType: InstanceType6, instanceId: number): Observable<CashFlowGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCashFlowGridSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCashFlowGridSettings(response_);
                } catch (e) {
                    return <Observable<CashFlowGridSettingsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CashFlowGridSettingsDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCashFlowGridSettings(response: Response): Observable<CashFlowGridSettingsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowGridSettingsDto.fromJS(resultData200) : new CashFlowGridSettingsDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CashFlowGridSettingsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @settings (optional) 
     * @return Success
     */
    saveCashFlowGridSettings(instanceType: InstanceType7, instanceId: number, settings: CashFlowGridSettingsDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/SaveCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSaveCashFlowGridSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSaveCashFlowGridSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSaveCashFlowGridSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CashFlowForecastServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getModels(instanceType: InstanceType8, instanceId: number): Observable<ForecastModelDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetModels?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetModels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetModels(response_);
                } catch (e) {
                    return <Observable<ForecastModelDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ForecastModelDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetModels(response: Response): Observable<ForecastModelDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastModelDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ForecastModelDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    addForecast(instanceType: InstanceType9, instanceId: number, input: AddForecastInput): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/AddForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddForecast(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddForecast(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processAddForecast(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateForecast(instanceType: InstanceType10, instanceId: number, input: UpdateForecastInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateForecast(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateForecast(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateForecast(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecast(instanceType: InstanceType11, instanceId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteForecast(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteForecast(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteForecast(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createForecastSchedule(instanceType: InstanceType12, instanceId: number, input: CreateForecastScheduleDto): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateForecastSchedule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateForecastSchedule(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateForecastSchedule(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateForecastSchedule(instanceType: InstanceType13, instanceId: number, input: UpdateForecastScheduleInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateForecastSchedule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateForecastSchedule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateForecastSchedule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastSchedule(instanceType: InstanceType14, instanceId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteForecastSchedule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteForecastSchedule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteForecastSchedule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getForecastSchedule(instanceType: InstanceType15, instanceId: number, id: number): Observable<ForecastScheduleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetForecastSchedule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetForecastSchedule(response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ForecastScheduleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetForecastSchedule(response: Response): Observable<ForecastScheduleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ForecastScheduleDto.fromJS(resultData200) : new ForecastScheduleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ForecastScheduleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getForecastSchedules(instanceType: InstanceType16, instanceId: number): Observable<ForecastScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetForecastSchedules(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetForecastSchedules(response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ForecastScheduleDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetForecastSchedules(response: Response): Observable<ForecastScheduleDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastScheduleDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ForecastScheduleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createForecastModel(instanceType: InstanceType17, instanceId: number, input: CreateForecastModelInput): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateForecastModel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateForecastModel(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateForecastModel(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    renameForecastModel(instanceType: InstanceType18, instanceId: number, input: RenameForecastModelInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/RenameForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRenameForecastModel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRenameForecastModel(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRenameForecastModel(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastModel(instanceType: InstanceType19, instanceId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteForecastModel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteForecastModel(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteForecastModel(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserChatFriendsWithSettings(response: Response): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number, userId: number, minMessageId: number): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserChatMessages(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUserChatMessages(response: Response): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ClassificationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCategoryTree(instanceType: InstanceType20, instanceId: number): Observable<GetCategoryTreeOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetCategoryTree?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCategoryTree(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCategoryTree(response_);
                } catch (e) {
                    return <Observable<GetCategoryTreeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCategoryTreeOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCategoryTree(response: Response): Observable<GetCategoryTreeOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCategoryTreeOutput.fromJS(resultData200) : new GetCategoryTreeOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetCategoryTreeOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    getRules(instanceType: InstanceType21, instanceId: number, input: any): Observable<RuleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRules(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRules(response_);
                } catch (e) {
                    return <Observable<RuleDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<RuleDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetRules(response: Response): Observable<RuleDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RuleDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RuleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createRule(instanceType: InstanceType22, instanceId: number, input: CreateRuleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/CreateRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateRule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateRule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateRule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getRuleForEdit(instanceType: InstanceType23, instanceId: number, id: number): Observable<EditRuleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRuleForEdit?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRuleForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRuleForEdit(response_);
                } catch (e) {
                    return <Observable<EditRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EditRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRuleForEdit(response: Response): Observable<EditRuleDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditRuleDto.fromJS(resultData200) : new EditRuleDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EditRuleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    editRule(instanceType: InstanceType24, instanceId: number, input: EditRuleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/EditRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processEditRule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEditRule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processEditRule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    moveRule(instanceType: InstanceType25, instanceId: number, input: MoveRuleDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/MoveRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processMoveRule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMoveRule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMoveRule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @sourceTransactionList (optional) 
     * @return Success
     */
    deleteRule(instanceType: InstanceType26, instanceId: number, sourceTransactionList: number[], applyOption: ApplyOption, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (sourceTransactionList !== undefined)
            sourceTransactionList && sourceTransactionList.forEach(item => { url_ += "SourceTransactionList=" + encodeURIComponent("" + item) + "&"; });
        if (applyOption === undefined || applyOption === null)
            throw new Error("The parameter 'applyOption' must be defined and cannot be null.");
        else
            url_ += "ApplyOption=" + encodeURIComponent("" + applyOption) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteRule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteRule(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteRule(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    addMapping(instanceType: InstanceType27, instanceId: number, input: AddMappingDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AddMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddMapping(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddMapping(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddMapping(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteMapping(instanceType: InstanceType28, instanceId: number, name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteMapping(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMapping(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createCategory(instanceType: InstanceType29, instanceId: number, input: CreateCategoryInput): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/CreateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateCategory(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateCategory(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateCategory(instanceType: InstanceType30, instanceId: number, input: UpdateCategoryInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateCategory(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCategory(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @moveToCategoryId (optional) 
     * @return Success
     */
    deleteCategory(instanceType: InstanceType31, instanceId: number, moveToCategoryId: number, deleteAllReferences: boolean, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (moveToCategoryId !== undefined)
            url_ += "MoveToCategoryId=" + encodeURIComponent("" + moveToCategoryId) + "&"; 
        if (deleteAllReferences === undefined || deleteAllReferences === null)
            throw new Error("The parameter 'deleteAllReferences' must be defined and cannot be null.");
        else
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteCategory(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteCategory(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @recategorizeInput (optional) 
     * @return Success
     */
    reclassify(instanceType: InstanceType32, instanceId: number, recategorizeInput: RecategorizeInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reclassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recategorizeInput);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processReclassify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReclassify(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processReclassify(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    resetToDefaults(instanceType: InstanceType33, instanceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ResetToDefaults?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetToDefaults(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetToDefaults(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetToDefaults(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    reset(instanceType: InstanceType34, instanceId: number, input: ResetClassificationDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reset?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processReset(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReset(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processReset(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateTransactionsCategory(instanceType: InstanceType35, instanceId: number, input: UpdateTransactionsCategoryInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTransactionsCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTransactionsCategory(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTransactionsCategory(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateTransactionsCategoryWithFilter(instanceType: InstanceType36, instanceId: number, input: UpdateTransactionsCategoryWithFilterInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategoryWithFilter?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTransactionsCategoryWithFilter(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTransactionsCategoryWithFilter(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTransactionsCategoryWithFilter(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    getTransactionCommonDetails(instanceType: InstanceType37, instanceId: number, input: GetTransactionCommonDetailsInput): Observable<TransactionCommonDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetTransactionCommonDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionCommonDetails(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactionCommonDetails(response_);
                } catch (e) {
                    return <Observable<TransactionCommonDetailsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionCommonDetailsDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionCommonDetails(response: Response): Observable<TransactionCommonDetailsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionCommonDetailsDto.fromJS(resultData200) : new TransactionCommonDetailsDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TransactionCommonDetailsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    autoClassify(instanceType: InstanceType38, instanceId: number, input: AutoClassifyDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AutoClassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAutoClassify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAutoClassify(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAutoClassify(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    changeCategoryForRules(instanceType: InstanceType39, instanceId: number, input: ChangeCategoryForRulesInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ChangeCategoryForRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeCategoryForRules(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeCategoryForRules(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeCategoryForRules(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getComments(instanceType: InstanceType40, instanceId: number, threadId: number): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/GetComments?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (threadId === undefined || threadId === null)
            throw new Error("The parameter 'threadId' must be defined and cannot be null.");
        else
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetComments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetComments(response_);
                } catch (e) {
                    return <Observable<CommentDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommentDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetComments(response: Response): Observable<CommentDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommentDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommentDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createComment(instanceType: InstanceType41, instanceId: number, input: CreateCommentInput): Observable<CreateCommentOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateComment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateComment(response_);
                } catch (e) {
                    return <Observable<CreateCommentOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateCommentOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateComment(response: Response): Observable<CreateCommentOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCommentOutput.fromJS(resultData200) : new CreateCommentOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateCommentOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    updateComment(instanceType: InstanceType42, instanceId: number, input: UpdateCommentInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/UpdateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateComment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateComment(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateComment(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteComment(instanceType: InstanceType43, instanceId: number, commentId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/DeleteComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined and cannot be null.");
        else
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteComment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteComment(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteComment(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createTransactionCommentThread(instanceType: InstanceType44, instanceId: number, input: CreateTransactionCommentThreadInput): Observable<CreateTransactionCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateTransactionCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateTransactionCommentThread(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateTransactionCommentThread(response_);
                } catch (e) {
                    return <Observable<CreateTransactionCommentThreadOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateTransactionCommentThreadOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateTransactionCommentThread(response: Response): Observable<CreateTransactionCommentThreadOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateTransactionCommentThreadOutput.fromJS(resultData200) : new CreateTransactionCommentThreadOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateTransactionCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    createCashFlowCommentThread(instanceType: InstanceType45, instanceId: number, input: CreateCashFlowCommentThreadInput): Observable<CreateCashFlowCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateCashFlowCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateCashFlowCommentThread(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateCashFlowCommentThread(response_);
                } catch (e) {
                    return <Observable<CreateCashFlowCommentThreadOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateCashFlowCommentThreadOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateCashFlowCommentThread(response: Response): Observable<CreateCashFlowCommentThreadOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCashFlowCommentThreadOutput.fromJS(resultData200) : new CreateCashFlowCommentThreadOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateCashFlowCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    setResolved(instanceType: InstanceType46, instanceId: number, input: SetResolvedInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/SetResolved?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetResolved(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetResolved(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetResolved(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === undefined || onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' must be defined and cannot be null.");
        else
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditionsForCombobox(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionsForCombobox(response: Response): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processFindUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFindUsers(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processFindUsers(response: Response): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDefaultEditionName(response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetDefaultEditionName(response: Response): Observable<GetDefaultEditionNameOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ContactAddressServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createContactAddress(input: CreateContactAddressInput): Observable<CreateContactAddressOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/CreateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContactAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContactAddress(response_);
                } catch (e) {
                    return <Observable<CreateContactAddressOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactAddressOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateContactAddress(response: Response): Observable<CreateContactAddressOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactAddressOutput.fromJS(resultData200) : new CreateContactAddressOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactAddressOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateContactAddress(input: UpdateContactAddressInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/UpdateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContactAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContactAddress(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContactAddress(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactAddress(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/DeleteContactAddress?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContactAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteContactAddress(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContactAddress(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressUsageTypes(): Observable<ListResultDtoOfAddressUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAddressUsageTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAddressUsageTypes(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAddressUsageTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfAddressUsageTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAddressUsageTypes(response: Response): Observable<ListResultDtoOfAddressUsageTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAddressUsageTypeDto.fromJS(resultData200) : new ListResultDtoOfAddressUsageTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfAddressUsageTypeDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressOwnershipTypes(): Observable<ListResultDtoOfAddressOwnershipTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressOwnershipTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAddressOwnershipTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAddressOwnershipTypes(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAddressOwnershipTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfAddressOwnershipTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAddressOwnershipTypes(response: Response): Observable<ListResultDtoOfAddressOwnershipTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAddressOwnershipTypeDto.fromJS(resultData200) : new ListResultDtoOfAddressOwnershipTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfAddressOwnershipTypeDto>(<any>null);
    }
}

@Injectable()
export class ContactBusinessServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getContactBusiness(personId: number): Observable<GetContactBusinessOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/GetContactBusiness?";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined and cannot be null.");
        else
            url_ += "PersonId=" + encodeURIComponent("" + personId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContactBusiness(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContactBusiness(response_);
                } catch (e) {
                    return <Observable<GetContactBusinessOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetContactBusinessOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetContactBusiness(response: Response): Observable<GetContactBusinessOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetContactBusinessOutput.fromJS(resultData200) : new GetContactBusinessOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetContactBusinessOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createContactBusiness(input: CreateContactBusinessInput): Observable<CreateContactBusinessOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/CreateContactBusiness";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContactBusiness(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContactBusiness(response_);
                } catch (e) {
                    return <Observable<CreateContactBusinessOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactBusinessOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateContactBusiness(response: Response): Observable<CreateContactBusinessOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactBusinessOutput.fromJS(resultData200) : new CreateContactBusinessOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactBusinessOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateContactBusiness(input: UpdateContactBusinessInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/UpdateContactBusiness";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContactBusiness(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContactBusiness(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContactBusiness(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactBusiness(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/DeleteContactBusiness?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContactBusiness(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteContactBusiness(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContactBusiness(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPersonOrgRelationTypes(): Observable<PersonOrgRelationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/GetPersonOrgRelationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPersonOrgRelationTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPersonOrgRelationTypes(response_);
                } catch (e) {
                    return <Observable<PersonOrgRelationTypeDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PersonOrgRelationTypeDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPersonOrgRelationTypes(response: Response): Observable<PersonOrgRelationTypeDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PersonOrgRelationTypeDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PersonOrgRelationTypeDto[]>(<any>null);
    }
}

@Injectable()
export class ContactEmailServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createContactEmail(input: CreateContactEmailInput): Observable<CreateContactEmailOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/CreateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContactEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContactEmail(response_);
                } catch (e) {
                    return <Observable<CreateContactEmailOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactEmailOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateContactEmail(response: Response): Observable<CreateContactEmailOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactEmailOutput.fromJS(resultData200) : new CreateContactEmailOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactEmailOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateContactEmail(input: UpdateContactEmailInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/UpdateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContactEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContactEmail(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContactEmail(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactEmail(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/DeleteContactEmail?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContactEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteContactEmail(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContactEmail(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEmailUsageTypes(): Observable<ListResultDtoOfEmailUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/GetEmailUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEmailUsageTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEmailUsageTypes(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEmailUsageTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfEmailUsageTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEmailUsageTypes(response: Response): Observable<ListResultDtoOfEmailUsageTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEmailUsageTypeDto.fromJS(resultData200) : new ListResultDtoOfEmailUsageTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfEmailUsageTypeDto>(<any>null);
    }
}

@Injectable()
export class ContactEmploymentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(personId: number): Observable<GetContactEmploymentOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmployment/Get?";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined and cannot be null.");
        else
            url_ += "PersonId=" + encodeURIComponent("" + personId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(response_);
                } catch (e) {
                    return <Observable<GetContactEmploymentOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetContactEmploymentOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<GetContactEmploymentOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetContactEmploymentOutput.fromJS(resultData200) : new GetContactEmploymentOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetContactEmploymentOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateContactEmploymentInput): Observable<CreateContactEmploymentOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmployment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(response_);
                } catch (e) {
                    return <Observable<CreateContactEmploymentOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactEmploymentOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CreateContactEmploymentOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactEmploymentOutput.fromJS(resultData200) : new CreateContactEmploymentOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactEmploymentOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: UpdateContactEmploymentInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmployment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmployment/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ContactLinkServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createContactLink(input: CreateContactLinkInput): Observable<CreateContactLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/CreateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContactLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContactLink(response_);
                } catch (e) {
                    return <Observable<CreateContactLinkOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactLinkOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateContactLink(response: Response): Observable<CreateContactLinkOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactLinkOutput.fromJS(resultData200) : new CreateContactLinkOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactLinkOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateContactLink(input: UpdateContactLinkInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/UpdateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContactLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContactLink(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContactLink(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactLink(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/DeleteContactLink?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContactLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteContactLink(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContactLink(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getContactLinkTypes(): Observable<ListResultDtoOfContactLinkTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/GetContactLinkTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContactLinkTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContactLinkTypes(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfContactLinkTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfContactLinkTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetContactLinkTypes(response: Response): Observable<ListResultDtoOfContactLinkTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfContactLinkTypeDto.fromJS(resultData200) : new ListResultDtoOfContactLinkTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfContactLinkTypeDto>(<any>null);
    }
}

@Injectable()
export class ContactPhoneServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createContactPhone(input: CreateContactPhoneInput): Observable<CreateContactPhoneOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/CreateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContactPhone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContactPhone(response_);
                } catch (e) {
                    return <Observable<CreateContactPhoneOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateContactPhoneOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateContactPhone(response: Response): Observable<CreateContactPhoneOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactPhoneOutput.fromJS(resultData200) : new CreateContactPhoneOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateContactPhoneOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateContactPhone(input: UpdateContactPhoneInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/UpdateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContactPhone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContactPhone(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContactPhone(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactPhone(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/DeleteContactPhone?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContactPhone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteContactPhone(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContactPhone(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPhoneUsageTypes(): Observable<ListResultDtoOfPhoneUsageTypeDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetPhoneUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPhoneUsageTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPhoneUsageTypes(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPhoneUsageTypeDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfPhoneUsageTypeDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPhoneUsageTypes(response: Response): Observable<ListResultDtoOfPhoneUsageTypeDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPhoneUsageTypeDto.fromJS(resultData200) : new ListResultDtoOfPhoneUsageTypeDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfPhoneUsageTypeDto>(<any>null);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCountries(response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CountryDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCountries(response: Response): Observable<CountryDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CountryDto[]>(<any>null);
    }

    /**
     * @code (optional) 
     * @return Success
     */
    getCountryStates(code: string): Observable<CountryStateDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountryStates?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCountryStates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCountryStates(response_);
                } catch (e) {
                    return <Observable<CountryStateDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CountryStateDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCountryStates(response: Response): Observable<CountryStateDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryStateDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CountryStateDto[]>(<any>null);
    }
}

@Injectable()
export class CreditReportServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadCreditReport(reportId: number): Observable<string> {
        let url_ = this.baseUrl + "/Reports/CreditReport/DownloadCreditReport?";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined and cannot be null.");
        else
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDownloadCreditReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadCreditReport(response_);
                } catch (e) {
                    return <Observable<string>><any>Observable.throw(e);
                }
            } else
                return <Observable<string>><any>Observable.throw(response_);
        });
    }

    protected processDownloadCreditReport(response: Response): Observable<string> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<string>(<any>null);
    }

    /**
     * @dateTime (optional) 
     * @return Success
     */
    getLastCreditReport(dateTime: moment.Moment): Observable<CreditReportOutput> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditReport/GetLastCreditReport?";
        if (dateTime !== undefined)
            url_ += "DateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLastCreditReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLastCreditReport(response_);
                } catch (e) {
                    return <Observable<CreditReportOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreditReportOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLastCreditReport(response: Response): Observable<CreditReportOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreditReportOutput.fromJS(resultData200) : new CreditReportOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreditReportOutput>(<any>null);
    }

    /**
     * @accountIds (optional) 
     * @return Success
     */
    getAccountInfo(creditReport: number, accountIds: number[]): Observable<AccountInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditReport/GetAccountInfo?";
        if (creditReport === undefined || creditReport === null)
            throw new Error("The parameter 'creditReport' must be defined and cannot be null.");
        else
            url_ += "creditReport=" + encodeURIComponent("" + creditReport) + "&"; 
        if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "accountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAccountInfo(response_);
                } catch (e) {
                    return <Observable<AccountInfoDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountInfoDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAccountInfo(response: Response): Observable<AccountInfoDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AccountInfoDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AccountInfoDto[]>(<any>null);
    }

    /**
     * @reportId (optional) 
     * @return Success
     */
    getCreditReportHistory(periodYears: number, reportId: number): Observable<KeyValuePairOfStringAndListOfScoreHistoryDto[]> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditReport/GetCreditReportHistory?";
        if (periodYears === undefined || periodYears === null)
            throw new Error("The parameter 'periodYears' must be defined and cannot be null.");
        else
            url_ += "periodYears=" + encodeURIComponent("" + periodYears) + "&"; 
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCreditReportHistory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCreditReportHistory(response_);
                } catch (e) {
                    return <Observable<KeyValuePairOfStringAndListOfScoreHistoryDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<KeyValuePairOfStringAndListOfScoreHistoryDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCreditReportHistory(response: Response): Observable<KeyValuePairOfStringAndListOfScoreHistoryDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KeyValuePairOfStringAndListOfScoreHistoryDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<KeyValuePairOfStringAndListOfScoreHistoryDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    loadAlerts(): Observable<AlertDto[]> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditReport/LoadAlerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processLoadAlerts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLoadAlerts(response_);
                } catch (e) {
                    return <Observable<AlertDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<AlertDto[]>><any>Observable.throw(response_);
        });
    }

    protected processLoadAlerts(response: Response): Observable<AlertDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AlertDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AlertDto[]>(<any>null);
    }
}

@Injectable()
export class CreditSimulatorServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getScoreSimulatorInfo(): Observable<ScoreSimulatorInfoDto> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditSimulator/GetScoreSimulatorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetScoreSimulatorInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetScoreSimulatorInfo(response_);
                } catch (e) {
                    return <Observable<ScoreSimulatorInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ScoreSimulatorInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetScoreSimulatorInfo(response: Response): Observable<ScoreSimulatorInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScoreSimulatorInfoDto.fromJS(resultData200) : new ScoreSimulatorInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ScoreSimulatorInfoDto>(<any>null);
    }

    /**
     * @simulatorData (optional) 
     * @return Success
     */
    simulateScore(simulatorData: ScoreSimulatorDto): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CreditReport/CreditSimulator/SimulateScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(simulatorData);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSimulateScore(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSimulateScore(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processSimulateScore(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }
}

@Injectable()
export class CustomersServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPersonContactInfo(contactId: number): Observable<PersonContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Customers/GetPersonContactInfo?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPersonContactInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPersonContactInfo(response_);
                } catch (e) {
                    return <Observable<PersonContactInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PersonContactInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPersonContactInfo(response: Response): Observable<PersonContactInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PersonContactInfoDto.fromJS(resultData200) : new PersonContactInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PersonContactInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationContactInfo(contactId: number): Observable<OrganizationContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Customers/GetOrganizationContactInfo?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationContactInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganizationContactInfo(response_);
                } catch (e) {
                    return <Observable<OrganizationContactInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationContactInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationContactInfo(response: Response): Observable<OrganizationContactInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationContactInfoDto.fromJS(resultData200) : new OrganizationContactInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OrganizationContactInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    getContactInfoByUser(userId: number): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Customers/GetContactInfoByUser?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContactInfoByUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContactInfoByUser(response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetContactInfoByUser(response: Response): Observable<ContactInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactInfoDto.fromJS(resultData200) : new ContactInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContactInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    getCustomerInfo(customerId: number): Observable<CustomerInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Customers/GetCustomerInfo?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCustomerInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCustomerInfo(response_);
                } catch (e) {
                    return <Observable<CustomerInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CustomerInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCustomerInfo(response: Response): Observable<CustomerInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerInfoDto.fromJS(resultData200) : new CustomerInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CustomerInfoDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createCustomer(input: CreateCustomerInput): Observable<CreateCustomerOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Customers/CreateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateCustomer(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateCustomer(response_);
                } catch (e) {
                    return <Observable<CreateCustomerOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateCustomerOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateCustomer(response: Response): Observable<CreateCustomerOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCustomerOutput.fromJS(resultData200) : new CreateCustomerOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateCustomerOutput>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getAccountTotals(instanceType: InstanceType47, instanceId: number): Observable<AccountTotals> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetAccountTotals?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAccountTotals(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAccountTotals(response_);
                } catch (e) {
                    return <Observable<AccountTotals>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountTotals>><any>Observable.throw(response_);
        });
    }

    protected processGetAccountTotals(response: Response): Observable<AccountTotals> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountTotals.fromJS(resultData200) : new AccountTotals();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AccountTotals>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCategorizationStatus(instanceType: InstanceType48, instanceId: number): Observable<CategorizationStatus> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetCategorizationStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCategorizationStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCategorizationStatus(response_);
                } catch (e) {
                    return <Observable<CategorizationStatus>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategorizationStatus>><any>Observable.throw(response_);
        });
    }

    protected processGetCategorizationStatus(response: Response): Observable<CategorizationStatus> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategorizationStatus.fromJS(resultData200) : new CategorizationStatus();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CategorizationStatus>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendAndGetDate(response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDate(response: Response): Observable<DateToStringOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendAndGetDateTime(response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDateTime(response: Response): Observable<DateToStringOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment, endDate: moment.Moment): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendAndGetDateRange(response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDateRange(response: Response): Observable<DateToStringOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCountries(response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCountries(response: Response): Observable<NameValueOfString[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<NameValueOfString[]>(<any>null);
    }

    /**
     * @selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[]): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendAndGetSelectedCountries(response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetSelectedCountries(response: Response): Observable<NameValueOfString[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<NameValueOfString[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendAndGetValue(response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetValue(response: Response): Observable<StringOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<StringOutput>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditions(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEditions(response: Response): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditionForEdit(response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionForEdit(response: Response): Observable<GetEditionEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetEditionEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrUpdateEdition(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateEdition(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteEdition(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/DeleteEdition?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteEdition(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteEdition(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @selectedEditionId (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number, addAllItem: boolean, onlyFreeItems: boolean): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem === undefined || addAllItem === null)
            throw new Error("The parameter 'addAllItem' must be defined and cannot be null.");
        else
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems === undefined || onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' must be defined and cannot be null.");
        else
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditionComboboxItems(response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionComboboxItems(response: Response): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class FinancialInformationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @css (optional) 
     * @errorPage (optional) 
     * @return Success
     */
    getSetupAccountsLink(instanceType: InstanceType49, instanceId: number, css: string, errorPage: string): Observable<GetSetupAccountsLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/FinancialInformation/GetSetupAccountsLink?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (css !== undefined)
            url_ += "css=" + encodeURIComponent("" + css) + "&"; 
        if (errorPage !== undefined)
            url_ += "errorPage=" + encodeURIComponent("" + errorPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSetupAccountsLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSetupAccountsLink(response_);
                } catch (e) {
                    return <Observable<GetSetupAccountsLinkOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetSetupAccountsLinkOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetSetupAccountsLink(response: Response): Observable<GetSetupAccountsLinkOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSetupAccountsLinkOutput.fromJS(resultData200) : new GetSetupAccountsLinkOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetSetupAccountsLinkOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    syncAllAccounts(instanceType: InstanceType50, instanceId: number, syncHistory: boolean): Observable<SyncAllAccountsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/FinancialInformation/SyncAllAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncHistory === undefined || syncHistory === null)
            throw new Error("The parameter 'syncHistory' must be defined and cannot be null.");
        else
            url_ += "syncHistory=" + encodeURIComponent("" + syncHistory) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSyncAllAccounts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSyncAllAccounts(response_);
                } catch (e) {
                    return <Observable<SyncAllAccountsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SyncAllAccountsOutput>><any>Observable.throw(response_);
        });
    }

    protected processSyncAllAccounts(response: Response): Observable<SyncAllAccountsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncAllAccountsOutput.fromJS(resultData200) : new SyncAllAccountsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SyncAllAccountsOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getSyncProgress(instanceType: InstanceType51, instanceId: number): Observable<SyncProgressOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/FinancialInformation/GetSyncProgress?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSyncProgress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSyncProgress(response_);
                } catch (e) {
                    return <Observable<SyncProgressOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SyncProgressOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetSyncProgress(response: Response): Observable<SyncProgressOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncProgressOutput.fromJS(resultData200) : new SyncProgressOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SyncProgressOutput>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateFriendshipRequest(response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FriendDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateFriendshipRequest(response: Response): Observable<FriendDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateFriendshipRequestByUserName(response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FriendDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateFriendshipRequestByUserName(response: Response): Observable<FriendDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processBlockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBlockUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processBlockUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUnblockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUnblockUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnblockUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAcceptFriendshipRequest(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAcceptFriendshipRequest(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: IncomeStatisticsDateInterval, startDate: moment.Moment, endDate: moment.Moment): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDashboardStatisticsData(response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>Observable.throw(e);
                }
            } else
                return <Observable<HostDashboardData>><any>Observable.throw(response_);
        });
    }

    protected processGetDashboardStatisticsData(response: Response): Observable<HostDashboardData> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HostDashboardData>(<any>null);
    }

    /**
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: IncomeStatisticsDateInterval2, startDate: moment.Moment, endDate: moment.Moment): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetIncomeStatistics(response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetIncomeStatistics(response: Response): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment, endDate: moment.Moment): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditionTenantStatistics(response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionTenantStatistics(response: Response): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllSettings(response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllSettings(response: Response): Observable<HostSettingsEditDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HostSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateAllSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateAllSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendTestEmail(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTestEmail(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setup(input: InstallDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetup(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetup(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAppSettingsJson(response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAppSettingsJson(response: Response): Observable<AppSettingsJsonDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCheckDatabase(response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>Observable.throw(response_);
        });
    }

    protected processCheckDatabase(response: Response): Observable<CheckDatabaseOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InstanceServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getStatus(instanceType: InstanceType52, instanceId: number): Observable<GetStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetStatus(response_);
                } catch (e) {
                    return <Observable<GetStatusOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetStatusOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetStatus(response: Response): Observable<GetStatusOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStatusOutput.fromJS(resultData200) : new GetStatusOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetStatusOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setup(instanceType: InstanceType53): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/Setup?";
        if (instanceType === undefined || instanceType === null)
            throw new Error("The parameter 'instanceType' must be defined and cannot be null.");
        else
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetup(response_);
                } catch (e) {
                    return <Observable<SetupOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SetupOutput>><any>Observable.throw(response_);
        });
    }

    protected processSetup(response: Response): Observable<SetupOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetupOutput.fromJS(resultData200) : new SetupOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SetupOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setupAndGrantPermissionsForUser(input: SetupInput): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/SetupAndGrantPermissionsForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetupAndGrantPermissionsForUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetupAndGrantPermissionsForUser(response_);
                } catch (e) {
                    return <Observable<SetupOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SetupOutput>><any>Observable.throw(response_);
        });
    }

    protected processSetupAndGrantPermissionsForUser(response: Response): Observable<SetupOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetupOutput.fromJS(resultData200) : new SetupOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SetupOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserInstanceInfo(userId: number): Observable<GetUserInstanceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUserInstanceInfo?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserInstanceInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserInstanceInfo(response_);
                } catch (e) {
                    return <Observable<GetUserInstanceInfoOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserInstanceInfoOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserInstanceInfo(response: Response): Observable<GetUserInstanceInfoOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserInstanceInfoOutput.fromJS(resultData200) : new GetUserInstanceInfoOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetUserInstanceInfoOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getInvoiceInfo(id: number): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Invoice/GetInvoiceInfo?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceInfo(response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceInfo(response: Response): Observable<InvoiceDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateInvoice(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateInvoice(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class KBAServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    requestKBA(input: RequestKBAInput): Observable<RequestKBAOutput> {
        let url_ = this.baseUrl + "/api/services/CreditReport/KBA/RequestKBA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRequestKBA(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRequestKBA(response_);
                } catch (e) {
                    return <Observable<RequestKBAOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RequestKBAOutput>><any>Observable.throw(response_);
        });
    }

    protected processRequestKBA(response: Response): Observable<RequestKBAOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestKBAOutput.fromJS(resultData200) : new RequestKBAOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RequestKBAOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    processKBAResponse(input: KBAResult): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CreditReport/KBA/ProcessKBAResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processProcessKBAResponse(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processProcessKBAResponse(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processProcessKBAResponse(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLanguages(response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguages(response: Response): Observable<GetLanguagesOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetLanguagesOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLanguageForEdit(response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguageForEdit(response: Response): Observable<GetLanguageForEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrUpdateLanguage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateLanguage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteLanguage(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/DeleteLanguage?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteLanguage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteLanguage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetDefaultLanguage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetDefaultLanguage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number, skipCount: number, sorting: string, sourceName: string, baseLanguageName: string, targetLanguageName: string, targetValueFilter: string, filterText: string): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageTexts?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLanguageTexts(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguageTexts(response: Response): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateLanguageText(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateLanguageText(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LeadServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @cancelLeadInfo (optional) 
     * @return Success
     */
    cancelLead(cancelLeadInfo: CancelLeadInfo): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/CancelLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cancelLeadInfo);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCancelLead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelLead(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelLead(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getCancellationReasons(): Observable<ListResultDtoOfLeadCancellationReasonDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetCancellationReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCancellationReasons(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCancellationReasons(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLeadCancellationReasonDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfLeadCancellationReasonDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCancellationReasons(response: Response): Observable<ListResultDtoOfLeadCancellationReasonDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLeadCancellationReasonDto.fromJS(resultData200) : new ListResultDtoOfLeadCancellationReasonDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfLeadCancellationReasonDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLeadStats(): Observable<LeadStatsDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLeadStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLeadStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLeadStats(response_);
                } catch (e) {
                    return <Observable<LeadStatsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<LeadStatsDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLeadStats(response: Response): Observable<LeadStatsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadStatsDto.fromJS(resultData200) : new LeadStatsDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LeadStatsDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    submitContactUsRequest(model: SubmitContactUsRequestInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitContactUsRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSubmitContactUsRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubmitContactUsRequest(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubmitContactUsRequest(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    submitTenantCreationRequest(input: SubmitTenantCreationRequestInput): Observable<SubmitTenantCreationRequestOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitTenantCreationRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSubmitTenantCreationRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubmitTenantCreationRequest(response_);
                } catch (e) {
                    return <Observable<SubmitTenantCreationRequestOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubmitTenantCreationRequestOutput>><any>Observable.throw(response_);
        });
    }

    protected processSubmitTenantCreationRequest(response: Response): Observable<SubmitTenantCreationRequestOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitTenantCreationRequestOutput.fromJS(resultData200) : new SubmitTenantCreationRequestOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SubmitTenantCreationRequestOutput>(<any>null);
    }

    /**
     * @leadBusinessRequests (optional) 
     * @return Success
     */
    submitLeadRequests(leadBusinessRequests: LeadBusinessInfoInput[]): Observable<LeadBusinessInfoOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitLeadRequests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leadBusinessRequests);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSubmitLeadRequests(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubmitLeadRequests(response_);
                } catch (e) {
                    return <Observable<LeadBusinessInfoOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<LeadBusinessInfoOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processSubmitLeadRequests(response: Response): Observable<LeadBusinessInfoOutput[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LeadBusinessInfoOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<LeadBusinessInfoOutput[]>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    selectPackage(packageId: number): Observable<SelectPackageResponseDto> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Member/SelectPackage?";
        if (packageId === undefined || packageId === null)
            throw new Error("The parameter 'packageId' must be defined and cannot be null.");
        else
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSelectPackage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSelectPackage(response_);
                } catch (e) {
                    return <Observable<SelectPackageResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SelectPackageResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processSelectPackage(response: Response): Observable<SelectPackageResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SelectPackageResponseDto.fromJS(resultData200) : new SelectPackageResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SelectPackageResponseDto>(<any>null);
    }

    /**
     * @memberInfo (optional) 
     * @return Success
     */
    submitMemberInfo(memberInfo: MemberInfoDto): Observable<SubmitMemberInfoResultDto> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Member/SubmitMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(memberInfo);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSubmitMemberInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubmitMemberInfo(response_);
                } catch (e) {
                    return <Observable<SubmitMemberInfoResultDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubmitMemberInfoResultDto>><any>Observable.throw(response_);
        });
    }

    protected processSubmitMemberInfo(response: Response): Observable<SubmitMemberInfoResultDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitMemberInfoResultDto.fromJS(resultData200) : new SubmitMemberInfoResultDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SubmitMemberInfoResultDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    paymentAuthorize(input: PaymentAuthorizeRequestDto): Observable<PaymentAuthorizeResponseDto> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Member/PaymentAuthorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processPaymentAuthorize(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPaymentAuthorize(response_);
                } catch (e) {
                    return <Observable<PaymentAuthorizeResponseDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentAuthorizeResponseDto>><any>Observable.throw(response_);
        });
    }

    protected processPaymentAuthorize(response: Response): Observable<PaymentAuthorizeResponseDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentAuthorizeResponseDto.fromJS(resultData200) : new PaymentAuthorizeResponseDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentAuthorizeResponseDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    registerMember(input: RegisterMemberRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Member/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRegisterMember(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegisterMember(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRegisterMember(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    cancelMembership(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Member/CancelMembership";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCancelMembership(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelMembership(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCancelMembership(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @return Success
     */
    getUserNotifications(state: State, maxResultCount: number, skipCount: number): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserNotifications(response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserNotifications(response: Response): Observable<GetNotificationsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetAllNotificationsAsRead(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetAllNotificationsAsRead(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetNotificationAsRead(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetNotificationAsRead(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetNotificationSettings(response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetNotificationSettings(response: Response): Observable<GetNotificationSettingsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateNotificationSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateNotificationSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getFiltersInitialData(): Observable<OrderFiltersInitialData> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetFiltersInitialData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetFiltersInitialData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetFiltersInitialData(response_);
                } catch (e) {
                    return <Observable<OrderFiltersInitialData>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrderFiltersInitialData>><any>Observable.throw(response_);
        });
    }

    protected processGetFiltersInitialData(response: Response): Observable<OrderFiltersInitialData> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrderFiltersInitialData.fromJS(resultData200) : new OrderFiltersInitialData();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OrderFiltersInitialData>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganizationUnits(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationUnits(response: Response): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number, sorting: string, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganizationUnitUsers(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationUnitUsers(response: Response): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrganizationUnit(response: Response): Observable<OrganizationUnitDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganizationUnit(response: Response): Observable<OrganizationUnitDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMoveOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processMoveOrganizationUnit(response: Response): Observable<OrganizationUnitDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @return Success
     */
    deleteOrganizationUnit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteOrganizationUnit(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number, organizationUnitId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId === undefined || organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' must be defined and cannot be null.");
        else
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRemoveUserFromOrganizationUnit(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddUsersToOrganizationUnit(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processFindUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFindUsers(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processFindUsers(response: Response): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PackageServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfPackageDto> {
        let url_ = this.baseUrl + "/api/services/CreditReport/Package/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPackageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfPackageDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<ListResultDtoOfPackageDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPackageDto.fromJS(resultData200) : new ListResultDtoOfPackageDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfPackageDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentInfo(response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentInfo(response: Response): Observable<PaymentInfoDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentInfoDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto): Observable<any> {
        let url_ = this.baseUrl + "/api/services/Platform/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreatePayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreatePayment(response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processCreatePayment(response: Response): Observable<any> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    executePayment(input: ExecutePaymentDto): Observable<any> {
        let url_ = this.baseUrl + "/api/services/Platform/Payment/ExecutePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processExecutePayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExecutePayment(response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processExecutePayment(response: Response): Observable<any> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentHistory(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentHistory(response: Response): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllPermissions(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPermissions(response: Response): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class PipelineServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @purposeId (optional) 
     * @return Success
     */
    getPipelinesData(purposeId: string): Observable<PipelineData[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelinesData?";
        if (purposeId !== undefined)
            url_ += "purposeId=" + encodeURIComponent("" + purposeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPipelinesData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPipelinesData(response_);
                } catch (e) {
                    return <Observable<PipelineData[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PipelineData[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPipelinesData(response: Response): Observable<PipelineData[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PipelineData.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PipelineData[]>(<any>null);
    }

    /**
     * @purposeId (optional) 
     * @return Success
     */
    getPipelinesFullData(purposeId: string): Observable<PipelineDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelinesFullData?";
        if (purposeId !== undefined)
            url_ += "purposeId=" + encodeURIComponent("" + purposeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPipelinesFullData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPipelinesFullData(response_);
                } catch (e) {
                    return <Observable<PipelineDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PipelineDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPipelinesFullData(response: Response): Observable<PipelineDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PipelineDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PipelineDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPipelineDefinition(pipelineId: number): Observable<PipelineDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinition?";
        if (pipelineId === undefined || pipelineId === null)
            throw new Error("The parameter 'pipelineId' must be defined and cannot be null.");
        else
            url_ += "PipelineId=" + encodeURIComponent("" + pipelineId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPipelineDefinition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPipelineDefinition(response_);
                } catch (e) {
                    return <Observable<PipelineDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PipelineDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPipelineDefinition(response: Response): Observable<PipelineDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PipelineDto.fromJS(resultData200) : new PipelineDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PipelineDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentUserProfileForEdit(response: Response): Observable<CurrentUserProfileEditDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdateGoogleAuthenticatorKey(response: Response): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendVerificationSms(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendVerificationSms(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processVerifySmsCode(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processVerifySmsCode(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateCurrentUserProfile(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCurrentUserProfile(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangePassword(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangePassword(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateProfilePicture(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProfilePicture(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPasswordComplexitySetting(response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetPasswordComplexitySetting(response: Response): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfilePicture(response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetProfilePicture(response: Response): Observable<GetProfilePictureOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string, userId: number, tenantId: number): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetFriendProfilePictureById(response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetFriendProfilePictureById(response: Response): Observable<GetProfilePictureOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePictureById(profilePictureId: string): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePictureById?";
        if (profilePictureId === undefined || profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' must be defined and cannot be null.");
        else
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfilePictureById(response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetProfilePictureById(response: Response): Observable<GetProfilePictureOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeLanguage(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeLanguage(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @permission (optional) 
     * @return Success
     */
    getRoles(permission: string): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRoles(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: Response): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRoleForEdit(response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetRoleForEdit(response: Response): Observable<GetRoleForEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrUpdateRole(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateRole(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRole(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/DeleteRole?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteRole(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteRole(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentLoginInformations(response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentLoginInformations(response: Response): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateUserSignInToken(response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserSignInToken(response: Response): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UpdateUserSignInTokenOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserInformation(): Observable<GetUserInformationOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/GetUserInformation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserInformation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserInformation(response_);
                } catch (e) {
                    return <Observable<GetUserInformationOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserInformationOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserInformation(response: Response): Observable<GetUserInformationOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserInformationOutput.fromJS(resultData200) : new GetUserInformationOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetUserInformationOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId === undefined || upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' must be defined and cannot be null.");
        else
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpgradeTenantToEquivalentEdition(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenancyServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenancies(customerId: number): Observable<PagedResultDtoOfTenancyListDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Tenancy/GetTenancies?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenancies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenancies(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenancyListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenancyListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenancies(response: Response): Observable<PagedResultDtoOfTenancyListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenancyListDto.fromJS(resultData200) : new PagedResultDtoOfTenancyListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTenancyListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createTenancy(input: CreateTenancyInput): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Tenancy/CreateTenancy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateTenancy(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateTenancy(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processCreateTenancy(response: Response): Observable<number> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number>(<any>null);
    }

    /**
     * @return Success
     */
    getTenancyForEdit(id: number, customerId: number): Observable<GetTenancyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Tenancy/GetTenancyForEdit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenancyForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenancyForEdit(response_);
                } catch (e) {
                    return <Observable<GetTenancyForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetTenancyForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTenancyForEdit(response: Response): Observable<GetTenancyForEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenancyForEditOutput.fromJS(resultData200) : new GetTenancyForEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetTenancyForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenancy(input: UpdateTenancyInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Tenancy/UpdateTenancy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTenancy(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTenancy(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTenancy(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTenancy(id: number, customerId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Tenancy/DeleteTenancy?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined and cannot be null.");
        else
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteTenancy(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteTenancy(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTenancy(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @subscriptionEndDateStart (optional) 
     * @subscriptionEndDateEnd (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getTenants(filter: string, subscriptionEndDateStart: moment.Moment, subscriptionEndDateEnd: moment.Moment, creationDateStart: moment.Moment, creationDateEnd: moment.Moment, editionId: number, editionIdSpecified: boolean, sorting: string, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified === undefined || editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' must be defined and cannot be null.");
        else
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenants(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenants(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenants(response: Response): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateTenant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateTenant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTenantForEdit(id: number): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantForEdit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenantForEdit(response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantForEdit(response: Response): Observable<TenantEditDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTenant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTenant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTenant(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/DeleteTenant?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteTenant(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTenant(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTenantFeaturesForEdit(id: number): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantFeaturesForEdit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantFeaturesForEdit(response: Response): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateTenantFeatures(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTenantFeatures(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetTenantSpecificFeatures(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetTenantSpecificFeatures(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUnlockTenantAdmin(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlockTenantAdmin(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantCustomization(customizationGroupName: string, customizationName: string): Observable<TenantCustomizationDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/GetTenantCustomization?";
        if (customizationGroupName === undefined || customizationGroupName === null)
            throw new Error("The parameter 'customizationGroupName' must be defined and cannot be null.");
        else
            url_ += "CustomizationGroupName=" + encodeURIComponent("" + customizationGroupName) + "&"; 
        if (customizationName === undefined || customizationName === null)
            throw new Error("The parameter 'customizationName' must be defined and cannot be null.");
        else
            url_ += "CustomizationName=" + encodeURIComponent("" + customizationName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantCustomization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenantCustomization(response_);
                } catch (e) {
                    return <Observable<TenantCustomizationDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantCustomizationDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantCustomization(response: Response): Observable<TenantCustomizationDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantCustomizationDto.fromJS(resultData200) : new TenantCustomizationDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantCustomizationDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addTenantCustomization(input: TenantCustomizationDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/AddTenantCustomization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddTenantCustomization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddTenantCustomization(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddTenantCustomization(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMemberActivity(response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetMemberActivity(response: Response): Observable<GetMemberActivityOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDashboardData(response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetDashboardData(response: Response): Observable<GetDashboardDataOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod2): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSalesSummary(response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetSalesSummary(response: Response): Observable<GetSalesSummaryOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getWorldMap(input: any): Observable<GetWorldMapOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetWorldMap?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetWorldMap(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetWorldMap(response_);
                } catch (e) {
                    return <Observable<GetWorldMapOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetWorldMapOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetWorldMap(response: Response): Observable<GetWorldMapOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWorldMapOutput.fromJS(resultData200) : new GetWorldMapOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetWorldMapOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getGeneralStats(input: any): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantDashboard/GetGeneralStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetGeneralStats(response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetGeneralStats(response: Response): Observable<GetGeneralStatsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantHostServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantApiHost(tenantHostType: TenantHostType): Observable<TenantApiHostOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetTenantApiHost?";
        if (tenantHostType === undefined || tenantHostType === null)
            throw new Error("The parameter 'tenantHostType' must be defined and cannot be null.");
        else
            url_ += "TenantHostType=" + encodeURIComponent("" + tenantHostType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantApiHost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenantApiHost(response_);
                } catch (e) {
                    return <Observable<TenantApiHostOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantApiHostOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantApiHost(response: Response): Observable<TenantApiHostOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantApiHostOutput.fromJS(resultData200) : new TenantApiHostOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantApiHostOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    checkHostNameDnsMapping(input: CheckHostNameDnsMappingInput): Observable<CheckHostNameDnsMappingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/CheckHostNameDnsMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCheckHostNameDnsMapping(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCheckHostNameDnsMapping(response_);
                } catch (e) {
                    return <Observable<CheckHostNameDnsMappingOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CheckHostNameDnsMappingOutput>><any>Observable.throw(response_);
        });
    }

    protected processCheckHostNameDnsMapping(response: Response): Observable<CheckHostNameDnsMappingOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckHostNameDnsMappingOutput.fromJS(resultData200) : new CheckHostNameDnsMappingOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CheckHostNameDnsMappingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSslBindings(): Observable<TenantSslBindingInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetSslBindings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSslBindings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSslBindings(response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslBindingInfo[]>><any>Observable.throw(response_);
        });
    }

    protected processGetSslBindings(response: Response): Observable<TenantSslBindingInfo[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslBindingInfo.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslBindingInfo[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addSslBinding(input: AddSslBindingInput): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/AddSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddSslBinding(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddSslBinding(response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>Observable.throw(response_);
        });
    }

    protected processAddSslBinding(response: Response): Observable<TenantSslBindingInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateSslBindingCertificate(input: UpdateSslBindingCertificateInput): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBindingCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSslBindingCertificate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSslBindingCertificate(response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSslBindingCertificate(response: Response): Observable<TenantSslBindingInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateSslBindingIsActive(input: UpdateSslBindingIsActiveInput): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBindingIsActive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSslBindingIsActive(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSslBindingIsActive(response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSslBindingIsActive(response: Response): Observable<TenantSslBindingInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSslBinding(tenantHostType: TenantHostType2): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/DeleteSslBinding?";
        if (tenantHostType === undefined || tenantHostType === null)
            throw new Error("The parameter 'tenantHostType' must be defined and cannot be null.");
        else
            url_ += "TenantHostType=" + encodeURIComponent("" + tenantHostType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteSslBinding(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteSslBinding(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteSslBinding(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantIntegrationsSettingsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIntegrationsSettings(): Observable<IntegrationsSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/GetIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetIntegrationsSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetIntegrationsSettings(response_);
                } catch (e) {
                    return <Observable<IntegrationsSettings>><any>Observable.throw(e);
                }
            } else
                return <Observable<IntegrationsSettings>><any>Observable.throw(response_);
        });
    }

    protected processGetIntegrationsSettings(response: Response): Observable<IntegrationsSettings> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IntegrationsSettings.fromJS(resultData200) : new IntegrationsSettings();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IntegrationsSettings>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateIntegrationsSettings(input: IntegrationsSettings): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/UpdateIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateIntegrationsSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateIntegrationsSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateIntegrationsSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantPaymentSettingsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBaseCommercePaymentSettings(): Observable<BaseCommercePaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBaseCommercePaymentSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBaseCommercePaymentSettings(response_);
                } catch (e) {
                    return <Observable<BaseCommercePaymentSettings>><any>Observable.throw(e);
                }
            } else
                return <Observable<BaseCommercePaymentSettings>><any>Observable.throw(response_);
        });
    }

    protected processGetBaseCommercePaymentSettings(response: Response): Observable<BaseCommercePaymentSettings> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseCommercePaymentSettings.fromJS(resultData200) : new BaseCommercePaymentSettings();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BaseCommercePaymentSettings>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateBaseCommercePaymentSettings(input: BaseCommercePaymentSettings): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateBaseCommercePaymentSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateBaseCommercePaymentSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateBaseCommercePaymentSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    completeTenantRegistration(input: CompleteTenantRegistrationInput): Observable<CompleteTenantRegistrationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantRegistration/CompleteTenantRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCompleteTenantRegistration(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCompleteTenantRegistration(response_);
                } catch (e) {
                    return <Observable<CompleteTenantRegistrationOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CompleteTenantRegistrationOutput>><any>Observable.throw(response_);
        });
    }

    protected processCompleteTenantRegistration(response: Response): Observable<CompleteTenantRegistrationOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompleteTenantRegistrationOutput.fromJS(resultData200) : new CompleteTenantRegistrationOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CompleteTenantRegistrationOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegisterTenant(response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegisterTenant(response: Response): Observable<RegisterTenantOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEditionsForSelect(response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionsForSelect(response: Response): Observable<EditionsSelectOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EditionsSelectOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEdition(editionId: number): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantRegistration/GetEdition?";
        if (editionId === undefined || editionId === null)
            throw new Error("The parameter 'editionId' must be defined and cannot be null.");
        else
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetEdition(response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEdition(response: Response): Observable<EditionSelectDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllSettings(response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllSettings(response: Response): Observable<TenantSettingsEditDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateAllSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateAllSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processClearLogo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processClearLogo(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearLogo(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processClearCustomCss(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearCustomCss(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearFavicons(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/ClearFavicons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processClearFavicons(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processClearFavicons(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearFavicons(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendTestEmail(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTestEmail(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantSettingsCreditReportServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIdcsSettings(): Observable<IdcsSettings> {
        let url_ = this.baseUrl + "/api/services/CreditReport/TenantSettingsCreditReport/GetIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetIdcsSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetIdcsSettings(response_);
                } catch (e) {
                    return <Observable<IdcsSettings>><any>Observable.throw(e);
                }
            } else
                return <Observable<IdcsSettings>><any>Observable.throw(response_);
        });
    }

    protected processGetIdcsSettings(response: Response): Observable<IdcsSettings> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdcsSettings.fromJS(resultData200) : new IdcsSettings();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IdcsSettings>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateIdcsSettings(input: IdcsSettings): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CreditReport/TenantSettingsCreditReport/UpdateIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateIdcsSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateIdcsSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateIdcsSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantSslCertificateServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantSslCertificates(): Observable<TenantSslCertificateInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/GetTenantSslCertificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantSslCertificates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTenantSslCertificates(response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantSslCertificates(response: Response): Observable<TenantSslCertificateInfo[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslCertificateInfo.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslCertificateInfo[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addTenantSslCertificate(input: AddTenantSslCertificateInput): Observable<TenantSslCertificateInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/AddTenantSslCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddTenantSslCertificate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddTenantSslCertificate(response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo>><any>Observable.throw(response_);
        });
    }

    protected processAddTenantSslCertificate(response: Response): Observable<TenantSslCertificateInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslCertificateInfo.fromJS(resultData200) : new TenantSslCertificateInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantSslCertificateInfo>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTenantSslCertificate(sslCertificateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/DeleteTenantSslCertificate?";
        if (sslCertificateId === undefined || sslCertificateId === null)
            throw new Error("The parameter 'sslCertificateId' must be defined and cannot be null.");
        else
            url_ += "SslCertificateId=" + encodeURIComponent("" + sslCertificateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteTenantSslCertificate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteTenantSslCertificate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTenantSslCertificate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @strings (optional) 
     * @return Success
     */
    getCommonPhrases(strings: string[]): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetCommonPhrases?";
        if (strings !== undefined)
            strings && strings.forEach(item => { url_ += "strings=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCommonPhrases(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCommonPhrases(response_);
                } catch (e) {
                    return <Observable<string[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCommonPhrases(response: Response): Observable<string[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<string[]>(<any>null);
    }

    /**
     * @text (optional) 
     * @return Success
     */
    getKeywords(text: string): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetKeywords?";
        if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetKeywords(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetKeywords(response_);
                } catch (e) {
                    return <Observable<string[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[]>><any>Observable.throw(response_);
        });
    }

    protected processGetKeywords(response: Response): Observable<string[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<string[]>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: DefaultTimezoneScope): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTimezones(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTimezones(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTimezones(response: Response): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTimezoneComboboxItems(response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTimezoneComboboxItems(response: Response): Observable<ComboboxItemDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<AuthenticateResultModel> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AuthenticateResultModel>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSendTwoFactorAuthCode(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTwoFactorAuthCode(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImpersonatedAuthenticate(response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processImpersonatedAuthenticate(response: Response): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLinkedAccountAuthenticate(response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processLinkedAccountAuthenticate(response: Response): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetExternalAuthenticationProviders(response: Response): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExternalAuthenticate(response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processExternalAuthenticate(response: Response): Observable<ExternalAuthenticateResultModel> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string, severity: string): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processTestNotification(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTestNotification(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTestNotification(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TransactionsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getFiltersInitialData(instanceType: InstanceType54, instanceId: number): Observable<FiltersInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetFiltersInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetFiltersInitialData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetFiltersInitialData(response_);
                } catch (e) {
                    return <Observable<FiltersInitialData>><any>Observable.throw(e);
                }
            } else
                return <Observable<FiltersInitialData>><any>Observable.throw(response_);
        });
    }

    protected processGetFiltersInitialData(response: Response): Observable<FiltersInitialData> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiltersInitialData.fromJS(resultData200) : new FiltersInitialData();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FiltersInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionAttributeTypes(instanceType: InstanceType55, instanceId: number): Observable<GetTransactionAttributeTypesOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionAttributeTypes?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionAttributeTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactionAttributeTypes(response_);
                } catch (e) {
                    return <Observable<GetTransactionAttributeTypesOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetTransactionAttributeTypesOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionAttributeTypes(response: Response): Observable<GetTransactionAttributeTypesOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionAttributeTypesOutput.fromJS(resultData200) : new GetTransactionAttributeTypesOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetTransactionAttributeTypesOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionDetails(instanceType: InstanceType56, instanceId: number, transactionId: number): Observable<GetTransactionDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactionDetails(response_);
                } catch (e) {
                    return <Observable<GetTransactionDetailsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetTransactionDetailsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionDetails(response: Response): Observable<GetTransactionDetailsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionDetailsOutput.fromJS(resultData200) : new GetTransactionDetailsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetTransactionDetailsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactionTypesAndCategories(): Observable<TransactionTypesAndCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionTypesAndCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionTypesAndCategories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactionTypesAndCategories(response_);
                } catch (e) {
                    return <Observable<TransactionTypesAndCategoriesDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TransactionTypesAndCategoriesDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionTypesAndCategories(response: Response): Observable<TransactionTypesAndCategoriesDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionTypesAndCategoriesDto.fromJS(resultData200) : new TransactionTypesAndCategoriesDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TransactionTypesAndCategoriesDto>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUiManagementSettings(response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUiManagementSettings(response: Response): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: UiCustomizationSettingsEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateUiManagementSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUiManagementSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: UiCustomizationSettingsEditDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDefaultUiManagementSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUseSystemDefaultSettings(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUseSystemDefaultSettings(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    activateUserForContact(input: ActivateUserForContactInput): Observable<ActivateUserForContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/User/ActivateUserForContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processActivateUserForContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processActivateUserForContact(response_);
                } catch (e) {
                    return <Observable<ActivateUserForContactOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ActivateUserForContactOutput>><any>Observable.throw(response_);
        });
    }

    protected processActivateUserForContact(response: Response): Observable<ActivateUserForContactOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivateUserForContactOutput.fromJS(resultData200) : new ActivateUserForContactOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ActivateUserForContactOutput>(<any>null);
    }

    /**
     * @filter (optional) 
     * @permission (optional) 
     * @role (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getUsers(filter: string, permission: string, role: number, sorting: string, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUsers(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: Response): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUsersToExcel(response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUsersToExcel(response: Response): Observable<FileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FileDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserForEdit(response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserForEdit(response: Response): Observable<GetUserForEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetUserForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserPermissionsForEdit(id: number): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserPermissionsForEdit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserPermissionsForEdit(response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserPermissionsForEdit(response: Response): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetUserSpecificPermissions(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetUserSpecificPermissions(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateUserPermissions(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserPermissions(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrUpdateUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/DeleteUser?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUnlockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUnlockUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlockUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processLinkToUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLinkToUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLinkToUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number, skipCount: number, sorting: string): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetLinkedUsers?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLinkedUsers(response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLinkedUsers(response: Response): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRecentlyUsedLinkedUsers(response: Response): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUnlinkUser(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlinkUser(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRecentUserLoginAttempts(response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRecentUserLoginAttempts(response: Response): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLatestWebLogs(response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLatestWebLogs(response: Response): Observable<GetLatestWebLogsOutput> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloadWebLogs(response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processDownloadWebLogs(response: Response): Observable<FileDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState;
    tenantId: number;
    serverRootAddress: string;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState;
    tenantId: number;
    serverRootAddress: string;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;
    autoDetectTenancy: boolean = false;
    features: string[];

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
    autoDetectTenancy: boolean;
    features: string[];
}

export class SendPasswordResetCodeOutput implements ISendPasswordResetCodeOutput {
    detectedTenancies: TenantModel[];

    constructor(data?: ISendPasswordResetCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeOutput {
        let result = new SendPasswordResetCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeOutput {
    detectedTenancies: TenantModel[];
}

export class TenantModel implements ITenantModel {
    id: number;
    tenancyName: string;
    name: string;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITenantModel {
    id: number;
    tenancyName: string;
    name: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number;
    resetCode: string;
    password: string;
    returnUrl: string;
    singleSignIn: string;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string;
    password: string;
    returnUrl: string;
    singleSignIn: string;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean;
    userName: string;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number;
    confirmationCode: string;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number;
    userId: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string;
    tenancyName: string;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string;
    tenancyName: string;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number;
    targetUserId: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string;
    tenancyName: string;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string;
    tenancyName: string;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[];

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[];
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number;
    userName: string;
    impersonatorTenantId: number;
    impersonatorUserId: number;
    serviceName: string;
    methodName: string;
    parameters: string;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string;
    clientName: string;
    browserInfo: string;
    exception: string;
    customData: string;
    id: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number;
    userName: string;
    impersonatorTenantId: number;
    impersonatorUserId: number;
    serviceName: string;
    methodName: string;
    parameters: string;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string;
    clientName: string;
    browserInfo: string;
    exception: string;
    customData: string;
    id: number;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class BankAccountDailyStatDto implements IBankAccountDailyStatDto {
    date: moment.Moment;
    startingBalance: number;
    startingBalanceAdjustments: number;
    income: number;
    expenses: number;
    adjustments: number;
    endingBalance: number;
    period: BankAccountDailyStatDtoPeriod;
    isForecast: boolean;

    constructor(data?: IBankAccountDailyStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startingBalance = data["startingBalance"];
            this.startingBalanceAdjustments = data["startingBalanceAdjustments"];
            this.income = data["income"];
            this.expenses = data["expenses"];
            this.adjustments = data["adjustments"];
            this.endingBalance = data["endingBalance"];
            this.period = data["period"];
            this.isForecast = data["isForecast"];
        }
    }

    static fromJS(data: any): BankAccountDailyStatDto {
        let result = new BankAccountDailyStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startingBalance"] = this.startingBalance;
        data["startingBalanceAdjustments"] = this.startingBalanceAdjustments;
        data["income"] = this.income;
        data["expenses"] = this.expenses;
        data["adjustments"] = this.adjustments;
        data["endingBalance"] = this.endingBalance;
        data["period"] = this.period;
        data["isForecast"] = this.isForecast;
        return data; 
    }
}

export interface IBankAccountDailyStatDto {
    date: moment.Moment;
    startingBalance: number;
    startingBalanceAdjustments: number;
    income: number;
    expenses: number;
    adjustments: number;
    endingBalance: number;
    period: BankAccountDailyStatDtoPeriod;
    isForecast: boolean;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items: CacheDto[];

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[];
}

export class CacheDto implements ICacheDto {
    name: string;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string;
}

export class StatsFilter implements IStatsFilter {
    forecastModelId: number;
    showResolvedComments: boolean = false;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];

    constructor(data?: IStatsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.showResolvedComments = data["showResolvedComments"] !== undefined ? data["showResolvedComments"] : false;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsFilter {
        let result = new StatsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["showResolvedComments"] = this.showResolvedComments;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsFilter {
    forecastModelId: number;
    showResolvedComments: boolean;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];
}

export class CashFlowStatsDto implements ICashFlowStatsDto {
    transactionStats: TransactionStatsDto[];
    commentThreads: CashFlowCommentThreadDto[];

    constructor(data?: ICashFlowStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionStats"] && data["transactionStats"].constructor === Array) {
                this.transactionStats = [];
                for (let item of data["transactionStats"])
                    this.transactionStats.push(TransactionStatsDto.fromJS(item));
            }
            if (data["commentThreads"] && data["commentThreads"].constructor === Array) {
                this.commentThreads = [];
                for (let item of data["commentThreads"])
                    this.commentThreads.push(CashFlowCommentThreadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowStatsDto {
        let result = new CashFlowStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionStats && this.transactionStats.constructor === Array) {
            data["transactionStats"] = [];
            for (let item of this.transactionStats)
                data["transactionStats"].push(item.toJSON());
        }
        if (this.commentThreads && this.commentThreads.constructor === Array) {
            data["commentThreads"] = [];
            for (let item of this.commentThreads)
                data["commentThreads"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowStatsDto {
    transactionStats: TransactionStatsDto[];
    commentThreads: CashFlowCommentThreadDto[];
}

export class TransactionStatsDto implements ITransactionStatsDto {
    adjustmentType: TransactionStatsDtoAdjustmentType;
    cashflowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    accountId: number;
    currencyId: string;
    date: moment.Moment;
    amount: number;
    count: number;
    comment: string;
    forecastId: number;

    constructor(data?: ITransactionStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adjustmentType = data["adjustmentType"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            this.currencyId = data["currencyId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.count = data["count"];
            this.comment = data["comment"];
            this.forecastId = data["forecastId"];
        }
    }

    static fromJS(data: any): TransactionStatsDto {
        let result = new TransactionStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        data["currencyId"] = this.currencyId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["count"] = this.count;
        data["comment"] = this.comment;
        data["forecastId"] = this.forecastId;
        return data; 
    }
}

export interface ITransactionStatsDto {
    adjustmentType: TransactionStatsDtoAdjustmentType;
    cashflowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    accountId: number;
    currencyId: string;
    date: moment.Moment;
    amount: number;
    count: number;
    comment: string;
    forecastId: number;
}

export class CashFlowCommentThreadDto implements ICashFlowCommentThreadDto {
    threadId: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    cashFlowTypeId: string;
    categoryId: number;
    transactionDescriptor: string;
    accountId: number;
    categorization: { [key: string] : string; };

    constructor(data?: ICashFlowCommentThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            if (data["categorization"]) {
                this.categorization = {};
                for (let key in data["categorization"]) {
                    if (data["categorization"].hasOwnProperty(key))
                        this.categorization[key] = data["categorization"][key];
                }
            }
        }
    }

    static fromJS(data: any): CashFlowCommentThreadDto {
        let result = new CashFlowCommentThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        if (this.categorization) {
            data["categorization"] = {};
            for (let key in this.categorization) {
                if (this.categorization.hasOwnProperty(key))
                    data["categorization"][key] = this.categorization[key];
            }
        }
        return data; 
    }
}

export interface ICashFlowCommentThreadDto {
    threadId: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    cashFlowTypeId: string;
    categoryId: number;
    transactionDescriptor: string;
    accountId: number;
    categorization: { [key: string] : string; };
}

export class CashFlowInitialData implements ICashFlowInitialData {
    banks: BankDto[];
    businessEntities: BusinessEntityDto[];
    cashflowTypes: { [key: string] : string; };
    bankAccountBalances: BankAccountBalanceDto[];

    constructor(data?: ICashFlowInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(BusinessEntityDto.fromJS(item));
            }
            if (data["cashflowTypes"]) {
                this.cashflowTypes = {};
                for (let key in data["cashflowTypes"]) {
                    if (data["cashflowTypes"].hasOwnProperty(key))
                        this.cashflowTypes[key] = data["cashflowTypes"][key];
                }
            }
            if (data["bankAccountBalances"] && data["bankAccountBalances"].constructor === Array) {
                this.bankAccountBalances = [];
                for (let item of data["bankAccountBalances"])
                    this.bankAccountBalances.push(BankAccountBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowInitialData {
        let result = new CashFlowInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        if (this.cashflowTypes) {
            data["cashflowTypes"] = {};
            for (let key in this.cashflowTypes) {
                if (this.cashflowTypes.hasOwnProperty(key))
                    data["cashflowTypes"][key] = this.cashflowTypes[key];
            }
        }
        if (this.bankAccountBalances && this.bankAccountBalances.constructor === Array) {
            data["bankAccountBalances"] = [];
            for (let item of this.bankAccountBalances)
                data["bankAccountBalances"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowInitialData {
    banks: BankDto[];
    businessEntities: BusinessEntityDto[];
    cashflowTypes: { [key: string] : string; };
    bankAccountBalances: BankAccountBalanceDto[];
}

export class BankDto implements IBankDto {
    id: number;
    name: string;
    bankAccounts: BankAccountDto[];

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankDto {
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBankDto {
    id: number;
    name: string;
    bankAccounts: BankAccountDto[];
}

export class BusinessEntityDto implements IBusinessEntityDto {
    id: number;
    name: string;

    constructor(data?: IBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BusinessEntityDto {
        let result = new BusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBusinessEntityDto {
    id: number;
    name: string;
}

export class BankAccountBalanceDto implements IBankAccountBalanceDto {
    bankAccountId: number;
    currencyId: string;
    balance: number;
    balanceDate: moment.Moment;
    isActive: boolean;
    reconciledBalance: number;

    constructor(data?: IBankAccountBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.currencyId = data["currencyId"];
            this.balance = data["balance"];
            this.balanceDate = data["balanceDate"] ? moment(data["balanceDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.reconciledBalance = data["reconciledBalance"];
        }
    }

    static fromJS(data: any): BankAccountBalanceDto {
        let result = new BankAccountBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["currencyId"] = this.currencyId;
        data["balance"] = this.balance;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["reconciledBalance"] = this.reconciledBalance;
        return data; 
    }
}

export interface IBankAccountBalanceDto {
    bankAccountId: number;
    currencyId: string;
    balance: number;
    balanceDate: moment.Moment;
    isActive: boolean;
    reconciledBalance: number;
}

export class BankAccountDto implements IBankAccountDto {
    id: number;
    accountName: string;
    accountNumber: string;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        return data; 
    }
}

export interface IBankAccountDto {
    id: number;
    accountName: string;
    accountNumber: string;
}

export class StatsDetailFilter implements IStatsDetailFilter {
    searchTerm: string;
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];

    constructor(data?: IStatsDetailFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchTerm = data["searchTerm"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilter {
        let result = new StatsDetailFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilter {
    searchTerm: string;
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];
}

export class CashFlowStatsDetailDto implements ICashFlowStatsDetailDto {
    id: number;
    date: moment.Moment;
    currencyId: string;
    credit: number;
    debit: number;
    description: string;
    comment: string;
    commentThreadId: number;

    constructor(data?: ICashFlowStatsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            this.credit = data["credit"];
            this.debit = data["debit"];
            this.description = data["description"];
            this.comment = data["comment"];
            this.commentThreadId = data["commentThreadId"];
        }
    }

    static fromJS(data: any): CashFlowStatsDetailDto {
        let result = new CashFlowStatsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["credit"] = this.credit;
        data["debit"] = this.debit;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["commentThreadId"] = this.commentThreadId;
        return data; 
    }
}

export interface ICashFlowStatsDetailDto {
    id: number;
    date: moment.Moment;
    currencyId: string;
    credit: number;
    debit: number;
    description: string;
    comment: string;
    commentThreadId: number;
}

export class CashFlowGridSettingsDto implements ICashFlowGridSettingsDto {
    general: CashflowGridGeneralSettingsDto = new CashflowGridGeneralSettingsDto();
    visualPreferences: CashflowGridVisualSettingsDto = new CashflowGridVisualSettingsDto();
    localizationAndCurrency: LocalizationAndCurrencyDto = new LocalizationAndCurrencyDto();

    constructor(data?: ICashFlowGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? CashflowGridGeneralSettingsDto.fromJS(data["general"]) : new CashflowGridGeneralSettingsDto();
            this.visualPreferences = data["visualPreferences"] ? CashflowGridVisualSettingsDto.fromJS(data["visualPreferences"]) : new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = data["localizationAndCurrency"] ? LocalizationAndCurrencyDto.fromJS(data["localizationAndCurrency"]) : new LocalizationAndCurrencyDto();
        }
    }

    static fromJS(data: any): CashFlowGridSettingsDto {
        let result = new CashFlowGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["visualPreferences"] = this.visualPreferences ? this.visualPreferences.toJSON() : <any>undefined;
        data["localizationAndCurrency"] = this.localizationAndCurrency ? this.localizationAndCurrency.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICashFlowGridSettingsDto {
    general: CashflowGridGeneralSettingsDto;
    visualPreferences: CashflowGridVisualSettingsDto;
    localizationAndCurrency: LocalizationAndCurrencyDto;
}

export class CashflowGridGeneralSettingsDto implements ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals: number;
    hideZeroValuesInCells: number;
    showNegativeValuesInRed: number;
    showColumnsWithZeroActivity: CashflowGridGeneralSettingsDtoShowColumnsWithZeroActivity;
    showNetChangeRow: boolean;

    constructor(data?: ICashflowGridGeneralSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.showAmountsWithDecimals = data["showAmountsWithDecimals"];
            this.hideZeroValuesInCells = data["hideZeroValuesInCells"];
            this.showNegativeValuesInRed = data["showNegativeValuesInRed"];
            this.showColumnsWithZeroActivity = data["showColumnsWithZeroActivity"];
            this.showNetChangeRow = data["showNetChangeRow"];
        }
    }

    static fromJS(data: any): CashflowGridGeneralSettingsDto {
        let result = new CashflowGridGeneralSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAmountsWithDecimals"] = this.showAmountsWithDecimals;
        data["hideZeroValuesInCells"] = this.hideZeroValuesInCells;
        data["showNegativeValuesInRed"] = this.showNegativeValuesInRed;
        data["showColumnsWithZeroActivity"] = this.showColumnsWithZeroActivity;
        data["showNetChangeRow"] = this.showNetChangeRow;
        return data; 
    }
}

export interface ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals: number;
    hideZeroValuesInCells: number;
    showNegativeValuesInRed: number;
    showColumnsWithZeroActivity: CashflowGridGeneralSettingsDtoShowColumnsWithZeroActivity;
    showNetChangeRow: boolean;
}

export class CashflowGridVisualSettingsDto implements ICashflowGridVisualSettingsDto {
    fontName: string;
    fontSize: string;
    cfoTheme: string;

    constructor(data?: ICashflowGridVisualSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fontName = data["fontName"];
            this.fontSize = data["fontSize"];
            this.cfoTheme = data["cfoTheme"];
        }
    }

    static fromJS(data: any): CashflowGridVisualSettingsDto {
        let result = new CashflowGridVisualSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fontName"] = this.fontName;
        data["fontSize"] = this.fontSize;
        data["cfoTheme"] = this.cfoTheme;
        return data; 
    }
}

export interface ICashflowGridVisualSettingsDto {
    fontName: string;
    fontSize: string;
    cfoTheme: string;
}

export class LocalizationAndCurrencyDto implements ILocalizationAndCurrencyDto {
    numberFormatting: string;

    constructor(data?: ILocalizationAndCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.numberFormatting = data["numberFormatting"];
        }
    }

    static fromJS(data: any): LocalizationAndCurrencyDto {
        let result = new LocalizationAndCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberFormatting"] = this.numberFormatting;
        return data; 
    }
}

export interface ILocalizationAndCurrencyDto {
    numberFormatting: string;
}

export class ForecastModelDto implements IForecastModelDto {
    id: number;
    name: string;

    constructor(data?: IForecastModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ForecastModelDto {
        let result = new ForecastModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IForecastModelDto {
    id: number;
    name: string;
}

export class AddForecastInput implements IAddForecastInput {
    forecastModelId: number;
    bankAccountId: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    cashFlowTypeId: string;
    categoryId: number;
    currencyId: string;
    amount: number;

    constructor(data?: IAddForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.bankAccountId = data["bankAccountId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.categoryId = data["categoryId"];
            this.currencyId = data["currencyId"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): AddForecastInput {
        let result = new AddForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["bankAccountId"] = this.bankAccountId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["categoryId"] = this.categoryId;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IAddForecastInput {
    forecastModelId: number;
    bankAccountId: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    cashFlowTypeId: string;
    categoryId: number;
    currencyId: string;
    amount: number;
}

export class UpdateForecastInput implements IUpdateForecastInput {
    id: number;
    amount: number;

    constructor(data?: IUpdateForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): UpdateForecastInput {
        let result = new UpdateForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IUpdateForecastInput {
    id: number;
    amount: number;
}

export class CreateForecastScheduleDto implements ICreateForecastScheduleDto {
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[] = [];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: CreateForecastScheduleDtoWeekDayNumber;

    constructor(data?: ICreateForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.categoryId = data["categoryId"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): CreateForecastScheduleDto {
        let result = new CreateForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface ICreateForecastScheduleDto {
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: CreateForecastScheduleDtoWeekDayNumber;
}

export class UpdateForecastScheduleInput implements IUpdateForecastScheduleInput {
    id: number;
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[] = [];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: UpdateForecastScheduleInputWeekDayNumber;

    constructor(data?: IUpdateForecastScheduleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.categoryId = data["categoryId"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): UpdateForecastScheduleInput {
        let result = new UpdateForecastScheduleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IUpdateForecastScheduleInput {
    id: number;
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: UpdateForecastScheduleInputWeekDayNumber;
}

export class ForecastScheduleDto implements IForecastScheduleDto {
    id: number;
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: ForecastScheduleDtoWeekDayNumber;

    constructor(data?: IForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.categoryId = data["categoryId"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): ForecastScheduleDto {
        let result = new ForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IForecastScheduleDto {
    id: number;
    bankAccountId: number;
    categoryId: number;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    endDate: moment.Moment;
    calculationTypeId: string;
    amount: number;
    monthNumber: number;
    weekNumber: number;
    dayNumber: number;
    weekDayNumber: ForecastScheduleDtoWeekDayNumber;
}

export class CreateForecastModelInput implements ICreateForecastModelInput {
    name: string;

    constructor(data?: ICreateForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateForecastModelInput {
        let result = new CreateForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateForecastModelInput {
    name: string;
}

export class RenameForecastModelInput implements IRenameForecastModelInput {
    id: number;
    newName: string;

    constructor(data?: IRenameForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): RenameForecastModelInput {
        let result = new RenameForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IRenameForecastModelInput {
    id: number;
    newName: string;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[];

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[];
}

export class FriendDto implements IFriendDto {
    friendUserId: number;
    friendTenantId: number;
    friendUserName: string;
    friendTenancyName: string;
    friendProfilePictureId: string;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendDtoState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number;
    friendUserName: string;
    friendTenancyName: string;
    friendProfilePictureId: string;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendDtoState;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[];

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[];
}

export class ChatMessageDto implements IChatMessageDto {
    userId: number;
    tenantId: number;
    targetUserId: number;
    targetTenantId: number;
    side: ChatMessageDtoSide;
    readState: ChatMessageDtoReadState;
    receiverReadState: ChatMessageDtoReceiverReadState;
    message: string;
    creationTime: moment.Moment;
    sharedMessageId: string;
    id: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number;
    targetUserId: number;
    targetTenantId: number;
    side: ChatMessageDtoSide;
    readState: ChatMessageDtoReadState;
    receiverReadState: ChatMessageDtoReceiverReadState;
    message: string;
    creationTime: moment.Moment;
    sharedMessageId: string;
    id: number;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number;
    userId: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number;
    userId: number;
}

export class GetCategoryTreeOutput implements IGetCategoryTreeOutput {
    types: { [key: string] : TypeDto; };
    accountingTypes: { [key: string] : AccountingTypeDto; };
    categories: { [key: string] : CategoryDto; };

    constructor(data?: IGetCategoryTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"]) {
                this.types = {};
                for (let key in data["types"]) {
                    if (data["types"].hasOwnProperty(key))
                        this.types[key] = data["types"][key] ? TypeDto.fromJS(data["types"][key]) : new TypeDto();
                }
            }
            if (data["accountingTypes"]) {
                this.accountingTypes = {};
                for (let key in data["accountingTypes"]) {
                    if (data["accountingTypes"].hasOwnProperty(key))
                        this.accountingTypes[key] = data["accountingTypes"][key] ? AccountingTypeDto.fromJS(data["accountingTypes"][key]) : new AccountingTypeDto();
                }
            }
            if (data["categories"]) {
                this.categories = {};
                for (let key in data["categories"]) {
                    if (data["categories"].hasOwnProperty(key))
                        this.categories[key] = data["categories"][key] ? CategoryDto.fromJS(data["categories"][key]) : new CategoryDto();
                }
            }
        }
    }

    static fromJS(data: any): GetCategoryTreeOutput {
        let result = new GetCategoryTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    data["types"][key] = this.types[key];
            }
        }
        if (this.accountingTypes) {
            data["accountingTypes"] = {};
            for (let key in this.accountingTypes) {
                if (this.accountingTypes.hasOwnProperty(key))
                    data["accountingTypes"][key] = this.accountingTypes[key];
            }
        }
        if (this.categories) {
            data["categories"] = {};
            for (let key in this.categories) {
                if (this.categories.hasOwnProperty(key))
                    data["categories"][key] = this.categories[key];
            }
        }
        return data; 
    }
}

export interface IGetCategoryTreeOutput {
    types: { [key: string] : TypeDto; };
    accountingTypes: { [key: string] : AccountingTypeDto; };
    categories: { [key: string] : CategoryDto; };
}

export class TypeDto implements ITypeDto {
    name: string;

    constructor(data?: ITypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TypeDto {
        let result = new TypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ITypeDto {
    name: string;
}

export class AccountingTypeDto implements IAccountingTypeDto {
    typeId: string;
    name: string;

    constructor(data?: IAccountingTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AccountingTypeDto {
        let result = new AccountingTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAccountingTypeDto {
    typeId: string;
    name: string;
}

export class CategoryDto implements ICategoryDto {
    accountingTypeId: number;
    parentId: number;
    name: string;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CategoryDto {
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategoryDto {
    accountingTypeId: number;
    parentId: number;
    name: string;
}

export class RuleDto implements IRuleDto {
    parentId: number;
    name: string;
    categoryId: number;
    creationTime: moment.Moment;
    sortOrder: number;
    isActive: boolean;
    transactionCount: number;
    id: number;

    constructor(data?: IRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sortOrder = data["sortOrder"];
            this.isActive = data["isActive"];
            this.transactionCount = data["transactionCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RuleDto {
        let result = new RuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        data["transactionCount"] = this.transactionCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRuleDto {
    parentId: number;
    name: string;
    categoryId: number;
    creationTime: moment.Moment;
    sortOrder: number;
    isActive: boolean;
    transactionCount: number;
    id: number;
}

export class CreateRuleDto implements ICreateRuleDto {
    parentId: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string;
    transactionDescriptorAttributeTypeId: string;
    condition: ConditionDto = new ConditionDto();
    sourceTransactionList: number[];
    applyOption: CreateRuleDtoApplyOption;

    constructor(data?: ICreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): CreateRuleDto {
        let result = new CreateRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface ICreateRuleDto {
    parentId: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string;
    transactionDescriptorAttributeTypeId: string;
    condition: ConditionDto;
    sourceTransactionList: number[];
    applyOption: CreateRuleDtoApplyOption;
}

export class ConditionDto implements IConditionDto {
    minAmount: number;
    maxAmount: number;
    cashFlowAmountFormat: ConditionDtoCashFlowAmountFormat;
    bankId: number;
    bankAccountId: number;
    transactionCategoryId: string;
    descriptionWords: string;
    attributes: { [key: string] : ConditionAttributeDto; };
    transactionTypes: string[];

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minAmount = data["minAmount"];
            this.maxAmount = data["maxAmount"];
            this.cashFlowAmountFormat = data["cashFlowAmountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.descriptionWords = data["descriptionWords"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? ConditionAttributeDto.fromJS(data["attributes"][key]) : new ConditionAttributeDto();
                }
            }
            if (data["transactionTypes"] && data["transactionTypes"].constructor === Array) {
                this.transactionTypes = [];
                for (let item of data["transactionTypes"])
                    this.transactionTypes.push(item);
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["cashFlowAmountFormat"] = this.cashFlowAmountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["descriptionWords"] = this.descriptionWords;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        if (this.transactionTypes && this.transactionTypes.constructor === Array) {
            data["transactionTypes"] = [];
            for (let item of this.transactionTypes)
                data["transactionTypes"].push(item);
        }
        return data; 
    }
}

export interface IConditionDto {
    minAmount: number;
    maxAmount: number;
    cashFlowAmountFormat: ConditionDtoCashFlowAmountFormat;
    bankId: number;
    bankAccountId: number;
    transactionCategoryId: string;
    descriptionWords: string;
    attributes: { [key: string] : ConditionAttributeDto; };
    transactionTypes: string[];
}

export class ConditionAttributeDto implements IConditionAttributeDto {
    attributeTypeId: string;
    conditionTypeId: ConditionAttributeDtoConditionTypeId;
    conditionValue: string;

    constructor(data?: IConditionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeTypeId = data["attributeTypeId"];
            this.conditionTypeId = data["conditionTypeId"];
            this.conditionValue = data["conditionValue"];
        }
    }

    static fromJS(data: any): ConditionAttributeDto {
        let result = new ConditionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        data["conditionTypeId"] = this.conditionTypeId;
        data["conditionValue"] = this.conditionValue;
        return data; 
    }
}

export interface IConditionAttributeDto {
    attributeTypeId: string;
    conditionTypeId: ConditionAttributeDtoConditionTypeId;
    conditionValue: string;
}

export class EditRuleDto implements IEditRuleDto {
    id: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string;
    transactionDescriptorAttributeTypeId: string;
    condition: ConditionDto = new ConditionDto();
    sourceTransactionList: number[];
    applyOption: EditRuleDtoApplyOption;

    constructor(data?: IEditRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): EditRuleDto {
        let result = new EditRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface IEditRuleDto {
    id: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string;
    transactionDescriptorAttributeTypeId: string;
    condition: ConditionDto;
    sourceTransactionList: number[];
    applyOption: EditRuleDtoApplyOption;
}

export class MoveRuleDto implements IMoveRuleDto {
    parentId: number;
    sortOrder: number;
    isRecategorize: boolean;
    sourceTransactionList: number[];
    applyOption: MoveRuleDtoApplyOption;
    id: number;

    constructor(data?: IMoveRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.sortOrder = data["sortOrder"];
            this.isRecategorize = data["isRecategorize"];
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MoveRuleDto {
        let result = new MoveRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isRecategorize"] = this.isRecategorize;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMoveRuleDto {
    parentId: number;
    sortOrder: number;
    isRecategorize: boolean;
    sourceTransactionList: number[];
    applyOption: MoveRuleDtoApplyOption;
    id: number;
}

export class AddMappingDto implements IAddMappingDto {
    oldName: string;
    newName: string;

    constructor(data?: IAddMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldName = data["oldName"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): AddMappingDto {
        let result = new AddMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldName"] = this.oldName;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IAddMappingDto {
    oldName: string;
    newName: string;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    accountingTypeId: number;
    parentId: number;
    name: string;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateCategoryInput {
    accountingTypeId: number;
    parentId: number;
    name: string;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    id: number;
    name: string;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateCategoryInput {
    id: number;
    name: string;
}

export class RecategorizeInput implements IRecategorizeInput {
    parseDescription: boolean;
    bankAccountIds: number[];
    startDate: moment.Moment;
    endDate: moment.Moment;
    ruleId: number;

    constructor(data?: IRecategorizeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parseDescription = data["parseDescription"];
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.ruleId = data["ruleId"];
        }
    }

    static fromJS(data: any): RecategorizeInput {
        let result = new RecategorizeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parseDescription"] = this.parseDescription;
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ruleId"] = this.ruleId;
        return data; 
    }
}

export interface IRecategorizeInput {
    parseDescription: boolean;
    bankAccountIds: number[];
    startDate: moment.Moment;
    endDate: moment.Moment;
    ruleId: number;
}

export class ResetClassificationDto implements IResetClassificationDto {
    removeForecasts: boolean = false;
    removeRules: boolean = false;
    removeCategoryTree: boolean = false;
    recalculateTransactionAttributes: boolean = false;

    constructor(data?: IResetClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.removeForecasts = data["removeForecasts"] !== undefined ? data["removeForecasts"] : false;
            this.removeRules = data["removeRules"] !== undefined ? data["removeRules"] : false;
            this.removeCategoryTree = data["removeCategoryTree"] !== undefined ? data["removeCategoryTree"] : false;
            this.recalculateTransactionAttributes = data["recalculateTransactionAttributes"] !== undefined ? data["recalculateTransactionAttributes"] : false;
        }
    }

    static fromJS(data: any): ResetClassificationDto {
        let result = new ResetClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["removeForecasts"] = this.removeForecasts;
        data["removeRules"] = this.removeRules;
        data["removeCategoryTree"] = this.removeCategoryTree;
        data["recalculateTransactionAttributes"] = this.recalculateTransactionAttributes;
        return data; 
    }
}

export interface IResetClassificationDto {
    removeForecasts: boolean;
    removeRules: boolean;
    removeCategoryTree: boolean;
    recalculateTransactionAttributes: boolean;
}

export class UpdateTransactionsCategoryInput implements IUpdateTransactionsCategoryInput {
    transactionIds: number[];
    categoryId: number;
    standardDescriptor: string;
    descriptorAttributeTypeId: string;

    constructor(data?: IUpdateTransactionsCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
            this.categoryId = data["categoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryInput {
        let result = new UpdateTransactionsCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryInput {
    transactionIds: number[];
    categoryId: number;
    standardDescriptor: string;
    descriptorAttributeTypeId: string;
}

export class UpdateTransactionsCategoryWithFilterInput implements IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter: StatsDetailFilterBase;
    destinationCategoryId: number;
    standardDescriptor: string;
    descriptorAttributeTypeId: string;

    constructor(data?: IUpdateTransactionsCategoryWithFilterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionFilter = data["transactionFilter"] ? StatsDetailFilterBase.fromJS(data["transactionFilter"]) : <any>undefined;
            this.destinationCategoryId = data["destinationCategoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryWithFilterInput {
        let result = new UpdateTransactionsCategoryWithFilterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionFilter"] = this.transactionFilter ? this.transactionFilter.toJSON() : <any>undefined;
        data["destinationCategoryId"] = this.destinationCategoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter: StatsDetailFilterBase;
    destinationCategoryId: number;
    standardDescriptor: string;
    descriptorAttributeTypeId: string;
}

export class StatsDetailFilterBase implements IStatsDetailFilterBase {
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];

    constructor(data?: IStatsDetailFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilterBase {
        let result = new StatsDetailFilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilterBase {
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];
}

export class GetTransactionCommonDetailsInput implements IGetTransactionCommonDetailsInput {
    transactionIds: number[];

    constructor(data?: IGetTransactionCommonDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetTransactionCommonDetailsInput {
        let result = new GetTransactionCommonDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data; 
    }
}

export interface IGetTransactionCommonDetailsInput {
    transactionIds: number[];
}

export class TransactionCommonDetailsDto implements ITransactionCommonDetailsDto {
    amountFormat: TransactionCommonDetailsDtoAmountFormat;
    bankId: number;
    bankAccountId: number;
    standardDescriptor: string;
    transactionCategoryId: string;
    transactionTypeId: string;
    descriptionPhrases: string[];
    attributes: TransactionAttributeDto[];
    sourceTransactionsAreMatchingExistingRules: boolean;

    constructor(data?: ITransactionCommonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amountFormat = data["amountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.transactionTypeId = data["transactionTypeId"];
            if (data["descriptionPhrases"] && data["descriptionPhrases"].constructor === Array) {
                this.descriptionPhrases = [];
                for (let item of data["descriptionPhrases"])
                    this.descriptionPhrases.push(item);
            }
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
            this.sourceTransactionsAreMatchingExistingRules = data["sourceTransactionsAreMatchingExistingRules"];
        }
    }

    static fromJS(data: any): TransactionCommonDetailsDto {
        let result = new TransactionCommonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountFormat"] = this.amountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["transactionTypeId"] = this.transactionTypeId;
        if (this.descriptionPhrases && this.descriptionPhrases.constructor === Array) {
            data["descriptionPhrases"] = [];
            for (let item of this.descriptionPhrases)
                data["descriptionPhrases"].push(item);
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["sourceTransactionsAreMatchingExistingRules"] = this.sourceTransactionsAreMatchingExistingRules;
        return data; 
    }
}

export interface ITransactionCommonDetailsDto {
    amountFormat: TransactionCommonDetailsDtoAmountFormat;
    bankId: number;
    bankAccountId: number;
    standardDescriptor: string;
    transactionCategoryId: string;
    transactionTypeId: string;
    descriptionPhrases: string[];
    attributes: TransactionAttributeDto[];
    sourceTransactionsAreMatchingExistingRules: boolean;
}

export class TransactionAttributeDto implements ITransactionAttributeDto {
    typeId: string;
    value: string;

    constructor(data?: ITransactionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TransactionAttributeDto {
        let result = new TransactionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITransactionAttributeDto {
    typeId: string;
    value: string;
}

export class AutoClassifyDto implements IAutoClassifyDto {
    bankAccountIds: number[];

    constructor(data?: IAutoClassifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
        }
    }

    static fromJS(data: any): AutoClassifyDto {
        let result = new AutoClassifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        return data; 
    }
}

export interface IAutoClassifyDto {
    bankAccountIds: number[];
}

export class ChangeCategoryForRulesInput implements IChangeCategoryForRulesInput {
    ruleIds: number[];
    categotyId: number;
    reclassifyTransactions: boolean = false;

    constructor(data?: IChangeCategoryForRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ruleIds"] && data["ruleIds"].constructor === Array) {
                this.ruleIds = [];
                for (let item of data["ruleIds"])
                    this.ruleIds.push(item);
            }
            this.categotyId = data["categotyId"];
            this.reclassifyTransactions = data["reclassifyTransactions"] !== undefined ? data["reclassifyTransactions"] : false;
        }
    }

    static fromJS(data: any): ChangeCategoryForRulesInput {
        let result = new ChangeCategoryForRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleIds && this.ruleIds.constructor === Array) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["categotyId"] = this.categotyId;
        data["reclassifyTransactions"] = this.reclassifyTransactions;
        return data; 
    }
}

export interface IChangeCategoryForRulesInput {
    ruleIds: number[];
    categotyId: number;
    reclassifyTransactions: boolean;
}

export class CommentDto implements ICommentDto {
    threadId: number;
    comment: string;
    createdByUser: UserKeyInfo;
    creationTime: moment.Moment;
    updatedByUser: UserKeyInfo;
    lastModificationTime: moment.Moment;
    id: number;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
            this.createdByUser = data["createdByUser"] ? UserKeyInfo.fromJS(data["createdByUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.updatedByUser = data["updatedByUser"] ? UserKeyInfo.fromJS(data["updatedByUser"]) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICommentDto {
    threadId: number;
    comment: string;
    createdByUser: UserKeyInfo;
    creationTime: moment.Moment;
    updatedByUser: UserKeyInfo;
    lastModificationTime: moment.Moment;
    id: number;
}

export class UserKeyInfo implements IUserKeyInfo {
    id: number;
    userName: string;
    fullName: string;

    constructor(data?: IUserKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UserKeyInfo {
        let result = new UserKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUserKeyInfo {
    id: number;
    userName: string;
    fullName: string;
}

export class CreateCommentInput implements ICreateCommentInput {
    threadId: number;
    comment: string;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateCommentInput {
    threadId: number;
    comment: string;
}

export class CreateCommentOutput implements ICreateCommentOutput {
    id: number;

    constructor(data?: ICreateCommentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCommentOutput {
        let result = new CreateCommentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCommentOutput {
    id: number;
}

export class UpdateCommentInput implements IUpdateCommentInput {
    comment: string;
    id: number;

    constructor(data?: IUpdateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentInput {
        let result = new UpdateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateCommentInput {
    comment: string;
    id: number;
}

export class CreateTransactionCommentThreadInput implements ICreateTransactionCommentThreadInput {
    transactionId: number;
    comment: string;

    constructor(data?: ICreateTransactionCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadInput {
        let result = new CreateTransactionCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadInput {
    transactionId: number;
    comment: string;
}

export class CreateTransactionCommentThreadOutput implements ICreateTransactionCommentThreadOutput {
    threadId: number;
    id: number;

    constructor(data?: ICreateTransactionCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadOutput {
        let result = new CreateTransactionCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadOutput {
    threadId: number;
    id: number;
}

export class CreateCashFlowCommentThreadInput implements ICreateCashFlowCommentThreadInput {
    accountId: number;
    comment: string;
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];

    constructor(data?: ICreateCashFlowCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.comment = data["comment"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadInput {
        let result = new CreateCashFlowCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["comment"] = this.comment;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadInput {
    accountId: number;
    comment: string;
    cashFlowTypeId: string;
    accountingTypeId: number;
    categoryId: number;
    subCategoryId: number;
    transactionDescriptor: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    currencyId: string;
    bankIds: number[];
    accountIds: number[];
    businessEntityIds: number[];
}

export class CreateCashFlowCommentThreadOutput implements ICreateCashFlowCommentThreadOutput {
    threadId: number;
    id: number;

    constructor(data?: ICreateCashFlowCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadOutput {
        let result = new CreateCashFlowCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadOutput {
    threadId: number;
    id: number;
}

export class SetResolvedInput implements ISetResolvedInput {
    threadId: number;
    isResolved: boolean;

    constructor(data?: ISetResolvedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.isResolved = data["isResolved"];
        }
    }

    static fromJS(data: any): SetResolvedInput {
        let result = new SetResolvedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["isResolved"] = this.isResolved;
        return data; 
    }
}

export interface ISetResolvedInput {
    threadId: number;
    isResolved: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[];

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[];
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean;
    value: string;
    displayText: string;
    isSelected: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean;
    value: string;
    displayText: string;
    isSelected: boolean;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[];

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[];
}

export class NameValueDto implements INameValueDto {
    name: string;
    value: string;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string;
    value: string;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string;
}

export class CreateContactAddressInput implements ICreateContactAddressInput {
    contactId: number;
    streetAddress: string;
    city: string;
    stateId: string;
    zip: string;
    countryId: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
    ownershipTypeId: string;

    constructor(data?: ICreateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
        }
    }

    static fromJS(data: any): CreateContactAddressInput {
        let result = new CreateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        return data; 
    }
}

export interface ICreateContactAddressInput {
    contactId: number;
    streetAddress: string;
    city: string;
    stateId: string;
    zip: string;
    countryId: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
    ownershipTypeId: string;
}

export class CreateContactAddressOutput implements ICreateContactAddressOutput {
    id: number;

    constructor(data?: ICreateContactAddressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactAddressOutput {
        let result = new CreateContactAddressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactAddressOutput {
    id: number;
}

export class UpdateContactAddressInput implements IUpdateContactAddressInput {
    id: number;
    contactId: number;
    streetAddress: string;
    city: string;
    stateId: string;
    zip: string;
    countryId: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
    ownershipTypeId: string;

    constructor(data?: IUpdateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactAddressInput {
        let result = new UpdateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        return data; 
    }
}

export interface IUpdateContactAddressInput {
    id: number;
    contactId: number;
    streetAddress: string;
    city: string;
    stateId: string;
    zip: string;
    countryId: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
    ownershipTypeId: string;
}

export class ListResultDtoOfAddressUsageTypeDto implements IListResultDtoOfAddressUsageTypeDto {
    items: AddressUsageTypeDto[];

    constructor(data?: IListResultDtoOfAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAddressUsageTypeDto {
        let result = new ListResultDtoOfAddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAddressUsageTypeDto {
    items: AddressUsageTypeDto[];
}

export class AddressUsageTypeDto implements IAddressUsageTypeDto {
    id: string;
    name: string;

    constructor(data?: IAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressUsageTypeDto {
        let result = new AddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAddressUsageTypeDto {
    id: string;
    name: string;
}

export class ListResultDtoOfAddressOwnershipTypeDto implements IListResultDtoOfAddressOwnershipTypeDto {
    items: AddressOwnershipTypeDto[];

    constructor(data?: IListResultDtoOfAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressOwnershipTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAddressOwnershipTypeDto {
        let result = new ListResultDtoOfAddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAddressOwnershipTypeDto {
    items: AddressOwnershipTypeDto[];
}

export class AddressOwnershipTypeDto implements IAddressOwnershipTypeDto {
    id: string;
    name: string;

    constructor(data?: IAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDto {
        let result = new AddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAddressOwnershipTypeDto {
    id: string;
    name: string;
}

export class GetContactBusinessOutput implements IGetContactBusinessOutput {
    contactBusinessInfo: ContactBusinessInfo;
    organizationBusinessInfo: OrganizationBusinessInfo;

    constructor(data?: IGetContactBusinessOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactBusinessInfo = data["contactBusinessInfo"] ? ContactBusinessInfo.fromJS(data["contactBusinessInfo"]) : <any>undefined;
            this.organizationBusinessInfo = data["organizationBusinessInfo"] ? OrganizationBusinessInfo.fromJS(data["organizationBusinessInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactBusinessOutput {
        let result = new GetContactBusinessOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactBusinessInfo"] = this.contactBusinessInfo ? this.contactBusinessInfo.toJSON() : <any>undefined;
        data["organizationBusinessInfo"] = this.organizationBusinessInfo ? this.organizationBusinessInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetContactBusinessOutput {
    contactBusinessInfo: ContactBusinessInfo;
    organizationBusinessInfo: OrganizationBusinessInfo;
}

export class ContactBusinessInfo implements IContactBusinessInfo {
    id: number;
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;

    constructor(data?: IContactBusinessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.relationTypeId = data["relationTypeId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.orgName = data["orgName"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.orgId = data["orgId"];
        }
    }

    static fromJS(data: any): ContactBusinessInfo {
        let result = new ContactBusinessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["relationTypeId"] = this.relationTypeId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["orgName"] = this.orgName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["orgId"] = this.orgId;
        return data; 
    }
}

export interface IContactBusinessInfo {
    id: number;
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;
}

export class OrganizationBusinessInfo implements IOrganizationBusinessInfo {
    name: string;
    typeName: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    ein: string;
    formedCountryId: string;
    formedStateId: string;
    formedDate: moment.Moment;
    annualRevenue: number;
    acceptCc: boolean;
    annualVolumesOnCards: number;
    productServicesSold: number;
    businessSicCode: number;
    phoneNumber: string;
    phoneExtension: string;

    constructor(data?: IOrganizationBusinessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.typeName = data["typeName"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.ein = data["ein"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.annualRevenue = data["annualRevenue"];
            this.acceptCc = data["acceptCc"];
            this.annualVolumesOnCards = data["annualVolumesOnCards"];
            this.productServicesSold = data["productServicesSold"];
            this.businessSicCode = data["businessSicCode"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
        }
    }

    static fromJS(data: any): OrganizationBusinessInfo {
        let result = new OrganizationBusinessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeName"] = this.typeName;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["ein"] = this.ein;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["annualRevenue"] = this.annualRevenue;
        data["acceptCc"] = this.acceptCc;
        data["annualVolumesOnCards"] = this.annualVolumesOnCards;
        data["productServicesSold"] = this.productServicesSold;
        data["businessSicCode"] = this.businessSicCode;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        return data; 
    }
}

export interface IOrganizationBusinessInfo {
    name: string;
    typeName: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    ein: string;
    formedCountryId: string;
    formedStateId: string;
    formedDate: moment.Moment;
    annualRevenue: number;
    acceptCc: boolean;
    annualVolumesOnCards: number;
    productServicesSold: number;
    businessSicCode: number;
    phoneNumber: string;
    phoneExtension: string;
}

export class CreateContactBusinessInput implements ICreateContactBusinessInput {
    contactBusinessCreateInfo: ContactBusinessCreateInfo = new ContactBusinessCreateInfo();

    constructor(data?: ICreateContactBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactBusinessCreateInfo = data["contactBusinessCreateInfo"] ? ContactBusinessCreateInfo.fromJS(data["contactBusinessCreateInfo"]) : new ContactBusinessCreateInfo();
        }
    }

    static fromJS(data: any): CreateContactBusinessInput {
        let result = new CreateContactBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactBusinessCreateInfo"] = this.contactBusinessCreateInfo ? this.contactBusinessCreateInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateContactBusinessInput {
    contactBusinessCreateInfo: ContactBusinessCreateInfo;
}

export class ContactBusinessCreateInfo implements IContactBusinessCreateInfo {
    personId: number;
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;

    constructor(data?: IContactBusinessCreateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.relationTypeId = data["relationTypeId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.orgName = data["orgName"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.orgId = data["orgId"];
        }
    }

    static fromJS(data: any): ContactBusinessCreateInfo {
        let result = new ContactBusinessCreateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["relationTypeId"] = this.relationTypeId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["orgName"] = this.orgName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["orgId"] = this.orgId;
        return data; 
    }
}

export interface IContactBusinessCreateInfo {
    personId: number;
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;
}

export class CreateContactBusinessOutput implements ICreateContactBusinessOutput {
    id: number;

    constructor(data?: ICreateContactBusinessOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactBusinessOutput {
        let result = new CreateContactBusinessOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactBusinessOutput {
    id: number;
}

export class UpdateContactBusinessInput implements IUpdateContactBusinessInput {
    id: number;
    contactBusinessEditInfo: ContactBusinessEditInfo = new ContactBusinessEditInfo();

    constructor(data?: IUpdateContactBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactBusinessEditInfo = data["contactBusinessEditInfo"] ? ContactBusinessEditInfo.fromJS(data["contactBusinessEditInfo"]) : new ContactBusinessEditInfo();
        }
    }

    static fromJS(data: any): UpdateContactBusinessInput {
        let result = new UpdateContactBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactBusinessEditInfo"] = this.contactBusinessEditInfo ? this.contactBusinessEditInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateContactBusinessInput {
    id: number;
    contactBusinessEditInfo: ContactBusinessEditInfo;
}

export class ContactBusinessEditInfo implements IContactBusinessEditInfo {
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;

    constructor(data?: IContactBusinessEditInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.relationTypeId = data["relationTypeId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.orgName = data["orgName"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.orgId = data["orgId"];
        }
    }

    static fromJS(data: any): ContactBusinessEditInfo {
        let result = new ContactBusinessEditInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relationTypeId"] = this.relationTypeId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["orgName"] = this.orgName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["orgId"] = this.orgId;
        return data; 
    }
}

export interface IContactBusinessEditInfo {
    relationTypeId: string;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    orgName: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    orgId: number;
}

export class PersonOrgRelationTypeDto implements IPersonOrgRelationTypeDto {
    id: string;
    name: string;
    isDeleted: boolean;

    constructor(data?: IPersonOrgRelationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isDeleted = data["isDeleted"];
        }
    }

    static fromJS(data: any): PersonOrgRelationTypeDto {
        let result = new PersonOrgRelationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IPersonOrgRelationTypeDto {
    id: string;
    name: string;
    isDeleted: boolean;
}

export class CreateContactEmailInput implements ICreateContactEmailInput {
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;

    constructor(data?: ICreateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInput {
        let result = new CreateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactEmailInput {
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
}

export class CreateContactEmailOutput implements ICreateContactEmailOutput {
    id: number;

    constructor(data?: ICreateContactEmailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactEmailOutput {
        let result = new CreateContactEmailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactEmailOutput {
    id: number;
}

export class UpdateContactEmailInput implements IUpdateContactEmailInput {
    id: number;
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;

    constructor(data?: IUpdateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactEmailInput {
        let result = new UpdateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactEmailInput {
    id: number;
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
}

export class ListResultDtoOfEmailUsageTypeDto implements IListResultDtoOfEmailUsageTypeDto {
    items: EmailUsageTypeDto[];

    constructor(data?: IListResultDtoOfEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EmailUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEmailUsageTypeDto {
        let result = new ListResultDtoOfEmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEmailUsageTypeDto {
    items: EmailUsageTypeDto[];
}

export class EmailUsageTypeDto implements IEmailUsageTypeDto {
    id: string;
    name: string;

    constructor(data?: IEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): EmailUsageTypeDto {
        let result = new EmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IEmailUsageTypeDto {
    id: string;
    name: string;
}

export class GetContactEmploymentOutput implements IGetContactEmploymentOutput {
    contactEmploymentInfo: ContactEmploymentInfo;
    organizationBusinessInfo: OrganizationBusinessInfo;

    constructor(data?: IGetContactEmploymentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactEmploymentInfo = data["contactEmploymentInfo"] ? ContactEmploymentInfo.fromJS(data["contactEmploymentInfo"]) : <any>undefined;
            this.organizationBusinessInfo = data["organizationBusinessInfo"] ? OrganizationBusinessInfo.fromJS(data["organizationBusinessInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactEmploymentOutput {
        let result = new GetContactEmploymentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactEmploymentInfo"] = this.contactEmploymentInfo ? this.contactEmploymentInfo.toJSON() : <any>undefined;
        data["organizationBusinessInfo"] = this.organizationBusinessInfo ? this.organizationBusinessInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetContactEmploymentOutput {
    contactEmploymentInfo: ContactEmploymentInfo;
    organizationBusinessInfo: OrganizationBusinessInfo;
}

export class ContactEmploymentInfo implements IContactEmploymentInfo {
    id: number;
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;

    constructor(data?: IContactEmploymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orgName = data["orgName"];
            this.orgId = data["orgId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.jobTitle = data["jobTitle"];
            this.supervisorName = data["supervisorName"];
            this.seniorManager = data["seniorManager"];
            this.workEmail = data["workEmail"];
            this.websiteUrl = data["websiteUrl"];
            this.monthlyIncome = data["monthlyIncome"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactEmploymentInfo {
        let result = new ContactEmploymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orgName"] = this.orgName;
        data["orgId"] = this.orgId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["jobTitle"] = this.jobTitle;
        data["supervisorName"] = this.supervisorName;
        data["seniorManager"] = this.seniorManager;
        data["workEmail"] = this.workEmail;
        data["websiteUrl"] = this.websiteUrl;
        data["monthlyIncome"] = this.monthlyIncome;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactEmploymentInfo {
    id: number;
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
}

export class CreateContactEmploymentInput implements ICreateContactEmploymentInput {
    contactEmploymentCreateInfo: ContactEmploymentCreateInfo = new ContactEmploymentCreateInfo();

    constructor(data?: ICreateContactEmploymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactEmploymentCreateInfo = data["contactEmploymentCreateInfo"] ? ContactEmploymentCreateInfo.fromJS(data["contactEmploymentCreateInfo"]) : new ContactEmploymentCreateInfo();
        }
    }

    static fromJS(data: any): CreateContactEmploymentInput {
        let result = new CreateContactEmploymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactEmploymentCreateInfo"] = this.contactEmploymentCreateInfo ? this.contactEmploymentCreateInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateContactEmploymentInput {
    contactEmploymentCreateInfo: ContactEmploymentCreateInfo;
}

export class ContactEmploymentCreateInfo implements IContactEmploymentCreateInfo {
    personId: number;
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;

    constructor(data?: IContactEmploymentCreateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.orgName = data["orgName"];
            this.orgId = data["orgId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.jobTitle = data["jobTitle"];
            this.supervisorName = data["supervisorName"];
            this.seniorManager = data["seniorManager"];
            this.workEmail = data["workEmail"];
            this.websiteUrl = data["websiteUrl"];
            this.monthlyIncome = data["monthlyIncome"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactEmploymentCreateInfo {
        let result = new ContactEmploymentCreateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["orgName"] = this.orgName;
        data["orgId"] = this.orgId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["jobTitle"] = this.jobTitle;
        data["supervisorName"] = this.supervisorName;
        data["seniorManager"] = this.seniorManager;
        data["workEmail"] = this.workEmail;
        data["websiteUrl"] = this.websiteUrl;
        data["monthlyIncome"] = this.monthlyIncome;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactEmploymentCreateInfo {
    personId: number;
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
}

export class CreateContactEmploymentOutput implements ICreateContactEmploymentOutput {
    id: number;

    constructor(data?: ICreateContactEmploymentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactEmploymentOutput {
        let result = new CreateContactEmploymentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactEmploymentOutput {
    id: number;
}

export class UpdateContactEmploymentInput implements IUpdateContactEmploymentInput {
    id: number;
    contactEmploymentEditInfo: ContactEmploymentEditInfo = new ContactEmploymentEditInfo();

    constructor(data?: IUpdateContactEmploymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactEmploymentEditInfo = data["contactEmploymentEditInfo"] ? ContactEmploymentEditInfo.fromJS(data["contactEmploymentEditInfo"]) : new ContactEmploymentEditInfo();
        }
    }

    static fromJS(data: any): UpdateContactEmploymentInput {
        let result = new UpdateContactEmploymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactEmploymentEditInfo"] = this.contactEmploymentEditInfo ? this.contactEmploymentEditInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateContactEmploymentInput {
    id: number;
    contactEmploymentEditInfo: ContactEmploymentEditInfo;
}

export class ContactEmploymentEditInfo implements IContactEmploymentEditInfo {
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;

    constructor(data?: IContactEmploymentEditInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orgName = data["orgName"];
            this.orgId = data["orgId"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.mobilePhoneNumber = data["mobilePhoneNumber"];
            this.jobTitle = data["jobTitle"];
            this.supervisorName = data["supervisorName"];
            this.seniorManager = data["seniorManager"];
            this.workEmail = data["workEmail"];
            this.websiteUrl = data["websiteUrl"];
            this.monthlyIncome = data["monthlyIncome"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactEmploymentEditInfo {
        let result = new ContactEmploymentEditInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orgName"] = this.orgName;
        data["orgId"] = this.orgId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["jobTitle"] = this.jobTitle;
        data["supervisorName"] = this.supervisorName;
        data["seniorManager"] = this.seniorManager;
        data["workEmail"] = this.workEmail;
        data["websiteUrl"] = this.websiteUrl;
        data["monthlyIncome"] = this.monthlyIncome;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactEmploymentEditInfo {
    orgName: string;
    orgId: number;
    countryId: string;
    stateId: string;
    city: string;
    streetAddress: string;
    zip: string;
    phoneNumber: string;
    phoneExtension: string;
    mobilePhoneNumber: string;
    jobTitle: string;
    supervisorName: string;
    seniorManager: string;
    workEmail: string;
    websiteUrl: string;
    monthlyIncome: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
}

export class CreateContactLinkInput implements ICreateContactLinkInput {
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    linkTypeId: string;

    constructor(data?: ICreateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): CreateContactLinkInput {
        let result = new CreateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface ICreateContactLinkInput {
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    linkTypeId: string;
}

export class CreateContactLinkOutput implements ICreateContactLinkOutput {
    id: number;

    constructor(data?: ICreateContactLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactLinkOutput {
        let result = new CreateContactLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactLinkOutput {
    id: number;
}

export class UpdateContactLinkInput implements IUpdateContactLinkInput {
    id: number;
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    linkTypeId: string;

    constructor(data?: IUpdateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactLinkInput {
        let result = new UpdateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        return data; 
    }
}

export interface IUpdateContactLinkInput {
    id: number;
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    linkTypeId: string;
}

export class ListResultDtoOfContactLinkTypeDto implements IListResultDtoOfContactLinkTypeDto {
    items: ContactLinkTypeDto[];

    constructor(data?: IListResultDtoOfContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactLinkTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfContactLinkTypeDto {
        let result = new ListResultDtoOfContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfContactLinkTypeDto {
    items: ContactLinkTypeDto[];
}

export class ContactLinkTypeDto implements IContactLinkTypeDto {
    id: string;
    name: string;
    isSocialNetwork: boolean;

    constructor(data?: IContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isSocialNetwork = data["isSocialNetwork"];
        }
    }

    static fromJS(data: any): ContactLinkTypeDto {
        let result = new ContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSocialNetwork"] = this.isSocialNetwork;
        return data; 
    }
}

export interface IContactLinkTypeDto {
    id: string;
    name: string;
    isSocialNetwork: boolean;
}

export class CreateContactPhoneInput implements ICreateContactPhoneInput {
    contactId: number;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;

    constructor(data?: ICreateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInput {
        let result = new CreateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactPhoneInput {
    contactId: number;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
}

export class CreateContactPhoneOutput implements ICreateContactPhoneOutput {
    id: number;

    constructor(data?: ICreateContactPhoneOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactPhoneOutput {
        let result = new CreateContactPhoneOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactPhoneOutput {
    id: number;
}

export class UpdateContactPhoneInput implements IUpdateContactPhoneInput {
    id: number;
    contactId: number;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;

    constructor(data?: IUpdateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactPhoneInput {
        let result = new UpdateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactPhoneInput {
    id: number;
    contactId: number;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string;
    usageTypeId: string;
}

export class ListResultDtoOfPhoneUsageTypeDto implements IListResultDtoOfPhoneUsageTypeDto {
    items: PhoneUsageTypeDto[];

    constructor(data?: IListResultDtoOfPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhoneUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPhoneUsageTypeDto {
        let result = new ListResultDtoOfPhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPhoneUsageTypeDto {
    items: PhoneUsageTypeDto[];
}

export class PhoneUsageTypeDto implements IPhoneUsageTypeDto {
    id: string;
    name: string;

    constructor(data?: IPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PhoneUsageTypeDto {
        let result = new PhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPhoneUsageTypeDto {
    id: string;
    name: string;
}

export class CountryDto implements ICountryDto {
    code: string;
    name: string;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryDto {
    code: string;
    name: string;
}

export class CountryStateDto implements ICountryStateDto {
    code: string;
    name: string;

    constructor(data?: ICountryStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryStateDto {
        let result = new CountryStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryStateDto {
    code: string;
    name: string;
}

export class CreditReportOutput implements ICreditReportOutput {
    memberExists: boolean;
    uncompletedPackageId: number;
    kbaPassed: boolean;
    creditReport: CreditReportDto;
    updatable: boolean;
    isPaymentDelayed: boolean;
    isSubscriptionCancelled: boolean;
    previousReportExists: boolean;
    memberFullName: string;
    providerCreatedDate: moment.Moment;

    constructor(data?: ICreditReportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberExists = data["memberExists"];
            this.uncompletedPackageId = data["uncompletedPackageId"];
            this.kbaPassed = data["kbaPassed"];
            this.creditReport = data["creditReport"] ? CreditReportDto.fromJS(data["creditReport"]) : <any>undefined;
            this.updatable = data["updatable"];
            this.isPaymentDelayed = data["isPaymentDelayed"];
            this.isSubscriptionCancelled = data["isSubscriptionCancelled"];
            this.previousReportExists = data["previousReportExists"];
            this.memberFullName = data["memberFullName"];
            this.providerCreatedDate = data["providerCreatedDate"] ? moment(data["providerCreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditReportOutput {
        let result = new CreditReportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberExists"] = this.memberExists;
        data["uncompletedPackageId"] = this.uncompletedPackageId;
        data["kbaPassed"] = this.kbaPassed;
        data["creditReport"] = this.creditReport ? this.creditReport.toJSON() : <any>undefined;
        data["updatable"] = this.updatable;
        data["isPaymentDelayed"] = this.isPaymentDelayed;
        data["isSubscriptionCancelled"] = this.isSubscriptionCancelled;
        data["previousReportExists"] = this.previousReportExists;
        data["memberFullName"] = this.memberFullName;
        data["providerCreatedDate"] = this.providerCreatedDate ? this.providerCreatedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreditReportOutput {
    memberExists: boolean;
    uncompletedPackageId: number;
    kbaPassed: boolean;
    creditReport: CreditReportDto;
    updatable: boolean;
    isPaymentDelayed: boolean;
    isSubscriptionCancelled: boolean;
    previousReportExists: boolean;
    memberFullName: string;
    providerCreatedDate: moment.Moment;
}

export class CreditReportDto implements ICreditReportDto {
    creditReportId: number;
    minScoreValue: number;
    maxScoreValue: number;
    bureauReports: CreditBureauReportDto[];
    accounts: AccountDto[];
    alerts: AlertDto[];
    recommendations: RecommendationDto[];
    creditorContacts: CreditorContactDto[];
    consumerStatements: ConsumerStatementDto[];
    publicInformation: PublicRecordDto[];

    constructor(data?: ICreditReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditReportId = data["creditReportId"];
            this.minScoreValue = data["minScoreValue"];
            this.maxScoreValue = data["maxScoreValue"];
            if (data["bureauReports"] && data["bureauReports"].constructor === Array) {
                this.bureauReports = [];
                for (let item of data["bureauReports"])
                    this.bureauReports.push(CreditBureauReportDto.fromJS(item));
            }
            if (data["accounts"] && data["accounts"].constructor === Array) {
                this.accounts = [];
                for (let item of data["accounts"])
                    this.accounts.push(AccountDto.fromJS(item));
            }
            if (data["alerts"] && data["alerts"].constructor === Array) {
                this.alerts = [];
                for (let item of data["alerts"])
                    this.alerts.push(AlertDto.fromJS(item));
            }
            if (data["recommendations"] && data["recommendations"].constructor === Array) {
                this.recommendations = [];
                for (let item of data["recommendations"])
                    this.recommendations.push(RecommendationDto.fromJS(item));
            }
            if (data["creditorContacts"] && data["creditorContacts"].constructor === Array) {
                this.creditorContacts = [];
                for (let item of data["creditorContacts"])
                    this.creditorContacts.push(CreditorContactDto.fromJS(item));
            }
            if (data["consumerStatements"] && data["consumerStatements"].constructor === Array) {
                this.consumerStatements = [];
                for (let item of data["consumerStatements"])
                    this.consumerStatements.push(ConsumerStatementDto.fromJS(item));
            }
            if (data["publicInformation"] && data["publicInformation"].constructor === Array) {
                this.publicInformation = [];
                for (let item of data["publicInformation"])
                    this.publicInformation.push(PublicRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditReportDto {
        let result = new CreditReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditReportId"] = this.creditReportId;
        data["minScoreValue"] = this.minScoreValue;
        data["maxScoreValue"] = this.maxScoreValue;
        if (this.bureauReports && this.bureauReports.constructor === Array) {
            data["bureauReports"] = [];
            for (let item of this.bureauReports)
                data["bureauReports"].push(item.toJSON());
        }
        if (this.accounts && this.accounts.constructor === Array) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (this.alerts && this.alerts.constructor === Array) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        if (this.recommendations && this.recommendations.constructor === Array) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item.toJSON());
        }
        if (this.creditorContacts && this.creditorContacts.constructor === Array) {
            data["creditorContacts"] = [];
            for (let item of this.creditorContacts)
                data["creditorContacts"].push(item.toJSON());
        }
        if (this.consumerStatements && this.consumerStatements.constructor === Array) {
            data["consumerStatements"] = [];
            for (let item of this.consumerStatements)
                data["consumerStatements"].push(item.toJSON());
        }
        if (this.publicInformation && this.publicInformation.constructor === Array) {
            data["publicInformation"] = [];
            for (let item of this.publicInformation)
                data["publicInformation"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditReportDto {
    creditReportId: number;
    minScoreValue: number;
    maxScoreValue: number;
    bureauReports: CreditBureauReportDto[];
    accounts: AccountDto[];
    alerts: AlertDto[];
    recommendations: RecommendationDto[];
    creditorContacts: CreditorContactDto[];
    consumerStatements: ConsumerStatementDto[];
    publicInformation: PublicRecordDto[];
}

export class CreditBureauReportDto implements ICreditBureauReportDto {
    bureau: string;
    creditScore: CreditScoreDto;
    creditSummary: CreditSummaryDto;
    personalInfo: PersonalInfoDto;
    inquiries: InquiryDto[];
    scoreFactors: ScoreFactorDto[];

    constructor(data?: ICreditBureauReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.creditScore = data["creditScore"] ? CreditScoreDto.fromJS(data["creditScore"]) : <any>undefined;
            this.creditSummary = data["creditSummary"] ? CreditSummaryDto.fromJS(data["creditSummary"]) : <any>undefined;
            this.personalInfo = data["personalInfo"] ? PersonalInfoDto.fromJS(data["personalInfo"]) : <any>undefined;
            if (data["inquiries"] && data["inquiries"].constructor === Array) {
                this.inquiries = [];
                for (let item of data["inquiries"])
                    this.inquiries.push(InquiryDto.fromJS(item));
            }
            if (data["scoreFactors"] && data["scoreFactors"].constructor === Array) {
                this.scoreFactors = [];
                for (let item of data["scoreFactors"])
                    this.scoreFactors.push(ScoreFactorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditBureauReportDto {
        let result = new CreditBureauReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["creditScore"] = this.creditScore ? this.creditScore.toJSON() : <any>undefined;
        data["creditSummary"] = this.creditSummary ? this.creditSummary.toJSON() : <any>undefined;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        if (this.inquiries && this.inquiries.constructor === Array) {
            data["inquiries"] = [];
            for (let item of this.inquiries)
                data["inquiries"].push(item.toJSON());
        }
        if (this.scoreFactors && this.scoreFactors.constructor === Array) {
            data["scoreFactors"] = [];
            for (let item of this.scoreFactors)
                data["scoreFactors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditBureauReportDto {
    bureau: string;
    creditScore: CreditScoreDto;
    creditSummary: CreditSummaryDto;
    personalInfo: PersonalInfoDto;
    inquiries: InquiryDto[];
    scoreFactors: ScoreFactorDto[];
}

export class AccountDto implements IAccountDto {
    accountIds: number[];
    accountName: string;
    state: AccountDtoState;
    creditLimit: number;
    availableCredit: number;
    outstandingBalance: number;
    ratio: number;
    dateOpened: moment.Moment;
    accountDetails: AccountInfoDto[];

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            this.accountName = data["accountName"];
            this.state = data["state"];
            this.creditLimit = data["creditLimit"];
            this.availableCredit = data["availableCredit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.ratio = data["ratio"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            if (data["accountDetails"] && data["accountDetails"].constructor === Array) {
                this.accountDetails = [];
                for (let item of data["accountDetails"])
                    this.accountDetails.push(AccountInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDto {
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["creditLimit"] = this.creditLimit;
        data["availableCredit"] = this.availableCredit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["ratio"] = this.ratio;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        if (this.accountDetails && this.accountDetails.constructor === Array) {
            data["accountDetails"] = [];
            for (let item of this.accountDetails)
                data["accountDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountDto {
    accountIds: number[];
    accountName: string;
    state: AccountDtoState;
    creditLimit: number;
    availableCredit: number;
    outstandingBalance: number;
    ratio: number;
    dateOpened: moment.Moment;
    accountDetails: AccountInfoDto[];
}

export class AlertDto implements IAlertDto {
    type: AlertDtoType;
    bureau: string;
    date: moment.Moment;
    text: string;

    constructor(data?: IAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.text = data["text"];
        }
    }

    static fromJS(data: any): AlertDto {
        let result = new AlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data; 
    }
}

export interface IAlertDto {
    type: AlertDtoType;
    bureau: string;
    date: moment.Moment;
    text: string;
}

export class RecommendationDto implements IRecommendationDto {
    header: string;
    text: string;
    isPositive: boolean;

    constructor(data?: IRecommendationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.header = data["header"];
            this.text = data["text"];
            this.isPositive = data["isPositive"];
        }
    }

    static fromJS(data: any): RecommendationDto {
        let result = new RecommendationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["text"] = this.text;
        data["isPositive"] = this.isPositive;
        return data; 
    }
}

export interface IRecommendationDto {
    header: string;
    text: string;
    isPositive: boolean;
}

export class CreditorContactDto implements ICreditorContactDto {
    name: string;
    address: AddressDto;
    phoneNumber: string;

    constructor(data?: ICreditorContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"] ? AddressDto.fromJS(data["address"]) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreditorContactDto {
        let result = new CreditorContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ICreditorContactDto {
    name: string;
    address: AddressDto;
    phoneNumber: string;
}

export class ConsumerStatementDto implements IConsumerStatementDto {
    bureau: string;
    date: moment.Moment;
    statement: string;

    constructor(data?: IConsumerStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.statement = data["statement"];
        }
    }

    static fromJS(data: any): ConsumerStatementDto {
        let result = new ConsumerStatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statement"] = this.statement;
        return data; 
    }
}

export interface IConsumerStatementDto {
    bureau: string;
    date: moment.Moment;
    statement: string;
}

export class PublicRecordDto implements IPublicRecordDto {
    title: string;
    status: string;
    amount: number;
    dateReleased: moment.Moment;
    publicRecordDetails: PublicRecordBureauInfoDto[];

    constructor(data?: IPublicRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            if (data["publicRecordDetails"] && data["publicRecordDetails"].constructor === Array) {
                this.publicRecordDetails = [];
                for (let item of data["publicRecordDetails"])
                    this.publicRecordDetails.push(PublicRecordBureauInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublicRecordDto {
        let result = new PublicRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        if (this.publicRecordDetails && this.publicRecordDetails.constructor === Array) {
            data["publicRecordDetails"] = [];
            for (let item of this.publicRecordDetails)
                data["publicRecordDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPublicRecordDto {
    title: string;
    status: string;
    amount: number;
    dateReleased: moment.Moment;
    publicRecordDetails: PublicRecordBureauInfoDto[];
}

export class CreditScoreDto implements ICreditScoreDto {
    score: number;
    scoreRank: CreditScoreDtoScoreRank;
    populationRank: number;
    qualitativeRank: number;
    scoreDate: moment.Moment;
    nextUpdate: number;

    constructor(data?: ICreditScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.score = data["score"];
            this.scoreRank = data["scoreRank"];
            this.populationRank = data["populationRank"];
            this.qualitativeRank = data["qualitativeRank"];
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.nextUpdate = data["nextUpdate"];
        }
    }

    static fromJS(data: any): CreditScoreDto {
        let result = new CreditScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["scoreRank"] = this.scoreRank;
        data["populationRank"] = this.populationRank;
        data["qualitativeRank"] = this.qualitativeRank;
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["nextUpdate"] = this.nextUpdate;
        return data; 
    }
}

export interface ICreditScoreDto {
    score: number;
    scoreRank: CreditScoreDtoScoreRank;
    populationRank: number;
    qualitativeRank: number;
    scoreDate: moment.Moment;
    nextUpdate: number;
}

export class CreditSummaryDto implements ICreditSummaryDto {
    totalAccounts: number;
    openAccounts: number;
    closedAccounts: number;
    deliquent: number;
    derogatory: number;
    balances: number;
    payments: number;
    publicRecords: number;
    inquiries2Years: number;

    constructor(data?: ICreditSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalAccounts = data["totalAccounts"];
            this.openAccounts = data["openAccounts"];
            this.closedAccounts = data["closedAccounts"];
            this.deliquent = data["deliquent"];
            this.derogatory = data["derogatory"];
            this.balances = data["balances"];
            this.payments = data["payments"];
            this.publicRecords = data["publicRecords"];
            this.inquiries2Years = data["inquiries2Years"];
        }
    }

    static fromJS(data: any): CreditSummaryDto {
        let result = new CreditSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAccounts"] = this.totalAccounts;
        data["openAccounts"] = this.openAccounts;
        data["closedAccounts"] = this.closedAccounts;
        data["deliquent"] = this.deliquent;
        data["derogatory"] = this.derogatory;
        data["balances"] = this.balances;
        data["payments"] = this.payments;
        data["publicRecords"] = this.publicRecords;
        data["inquiries2Years"] = this.inquiries2Years;
        return data; 
    }
}

export interface ICreditSummaryDto {
    totalAccounts: number;
    openAccounts: number;
    closedAccounts: number;
    deliquent: number;
    derogatory: number;
    balances: number;
    payments: number;
    publicRecords: number;
    inquiries2Years: number;
}

export class PersonalInfoDto implements IPersonalInfoDto {
    name: string;
    doB: moment.Moment;
    currentAddress: AddressDto;
    previousAddresses: AddressDto[];
    employers: EmployerDto[];

    constructor(data?: IPersonalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.currentAddress = data["currentAddress"] ? AddressDto.fromJS(data["currentAddress"]) : <any>undefined;
            if (data["previousAddresses"] && data["previousAddresses"].constructor === Array) {
                this.previousAddresses = [];
                for (let item of data["previousAddresses"])
                    this.previousAddresses.push(AddressDto.fromJS(item));
            }
            if (data["employers"] && data["employers"].constructor === Array) {
                this.employers = [];
                for (let item of data["employers"])
                    this.employers.push(EmployerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalInfoDto {
        let result = new PersonalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["currentAddress"] = this.currentAddress ? this.currentAddress.toJSON() : <any>undefined;
        if (this.previousAddresses && this.previousAddresses.constructor === Array) {
            data["previousAddresses"] = [];
            for (let item of this.previousAddresses)
                data["previousAddresses"].push(item.toJSON());
        }
        if (this.employers && this.employers.constructor === Array) {
            data["employers"] = [];
            for (let item of this.employers)
                data["employers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalInfoDto {
    name: string;
    doB: moment.Moment;
    currentAddress: AddressDto;
    previousAddresses: AddressDto[];
    employers: EmployerDto[];
}

export class InquiryDto implements IInquiryDto {
    creditorName: string;
    industry: string;
    dateOfInquiry: moment.Moment;

    constructor(data?: IInquiryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditorName = data["creditorName"];
            this.industry = data["industry"];
            this.dateOfInquiry = data["dateOfInquiry"] ? moment(data["dateOfInquiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InquiryDto {
        let result = new InquiryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditorName"] = this.creditorName;
        data["industry"] = this.industry;
        data["dateOfInquiry"] = this.dateOfInquiry ? this.dateOfInquiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IInquiryDto {
    creditorName: string;
    industry: string;
    dateOfInquiry: moment.Moment;
}

export class ScoreFactorDto implements IScoreFactorDto {
    isPositive: boolean;
    text: string;

    constructor(data?: IScoreFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isPositive = data["isPositive"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): ScoreFactorDto {
        let result = new ScoreFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPositive"] = this.isPositive;
        data["text"] = this.text;
        return data; 
    }
}

export interface IScoreFactorDto {
    isPositive: boolean;
    text: string;
}

export class AccountInfoDto implements IAccountInfoDto {
    bureau: string;
    status: AccountInfoDtoStatus;
    totalCreditLimit: number;
    availableCredit: number;
    creditUtilization: number;
    accountName: string;
    accountNumber: string;
    balance: number;
    pastDue: number;
    dateOpened: moment.Moment;
    moPayment: number;
    paymentStatus: string;
    terms: string;
    comment: string;
    maxAccountHistoryDate: moment.Moment;
    twoYearHistory: AccountCreditHistoryDto[];

    constructor(data?: IAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.status = data["status"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.availableCredit = data["availableCredit"];
            this.creditUtilization = data["creditUtilization"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.balance = data["balance"];
            this.pastDue = data["pastDue"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.moPayment = data["moPayment"];
            this.paymentStatus = data["paymentStatus"];
            this.terms = data["terms"];
            this.comment = data["comment"];
            this.maxAccountHistoryDate = data["maxAccountHistoryDate"] ? moment(data["maxAccountHistoryDate"].toString()) : <any>undefined;
            if (data["twoYearHistory"] && data["twoYearHistory"].constructor === Array) {
                this.twoYearHistory = [];
                for (let item of data["twoYearHistory"])
                    this.twoYearHistory.push(AccountCreditHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountInfoDto {
        let result = new AccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["status"] = this.status;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["availableCredit"] = this.availableCredit;
        data["creditUtilization"] = this.creditUtilization;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["balance"] = this.balance;
        data["pastDue"] = this.pastDue;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["moPayment"] = this.moPayment;
        data["paymentStatus"] = this.paymentStatus;
        data["terms"] = this.terms;
        data["comment"] = this.comment;
        data["maxAccountHistoryDate"] = this.maxAccountHistoryDate ? this.maxAccountHistoryDate.toISOString() : <any>undefined;
        if (this.twoYearHistory && this.twoYearHistory.constructor === Array) {
            data["twoYearHistory"] = [];
            for (let item of this.twoYearHistory)
                data["twoYearHistory"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountInfoDto {
    bureau: string;
    status: AccountInfoDtoStatus;
    totalCreditLimit: number;
    availableCredit: number;
    creditUtilization: number;
    accountName: string;
    accountNumber: string;
    balance: number;
    pastDue: number;
    dateOpened: moment.Moment;
    moPayment: number;
    paymentStatus: string;
    terms: string;
    comment: string;
    maxAccountHistoryDate: moment.Moment;
    twoYearHistory: AccountCreditHistoryDto[];
}

export class AddressDto implements IAddressDto {
    line1: string;
    line2: string;
    line3: string;
    line4: string;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.line3 = data["line3"];
            this.line4 = data["line4"];
        }
    }

    static fromJS(data: any): AddressDto {
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        return data; 
    }
}

export interface IAddressDto {
    line1: string;
    line2: string;
    line3: string;
    line4: string;
}

export class PublicRecordBureauInfoDto implements IPublicRecordBureauInfoDto {
    bureau: string;
    title: string;
    type: string;
    status: string;
    amount: number;
    dateFiledOrReported: moment.Moment;
    referenceNo: string;
    court: string;
    dateVerified: moment.Moment;
    dateUpdated: moment.Moment;
    dateReleased: moment.Moment;
    remarks: string;

    constructor(data?: IPublicRecordBureauInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.title = data["title"];
            this.type = data["type"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateFiledOrReported = data["dateFiledOrReported"] ? moment(data["dateFiledOrReported"].toString()) : <any>undefined;
            this.referenceNo = data["referenceNo"];
            this.court = data["court"];
            this.dateVerified = data["dateVerified"] ? moment(data["dateVerified"].toString()) : <any>undefined;
            this.dateUpdated = data["dateUpdated"] ? moment(data["dateUpdated"].toString()) : <any>undefined;
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
        }
    }

    static fromJS(data: any): PublicRecordBureauInfoDto {
        let result = new PublicRecordBureauInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["title"] = this.title;
        data["type"] = this.type;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateFiledOrReported"] = this.dateFiledOrReported ? this.dateFiledOrReported.toISOString() : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["court"] = this.court;
        data["dateVerified"] = this.dateVerified ? this.dateVerified.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface IPublicRecordBureauInfoDto {
    bureau: string;
    title: string;
    type: string;
    status: string;
    amount: number;
    dateFiledOrReported: moment.Moment;
    referenceNo: string;
    court: string;
    dateVerified: moment.Moment;
    dateUpdated: moment.Moment;
    dateReleased: moment.Moment;
    remarks: string;
}

export class EmployerDto implements IEmployerDto {
    name: string;
    date: moment.Moment;
    type: string;

    constructor(data?: IEmployerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): EmployerDto {
        let result = new EmployerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEmployerDto {
    name: string;
    date: moment.Moment;
    type: string;
}

export class AccountCreditHistoryDto implements IAccountCreditHistoryDto {
    year: number;
    month: number;
    status: string;
    isPositiveStatus: boolean;
    statusType: AccountCreditHistoryDtoStatusType;

    constructor(data?: IAccountCreditHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.year = data["year"];
            this.month = data["month"];
            this.status = data["status"];
            this.isPositiveStatus = data["isPositiveStatus"];
            this.statusType = data["statusType"];
        }
    }

    static fromJS(data: any): AccountCreditHistoryDto {
        let result = new AccountCreditHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["status"] = this.status;
        data["isPositiveStatus"] = this.isPositiveStatus;
        data["statusType"] = this.statusType;
        return data; 
    }
}

export interface IAccountCreditHistoryDto {
    year: number;
    month: number;
    status: string;
    isPositiveStatus: boolean;
    statusType: AccountCreditHistoryDtoStatusType;
}

export class KeyValuePairOfStringAndListOfScoreHistoryDto implements IKeyValuePairOfStringAndListOfScoreHistoryDto {
    key: string;
    value: ScoreHistoryDto[];

    constructor(data?: IKeyValuePairOfStringAndListOfScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            if (data["value"] && data["value"].constructor === Array) {
                this.value = [];
                for (let item of data["value"])
                    this.value.push(ScoreHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndListOfScoreHistoryDto {
        let result = new KeyValuePairOfStringAndListOfScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (this.value && this.value.constructor === Array) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IKeyValuePairOfStringAndListOfScoreHistoryDto {
    key: string;
    value: ScoreHistoryDto[];
}

export class ScoreHistoryDto implements IScoreHistoryDto {
    scoreDate: moment.Moment;
    score: number;

    constructor(data?: IScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.score = data["score"];
        }
    }

    static fromJS(data: any): ScoreHistoryDto {
        let result = new ScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["score"] = this.score;
        return data; 
    }
}

export interface IScoreHistoryDto {
    scoreDate: moment.Moment;
    score: number;
}

export class ScoreSimulatorInfoDto implements IScoreSimulatorInfoDto {
    initialScore: number;
    totalCreditLimit: number;
    outstandingBalance: number;
    accessStatus: ScoreSimulatorInfoDtoAccessStatus;

    constructor(data?: IScoreSimulatorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.initialScore = data["initialScore"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.accessStatus = data["accessStatus"];
        }
    }

    static fromJS(data: any): ScoreSimulatorInfoDto {
        let result = new ScoreSimulatorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialScore"] = this.initialScore;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["accessStatus"] = this.accessStatus;
        return data; 
    }
}

export interface IScoreSimulatorInfoDto {
    initialScore: number;
    totalCreditLimit: number;
    outstandingBalance: number;
    accessStatus: ScoreSimulatorInfoDtoAccessStatus;
}

export class ScoreSimulatorDto implements IScoreSimulatorDto {
    onTimePayment: number;
    closeOldestCreditCard: boolean;
    oneAccountPastDue: number;
    allAccountsPastDue: number;
    increaseCreditBalance: number;
    decreaseCreditBalance: number;
    increaseCreditCardLimit: number;
    moveOneAccountToCollection: boolean;
    addTaxLienPublicRecord: boolean;
    addForeClosurePublicRecord: boolean;
    addChildSupportPublicRecord: boolean;
    addWageGarnishmentPublicRecord: boolean;
    declareBankruptcy: boolean;
    payOffAllCreditCards: boolean;
    applyForCreditCard: number;
    obtainCreditCard: number;
    obtainMortgage: number;
    obtainAutoLoan: number;
    obtainPersonalLoan: number;
    transferCreditBalances: number;

    constructor(data?: IScoreSimulatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.onTimePayment = data["onTimePayment"];
            this.closeOldestCreditCard = data["closeOldestCreditCard"];
            this.oneAccountPastDue = data["oneAccountPastDue"];
            this.allAccountsPastDue = data["allAccountsPastDue"];
            this.increaseCreditBalance = data["increaseCreditBalance"];
            this.decreaseCreditBalance = data["decreaseCreditBalance"];
            this.increaseCreditCardLimit = data["increaseCreditCardLimit"];
            this.moveOneAccountToCollection = data["moveOneAccountToCollection"];
            this.addTaxLienPublicRecord = data["addTaxLienPublicRecord"];
            this.addForeClosurePublicRecord = data["addForeClosurePublicRecord"];
            this.addChildSupportPublicRecord = data["addChildSupportPublicRecord"];
            this.addWageGarnishmentPublicRecord = data["addWageGarnishmentPublicRecord"];
            this.declareBankruptcy = data["declareBankruptcy"];
            this.payOffAllCreditCards = data["payOffAllCreditCards"];
            this.applyForCreditCard = data["applyForCreditCard"];
            this.obtainCreditCard = data["obtainCreditCard"];
            this.obtainMortgage = data["obtainMortgage"];
            this.obtainAutoLoan = data["obtainAutoLoan"];
            this.obtainPersonalLoan = data["obtainPersonalLoan"];
            this.transferCreditBalances = data["transferCreditBalances"];
        }
    }

    static fromJS(data: any): ScoreSimulatorDto {
        let result = new ScoreSimulatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTimePayment"] = this.onTimePayment;
        data["closeOldestCreditCard"] = this.closeOldestCreditCard;
        data["oneAccountPastDue"] = this.oneAccountPastDue;
        data["allAccountsPastDue"] = this.allAccountsPastDue;
        data["increaseCreditBalance"] = this.increaseCreditBalance;
        data["decreaseCreditBalance"] = this.decreaseCreditBalance;
        data["increaseCreditCardLimit"] = this.increaseCreditCardLimit;
        data["moveOneAccountToCollection"] = this.moveOneAccountToCollection;
        data["addTaxLienPublicRecord"] = this.addTaxLienPublicRecord;
        data["addForeClosurePublicRecord"] = this.addForeClosurePublicRecord;
        data["addChildSupportPublicRecord"] = this.addChildSupportPublicRecord;
        data["addWageGarnishmentPublicRecord"] = this.addWageGarnishmentPublicRecord;
        data["declareBankruptcy"] = this.declareBankruptcy;
        data["payOffAllCreditCards"] = this.payOffAllCreditCards;
        data["applyForCreditCard"] = this.applyForCreditCard;
        data["obtainCreditCard"] = this.obtainCreditCard;
        data["obtainMortgage"] = this.obtainMortgage;
        data["obtainAutoLoan"] = this.obtainAutoLoan;
        data["obtainPersonalLoan"] = this.obtainPersonalLoan;
        data["transferCreditBalances"] = this.transferCreditBalances;
        return data; 
    }
}

export interface IScoreSimulatorDto {
    onTimePayment: number;
    closeOldestCreditCard: boolean;
    oneAccountPastDue: number;
    allAccountsPastDue: number;
    increaseCreditBalance: number;
    decreaseCreditBalance: number;
    increaseCreditCardLimit: number;
    moveOneAccountToCollection: boolean;
    addTaxLienPublicRecord: boolean;
    addForeClosurePublicRecord: boolean;
    addChildSupportPublicRecord: boolean;
    addWageGarnishmentPublicRecord: boolean;
    declareBankruptcy: boolean;
    payOffAllCreditCards: boolean;
    applyForCreditCard: number;
    obtainCreditCard: number;
    obtainMortgage: number;
    obtainAutoLoan: number;
    obtainPersonalLoan: number;
    transferCreditBalances: number;
}

export class PersonContactInfoDto implements IPersonContactInfoDto {
    person: PersonInfoDto;
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;

    constructor(data?: IPersonContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.person = data["person"] ? PersonInfoDto.fromJS(data["person"]) : <any>undefined;
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.photo = data["photo"] ? ContactPhotoDto.fromJS(data["photo"]) : <any>undefined;
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLinkDto.fromJS(item));
            }
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): PersonContactInfoDto {
        let result = new PersonContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IPersonContactInfoDto {
    person: PersonInfoDto;
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;
}

export class PersonInfoDto implements IPersonInfoDto {
    namePrefix: string;
    middleName: string;
    nameSuffix: string;
    nickName: string;
    dob: moment.Moment;
    ssn: string;
    timeZone: string;
    identityConfirmationDate: moment.Moment;
    identityConfirmedByUser: UserKeyInfoDto;
    maritalStatus: string;
    marriageDate: moment.Moment;
    divorceDate: moment.Moment;
    gender: string;
    citizenship: string;
    isUSCitizen: boolean;
    contactId: number;
    firstName: string;
    lastName: string;

    constructor(data?: IPersonInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namePrefix = data["namePrefix"];
            this.middleName = data["middleName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.timeZone = data["timeZone"];
            this.identityConfirmationDate = data["identityConfirmationDate"] ? moment(data["identityConfirmationDate"].toString()) : <any>undefined;
            this.identityConfirmedByUser = data["identityConfirmedByUser"] ? UserKeyInfoDto.fromJS(data["identityConfirmedByUser"]) : <any>undefined;
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.citizenship = data["citizenship"];
            this.isUSCitizen = data["isUSCitizen"];
            this.contactId = data["contactId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): PersonInfoDto {
        let result = new PersonInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["middleName"] = this.middleName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["timeZone"] = this.timeZone;
        data["identityConfirmationDate"] = this.identityConfirmationDate ? this.identityConfirmationDate.toISOString() : <any>undefined;
        data["identityConfirmedByUser"] = this.identityConfirmedByUser ? this.identityConfirmedByUser.toJSON() : <any>undefined;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["citizenship"] = this.citizenship;
        data["isUSCitizen"] = this.isUSCitizen;
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IPersonInfoDto {
    namePrefix: string;
    middleName: string;
    nameSuffix: string;
    nickName: string;
    dob: moment.Moment;
    ssn: string;
    timeZone: string;
    identityConfirmationDate: moment.Moment;
    identityConfirmedByUser: UserKeyInfoDto;
    maritalStatus: string;
    marriageDate: moment.Moment;
    divorceDate: moment.Moment;
    gender: string;
    citizenship: string;
    isUSCitizen: boolean;
    contactId: number;
    firstName: string;
    lastName: string;
}

export class ContactPhotoDto implements IContactPhotoDto {
    thumbnail: string;
    source: string;
    comment: string;

    constructor(data?: IContactPhotoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactPhotoDto {
        let result = new ContactPhotoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactPhotoDto {
    thumbnail: string;
    source: string;
    comment: string;
}

export class ContactEmailDto implements IContactEmailDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;

    constructor(data?: IContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.usageTypeId = data["usageTypeId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.confirmedByUser = data["confirmedByUser"] ? UserKeyInfoDto.fromJS(data["confirmedByUser"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactEmailDto {
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["usageTypeId"] = this.usageTypeId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUser"] = this.confirmedByUser ? this.confirmedByUser.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactEmailDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;
}

export class ContactPhoneDto implements IContactPhoneDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;

    constructor(data?: IContactPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.usageTypeId = data["usageTypeId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.confirmedByUser = data["confirmedByUser"] ? UserKeyInfoDto.fromJS(data["confirmedByUser"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactPhoneDto {
        let result = new ContactPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["usageTypeId"] = this.usageTypeId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUser"] = this.confirmedByUser ? this.confirmedByUser.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactPhoneDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    phoneNumber: string;
    phoneExtension: string;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;
}

export class ContactAddressDto implements IContactAddressDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    streetAddress: string;
    city: string;
    state: string;
    country: string;
    zip: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.usageTypeId = data["usageTypeId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.zip = data["zip"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.confirmedByUser = data["confirmedByUser"] ? UserKeyInfoDto.fromJS(data["confirmedByUser"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactAddressDto {
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["usageTypeId"] = this.usageTypeId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUser"] = this.confirmedByUser ? this.confirmedByUser.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactAddressDto {
    contactId: number;
    id: number;
    usageTypeId: string;
    streetAddress: string;
    city: string;
    state: string;
    country: string;
    zip: string;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;
}

export class ContactLinkDto implements IContactLinkDto {
    contactId: number;
    id: number;
    linkTypeId: string;
    url: string;
    isSocialNetwork: boolean;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;

    constructor(data?: IContactLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
            this.isSocialNetwork = data["isSocialNetwork"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.confirmedByUser = data["confirmedByUser"] ? UserKeyInfoDto.fromJS(data["confirmedByUser"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactLinkDto {
        let result = new ContactLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isSocialNetwork"] = this.isSocialNetwork;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["confirmedByUser"] = this.confirmedByUser ? this.confirmedByUser.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactLinkDto {
    contactId: number;
    id: number;
    linkTypeId: string;
    url: string;
    isSocialNetwork: boolean;
    isActive: boolean;
    isConfirmed: boolean;
    confirmationDate: moment.Moment;
    confirmedByUserId: number;
    confirmedByUser: UserKeyInfoDto;
    comment: string;
}

export class UserKeyInfoDto implements IUserKeyInfoDto {
    id: number;
    userName: string;
    fullName: string;

    constructor(data?: IUserKeyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UserKeyInfoDto {
        let result = new UserKeyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUserKeyInfoDto {
    id: number;
    userName: string;
    fullName: string;
}

export class OrganizationContactInfoDto implements IOrganizationContactInfoDto {
    organization: OrganizationInfoDto;
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;

    constructor(data?: IOrganizationContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"] ? OrganizationInfoDto.fromJS(data["organization"]) : <any>undefined;
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.photo = data["photo"] ? ContactPhotoDto.fromJS(data["photo"]) : <any>undefined;
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLinkDto.fromJS(item));
            }
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): OrganizationContactInfoDto {
        let result = new OrganizationContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IOrganizationContactInfoDto {
    organization: OrganizationInfoDto;
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;
}

export class OrganizationInfoDto implements IOrganizationInfoDto {
    industry: string;
    type: string;
    contactPerson: PersonKeyInfoDto;

    constructor(data?: IOrganizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.industry = data["industry"];
            this.type = data["type"];
            this.contactPerson = data["contactPerson"] ? PersonKeyInfoDto.fromJS(data["contactPerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationInfoDto {
        let result = new OrganizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["industry"] = this.industry;
        data["type"] = this.type;
        data["contactPerson"] = this.contactPerson ? this.contactPerson.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOrganizationInfoDto {
    industry: string;
    type: string;
    contactPerson: PersonKeyInfoDto;
}

export class PersonKeyInfoDto implements IPersonKeyInfoDto {
    contactId: number;
    firstName: string;
    lastName: string;

    constructor(data?: IPersonKeyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): PersonKeyInfoDto {
        let result = new PersonKeyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IPersonKeyInfoDto {
    contactId: number;
    firstName: string;
    lastName: string;
}

export class ContactInfoDto implements IContactInfoDto {
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.photo = data["photo"] ? ContactPhotoDto.fromJS(data["photo"]) : <any>undefined;
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLinkDto.fromJS(item));
            }
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactInfoDto {
    id: number;
    fullName: string;
    photo: ContactPhotoDto;
    emails: ContactEmailDto[];
    phones: ContactPhoneDto[];
    addresses: ContactAddressDto[];
    links: ContactLinkDto[];
    comment: string;
}

export class CustomerInfoDto implements ICustomerInfoDto {
    name: string;
    status: string;
    score: number;
    primaryContactInfo: PersonContactInfoDto;
    organizationContactInfo: OrganizationContactInfoDto;
    contactPersons: PersonContactInfoDto[];
    creationDate: moment.Moment;
    userContextOrderId: number;
    userContextOrderType: string;

    constructor(data?: ICustomerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.status = data["status"];
            this.score = data["score"];
            this.primaryContactInfo = data["primaryContactInfo"] ? PersonContactInfoDto.fromJS(data["primaryContactInfo"]) : <any>undefined;
            this.organizationContactInfo = data["organizationContactInfo"] ? OrganizationContactInfoDto.fromJS(data["organizationContactInfo"]) : <any>undefined;
            if (data["contactPersons"] && data["contactPersons"].constructor === Array) {
                this.contactPersons = [];
                for (let item of data["contactPersons"])
                    this.contactPersons.push(PersonContactInfoDto.fromJS(item));
            }
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.userContextOrderId = data["userContextOrderId"];
            this.userContextOrderType = data["userContextOrderType"];
        }
    }

    static fromJS(data: any): CustomerInfoDto {
        let result = new CustomerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["status"] = this.status;
        data["score"] = this.score;
        data["primaryContactInfo"] = this.primaryContactInfo ? this.primaryContactInfo.toJSON() : <any>undefined;
        data["organizationContactInfo"] = this.organizationContactInfo ? this.organizationContactInfo.toJSON() : <any>undefined;
        if (this.contactPersons && this.contactPersons.constructor === Array) {
            data["contactPersons"] = [];
            for (let item of this.contactPersons)
                data["contactPersons"].push(item.toJSON());
        }
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["userContextOrderId"] = this.userContextOrderId;
        data["userContextOrderType"] = this.userContextOrderType;
        return data; 
    }
}

export interface ICustomerInfoDto {
    name: string;
    status: string;
    score: number;
    primaryContactInfo: PersonContactInfoDto;
    organizationContactInfo: OrganizationContactInfoDto;
    contactPersons: PersonContactInfoDto[];
    creationDate: moment.Moment;
    userContextOrderId: number;
    userContextOrderType: string;
}

export class CreateCustomerInput implements ICreateCustomerInput {
    firstName: string;
    lastName: string;
    dob: moment.Moment;
    emailAddress: string;
    phoneNumber: string;
    ssn: string;
    suppressSimilarContactWarning: boolean = false;
    organizationUnitId: number;

    constructor(data?: ICreateCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.ssn = data["ssn"];
            this.suppressSimilarContactWarning = data["suppressSimilarContactWarning"] !== undefined ? data["suppressSimilarContactWarning"] : false;
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateCustomerInput {
        let result = new CreateCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["ssn"] = this.ssn;
        data["suppressSimilarContactWarning"] = this.suppressSimilarContactWarning;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateCustomerInput {
    firstName: string;
    lastName: string;
    dob: moment.Moment;
    emailAddress: string;
    phoneNumber: string;
    ssn: string;
    suppressSimilarContactWarning: boolean;
    organizationUnitId: number;
}

export class CreateCustomerOutput implements ICreateCustomerOutput {
    id: number;
    similarCustomerExists: boolean;

    constructor(data?: ICreateCustomerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.similarCustomerExists = data["similarCustomerExists"];
        }
    }

    static fromJS(data: any): CreateCustomerOutput {
        let result = new CreateCustomerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["similarCustomerExists"] = this.similarCustomerExists;
        return data; 
    }
}

export interface ICreateCustomerOutput {
    id: number;
    similarCustomerExists: boolean;
}

export class AccountTotals implements IAccountTotals {
    syncAccountCount: number;
    bankAccountCount: number;
    totalNetWorth: number;
    currency: string;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncAccountCount = data["syncAccountCount"];
            this.bankAccountCount = data["bankAccountCount"];
            this.totalNetWorth = data["totalNetWorth"];
            this.currency = data["currency"];
        }
    }

    static fromJS(data: any): AccountTotals {
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountCount"] = this.syncAccountCount;
        data["bankAccountCount"] = this.bankAccountCount;
        data["totalNetWorth"] = this.totalNetWorth;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface IAccountTotals {
    syncAccountCount: number;
    bankAccountCount: number;
    totalNetWorth: number;
    currency: string;
}

export class CategorizationStatus implements ICategorizationStatus {
    classifiedTransactionCount: number;
    classifiedTransactionPercent: number;
    unclassifiedTransactionCount: number;
    unclassifiedTransactionPercent: number;

    constructor(data?: ICategorizationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classifiedTransactionCount = data["classifiedTransactionCount"];
            this.classifiedTransactionPercent = data["classifiedTransactionPercent"];
            this.unclassifiedTransactionCount = data["unclassifiedTransactionCount"];
            this.unclassifiedTransactionPercent = data["unclassifiedTransactionPercent"];
        }
    }

    static fromJS(data: any): CategorizationStatus {
        let result = new CategorizationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedTransactionCount"] = this.classifiedTransactionCount;
        data["classifiedTransactionPercent"] = this.classifiedTransactionPercent;
        data["unclassifiedTransactionCount"] = this.unclassifiedTransactionCount;
        data["unclassifiedTransactionPercent"] = this.unclassifiedTransactionPercent;
        return data; 
    }
}

export interface ICategorizationStatus {
    classifiedTransactionCount: number;
    classifiedTransactionPercent: number;
    unclassifiedTransactionCount: number;
    unclassifiedTransactionPercent: number;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString: string;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string;
}

export class NameValueOfString implements INameValueOfString {
    name: string;
    value: string;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string;
    value: string;
}

export class StringOutput implements IStringOutput {
    output: string;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[];

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[];
}

export class EditionListDto implements IEditionListDto {
    name: string;
    displayName: string;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string;
    displayName: string;
    creationTime: moment.Moment;
    id: number;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
    features: FlatFeatureDto[];

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
    features: FlatFeatureDto[];
}

export class EditionEditDto implements IEditionEditDto {
    id: number;
    displayName: string;
    monthlyPrice: number;
    annualPrice: number;
    trialDayCount: number;
    waitingDayAfterExpire: number;
    expiringEditionId: number;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number;
    displayName: string;
    monthlyPrice: number;
    annualPrice: number;
    trialDayCount: number;
    waitingDayAfterExpire: number;
    expiringEditionId: number;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    defaultValue: string;
    inputType: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    defaultValue: string;
    inputType: FeatureInputTypeDto;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string;
    attributes: { [key: string] : any; };
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string;
    attributes: { [key: string] : any; };
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class IValueValidator implements IIValueValidator {
    name: string;
    attributes: { [key: string] : any; };

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string;
    attributes: { [key: string] : any; };
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[];

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[];
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string;
    displayText: string;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string;
    displayText: string;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto = new EditionEditDto();
    featureValues: NameValueDto[] = [];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class GetSetupAccountsLinkOutput implements IGetSetupAccountsLinkOutput {
    setupAccountsLink: string;

    constructor(data?: IGetSetupAccountsLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setupAccountsLink = data["setupAccountsLink"];
        }
    }

    static fromJS(data: any): GetSetupAccountsLinkOutput {
        let result = new GetSetupAccountsLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupAccountsLink"] = this.setupAccountsLink;
        return data; 
    }
}

export interface IGetSetupAccountsLinkOutput {
    setupAccountsLink: string;
}

export class SyncAllAccountsOutput implements ISyncAllAccountsOutput {
    syncInProgressAccountsCount: number;

    constructor(data?: ISyncAllAccountsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncInProgressAccountsCount = data["syncInProgressAccountsCount"];
        }
    }

    static fromJS(data: any): SyncAllAccountsOutput {
        let result = new SyncAllAccountsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncInProgressAccountsCount"] = this.syncInProgressAccountsCount;
        return data; 
    }
}

export interface ISyncAllAccountsOutput {
    syncInProgressAccountsCount: number;
}

export class SyncProgressOutput implements ISyncProgressOutput {
    totalProgress: SyncProgressDto;
    accountProgresses: SyncProgressDto[];

    constructor(data?: ISyncProgressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProgress = data["totalProgress"] ? SyncProgressDto.fromJS(data["totalProgress"]) : <any>undefined;
            if (data["accountProgresses"] && data["accountProgresses"].constructor === Array) {
                this.accountProgresses = [];
                for (let item of data["accountProgresses"])
                    this.accountProgresses.push(SyncProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressOutput {
        let result = new SyncProgressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProgress"] = this.totalProgress ? this.totalProgress.toJSON() : <any>undefined;
        if (this.accountProgresses && this.accountProgresses.constructor === Array) {
            data["accountProgresses"] = [];
            for (let item of this.accountProgresses)
                data["accountProgresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISyncProgressOutput {
    totalProgress: SyncProgressDto;
    accountProgresses: SyncProgressDto[];
}

export class SyncProgressDto implements ISyncProgressDto {
    accountName: string;
    progressStatus: string;
    progressPercent: number;

    constructor(data?: ISyncProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountName = data["accountName"];
            this.progressStatus = data["progressStatus"];
            this.progressPercent = data["progressPercent"];
        }
    }

    static fromJS(data: any): SyncProgressDto {
        let result = new SyncProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["progressStatus"] = this.progressStatus;
        data["progressPercent"] = this.progressPercent;
        return data; 
    }
}

export interface ISyncProgressDto {
    accountName: string;
    progressStatus: string;
    progressPercent: number;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string;
}

export class BlockUserInput implements IBlockUserInput {
    userId: number;
    tenantId: number;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId: number;
    tenantId: number;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
    incomeStatistics: IncomeStastistic[];
    editionStatistics: TenantEdition[];
    expiringTenants: ExpiringTenant[];
    recentTenants: RecentTenant[];
    maxExpiringTenantsShownCount: number;
    maxRecentTenantsShownCount: number;
    subscriptionEndAlertDayCount: number;
    recentTenantsDayCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;
    tenantCreationStartDate: moment.Moment;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
    incomeStatistics: IncomeStastistic[];
    editionStatistics: TenantEdition[];
    expiringTenants: ExpiringTenant[];
    recentTenants: RecentTenant[];
    maxExpiringTenantsShownCount: number;
    maxRecentTenantsShownCount: number;
    subscriptionEndAlertDayCount: number;
    recentTenantsDayCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;
    tenantCreationStartDate: moment.Moment;
}

export class IncomeStastistic implements IIncomeStastistic {
    label: string;
    date: moment.Moment;
    amount: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string;
    date: moment.Moment;
    amount: number;
}

export class TenantEdition implements ITenantEdition {
    label: string;
    value: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string;
    value: number;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName: string;
    remainingDayCount: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string;
    remainingDayCount: number;
}

export class RecentTenant implements IRecentTenant {
    id: number;
    name: string;
    creationTime: moment.Moment;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number;
    name: string;
    creationTime: moment.Moment;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[];

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[];
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[];

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[];
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto = new GeneralSettingsEditDto();
    userManagement: HostUserManagementSettingsEditDto = new HostUserManagementSettingsEditDto();
    email: EmailSettingsEditDto = new EmailSettingsEditDto();
    tenantManagement: TenantManagementSettingsEditDto = new TenantManagementSettingsEditDto();
    security: SecuritySettingsEditDto = new SecuritySettingsEditDto();
    billing: HostBillingSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string;
    timezoneForComparison: string;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string;
    timezoneForComparison: string;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string;
    defaultFromDisplayName: string;
    smtpHost: string;
    smtpPort: number;
    smtpUserName: string;
    smtpPassword: string;
    smtpDomain: string;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string;
    defaultFromDisplayName: string;
    smtpHost: string;
    smtpPort: number;
    smtpUserName: string;
    smtpPassword: string;
    smtpDomain: string;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string;
    address: string;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string;
    address: string;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl: string;
    serverSiteUrl: string;
    languages: NameValue[];

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string;
    serverSiteUrl: string;
    languages: NameValue[];
}

export class NameValue implements INameValue {
    name: string;
    value: string;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string;
    value: string;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class GetStatusOutput implements IGetStatusOutput {
    status: GetStatusOutputStatus;
    userId: number;
    hasSyncAccounts: boolean;
    hasTransactions: boolean;

    constructor(data?: IGetStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.userId = data["userId"];
            this.hasSyncAccounts = data["hasSyncAccounts"];
            this.hasTransactions = data["hasTransactions"];
        }
    }

    static fromJS(data: any): GetStatusOutput {
        let result = new GetStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["hasSyncAccounts"] = this.hasSyncAccounts;
        data["hasTransactions"] = this.hasTransactions;
        return data; 
    }
}

export interface IGetStatusOutput {
    status: GetStatusOutputStatus;
    userId: number;
    hasSyncAccounts: boolean;
    hasTransactions: boolean;
}

export class SetupOutput implements ISetupOutput {
    alreadyInitialized: boolean;

    constructor(data?: ISetupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alreadyInitialized = data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): SetupOutput {
        let result = new SetupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data; 
    }
}

export interface ISetupOutput {
    alreadyInitialized: boolean;
}

export class SetupInput implements ISetupInput {
    userId: number;

    constructor(data?: ISetupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): SetupInput {
        let result = new SetupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ISetupInput {
    userId: number;
}

export class GetUserInstanceInfoOutput implements IGetUserInstanceInfoOutput {
    id: number;
    status: GetUserInstanceInfoOutputStatus;

    constructor(data?: IGetUserInstanceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): GetUserInstanceInfoOutput {
        let result = new GetUserInstanceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IGetUserInstanceInfoOutput {
    id: number;
    status: GetUserInstanceInfoOutputStatus;
}

export class InvoiceDto implements IInvoiceDto {
    amount: number;
    editionDisplayName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    tenantLegalName: string;
    tenantAddress: string[];
    tenantTaxNo: string;
    hostLegalName: string;
    hostAddress: string[];

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string;
    invoiceNo: string;
    invoiceDate: moment.Moment;
    tenantLegalName: string;
    tenantAddress: string[];
    tenantTaxNo: string;
    hostLegalName: string;
    hostAddress: string[];
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class RequestKBAInput implements IRequestKBAInput {
    redirectUrl: string;
    cssUrl: string;

    constructor(data?: IRequestKBAInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.redirectUrl = data["redirectUrl"];
            this.cssUrl = data["cssUrl"];
        }
    }

    static fromJS(data: any): RequestKBAInput {
        let result = new RequestKBAInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["cssUrl"] = this.cssUrl;
        return data; 
    }
}

export interface IRequestKBAInput {
    redirectUrl: string;
    cssUrl: string;
}

export class RequestKBAOutput implements IRequestKBAOutput {
    kbaAlreadyPassed: boolean;
    kbaUrl: string;

    constructor(data?: IRequestKBAOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kbaAlreadyPassed = data["kbaAlreadyPassed"];
            this.kbaUrl = data["kbaUrl"];
        }
    }

    static fromJS(data: any): RequestKBAOutput {
        let result = new RequestKBAOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kbaAlreadyPassed"] = this.kbaAlreadyPassed;
        data["kbaUrl"] = this.kbaUrl;
        return data; 
    }
}

export interface IRequestKBAOutput {
    kbaAlreadyPassed: boolean;
    kbaUrl: string;
}

export class KBAResult implements IKBAResult {
    memberId: string;
    passed: boolean;
    error: string;

    constructor(data?: IKBAResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.passed = data["passed"];
            this.error = data["error"];
        }
    }

    static fromJS(data: any): KBAResult {
        let result = new KBAResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["passed"] = this.passed;
        data["error"] = this.error;
        return data; 
    }
}

export interface IKBAResult {
    memberId: string;
    passed: boolean;
    error: string;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName: string;
    items: ApplicationLanguageListDto[];

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string;
    items: ApplicationLanguageListDto[];
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId: number;
    name: string;
    displayName: string;
    icon: string;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number;
    deletionTime: moment.Moment;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number;
    name: string;
    displayName: string;
    icon: string;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number;
    deletionTime: moment.Moment;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[];
    flags: ComboboxItemDto[];

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[];
    flags: ComboboxItemDto[];
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number;
    name: string;
    icon: string;
    isEnabled: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number;
    name: string;
    icon: string;
    isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string;
    displayText: string;
    isSelected: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string;
    displayText: string;
    isSelected: boolean;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto = new ApplicationLanguageEditDto();

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[];

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[];
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key: string;
    baseValue: string;
    targetValue: string;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string;
    baseValue: string;
    targetValue: string;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class CancelLeadInfo implements ICancelLeadInfo {
    leadId: number;
    cancellationReasonId: string;
    comment: string;

    constructor(data?: ICancelLeadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.cancellationReasonId = data["cancellationReasonId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CancelLeadInfo {
        let result = new CancelLeadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["cancellationReasonId"] = this.cancellationReasonId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICancelLeadInfo {
    leadId: number;
    cancellationReasonId: string;
    comment: string;
}

export class ListResultDtoOfLeadCancellationReasonDto implements IListResultDtoOfLeadCancellationReasonDto {
    items: LeadCancellationReasonDto[];

    constructor(data?: IListResultDtoOfLeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LeadCancellationReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLeadCancellationReasonDto {
        let result = new ListResultDtoOfLeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLeadCancellationReasonDto {
    items: LeadCancellationReasonDto[];
}

export class LeadCancellationReasonDto implements ILeadCancellationReasonDto {
    id: string;
    name: string;
    isCommentRequired: boolean;
    sortOrder: number;

    constructor(data?: ILeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCommentRequired = data["isCommentRequired"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): LeadCancellationReasonDto {
        let result = new LeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCommentRequired"] = this.isCommentRequired;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ILeadCancellationReasonDto {
    id: string;
    name: string;
    isCommentRequired: boolean;
    sortOrder: number;
}

export class LeadStatsDto implements ILeadStatsDto {
    data: LeadStatsData[];
    pipelines: KeyValuePairOfInt32AndString[];
    stages: KeyValuePairOfInt32AndString[];
    types: KeyValuePairOfInt32AndString[];

    constructor(data?: ILeadStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(LeadStatsData.fromJS(item));
            }
            if (data["pipelines"] && data["pipelines"].constructor === Array) {
                this.pipelines = [];
                for (let item of data["pipelines"])
                    this.pipelines.push(KeyValuePairOfInt32AndString.fromJS(item));
            }
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(KeyValuePairOfInt32AndString.fromJS(item));
            }
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(KeyValuePairOfInt32AndString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeadStatsDto {
        let result = new LeadStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (this.pipelines && this.pipelines.constructor === Array) {
            data["pipelines"] = [];
            for (let item of this.pipelines)
                data["pipelines"].push(item.toJSON());
        }
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILeadStatsDto {
    data: LeadStatsData[];
    pipelines: KeyValuePairOfInt32AndString[];
    stages: KeyValuePairOfInt32AndString[];
    types: KeyValuePairOfInt32AndString[];
}

export class LeadStatsData implements ILeadStatsData {
    typeId: number;
    stageId: number;
    pipelineId: number;
    count: number;

    constructor(data?: ILeadStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.stageId = data["stageId"];
            this.pipelineId = data["pipelineId"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): LeadStatsData {
        let result = new LeadStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["stageId"] = this.stageId;
        data["pipelineId"] = this.pipelineId;
        data["count"] = this.count;
        return data; 
    }
}

export interface ILeadStatsData {
    typeId: number;
    stageId: number;
    pipelineId: number;
    count: number;
}

export class KeyValuePairOfInt32AndString implements IKeyValuePairOfInt32AndString {
    key: number;
    value: string;

    constructor(data?: IKeyValuePairOfInt32AndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfInt32AndString {
        let result = new KeyValuePairOfInt32AndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePairOfInt32AndString {
    key: number;
    value: string;
}

export class SubmitContactUsRequestInput implements ISubmitContactUsRequestInput {
    website: string;
    tenancyName: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    phoneExt: string;
    comments: string;
    sourceCode: string;

    constructor(data?: ISubmitContactUsRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.website = data["website"];
            this.tenancyName = data["tenancyName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.phoneExt = data["phoneExt"];
            this.comments = data["comments"];
            this.sourceCode = data["sourceCode"];
        }
    }

    static fromJS(data: any): SubmitContactUsRequestInput {
        let result = new SubmitContactUsRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["website"] = this.website;
        data["tenancyName"] = this.tenancyName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        return data; 
    }
}

export interface ISubmitContactUsRequestInput {
    website: string;
    tenancyName: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    phoneExt: string;
    comments: string;
    sourceCode: string;
}

export class SubmitTenantCreationRequestInput implements ISubmitTenantCreationRequestInput {
    companyName: string;
    editionId: number;
    paymentPeriodType: SubmitTenantCreationRequestInputPaymentPeriodType;
    leadInterests: LeadInterestDto[] = [];
    leadRequestXref: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    phoneExt: string;
    comments: string;
    sourceCode: string;

    constructor(data?: ISubmitTenantCreationRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["leadInterests"] && data["leadInterests"].constructor === Array) {
                this.leadInterests = [];
                for (let item of data["leadInterests"])
                    this.leadInterests.push(LeadInterestDto.fromJS(item));
            }
            this.leadRequestXref = data["leadRequestXref"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.phoneExt = data["phoneExt"];
            this.comments = data["comments"];
            this.sourceCode = data["sourceCode"];
        }
    }

    static fromJS(data: any): SubmitTenantCreationRequestInput {
        let result = new SubmitTenantCreationRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.leadInterests && this.leadInterests.constructor === Array) {
            data["leadInterests"] = [];
            for (let item of this.leadInterests)
                data["leadInterests"].push(item.toJSON());
        }
        data["leadRequestXref"] = this.leadRequestXref;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        return data; 
    }
}

export interface ISubmitTenantCreationRequestInput {
    companyName: string;
    editionId: number;
    paymentPeriodType: SubmitTenantCreationRequestInputPaymentPeriodType;
    leadInterests: LeadInterestDto[];
    leadRequestXref: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    phoneExt: string;
    comments: string;
    sourceCode: string;
}

export class LeadInterestDto implements ILeadInterestDto {
    productId: number;
    quantity: number;
    amount: number;

    constructor(data?: ILeadInterestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.quantity = data["quantity"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): LeadInterestDto {
        let result = new LeadInterestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface ILeadInterestDto {
    productId: number;
    quantity: number;
    amount: number;
}

export class SubmitTenantCreationRequestOutput implements ISubmitTenantCreationRequestOutput {
    leadRequestXref: string;
    paymentPeriodType: SubmitTenantCreationRequestOutputPaymentPeriodType;
    totalMonthlyAmount: number;
    trialDayCount: number;

    constructor(data?: ISubmitTenantCreationRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.totalMonthlyAmount = data["totalMonthlyAmount"];
            this.trialDayCount = data["trialDayCount"];
        }
    }

    static fromJS(data: any): SubmitTenantCreationRequestOutput {
        let result = new SubmitTenantCreationRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["totalMonthlyAmount"] = this.totalMonthlyAmount;
        data["trialDayCount"] = this.trialDayCount;
        return data; 
    }
}

export interface ISubmitTenantCreationRequestOutput {
    leadRequestXref: string;
    paymentPeriodType: SubmitTenantCreationRequestOutputPaymentPeriodType;
    totalMonthlyAmount: number;
    trialDayCount: number;
}

export class LeadBusinessInfoInput implements ILeadBusinessInfoInput {
    shortname: string;
    companyName: string;
    emailAddress1: string;
    emailAddress2: string;
    address: string;
    city: string;
    state: string;
    zip: string;
    industry: string;
    relationship: string;
    categories: string;
    primaryFundingType: string;
    referralType: string;
    yearsInBusiness: number;
    founded: moment.Moment;
    companySize: string;
    type: string;
    ticker: string;
    refID: string;
    logo: string;
    rating: number;
    ucc: number;
    primaryContactPrefix: string;
    primaryContactPerson: string;
    primaryContactTitle: string;
    primaryContactEmail: string;
    primaryContactPhone1: string;
    primaryContactPhone1Ext: string;
    primaryContactPhone2: string;
    primaryContactDOB: moment.Moment;
    primaryContactCollege: string;
    primaryContactCityState: string;
    primaryContactPersonalProfile: string;
    primaryContactPersonalLinkedIn: string;
    businessPhones: LeadBusinessPhoneInput[];
    businessLinks: LeadBusinessLinkInput[];
    businessAliases: LeadBusinessAliasInput[];
    businessTeamContacts: LeadBusinessTeamContactInput[];

    constructor(data?: ILeadBusinessInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shortname = data["shortname"];
            this.companyName = data["companyName"];
            this.emailAddress1 = data["emailAddress1"];
            this.emailAddress2 = data["emailAddress2"];
            this.address = data["address"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
            this.industry = data["industry"];
            this.relationship = data["relationship"];
            this.categories = data["categories"];
            this.primaryFundingType = data["primaryFundingType"];
            this.referralType = data["referralType"];
            this.yearsInBusiness = data["yearsInBusiness"];
            this.founded = data["founded"] ? moment(data["founded"].toString()) : <any>undefined;
            this.companySize = data["companySize"];
            this.type = data["type"];
            this.ticker = data["ticker"];
            this.refID = data["refID"];
            this.logo = data["logo"];
            this.rating = data["rating"];
            this.ucc = data["ucc"];
            this.primaryContactPrefix = data["primaryContactPrefix"];
            this.primaryContactPerson = data["primaryContactPerson"];
            this.primaryContactTitle = data["primaryContactTitle"];
            this.primaryContactEmail = data["primaryContactEmail"];
            this.primaryContactPhone1 = data["primaryContactPhone1"];
            this.primaryContactPhone1Ext = data["primaryContactPhone1Ext"];
            this.primaryContactPhone2 = data["primaryContactPhone2"];
            this.primaryContactDOB = data["primaryContactDOB"] ? moment(data["primaryContactDOB"].toString()) : <any>undefined;
            this.primaryContactCollege = data["primaryContactCollege"];
            this.primaryContactCityState = data["primaryContactCityState"];
            this.primaryContactPersonalProfile = data["primaryContactPersonalProfile"];
            this.primaryContactPersonalLinkedIn = data["primaryContactPersonalLinkedIn"];
            if (data["businessPhones"] && data["businessPhones"].constructor === Array) {
                this.businessPhones = [];
                for (let item of data["businessPhones"])
                    this.businessPhones.push(LeadBusinessPhoneInput.fromJS(item));
            }
            if (data["businessLinks"] && data["businessLinks"].constructor === Array) {
                this.businessLinks = [];
                for (let item of data["businessLinks"])
                    this.businessLinks.push(LeadBusinessLinkInput.fromJS(item));
            }
            if (data["businessAliases"] && data["businessAliases"].constructor === Array) {
                this.businessAliases = [];
                for (let item of data["businessAliases"])
                    this.businessAliases.push(LeadBusinessAliasInput.fromJS(item));
            }
            if (data["businessTeamContacts"] && data["businessTeamContacts"].constructor === Array) {
                this.businessTeamContacts = [];
                for (let item of data["businessTeamContacts"])
                    this.businessTeamContacts.push(LeadBusinessTeamContactInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeadBusinessInfoInput {
        let result = new LeadBusinessInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortname"] = this.shortname;
        data["companyName"] = this.companyName;
        data["emailAddress1"] = this.emailAddress1;
        data["emailAddress2"] = this.emailAddress2;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["industry"] = this.industry;
        data["relationship"] = this.relationship;
        data["categories"] = this.categories;
        data["primaryFundingType"] = this.primaryFundingType;
        data["referralType"] = this.referralType;
        data["yearsInBusiness"] = this.yearsInBusiness;
        data["founded"] = this.founded ? this.founded.toISOString() : <any>undefined;
        data["companySize"] = this.companySize;
        data["type"] = this.type;
        data["ticker"] = this.ticker;
        data["refID"] = this.refID;
        data["logo"] = this.logo;
        data["rating"] = this.rating;
        data["ucc"] = this.ucc;
        data["primaryContactPrefix"] = this.primaryContactPrefix;
        data["primaryContactPerson"] = this.primaryContactPerson;
        data["primaryContactTitle"] = this.primaryContactTitle;
        data["primaryContactEmail"] = this.primaryContactEmail;
        data["primaryContactPhone1"] = this.primaryContactPhone1;
        data["primaryContactPhone1Ext"] = this.primaryContactPhone1Ext;
        data["primaryContactPhone2"] = this.primaryContactPhone2;
        data["primaryContactDOB"] = this.primaryContactDOB ? this.primaryContactDOB.toISOString() : <any>undefined;
        data["primaryContactCollege"] = this.primaryContactCollege;
        data["primaryContactCityState"] = this.primaryContactCityState;
        data["primaryContactPersonalProfile"] = this.primaryContactPersonalProfile;
        data["primaryContactPersonalLinkedIn"] = this.primaryContactPersonalLinkedIn;
        if (this.businessPhones && this.businessPhones.constructor === Array) {
            data["businessPhones"] = [];
            for (let item of this.businessPhones)
                data["businessPhones"].push(item.toJSON());
        }
        if (this.businessLinks && this.businessLinks.constructor === Array) {
            data["businessLinks"] = [];
            for (let item of this.businessLinks)
                data["businessLinks"].push(item.toJSON());
        }
        if (this.businessAliases && this.businessAliases.constructor === Array) {
            data["businessAliases"] = [];
            for (let item of this.businessAliases)
                data["businessAliases"].push(item.toJSON());
        }
        if (this.businessTeamContacts && this.businessTeamContacts.constructor === Array) {
            data["businessTeamContacts"] = [];
            for (let item of this.businessTeamContacts)
                data["businessTeamContacts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILeadBusinessInfoInput {
    shortname: string;
    companyName: string;
    emailAddress1: string;
    emailAddress2: string;
    address: string;
    city: string;
    state: string;
    zip: string;
    industry: string;
    relationship: string;
    categories: string;
    primaryFundingType: string;
    referralType: string;
    yearsInBusiness: number;
    founded: moment.Moment;
    companySize: string;
    type: string;
    ticker: string;
    refID: string;
    logo: string;
    rating: number;
    ucc: number;
    primaryContactPrefix: string;
    primaryContactPerson: string;
    primaryContactTitle: string;
    primaryContactEmail: string;
    primaryContactPhone1: string;
    primaryContactPhone1Ext: string;
    primaryContactPhone2: string;
    primaryContactDOB: moment.Moment;
    primaryContactCollege: string;
    primaryContactCityState: string;
    primaryContactPersonalProfile: string;
    primaryContactPersonalLinkedIn: string;
    businessPhones: LeadBusinessPhoneInput[];
    businessLinks: LeadBusinessLinkInput[];
    businessAliases: LeadBusinessAliasInput[];
    businessTeamContacts: LeadBusinessTeamContactInput[];
}

export class LeadBusinessPhoneInput implements ILeadBusinessPhoneInput {
    phoneNumber: string;

    constructor(data?: ILeadBusinessPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): LeadBusinessPhoneInput {
        let result = new LeadBusinessPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ILeadBusinessPhoneInput {
    phoneNumber: string;
}

export class LeadBusinessLinkInput implements ILeadBusinessLinkInput {
    linkType: string;
    link: string;

    constructor(data?: ILeadBusinessLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkType = data["linkType"];
            this.link = data["link"];
        }
    }

    static fromJS(data: any): LeadBusinessLinkInput {
        let result = new LeadBusinessLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkType"] = this.linkType;
        data["link"] = this.link;
        return data; 
    }
}

export interface ILeadBusinessLinkInput {
    linkType: string;
    link: string;
}

export class LeadBusinessAliasInput implements ILeadBusinessAliasInput {
    alias: string;

    constructor(data?: ILeadBusinessAliasInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.alias = data["alias"];
        }
    }

    static fromJS(data: any): LeadBusinessAliasInput {
        let result = new LeadBusinessAliasInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alias"] = this.alias;
        return data; 
    }
}

export interface ILeadBusinessAliasInput {
    alias: string;
}

export class LeadBusinessTeamContactInput implements ILeadBusinessTeamContactInput {
    prefix: string;
    fullName: string;
    title: string;
    emailAddress: string;
    phoneNumber: string;

    constructor(data?: ILeadBusinessTeamContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prefix = data["prefix"];
            this.fullName = data["fullName"];
            this.title = data["title"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): LeadBusinessTeamContactInput {
        let result = new LeadBusinessTeamContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["fullName"] = this.fullName;
        data["title"] = this.title;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ILeadBusinessTeamContactInput {
    prefix: string;
    fullName: string;
    title: string;
    emailAddress: string;
    phoneNumber: string;
}

export class LeadBusinessInfoOutput implements ILeadBusinessInfoOutput {
    leadRequestXref: string;
    shortName: string;
    companyName: string;
    primaryContactPerson: string;
    errorMessage: string;

    constructor(data?: ILeadBusinessInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.shortName = data["shortName"];
            this.companyName = data["companyName"];
            this.primaryContactPerson = data["primaryContactPerson"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): LeadBusinessInfoOutput {
        let result = new LeadBusinessInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["shortName"] = this.shortName;
        data["companyName"] = this.companyName;
        data["primaryContactPerson"] = this.primaryContactPerson;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface ILeadBusinessInfoOutput {
    leadRequestXref: string;
    shortName: string;
    companyName: string;
    primaryContactPerson: string;
    errorMessage: string;
}

export class SelectPackageResponseDto implements ISelectPackageResponseDto {
    registrationId: string;
    memberInfo: MemberInfoDto;
    paymentAuthorizationRequired: boolean;

    constructor(data?: ISelectPackageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.memberInfo = data["memberInfo"] ? MemberInfoDto.fromJS(data["memberInfo"]) : <any>undefined;
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SelectPackageResponseDto {
        let result = new SelectPackageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISelectPackageResponseDto {
    registrationId: string;
    memberInfo: MemberInfoDto;
    paymentAuthorizationRequired: boolean;
}

export class MemberInfoDto implements IMemberInfoDto {
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string;
    address: MemberAddressDto;
    doB: moment.Moment;
    ssn: string;
    gender: MemberInfoDtoGender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo;

    constructor(data?: IMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberInfoDto {
        let result = new MemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberInfoDto {
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string;
    address: MemberAddressDto;
    doB: moment.Moment;
    ssn: string;
    gender: MemberInfoDtoGender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo;
}

export class MemberAddressDto implements IMemberAddressDto {
    streetAddress: string;
    zip: string;
    city: string;
    stateId: string;
    state: string;
    countryId: string;
    country: string;

    constructor(data?: IMemberAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.state = data["state"];
            this.countryId = data["countryId"];
            this.country = data["country"];
        }
    }

    static fromJS(data: any): MemberAddressDto {
        let result = new MemberAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["state"] = this.state;
        data["countryId"] = this.countryId;
        data["country"] = this.country;
        return data; 
    }
}

export interface IMemberAddressDto {
    streetAddress: string;
    zip: string;
    city: string;
    stateId: string;
    state: string;
    countryId: string;
    country: string;
}

export class UTMParameterInfo implements IUTMParameterInfo {
    source: string;
    medium: string;
    campaign: string;
    term: string;
    content: string;

    constructor(data?: IUTMParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"];
            this.medium = data["medium"];
            this.campaign = data["campaign"];
            this.term = data["term"];
            this.content = data["content"];
        }
    }

    static fromJS(data: any): UTMParameterInfo {
        let result = new UTMParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["medium"] = this.medium;
        data["campaign"] = this.campaign;
        data["term"] = this.term;
        data["content"] = this.content;
        return data; 
    }
}

export interface IUTMParameterInfo {
    source: string;
    medium: string;
    campaign: string;
    term: string;
    content: string;
}

export class SubmitMemberInfoResultDto implements ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired: boolean;

    constructor(data?: ISubmitMemberInfoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SubmitMemberInfoResultDto {
        let result = new SubmitMemberInfoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired: boolean;
}

export class PaymentAuthorizeRequestDto implements IPaymentAuthorizeRequestDto {
    registrationId: string;
    packageId: number;
    bankCard: BankCardDto = new BankCardDto();

    constructor(data?: IPaymentAuthorizeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.packageId = data["packageId"];
            this.bankCard = data["bankCard"] ? BankCardDto.fromJS(data["bankCard"]) : new BankCardDto();
        }
    }

    static fromJS(data: any): PaymentAuthorizeRequestDto {
        let result = new PaymentAuthorizeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["packageId"] = this.packageId;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaymentAuthorizeRequestDto {
    registrationId: string;
    packageId: number;
    bankCard: BankCardDto;
}

export class BankCardDto implements IBankCardDto {
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    cvv: string;
    billingAddress: string;
    billingZip: string;
    billingCity: string;
    billingStateCode: string;
    billingState: string;
    billingCountryCode: string;
    billingCountry: string;

    constructor(data?: IBankCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.cvv = data["cvv"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingState = data["billingState"];
            this.billingCountryCode = data["billingCountryCode"];
            this.billingCountry = data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardDto {
        let result = new BankCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data; 
    }
}

export interface IBankCardDto {
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    cvv: string;
    billingAddress: string;
    billingZip: string;
    billingCity: string;
    billingStateCode: string;
    billingState: string;
    billingCountryCode: string;
    billingCountry: string;
}

export class PaymentAuthorizeResponseDto implements IPaymentAuthorizeResponseDto {
    success: boolean;
    errors: string[];

    constructor(data?: IPaymentAuthorizeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(item);
            }
        }
    }

    static fromJS(data: any): PaymentAuthorizeResponseDto {
        let result = new PaymentAuthorizeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IPaymentAuthorizeResponseDto {
    success: boolean;
    errors: string[];
}

export class RegisterMemberRequest implements IRegisterMemberRequest {
    password: string;
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string;
    address: MemberAddressDto;
    doB: moment.Moment;
    ssn: string;
    gender: RegisterMemberRequestGender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo;

    constructor(data?: IRegisterMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberRequest {
        let result = new RegisterMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterMemberRequest {
    password: string;
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string;
    address: MemberAddressDto;
    doB: moment.Moment;
    ssn: string;
    gender: RegisterMemberRequestGender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[];

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[];
}

export class UserNotification implements IUserNotification {
    tenantId: number;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class TenantNotification implements ITenantNotification {
    tenantId: number;
    notificationName: string;
    data: NotificationData;
    entityType: string;
    entityTypeName: string;
    entityId: any;
    severity: TenantNotificationSeverity;
    creationTime: moment.Moment;
    id: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            if (data["entityId"]) {
                this.entityId = {};
                for (let key in data["entityId"]) {
                    if (data["entityId"].hasOwnProperty(key))
                        this.entityId[key] = data["entityId"][key];
                }
            }
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        if (this.entityId) {
            data["entityId"] = {};
            for (let key in this.entityId) {
                if (this.entityId.hasOwnProperty(key))
                    data["entityId"][key] = this.entityId[key];
            }
        }
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number;
    notificationName: string;
    data: NotificationData;
    entityType: string;
    entityTypeName: string;
    entityId: any;
    severity: TenantNotificationSeverity;
    creationTime: moment.Moment;
    id: string;
}

export class NotificationData implements INotificationData {
    type: string;
    properties: { [key: string] : any; };

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string;
    properties: { [key: string] : any; };
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[];

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[];
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string;
    description: string;
    name: string;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string;
    description: string;
    name: string;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[];

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[];
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class OrderFiltersInitialData implements IOrderFiltersInitialData {
    pipelines: PipelineDto[];
    subscriptionStatuses: BillingSubscriptionStatusDto[];

    constructor(data?: IOrderFiltersInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pipelines"] && data["pipelines"].constructor === Array) {
                this.pipelines = [];
                for (let item of data["pipelines"])
                    this.pipelines.push(PipelineDto.fromJS(item));
            }
            if (data["subscriptionStatuses"] && data["subscriptionStatuses"].constructor === Array) {
                this.subscriptionStatuses = [];
                for (let item of data["subscriptionStatuses"])
                    this.subscriptionStatuses.push(BillingSubscriptionStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderFiltersInitialData {
        let result = new OrderFiltersInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pipelines && this.pipelines.constructor === Array) {
            data["pipelines"] = [];
            for (let item of this.pipelines)
                data["pipelines"].push(item.toJSON());
        }
        if (this.subscriptionStatuses && this.subscriptionStatuses.constructor === Array) {
            data["subscriptionStatuses"] = [];
            for (let item of this.subscriptionStatuses)
                data["subscriptionStatuses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderFiltersInitialData {
    pipelines: PipelineDto[];
    subscriptionStatuses: BillingSubscriptionStatusDto[];
}

export class PipelineDto implements IPipelineDto {
    id: number;
    name: string;
    purpose: string;
    stages: StageDto[];

    constructor(data?: IPipelineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.purpose = data["purpose"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(StageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDto {
        let result = new PipelineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["purpose"] = this.purpose;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPipelineDto {
    id: number;
    name: string;
    purpose: string;
    stages: StageDto[];
}

export class BillingSubscriptionStatusDto implements IBillingSubscriptionStatusDto {
    id: string;
    name: string;

    constructor(data?: IBillingSubscriptionStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BillingSubscriptionStatusDto {
        let result = new BillingSubscriptionStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBillingSubscriptionStatusDto {
    id: string;
    name: string;
}

export class StageDto implements IStageDto {
    id: number;
    name: string;
    color: string;
    accessibleActions: ActionDto[];

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.color = data["color"];
            if (data["accessibleActions"] && data["accessibleActions"].constructor === Array) {
                this.accessibleActions = [];
                for (let item of data["accessibleActions"])
                    this.accessibleActions.push(ActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDto {
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["color"] = this.color;
        if (this.accessibleActions && this.accessibleActions.constructor === Array) {
            data["accessibleActions"] = [];
            for (let item of this.accessibleActions)
                data["accessibleActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStageDto {
    id: number;
    name: string;
    color: string;
    accessibleActions: ActionDto[];
}

export class ActionDto implements IActionDto {
    id: number;
    name: string;
    sysId: string;
    targetStageId: number;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            this.targetStageId = data["targetStageId"];
        }
    }

    static fromJS(data: any): ActionDto {
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        data["targetStageId"] = this.targetStageId;
        return data; 
    }
}

export interface IActionDto {
    id: number;
    name: string;
    sysId: string;
    targetStageId: number;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[];

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[];
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId: number;
    code: string;
    displayName: string;
    memberCount: number;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number;
    code: string;
    displayName: string;
    memberCount: number;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[];

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[];
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    profilePictureId: string;
    addedTime: moment.Moment;
    id: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    profilePictureId: string;
    addedTime: moment.Moment;
    id: number;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number;
    newParentId: number;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[];
    organizationUnitId: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[];
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;
}

export class ListResultDtoOfPackageDto implements IListResultDtoOfPackageDto {
    items: PackageDto[];

    constructor(data?: IListResultDtoOfPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPackageDto {
        let result = new ListResultDtoOfPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPackageDto {
    items: PackageDto[];
}

export class PackageDto implements IPackageDto {
    tenantId: number;
    name: string;
    idcsPackageId: number;
    description: string;
    initialPaymentAmount: number;
    trialPeriodDays: number;
    monthlyPaymentAmount: number;
    isActive: boolean;
    isSimulatorEnabled: boolean;
    isDeleted: boolean;
    deleterUserId: number;
    deletionTime: moment.Moment;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;

    constructor(data?: IPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.idcsPackageId = data["idcsPackageId"];
            this.description = data["description"];
            this.initialPaymentAmount = data["initialPaymentAmount"];
            this.trialPeriodDays = data["trialPeriodDays"];
            this.monthlyPaymentAmount = data["monthlyPaymentAmount"];
            this.isActive = data["isActive"];
            this.isSimulatorEnabled = data["isSimulatorEnabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PackageDto {
        let result = new PackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["idcsPackageId"] = this.idcsPackageId;
        data["description"] = this.description;
        data["initialPaymentAmount"] = this.initialPaymentAmount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["monthlyPaymentAmount"] = this.monthlyPaymentAmount;
        data["isActive"] = this.isActive;
        data["isSimulatorEnabled"] = this.isSimulatorEnabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPackageDto {
    tenantId: number;
    name: string;
    idcsPackageId: number;
    description: string;
    initialPaymentAmount: number;
    trialPeriodDays: number;
    monthlyPaymentAmount: number;
    isActive: boolean;
    isSimulatorEnabled: boolean;
    isDeleted: boolean;
    deleterUserId: number;
    deletionTime: moment.Moment;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export class EditionSelectDto implements IEditionSelectDto {
    id: number;
    name: string;
    displayName: string;
    expiringEditionId: number;
    monthlyPrice: number;
    annualPrice: number;
    trialDayCount: number;
    waitingDayAfterExpire: number;
    isFree: boolean;
    additionalData: AdditionalData;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string;
    displayName: string;
    expiringEditionId: number;
    monthlyPrice: number;
    annualPrice: number;
    trialDayCount: number;
    waitingDayAfterExpire: number;
    isFree: boolean;
    additionalData: AdditionalData;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId: number;
    editionPaymentType: CreatePaymentDtoEditionPaymentType;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: CreatePaymentDtoEditionPaymentType;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType;
}

export class ExecutePaymentDto implements IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType;
    editionId: number;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType;
    additionalData: { [key: string] : string; };

    constructor(data?: IExecutePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.editionPaymentType = data["editionPaymentType"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["additionalData"]) {
                this.additionalData = {};
                for (let key in data["additionalData"]) {
                    if (data["additionalData"].hasOwnProperty(key))
                        this.additionalData[key] = data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExecutePaymentDto {
        let result = new ExecutePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["editionPaymentType"] = this.editionPaymentType;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    data["additionalData"][key] = this.additionalData[key];
            }
        }
        return data; 
    }
}

export interface IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType;
    editionId: number;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType;
    additionalData: { [key: string] : string; };
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[];

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[];
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway: string;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string;
    paymentId: string;
    payerId: string;
    status: string;
    editionDisplayName: string;
    tenantId: number;
    invoiceNo: string;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string;
    paymentId: string;
    payerId: string;
    status: string;
    editionDisplayName: string;
    tenantId: number;
    invoiceNo: string;
    lastModificationTime: moment.Moment;
    lastModifierUserId: number;
    creationTime: moment.Moment;
    creatorUserId: number;
    id: number;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[];

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[];
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number;
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    isGrantedByDefault: boolean;
}

export class PipelineData implements IPipelineData {
    id: number;
    name: string;

    constructor(data?: IPipelineData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PipelineData {
        let result = new PipelineData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPipelineData {
    id: number;
    name: string;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string;
    isPhoneNumberConfirmed: boolean;
    timezone: string;
    qrCodeSetupImageUrl: string;
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string;
    isPhoneNumberConfirmed: boolean;
    timezone: string;
    qrCodeSetupImageUrl: string;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileName: string;
    x: number;
    y: number;
    width: number;
    height: number;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileName: string;
    x: number;
    y: number;
    width: number;
    height: number;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture: string;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[];

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[];
}

export class RoleListDto implements IRoleListDto {
    name: string;
    displayName: string;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string;
    displayName: string;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[];
    grantedPermissionNames: string[];

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[];
    grantedPermissionNames: string[];
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    displayName: string;
    isDefault: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number;
    displayName: string;
    isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    isGrantedByDefault: boolean;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto = new RoleEditDto();
    grantedPermissionNames: string[] = [];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    profilePictureId: string;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    profilePictureId: string;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string;
    name: string;
    logoId: string;
    logoFileType: string;
    customCssId: string;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType;
    subscriptionDateString: string;
    creationTimeString: string;
    tenantCustomizations: TenantCustomizationInfoDto;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.tenantCustomizations = data["tenantCustomizations"] ? TenantCustomizationInfoDto.fromJS(data["tenantCustomizations"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["tenantCustomizations"] = this.tenantCustomizations ? this.tenantCustomizations.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string;
    name: string;
    logoId: string;
    logoFileType: string;
    customCssId: string;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType;
    subscriptionDateString: string;
    creationTimeString: string;
    tenantCustomizations: TenantCustomizationInfoDto;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string;
    trialDayCount: number;
    monthlyPrice: number;
    annualPrice: number;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string;
    trialDayCount: number;
    monthlyPrice: number;
    annualPrice: number;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantCustomizationInfoDto implements ITenantCustomizationInfoDto {
    favicons: FaviconDto[];
    siteTitle: string;

    constructor(data?: ITenantCustomizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["favicons"] && data["favicons"].constructor === Array) {
                this.favicons = [];
                for (let item of data["favicons"])
                    this.favicons.push(FaviconDto.fromJS(item));
            }
            this.siteTitle = data["siteTitle"];
        }
    }

    static fromJS(data: any): TenantCustomizationInfoDto {
        let result = new TenantCustomizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.favicons && this.favicons.constructor === Array) {
            data["favicons"] = [];
            for (let item of this.favicons)
                data["favicons"].push(item.toJSON());
        }
        data["siteTitle"] = this.siteTitle;
        return data; 
    }
}

export interface ITenantCustomizationInfoDto {
    favicons: FaviconDto[];
    siteTitle: string;
}

export class FaviconDto implements IFaviconDto {
    faviconName: string;
    faviconUri: string;

    constructor(data?: IFaviconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.faviconName = data["faviconName"];
            this.faviconUri = data["faviconUri"];
        }
    }

    static fromJS(data: any): FaviconDto {
        let result = new FaviconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faviconName"] = this.faviconName;
        data["faviconUri"] = this.faviconUri;
        return data; 
    }
}

export interface IFaviconDto {
    faviconName: string;
    faviconUri: string;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string;
    encodedUserId: string;
    encodedTenantId: string;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string;
    encodedUserId: string;
    encodedTenantId: string;
}

export class GetUserInformationOutput implements IGetUserInformationOutput {
    tenancyName: string;
    userName: string;

    constructor(data?: IGetUserInformationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetUserInformationOutput {
        let result = new GetUserInformationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetUserInformationOutput {
    tenancyName: string;
    userName: string;
}

export class PagedResultDtoOfTenancyListDto implements IPagedResultDtoOfTenancyListDto {
    totalCount: number;
    items: TenancyListDto[];

    constructor(data?: IPagedResultDtoOfTenancyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenancyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenancyListDto {
        let result = new PagedResultDtoOfTenancyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenancyListDto {
    totalCount: number;
    items: TenancyListDto[];
}

export class TenancyListDto implements ITenancyListDto {
    name: string;
    id: number;

    constructor(data?: ITenancyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenancyListDto {
        let result = new TenancyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenancyListDto {
    name: string;
    id: number;
}

export class CreateTenancyInput implements ICreateTenancyInput {
    customerId: number;
    adminEmailAddress: string;
    adminPassword: string;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;

    constructor(data?: ICreateTenancyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerId = data["customerId"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenancyInput {
        let result = new CreateTenancyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenancyInput {
    customerId: number;
    adminEmailAddress: string;
    adminPassword: string;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
}

export class GetTenancyForEditOutput implements IGetTenancyForEditOutput {
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;

    constructor(data?: IGetTenancyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): GetTenancyForEditOutput {
        let result = new GetTenancyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface IGetTenancyForEditOutput {
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
}

export class UpdateTenancyInput implements IUpdateTenancyInput {
    id: number;
    customerId: number;
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;

    constructor(data?: IUpdateTenancyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): UpdateTenancyInput {
        let result = new UpdateTenancyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface IUpdateTenancyInput {
    id: number;
    customerId: number;
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[];

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[];
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string;
    name: string;
    editionDisplayName: string;
    hasOwnDatabase: boolean;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment;
    editionId: number;
    isInTrialPeriod: boolean;
    id: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.hasOwnDatabase = data["hasOwnDatabase"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["hasOwnDatabase"] = this.hasOwnDatabase;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string;
    name: string;
    editionDisplayName: string;
    hasOwnDatabase: boolean;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment;
    editionId: number;
    isInTrialPeriod: boolean;
    id: number;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    cfoConnectionString: string;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    cfoConnectionString: string;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    cfoConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
    id: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string;
    crmConnectionString: string;
    memberDbConnectionString: string;
    cfoConnectionString: string;
    editionId: number;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment;
    isInTrialPeriod: boolean;
    id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[];
    features: FlatFeatureDto[];

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[];
    features: FlatFeatureDto[];
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[] = [];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number;
}

export class TenantCustomizationDto implements ITenantCustomizationDto {
    customizationGroupName: string;
    customizationName: string;
    value: string;

    constructor(data?: ITenantCustomizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customizationGroupName = data["customizationGroupName"];
            this.customizationName = data["customizationName"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantCustomizationDto {
        let result = new TenantCustomizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customizationGroupName"] = this.customizationGroupName;
        data["customizationName"] = this.customizationName;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantCustomizationDto {
    customizationGroupName: string;
    customizationName: string;
    value: string;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities: MemberActivity[];

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[];
}

export class MemberActivity implements IMemberActivity {
    name: string;
    earnings: string;
    cases: number;
    closed: number;
    rate: string;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string;
    earnings: string;
    cases: number;
    closed: number;
    rate: string;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[];
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[];
    profitShares: number[];

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[];
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[];
    profitShares: number[];
}

export class SalesSummaryData implements ISalesSummaryData {
    period: string;
    sales: number;
    profit: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string;
    sales: number;
    profit: number;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[];

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[];
}

export class GetWorldMapOutput implements IGetWorldMapOutput {
    countries: WorldMapCountry[];

    constructor(data?: IGetWorldMapOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["countries"] && data["countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["countries"])
                    this.countries.push(WorldMapCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWorldMapOutput {
        let result = new GetWorldMapOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.countries && this.countries.constructor === Array) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetWorldMapOutput {
    countries: WorldMapCountry[];
}

export class WorldMapCountry implements IWorldMapCountry {
    countryName: string;
    color: number;

    constructor(data?: IWorldMapCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.color = data["color"];
        }
    }

    static fromJS(data: any): WorldMapCountry {
        let result = new WorldMapCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["color"] = this.color;
        return data; 
    }
}

export interface IWorldMapCountry {
    countryName: string;
    color: number;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export class TenantApiHostOutput implements ITenantApiHostOutput {
    apiHostName: string;

    constructor(data?: ITenantApiHostOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiHostName = data["apiHostName"];
        }
    }

    static fromJS(data: any): TenantApiHostOutput {
        let result = new TenantApiHostOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiHostName"] = this.apiHostName;
        return data; 
    }
}

export interface ITenantApiHostOutput {
    apiHostName: string;
}

export class CheckHostNameDnsMappingInput implements ICheckHostNameDnsMappingInput {
    tenantHostType: CheckHostNameDnsMappingInputTenantHostType;
    hostName: string;

    constructor(data?: ICheckHostNameDnsMappingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingInput {
        let result = new CheckHostNameDnsMappingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["hostName"] = this.hostName;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingInput {
    tenantHostType: CheckHostNameDnsMappingInputTenantHostType;
    hostName: string;
}

export class CheckHostNameDnsMappingOutput implements ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped: boolean;

    constructor(data?: ICheckHostNameDnsMappingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hostNameDnsMapped = data["hostNameDnsMapped"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingOutput {
        let result = new CheckHostNameDnsMappingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostNameDnsMapped"] = this.hostNameDnsMapped;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped: boolean;
}

export class TenantSslBindingInfo implements ITenantSslBindingInfo {
    id: number;
    hostName: string;
    hostType: TenantSslBindingInfoHostType;
    isActive: boolean;
    sslCertificateId: number;
    sslCertificateExpiration: moment.Moment;
    sslCertificateThumbprint: string;

    constructor(data?: ITenantSslBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostName = data["hostName"];
            this.hostType = data["hostType"];
            this.isActive = data["isActive"];
            this.sslCertificateId = data["sslCertificateId"];
            this.sslCertificateExpiration = data["sslCertificateExpiration"] ? moment(data["sslCertificateExpiration"].toString()) : <any>undefined;
            this.sslCertificateThumbprint = data["sslCertificateThumbprint"];
        }
    }

    static fromJS(data: any): TenantSslBindingInfo {
        let result = new TenantSslBindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostName"] = this.hostName;
        data["hostType"] = this.hostType;
        data["isActive"] = this.isActive;
        data["sslCertificateId"] = this.sslCertificateId;
        data["sslCertificateExpiration"] = this.sslCertificateExpiration ? this.sslCertificateExpiration.toISOString() : <any>undefined;
        data["sslCertificateThumbprint"] = this.sslCertificateThumbprint;
        return data; 
    }
}

export interface ITenantSslBindingInfo {
    id: number;
    hostName: string;
    hostType: TenantSslBindingInfoHostType;
    isActive: boolean;
    sslCertificateId: number;
    sslCertificateExpiration: moment.Moment;
    sslCertificateThumbprint: string;
}

export class AddSslBindingInput implements IAddSslBindingInput {
    tenantHostType: AddSslBindingInputTenantHostType;
    domainName: string;
    sslCertificateId: number;

    constructor(data?: IAddSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.domainName = data["domainName"];
            this.sslCertificateId = data["sslCertificateId"];
        }
    }

    static fromJS(data: any): AddSslBindingInput {
        let result = new AddSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["domainName"] = this.domainName;
        data["sslCertificateId"] = this.sslCertificateId;
        return data; 
    }
}

export interface IAddSslBindingInput {
    tenantHostType: AddSslBindingInputTenantHostType;
    domainName: string;
    sslCertificateId: number;
}

export class UpdateSslBindingCertificateInput implements IUpdateSslBindingCertificateInput {
    tenantHostType: UpdateSslBindingCertificateInputTenantHostType;
    sslCertificateId: number;

    constructor(data?: IUpdateSslBindingCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.sslCertificateId = data["sslCertificateId"];
        }
    }

    static fromJS(data: any): UpdateSslBindingCertificateInput {
        let result = new UpdateSslBindingCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["sslCertificateId"] = this.sslCertificateId;
        return data; 
    }
}

export interface IUpdateSslBindingCertificateInput {
    tenantHostType: UpdateSslBindingCertificateInputTenantHostType;
    sslCertificateId: number;
}

export class UpdateSslBindingIsActiveInput implements IUpdateSslBindingIsActiveInput {
    tenantHostType: UpdateSslBindingIsActiveInputTenantHostType;
    isActive: boolean;

    constructor(data?: IUpdateSslBindingIsActiveInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateSslBindingIsActiveInput {
        let result = new UpdateSslBindingIsActiveInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateSslBindingIsActiveInput {
    tenantHostType: UpdateSslBindingIsActiveInputTenantHostType;
    isActive: boolean;
}

export class IntegrationsSettings implements IIntegrationsSettings {
    googleMapsJavascriptApiKey: string;

    constructor(data?: IIntegrationsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.googleMapsJavascriptApiKey = data["googleMapsJavascriptApiKey"];
        }
    }

    static fromJS(data: any): IntegrationsSettings {
        let result = new IntegrationsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapsJavascriptApiKey"] = this.googleMapsJavascriptApiKey;
        return data; 
    }
}

export interface IIntegrationsSettings {
    googleMapsJavascriptApiKey: string;
}

export class BaseCommercePaymentSettings implements IBaseCommercePaymentSettings {
    userName: string;
    password: string;
    key: string;
    sandBox: boolean;

    constructor(data?: IBaseCommercePaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.key = data["key"];
            this.sandBox = data["sandBox"];
        }
    }

    static fromJS(data: any): BaseCommercePaymentSettings {
        let result = new BaseCommercePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["key"] = this.key;
        data["sandBox"] = this.sandBox;
        return data; 
    }
}

export interface IBaseCommercePaymentSettings {
    userName: string;
    password: string;
    key: string;
    sandBox: boolean;
}

export class CompleteTenantRegistrationInput implements ICompleteTenantRegistrationInput {
    leadRequestXref: string;
    tenantName: string;
    tenancyName: string;
    adminEmailAddress: string;
    adminPassword: string;

    constructor(data?: ICompleteTenantRegistrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.tenantName = data["tenantName"];
            this.tenancyName = data["tenancyName"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationInput {
        let result = new CompleteTenantRegistrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["tenantName"] = this.tenantName;
        data["tenancyName"] = this.tenancyName;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        return data; 
    }
}

export interface ICompleteTenantRegistrationInput {
    leadRequestXref: string;
    tenantName: string;
    tenancyName: string;
    adminEmailAddress: string;
    adminPassword: string;
}

export class CompleteTenantRegistrationOutput implements ICompleteTenantRegistrationOutput {
    tenantId: number;
    tenancyName: string;

    constructor(data?: ICompleteTenantRegistrationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationOutput {
        let result = new CompleteTenantRegistrationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ICompleteTenantRegistrationOutput {
    tenantId: number;
    tenancyName: string;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
    captchaResponse: string;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType;
    gateway: RegisterTenantInputGateway;
    editionId: number;
    paymentId: string;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.gateway = data["gateway"];
            this.editionId = data["editionId"];
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["gateway"] = this.gateway;
        data["editionId"] = this.editionId;
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
    captchaResponse: string;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType;
    gateway: RegisterTenantInputGateway;
    editionId: number;
    paymentId: string;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string;
    name: string;
    userName: string;
    emailAddress: string;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string;
    name: string;
    userName: string;
    emailAddress: string;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[];
    editionsWithFeatures: EditionWithFeaturesDto[];
    tenantEditionId: number;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[];
    editionsWithFeatures: EditionWithFeaturesDto[];
    tenantEditionId: number;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    defaultValue: string;
    inputType: IInputType;
    textHtmlColor: string;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string;
    name: string;
    displayName: string;
    description: string;
    defaultValue: string;
    inputType: IInputType;
    textHtmlColor: string;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[];

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[];
}

export class IInputType implements IIInputType {
    name: string;
    attributes: { [key: string] : any; };
    validator: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string;
    attributes: { [key: string] : any; };
    validator: IValueValidator;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto = new TenantUserManagementSettingsEditDto();
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto = new SecuritySettingsEditDto();
    billing: TenantBillingSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string;
    userName: string;
    password: string;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string;
    userName: string;
    password: string;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string;
    address: string;
    taxVatNo: string;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string;
    address: string;
    taxVatNo: string;
}

export class IdcsSettings implements IIdcsSettings {
    requestSource: string;
    partnerCode: string;
    partnerAccount: string;
    password: string;
    branding: string;

    constructor(data?: IIdcsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestSource = data["requestSource"];
            this.partnerCode = data["partnerCode"];
            this.partnerAccount = data["partnerAccount"];
            this.password = data["password"];
            this.branding = data["branding"];
        }
    }

    static fromJS(data: any): IdcsSettings {
        let result = new IdcsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestSource"] = this.requestSource;
        data["partnerCode"] = this.partnerCode;
        data["partnerAccount"] = this.partnerAccount;
        data["password"] = this.password;
        data["branding"] = this.branding;
        return data; 
    }
}

export interface IIdcsSettings {
    requestSource: string;
    partnerCode: string;
    partnerAccount: string;
    password: string;
    branding: string;
}

export class TenantSslCertificateInfo implements ITenantSslCertificateInfo {
    id: number;
    hostNames: string;
    expiration: moment.Moment;
    thumbprint: string;

    constructor(data?: ITenantSslCertificateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostNames = data["hostNames"];
            this.expiration = data["expiration"] ? moment(data["expiration"].toString()) : <any>undefined;
            this.thumbprint = data["thumbprint"];
        }
    }

    static fromJS(data: any): TenantSslCertificateInfo {
        let result = new TenantSslCertificateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostNames"] = this.hostNames;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["thumbprint"] = this.thumbprint;
        return data; 
    }
}

export interface ITenantSslCertificateInfo {
    id: number;
    hostNames: string;
    expiration: moment.Moment;
    thumbprint: string;
}

export class AddTenantSslCertificateInput implements IAddTenantSslCertificateInput {
    base64EncodedCertificate: string;
    password: string;

    constructor(data?: IAddTenantSslCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base64EncodedCertificate = data["base64EncodedCertificate"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): AddTenantSslCertificateInput {
        let result = new AddTenantSslCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64EncodedCertificate"] = this.base64EncodedCertificate;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAddTenantSslCertificateInput {
    base64EncodedCertificate: string;
    password: string;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[];

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[];
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string;
    rememberClient: boolean;
    twoFactorRememberClientToken: string;
    singleSignIn: boolean;
    returnUrl: string;
    autoDetectTenancy: boolean = false;
    features: string[];

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticateModel {
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string;
    rememberClient: boolean;
    twoFactorRememberClientToken: string;
    singleSignIn: boolean;
    returnUrl: string;
    autoDetectTenancy: boolean;
    features: string[];
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[];
    twoFactorRememberClientToken: string;
    returnUrl: string;
    detectedTenancies: TenantModel[];

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[];
    twoFactorRememberClientToken: string;
    returnUrl: string;
    detectedTenancies: TenantModel[];
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string;
    clientId: string;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string;
    clientId: string;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string;
    singleSignIn: boolean;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string;
    singleSignIn: boolean;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string;
}

export class FiltersInitialData implements IFiltersInitialData {
    banks: BankDto[];
    cashflowTypes: FilterElementDtoOfString[];
    currencies: FilterElementDtoOfString[];
    businessEntities: FilterElementDtoOfInt32[];

    constructor(data?: IFiltersInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["cashflowTypes"] && data["cashflowTypes"].constructor === Array) {
                this.cashflowTypes = [];
                for (let item of data["cashflowTypes"])
                    this.cashflowTypes.push(FilterElementDtoOfString.fromJS(item));
            }
            if (data["currencies"] && data["currencies"].constructor === Array) {
                this.currencies = [];
                for (let item of data["currencies"])
                    this.currencies.push(FilterElementDtoOfString.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(FilterElementDtoOfInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FiltersInitialData {
        let result = new FiltersInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.cashflowTypes && this.cashflowTypes.constructor === Array) {
            data["cashflowTypes"] = [];
            for (let item of this.cashflowTypes)
                data["cashflowTypes"].push(item.toJSON());
        }
        if (this.currencies && this.currencies.constructor === Array) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFiltersInitialData {
    banks: BankDto[];
    cashflowTypes: FilterElementDtoOfString[];
    currencies: FilterElementDtoOfString[];
    businessEntities: FilterElementDtoOfInt32[];
}

export class FilterElementDtoOfString implements IFilterElementDtoOfString {
    id: string;
    name: string;

    constructor(data?: IFilterElementDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): FilterElementDtoOfString {
        let result = new FilterElementDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IFilterElementDtoOfString {
    id: string;
    name: string;
}

export class FilterElementDtoOfInt32 implements IFilterElementDtoOfInt32 {
    id: number;
    name: string;

    constructor(data?: IFilterElementDtoOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): FilterElementDtoOfInt32 {
        let result = new FilterElementDtoOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IFilterElementDtoOfInt32 {
    id: number;
    name: string;
}

export class GetTransactionAttributeTypesOutput implements IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes: { [key: string] : TransactionAttributeTypeDto; };

    constructor(data?: IGetTransactionAttributeTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionAttributeTypes"]) {
                this.transactionAttributeTypes = {};
                for (let key in data["transactionAttributeTypes"]) {
                    if (data["transactionAttributeTypes"].hasOwnProperty(key))
                        this.transactionAttributeTypes[key] = data["transactionAttributeTypes"][key] ? TransactionAttributeTypeDto.fromJS(data["transactionAttributeTypes"][key]) : new TransactionAttributeTypeDto();
                }
            }
        }
    }

    static fromJS(data: any): GetTransactionAttributeTypesOutput {
        let result = new GetTransactionAttributeTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionAttributeTypes) {
            data["transactionAttributeTypes"] = {};
            for (let key in this.transactionAttributeTypes) {
                if (this.transactionAttributeTypes.hasOwnProperty(key))
                    data["transactionAttributeTypes"][key] = this.transactionAttributeTypes[key];
            }
        }
        return data; 
    }
}

export interface IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes: { [key: string] : TransactionAttributeTypeDto; };
}

export class TransactionAttributeTypeDto implements ITransactionAttributeTypeDto {
    name: string;
    parserCode: string;

    constructor(data?: ITransactionAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parserCode = data["parserCode"];
        }
    }

    static fromJS(data: any): TransactionAttributeTypeDto {
        let result = new TransactionAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parserCode"] = this.parserCode;
        return data; 
    }
}

export interface ITransactionAttributeTypeDto {
    name: string;
    parserCode: string;
}

export class GetTransactionDetailsOutput implements IGetTransactionDetailsOutput {
    transactionDetails: TransactionDetailsDto;

    constructor(data?: IGetTransactionDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionDetails = data["transactionDetails"] ? TransactionDetailsDto.fromJS(data["transactionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionDetailsOutput {
        let result = new GetTransactionDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionDetails"] = this.transactionDetails ? this.transactionDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTransactionDetailsOutput {
    transactionDetails: TransactionDetailsDto;
}

export class TransactionDetailsDto implements ITransactionDetailsDto {
    bankAccountName: string;
    attributes: TransactionAttributeDto[];
    id: number;
    bankAccountBankName: string;
    bankAccountNumber: string;
    date: moment.Moment;
    currency: string;
    amount: number;
    description: string;
    cashFlowTypeId: string;
    endingBalance: number;
    isBalanceConfirmed: boolean;
    cashflowCategoryGroupName: string;
    cashflowCategoryName: string;

    constructor(data?: ITransactionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountName = data["bankAccountName"];
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
            this.id = data["id"];
            this.bankAccountBankName = data["bankAccountBankName"];
            this.bankAccountNumber = data["bankAccountNumber"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.endingBalance = data["endingBalance"];
            this.isBalanceConfirmed = data["isBalanceConfirmed"];
            this.cashflowCategoryGroupName = data["cashflowCategoryGroupName"];
            this.cashflowCategoryName = data["cashflowCategoryName"];
        }
    }

    static fromJS(data: any): TransactionDetailsDto {
        let result = new TransactionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountName"] = this.bankAccountName;
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["bankAccountBankName"] = this.bankAccountBankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["endingBalance"] = this.endingBalance;
        data["isBalanceConfirmed"] = this.isBalanceConfirmed;
        data["cashflowCategoryGroupName"] = this.cashflowCategoryGroupName;
        data["cashflowCategoryName"] = this.cashflowCategoryName;
        return data; 
    }
}

export interface ITransactionDetailsDto {
    bankAccountName: string;
    attributes: TransactionAttributeDto[];
    id: number;
    bankAccountBankName: string;
    bankAccountNumber: string;
    date: moment.Moment;
    currency: string;
    amount: number;
    description: string;
    cashFlowTypeId: string;
    endingBalance: number;
    isBalanceConfirmed: boolean;
    cashflowCategoryGroupName: string;
    cashflowCategoryName: string;
}

export class TransactionTypesAndCategoriesDto implements ITransactionTypesAndCategoriesDto {
    types: TransactionTypeDto[];
    categories: FilterElementDtoOfString[];

    constructor(data?: ITransactionTypesAndCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(TransactionTypeDto.fromJS(item));
            }
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(FilterElementDtoOfString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionTypesAndCategoriesDto {
        let result = new TransactionTypesAndCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionTypesAndCategoriesDto {
    types: TransactionTypeDto[];
    categories: FilterElementDtoOfString[];
}

export class TransactionTypeDto implements ITransactionTypeDto {
    id: string;
    name: string;
    categories: string[];

    constructor(data?: ITransactionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(item);
            }
        }
    }

    static fromJS(data: any): TransactionTypeDto {
        let result = new TransactionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data; 
    }
}

export interface ITransactionTypeDto {
    id: string;
    name: string;
    categories: string[];
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto;
    header: UiCustomizationHeaderSettingsEditDto;
    menu: UiCustomizationMenuSettingsEditDto;
    footer: UiCustomizationFooterSettingsEditDto;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto;
    header: UiCustomizationHeaderSettingsEditDto;
    menu: UiCustomizationMenuSettingsEditDto;
    footer: UiCustomizationFooterSettingsEditDto;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType: string;
    pageLoader: string;
    contentSkin: string;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.pageLoader = data["pageLoader"];
            this.contentSkin = data["contentSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["pageLoader"] = this.pageLoader;
        data["contentSkin"] = this.contentSkin;
        return data; 
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string;
    pageLoader: string;
    contentSkin: string;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean;
    desktopMinimizeMode: string;
    mobileFixedHeader: boolean;
    dropdownSkinDesktop: string;
    displaySubmenuArrowDesktop: boolean;
    dropdownSkin: string;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.dropdownSkinDesktop = data["dropdownSkinDesktop"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
            this.dropdownSkin = data["dropdownSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["dropdownSkinDesktop"] = this.dropdownSkinDesktop;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        data["dropdownSkin"] = this.dropdownSkin;
        return data; 
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean;
    desktopMinimizeMode: string;
    mobileFixedHeader: boolean;
    dropdownSkinDesktop: string;
    displaySubmenuArrowDesktop: boolean;
    dropdownSkin: string;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position: string;
    asideSkin: string;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    allowAsideHiding: boolean;
    defaultHiddenAside: boolean;
    submenuToggle: string;
    dropdownSubmenuSkin: string;
    dropdownSubmenuArrow: boolean;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string;
    asideSkin: string;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    allowAsideHiding: boolean;
    defaultHiddenAside: boolean;
    submenuToggle: string;
    dropdownSubmenuSkin: string;
    dropdownSubmenuArrow: boolean;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean;
}

export class ActivateUserForContactInput implements IActivateUserForContactInput {
    contactId: number;

    constructor(data?: IActivateUserForContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
        }
    }

    static fromJS(data: any): ActivateUserForContactInput {
        let result = new ActivateUserForContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        return data; 
    }
}

export interface IActivateUserForContactInput {
    contactId: number;
}

export class ActivateUserForContactOutput implements IActivateUserForContactOutput {
    userId: number;

    constructor(data?: IActivateUserForContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ActivateUserForContactOutput {
        let result = new ActivateUserForContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IActivateUserForContactOutput {
    userId: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[];

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[];
}

export class UserListDto implements IUserListDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string;
    profilePictureId: string;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[];
    lastLoginTime: moment.Moment;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string;
    profilePictureId: string;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[];
    lastLoginTime: moment.Moment;
    isActive: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number;
    roleName: string;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string;
    user: UserEditDto;
    roles: UserRoleDto[];
    allOrganizationUnits: OrganizationUnitDto[];
    memberedOrganizationUnits: string[];

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string;
    user: UserEditDto;
    roles: UserRoleDto[];
    allOrganizationUnits: OrganizationUnitDto[];
    memberedOrganizationUnits: string[];
}

export class UserEditDto implements IUserEditDto {
    id: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string;
    password: string;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string;
    password: string;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number;
    roleName: string;
    roleDisplayName: string;
    isAssigned: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string;
    roleDisplayName: string;
    isAssigned: boolean;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[];
    grantedPermissionNames: string[];

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[];
    grantedPermissionNames: string[];
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[] = [];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto = new UserEditDto();
    assignedRoleNames: string[] = [];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[];

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[];
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[];

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[];
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number;
    tenancyName: string;
    username: string;
    lastLoginTime: moment.Moment;
    id: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number;
    tenancyName: string;
    username: string;
    lastLoginTime: moment.Moment;
    id: number;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[];

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[];
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number;
    userId: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number;
    userId: number;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[];

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[];
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string;
    userNameOrEmail: string;
    clientIpAddress: string;
    clientName: string;
    browserInfo: string;
    result: string;
    creationTime: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string;
    userNameOrEmail: string;
    clientIpAddress: string;
    clientName: string;
    browserInfo: string;
    result: string;
    creationTime: moment.Moment;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[];

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[];
}

export enum InstanceType {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType2 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum GroupBy {
    Daily = <any>"Daily", 
    Weekly = <any>"Weekly", 
    Monthly = <any>"Monthly", 
    Quarterly = <any>"Quarterly", 
    Yearly = <any>"Yearly", 
}

export enum InstanceType3 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType4 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType5 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType6 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType7 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType8 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType9 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType10 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType11 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType12 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType13 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType14 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType15 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType16 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType17 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType18 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType19 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType20 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType21 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType22 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType23 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType24 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType25 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType26 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum ApplyOption {
    None = <any>"None", 
    MatchedAndUnclassified = <any>"MatchedAndUnclassified", 
    SelectedOnly = <any>"SelectedOnly", 
    AllExisting = <any>"AllExisting", 
}

export enum InstanceType27 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType28 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType29 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType30 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType31 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType32 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType33 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType34 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType35 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType36 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType37 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType38 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType39 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType40 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType41 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType42 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType43 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType44 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType45 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType46 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType47 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType48 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType49 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType50 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType51 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum IncomeStatisticsDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum InstanceType52 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType53 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum State {
    _0 = 0, 
    _1 = 1, 
}

export enum SalesSummaryDatePeriod {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum SalesSummaryDatePeriod2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum TenantHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum TenantHostType2 {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum DefaultTimezoneScope {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export enum InstanceType54 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType55 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum InstanceType56 {
    Personal = <any>"Personal", 
    Business = <any>"Business", 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum BankAccountDailyStatDtoPeriod {
    Daily = <any>"Daily", 
    Weekly = <any>"Weekly", 
    Monthly = <any>"Monthly", 
    Quarterly = <any>"Quarterly", 
    Yearly = <any>"Yearly", 
}

export enum TransactionStatsDtoAdjustmentType {
    _0 = 0, 
    _1 = 1, 
}

export enum CashflowGridGeneralSettingsDtoShowColumnsWithZeroActivity {
    Days = <any>"Days", 
    Weeks = <any>"Weeks", 
    Months = <any>"Months", 
    Quarters = <any>"Quarters", 
    Years = <any>"Years", 
    None = <any>"None", 
}

export enum CreateForecastScheduleDtoWeekDayNumber {
    Sunday = <any>"Sunday", 
    Monday = <any>"Monday", 
    Tuesday = <any>"Tuesday", 
    Wednesday = <any>"Wednesday", 
    Thursday = <any>"Thursday", 
    Friday = <any>"Friday", 
    Saturday = <any>"Saturday", 
}

export enum UpdateForecastScheduleInputWeekDayNumber {
    Sunday = <any>"Sunday", 
    Monday = <any>"Monday", 
    Tuesday = <any>"Tuesday", 
    Wednesday = <any>"Wednesday", 
    Thursday = <any>"Thursday", 
    Friday = <any>"Friday", 
    Saturday = <any>"Saturday", 
}

export enum ForecastScheduleDtoWeekDayNumber {
    Sunday = <any>"Sunday", 
    Monday = <any>"Monday", 
    Tuesday = <any>"Tuesday", 
    Wednesday = <any>"Wednesday", 
    Thursday = <any>"Thursday", 
    Friday = <any>"Friday", 
    Saturday = <any>"Saturday", 
}

export enum FriendDtoState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReceiverReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum CreateRuleDtoApplyOption {
    None = <any>"None", 
    MatchedAndUnclassified = <any>"MatchedAndUnclassified", 
    SelectedOnly = <any>"SelectedOnly", 
    AllExisting = <any>"AllExisting", 
}

export enum ConditionDtoCashFlowAmountFormat {
    Unspecified = <any>"Unspecified", 
    Debits = <any>"Debits", 
    Credits = <any>"Credits", 
}

export enum ConditionAttributeDtoConditionTypeId {
    Exist = <any>"Exist", 
    Equal = <any>"Equal", 
}

export enum EditRuleDtoApplyOption {
    None = <any>"None", 
    MatchedAndUnclassified = <any>"MatchedAndUnclassified", 
    SelectedOnly = <any>"SelectedOnly", 
    AllExisting = <any>"AllExisting", 
}

export enum MoveRuleDtoApplyOption {
    None = <any>"None", 
    MatchedAndUnclassified = <any>"MatchedAndUnclassified", 
    SelectedOnly = <any>"SelectedOnly", 
    AllExisting = <any>"AllExisting", 
}

export enum TransactionCommonDetailsDtoAmountFormat {
    Debits = <any>"Debits", 
    Credits = <any>"Credits", 
}

export enum AccountDtoState {
    _0 = 0, 
    _1 = 1, 
}

export enum AlertDtoType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum CreditScoreDtoScoreRank {
    Poor = <any>"Poor", 
    Fair = <any>"Fair", 
    Good = <any>"Good", 
    Excellent = <any>"Excellent", 
}

export enum AccountInfoDtoStatus {
    _0 = 0, 
    _1 = 1, 
}

export enum AccountCreditHistoryDtoStatusType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
}

export enum ScoreSimulatorInfoDtoAccessStatus {
    Ok = <any>"Ok", 
    NoMember = <any>"NoMember", 
    MemberIsCancelled = <any>"MemberIsCancelled", 
    KbaIsNotPassed = <any>"KbaIsNotPassed", 
    UnsupportedPackage = <any>"UnsupportedPackage", 
    NoPayment = <any>"NoPayment", 
}

export enum GetStatusOutputStatus {
    NotInitialized = <any>"NotInitialized", 
    Active = <any>"Active", 
    Inactive = <any>"Inactive", 
}

export enum GetUserInstanceInfoOutputStatus {
    NotInitialized = <any>"NotInitialized", 
    Active = <any>"Active", 
    Inactive = <any>"Inactive", 
}

export enum SubmitTenantCreationRequestInputPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum SubmitTenantCreationRequestOutputPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum MemberInfoDtoGender {
    _0 = 0, 
    _1 = 1, 
}

export enum RegisterMemberRequestGender {
    _0 = 0, 
    _1 = 1, 
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export enum TenantNotificationSeverity {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class AdditionalData implements IAdditionalData {
    paypal: { [key: string] : string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; };
}

export enum CreatePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreatePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CreatePaymentDtoSubscriptionPaymentGatewayType {
    _1 = 1, 
}

export enum ExecutePaymentDtoGateway {
    _1 = 1, 
}

export enum ExecutePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ExecutePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum TenantLoginInfoDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CheckHostNameDnsMappingInputTenantHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum TenantSslBindingInfoHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum AddSslBindingInputTenantHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum UpdateSslBindingCertificateInputTenantHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum UpdateSslBindingIsActiveInputTenantHostType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum RegisterTenantInputSubscriptionStartType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterTenantInputGateway {
    _1 = 1, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}