/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.10.0 (NJsonSchema v9.10.49.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    validateMemberSignUp(body: SignUpMemberRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ValidateMemberSignUp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMemberSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMemberSignUp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateMemberSignUp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    signUpMember(body: SignUpMemberRequest | null | undefined): Observable<SignUpMemberResponse> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SignUpMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUpMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUpMember(<any>response_);
                } catch (e) {
                    return <Observable<SignUpMemberResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SignUpMemberResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSignUpMember(response: HttpResponseBase): Observable<SignUpMemberResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SignUpMemberResponse.fromJS(resultData200) : new SignUpMemberResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SignUpMemberResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | null | undefined): Observable<SendPasswordResetCodeOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<SendPasswordResetCodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendPasswordResetCodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<SendPasswordResetCodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendPasswordResetCodeOutput.fromJS(resultData200) : new SendPasswordResetCodeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendPasswordResetCodeOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }

    /**
     * @return Success
     */
    cancelUserAccount(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Account/CancelUserAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelUserAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelUserAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelUserAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<ActivityDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActivityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityDto.fromJS(resultData200) : new ActivityDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @assignedTo (optional) 
     * @dateFrom (optional) 
     * @dateTo (optional) 
     * @return Success
     */
    getAll(assignedTo: number | null | undefined, dateFrom: moment.Moment | null | undefined, dateTo: moment.Moment | null | undefined): Observable<ActivityDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetAll?";
        if (assignedTo !== undefined)
            url_ += "AssignedTo=" + encodeURIComponent("" + assignedTo) + "&"; 
        if (dateFrom !== undefined)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (dateTo !== undefined)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ActivityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ActivityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    move(body: MoveActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMove(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    transition(body: TransitionActivityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Transition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTransition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUser(body: AssignActivityUserDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Activity/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }
}

@Injectable()
export class ApiKeyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getAll(userId: number | null | undefined): Observable<ApiKeyInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/GetAll?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApiKeyInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiKeyInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApiKeyInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApiKeyInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    generate(body: GenerateApiKeyInput | null | undefined): Observable<ApiKeyInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Generate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(<any>response_);
                } catch (e) {
                    return <Observable<ApiKeyInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiKeyInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<ApiKeyInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiKeyInfo.fromJS(resultData200) : new ApiKeyInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiKeyInfo>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/ApiKey/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerApplicant(body: RegisterApplicantRequest | null | undefined): Observable<RegisterApplicantResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/RegisterApplicant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterApplicant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterApplicant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterApplicantResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterApplicantResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterApplicant(response: HttpResponseBase): Observable<RegisterApplicantResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterApplicantResponse.fromJS(resultData200) : new RegisterApplicantResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterApplicantResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getInitialMemberApplication(applicantUserId: number, applicationId: string): Observable<OfferApplicationDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Application/GetInitialMemberApplication?";
        if (applicantUserId === undefined || applicantUserId === null)
            throw new Error("The parameter 'applicantUserId' must be defined and cannot be null.");
        else
            url_ += "applicantUserId=" + encodeURIComponent("" + applicantUserId) + "&"; 
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined and cannot be null.");
        else
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialMemberApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialMemberApplication(<any>response_);
                } catch (e) {
                    return <Observable<OfferApplicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferApplicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInitialMemberApplication(response: HttpResponseBase): Observable<OfferApplicationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferApplicationDto.fromJS(resultData200) : new OfferApplicationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userId (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userId: number | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogListDtoPagedResultDto.fromJS(resultData200) : new AuditLogListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userId (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userId: number | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<EntityChangeListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityChangeListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityChangeListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<EntityChangeListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntityChangeListDtoPagedResultDto.fromJS(resultData200) : new EntityChangeListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityChangeListDtoPagedResultDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BankAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currency: string): Observable<SyncAccountBankDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<SyncAccountBankDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAccountBankDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<SyncAccountBankDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SyncAccountBankDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountBankDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    recalculateAllBankAccountDailyStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/RecalculateAllBankAccountDailyStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculateAllBankAccountDailyStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculateAllBankAccountDailyStats(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecalculateAllBankAccountDailyStats(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @forecastModelId (optional) 
     * @accounts (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @groupBy (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currency: string, forecastModelId: number | null | undefined, accounts: number[] | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, groupBy: GroupByPeriod | null | undefined): Observable<BankAccountDailyStatDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined and cannot be null.");
        else
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&"; 
        if (forecastModelId !== undefined)
            url_ += "ForecastModelId=" + encodeURIComponent("" + forecastModelId) + "&"; 
        if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "Accounts=" + encodeURIComponent("" + item) + "&"; });
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountDailyStatDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountDailyStatDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<BankAccountDailyStatDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankAccountDailyStatDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountDailyStatDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    discardDiscrepancies(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: DiscardDiscrepanciesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancies?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancies(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDiscardDiscrepancies(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    discardDiscrepancy(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/DiscardDiscrepancy?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiscardDiscrepancy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiscardDiscrepancy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDiscardDiscrepancy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBankAccount(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateBankAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BankAccounts/UpdateBankAccount?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BusinessEntityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBusinessEntities(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BusinessEntityDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBusinessEntities?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessEntities(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessEntities(response: HttpResponseBase): Observable<BusinessEntityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTypes(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BusinessEntityTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetTypes?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypes(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTypes(response: HttpResponseBase): Observable<BusinessEntityTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityTypeDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<BusinessEntityInfoDto> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/Get?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BusinessEntityInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BusinessEntityInfoDto.fromJS(resultData200) : new BusinessEntityInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityInfoDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createBusinessEntity(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateBusinessEntityDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/CreateBusinessEntity?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBusinessEntity(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBusinessEntity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBusinessEntity(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateBusinessEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBusinessEntity?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBusinessEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBusinessEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBusinessEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @businessEntityId (optional) 
     * @return Success
     */
    getBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, businessEntityId: number | null | undefined): Observable<BusinessEntityBankAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/GetBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (businessEntityId !== undefined)
            url_ += "businessEntityId=" + encodeURIComponent("" + businessEntityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<BusinessEntityBankAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessEntityBankAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccounts(response: HttpResponseBase): Observable<BusinessEntityBankAccountDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BusinessEntityBankAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessEntityBankAccountDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateBankAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: BusinessEntityUpdateBankAccountsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/BusinessEntity/UpdateBankAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<CacheDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<CacheDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CacheDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<CacheDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CacheDtoListResultDto.fromJS(resultData200) : new CacheDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CacheDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    clearCache(body: StringEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CashflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: StatsFilter | null | undefined): Observable<CashFlowStatsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStats(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowStatsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStats(response: HttpResponseBase): Observable<CashFlowStatsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowStatsDto.fromJS(resultData200) : new CashFlowStatsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowInitialData(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<CashFlowInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowInitialData(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowInitialData>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowInitialData>><any>_observableThrow(response_);
        }));
    }

    protected processGetCashFlowInitialData(response: HttpResponseBase): Observable<CashFlowInitialData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowInitialData.fromJS(resultData200) : new CashFlowInitialData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getStatsDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: StatsDetailFilter | null | undefined): Observable<CashFlowStatsDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetStatsDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatsDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatsDetails(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowStatsDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowStatsDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatsDetails(response: HttpResponseBase): Observable<CashFlowStatsDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CashFlowStatsDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowStatsDetailDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getCashFlowGridSettings(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<CashFlowGridSettingsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/GetCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashFlowGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<CashFlowGridSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashFlowGridSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCashFlowGridSettings(response: HttpResponseBase): Observable<CashFlowGridSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CashFlowGridSettingsDto.fromJS(resultData200) : new CashFlowGridSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashFlowGridSettingsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    saveCashFlowGridSettings(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CashFlowGridSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Cashflow/SaveCashFlowGridSettings?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCashFlowGridSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCashFlowGridSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCashFlowGridSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CashFlowForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getModels(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<ForecastModelDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetModels?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModels(<any>response_);
                } catch (e) {
                    return <Observable<ForecastModelDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastModelDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModels(response: HttpResponseBase): Observable<ForecastModelDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastModelDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastModelDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    addForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AddForecastInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/AddForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddForecast(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddForecast(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    importForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ImportForecastInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/ImportForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImportForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastsInput | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecasts(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecasts(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecast(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteForecast(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecast?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecast(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecast(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    deleteForecasts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecasts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecasts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecasts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastScheduleDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecastSchedule(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateForecastScheduleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/UpdateForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecastSchedule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getForecastSchedule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<ForecastScheduleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedule(<any>response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastScheduleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastSchedule(response: HttpResponseBase): Observable<ForecastScheduleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ForecastScheduleDto.fromJS(resultData200) : new ForecastScheduleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getForecastSchedules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<ForecastScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/GetForecastSchedules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForecastSchedules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForecastSchedules(<any>response_);
                } catch (e) {
                    return <Observable<ForecastScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForecastScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetForecastSchedules(response: HttpResponseBase): Observable<ForecastScheduleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ForecastScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForecastScheduleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateForecastModelInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/CreateForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateForecastModel(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    renameForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RenameForecastModelInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/RenameForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteForecastModel(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CashFlowForecast/DeleteForecastModel?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteForecastModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteForecastModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteForecastModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CategoryTreeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @includeNonCashflowNodes (optional) 
     * @return Success
     */
    get(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, includeNonCashflowNodes: boolean | null | undefined): Observable<GetCategoryTreeOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Get?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (includeNonCashflowNodes !== undefined)
            url_ += "includeNonCashflowNodes=" + encodeURIComponent("" + includeNonCashflowNodes) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GetCategoryTreeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCategoryTreeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCategoryTreeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCategoryTreeOutput.fromJS(resultData200) : new GetCategoryTreeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryTreeOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @reportTemplate (optional) 
     * @return Success
     */
    getReportTemplateDefinition(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, reportTemplate: ReportTemplate | null | undefined): Observable<GetReportTemplateDefinitionOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/GetReportTemplateDefinition?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (reportTemplate !== undefined)
            url_ += "reportTemplate=" + encodeURIComponent("" + reportTemplate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplateDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplateDefinition(<any>response_);
                } catch (e) {
                    return <Observable<GetReportTemplateDefinitionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportTemplateDefinitionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplateDefinition(response: HttpResponseBase): Observable<GetReportTemplateDefinitionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReportTemplateDefinitionOutput.fromJS(resultData200) : new GetReportTemplateDefinitionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplateDefinitionOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCategoryInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCategoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateCategoryStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCategoryStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateCategoryStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategoryStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @moveToCategoryId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    deleteCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, moveToCategoryId: number | null | undefined, deleteAllReferences: boolean | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (moveToCategoryId !== undefined)
            url_ += "MoveToCategoryId=" + encodeURIComponent("" + moveToCategoryId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateAccountingTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/CreateAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateAccountingTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/UpdateAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @moveToAccountingTypeId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    deleteAccountingType(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, moveToAccountingTypeId: number | null | undefined, deleteAllReferences: boolean | null | undefined, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/DeleteAccountingType?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (moveToAccountingTypeId !== undefined)
            url_ += "MoveToAccountingTypeId=" + encodeURIComponent("" + moveToAccountingTypeId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccountingType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccountingType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccountingType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @isOverride (optional) 
     * @body (optional) 
     * @return Success
     */
    sync(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, isOverride: boolean | null | undefined, body: SyncDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Sync?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @isOverride (optional) 
     * @body (optional) 
     * @return Success
     */
    import(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, isOverride: boolean | null | undefined, body: AccountingCategoryDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/CategoryTree/Import?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @userId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ChatMessageDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessageDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessageDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ChatMessageDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChatMessageDtoListResultDto.fromJS(resultData200) : new ChatMessageDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessageDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ClassificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @input (optional) 
     * @return Success
     */
    getRules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, input: GetRulesInput | null | undefined): Observable<RuleDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(<any>response_);
                } catch (e) {
                    return <Observable<RuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<RuleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RuleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RuleDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/CreateRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getRuleForEdit(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: number | null | undefined): Observable<EditRuleDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetRuleForEdit?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRuleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRuleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<EditRuleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditRuleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRuleForEdit(response: HttpResponseBase): Observable<EditRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditRuleDto.fromJS(resultData200) : new EditRuleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditRuleDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    editRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: EditRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/EditRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    moveRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: MoveRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/MoveRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @sourceTransactionList (optional) 
     * @applyOption (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteRule(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, sourceTransactionList: number[] | null | undefined, applyOption: ApplyToTransactionsOption | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteRule?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (sourceTransactionList !== undefined)
            sourceTransactionList && sourceTransactionList.forEach(item => { url_ += "SourceTransactionList=" + encodeURIComponent("" + item) + "&"; });
        if (applyOption !== undefined)
            url_ += "ApplyOption=" + encodeURIComponent("" + applyOption) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    addMapping(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AddMappingDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AddMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    deleteMapping(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, name: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/DeleteMapping?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMapping(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    reclassify(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RecategorizeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reclassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReclassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReclassify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReclassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    resetToDefaults(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ResetToDefaults?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetToDefaults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetToDefaults(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetToDefaults(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    reset(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ResetClassificationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/Reset?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateTransactionsCategory(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateTransactionsCategoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategory?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransactionsCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateTransactionsCategoryWithFilter(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateTransactionsCategoryWithFilterInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/UpdateTransactionsCategoryWithFilter?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionsCategoryWithFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionsCategoryWithFilter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransactionsCategoryWithFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getTransactionCommonDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GetTransactionCommonDetailsInput | null | undefined): Observable<TransactionCommonDetailsDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetTransactionCommonDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionCommonDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionCommonDetails(<any>response_);
                } catch (e) {
                    return <Observable<TransactionCommonDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionCommonDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionCommonDetails(response: HttpResponseBase): Observable<TransactionCommonDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionCommonDetailsDto.fromJS(resultData200) : new TransactionCommonDetailsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCommonDetailsDto>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    autoClassify(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: AutoClassifyDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/AutoClassify?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoClassify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoClassify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAutoClassify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    changeCategoryForRules(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: ChangeCategoryForRulesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/ChangeCategoryForRules?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeCategoryForRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeCategoryForRules(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeCategoryForRules(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    getKeyAttributeValues(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GetKeyAttributeValuesInput | null | undefined): Observable<AttributeValuesDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Classification/GetKeyAttributeValues?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeyAttributeValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeyAttributeValues(<any>response_);
                } catch (e) {
                    return <Observable<AttributeValuesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttributeValuesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeyAttributeValues(response: HttpResponseBase): Observable<AttributeValuesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AttributeValuesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttributeValuesDto[]>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @threadId (optional) 
     * @return Success
     */
    getComments(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, threadId: number | null | undefined): Observable<CommentDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/GetComments?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (threadId !== undefined)
            url_ += "threadId=" + encodeURIComponent("" + threadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(<any>response_);
                } catch (e) {
                    return <Observable<CommentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<CommentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CommentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCommentInput | null | undefined): Observable<CreateCommentOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(<any>response_);
                } catch (e) {
                    return <Observable<CreateCommentOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCommentOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<CreateCommentOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCommentOutput.fromJS(resultData200) : new CreateCommentOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCommentOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    updateComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateCommentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/UpdateComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @commentId (optional) 
     * @return Success
     */
    deleteComment(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, commentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/DeleteComment?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createTransactionCommentThread(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateTransactionCommentThreadInput | null | undefined): Observable<CreateTransactionCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateTransactionCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransactionCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransactionCommentThread(<any>response_);
                } catch (e) {
                    return <Observable<CreateTransactionCommentThreadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateTransactionCommentThreadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTransactionCommentThread(response: HttpResponseBase): Observable<CreateTransactionCommentThreadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateTransactionCommentThreadOutput.fromJS(resultData200) : new CreateTransactionCommentThreadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTransactionCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    createCashFlowCommentThread(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateCashFlowCommentThreadInput | null | undefined): Observable<CreateCashFlowCommentThreadOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/CreateCashFlowCommentThread?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCashFlowCommentThread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCashFlowCommentThread(<any>response_);
                } catch (e) {
                    return <Observable<CreateCashFlowCommentThreadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateCashFlowCommentThreadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCashFlowCommentThread(response: HttpResponseBase): Observable<CreateCashFlowCommentThreadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateCashFlowCommentThreadOutput.fromJS(resultData200) : new CreateCashFlowCommentThreadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCashFlowCommentThreadOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    setResolved(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: SetResolvedInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Comment/SetResolved?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetResolved(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetResolved(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetResolved(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscribableEditionComboboxItemDtoListResultDto.fromJS(resultData200) : new SubscribableEditionComboboxItemDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | null | undefined): Observable<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoPagedResultDto.fromJS(resultData200) : new NameValueDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class CommonUserInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompany(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/CommonUserInfo/GetCompany";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactInfo(contactId: number | null | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfo(<any>response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfo(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactInfoDto.fromJS(resultData200) : new ContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getContactInfoForUser(userId: number | null | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactInfoForUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForUser(<any>response_);
                } catch (e) {
                    return <Observable<ContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactInfoForUser(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactInfoDto.fromJS(resultData200) : new ContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getContactShortInfoForUser(userId: number | null | undefined): Observable<ContactShortInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactShortInfoForUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactShortInfoForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactShortInfoForUser(<any>response_);
                } catch (e) {
                    return <Observable<ContactShortInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactShortInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactShortInfoForUser(response: HttpResponseBase): Observable<ContactShortInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactShortInfo.fromJS(resultData200) : new ContactShortInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactShortInfo>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContact(body: CreateContactInput | null | undefined): Observable<CreateContactOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/CreateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContact(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContact(response: HttpResponseBase): Observable<CreateContactOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactOutput.fromJS(resultData200) : new CreateContactOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactOutput>(<any>null);
    }

    /**
     * @namePrefix (optional) 
     * @firstName (optional) 
     * @middleName (optional) 
     * @lastName (optional) 
     * @nameSuffix (optional) 
     * @companyName (optional) 
     * @emailAddresses (optional) 
     * @phoneNumbers (optional) 
     * @streetAddress (optional) 
     * @city (optional) 
     * @stateId (optional) 
     * @zip (optional) 
     * @countryId (optional) 
     * @groupId (optional) 
     * @return Success
     */
    getSimilarContacts(namePrefix: string | null | undefined, firstName: string | null | undefined, middleName: string | null | undefined, lastName: string | null | undefined, nameSuffix: string | null | undefined, companyName: string | null | undefined, emailAddresses: string[] | null | undefined, phoneNumbers: string[] | null | undefined, streetAddress: string | null | undefined, city: string | null | undefined, stateId: string | null | undefined, zip: string | null | undefined, countryId: string | null | undefined, groupId: string | null | undefined): Observable<SimilarContactOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetSimilarContacts?";
        if (namePrefix !== undefined)
            url_ += "NamePrefix=" + encodeURIComponent("" + namePrefix) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (middleName !== undefined)
            url_ += "MiddleName=" + encodeURIComponent("" + middleName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (nameSuffix !== undefined)
            url_ += "NameSuffix=" + encodeURIComponent("" + nameSuffix) + "&"; 
        if (companyName !== undefined)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&"; 
        if (emailAddresses !== undefined)
            emailAddresses && emailAddresses.forEach(item => { url_ += "EmailAddresses=" + encodeURIComponent("" + item) + "&"; });
        if (phoneNumbers !== undefined)
            phoneNumbers && phoneNumbers.forEach(item => { url_ += "PhoneNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (streetAddress !== undefined)
            url_ += "StreetAddress=" + encodeURIComponent("" + streetAddress) + "&"; 
        if (city !== undefined)
            url_ += "City=" + encodeURIComponent("" + city) + "&"; 
        if (stateId !== undefined)
            url_ += "StateId=" + encodeURIComponent("" + stateId) + "&"; 
        if (zip !== undefined)
            url_ += "Zip=" + encodeURIComponent("" + zip) + "&"; 
        if (countryId !== undefined)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&"; 
        if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimilarContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimilarContacts(<any>response_);
                } catch (e) {
                    return <Observable<SimilarContactOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimilarContactOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSimilarContacts(response: HttpResponseBase): Observable<SimilarContactOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SimilarContactOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimilarContactOutput[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactStatus(body: UpdateContactStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactStatuses(body: UpdateContactStatusesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateContactStatuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactStatuses(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactStatuses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getContactGroups(): Observable<ContactGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactGroups(<any>response_);
                } catch (e) {
                    return <Observable<ContactGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactGroups(response: HttpResponseBase): Observable<ContactGroupDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGroupDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getContactStatuses(): Observable<ContactStatusDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetContactStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactStatuses(<any>response_);
                } catch (e) {
                    return <Observable<ContactStatusDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactStatusDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactStatuses(response: HttpResponseBase): Observable<ContactStatusDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactStatusDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactStatusDto[]>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsers(contactGroupId: string, searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetAllowedAssignableUsers?";
        if (contactGroupId === undefined || contactGroupId === null)
            throw new Error("The parameter 'contactGroupId' must be defined and cannot be null.");
        else
            url_ += "ContactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllowedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getRelatedAssignableUsers(entityId: number): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/GetRelatedAssignableUsers?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedAssignableUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedAssignableUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRelatedAssignableUsers(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUser(body: AssignUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    assignUserForEach(body: AssignUserForEachInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/AssignUserForEach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUserForEach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUserForEach(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAssignUserForEach(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateContactOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Contact/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactAddressServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactAddress(body: CreateContactAddressInput | null | undefined): Observable<CreateContactAddressOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/CreateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactAddressOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactAddressOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactAddress(response: HttpResponseBase): Observable<CreateContactAddressOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactAddressOutput.fromJS(resultData200) : new CreateContactAddressOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactAddressOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactAddress(body: UpdateContactAddressInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/UpdateContactAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactAddress(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/DeleteContactAddress?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressUsageTypes(): Observable<AddressUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<AddressUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressUsageTypes(response: HttpResponseBase): Observable<AddressUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AddressUsageTypeDtoListResultDto.fromJS(resultData200) : new AddressUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressUsageTypeDtoListResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressOwnershipTypes(): Observable<AddressOwnershipTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactAddress/GetAddressOwnershipTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressOwnershipTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressOwnershipTypes(<any>response_);
                } catch (e) {
                    return <Observable<AddressOwnershipTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressOwnershipTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressOwnershipTypes(response: HttpResponseBase): Observable<AddressOwnershipTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AddressOwnershipTypeDtoListResultDto.fromJS(resultData200) : new AddressOwnershipTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressOwnershipTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactBusinessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getContactBusiness(personId: number): Observable<GetContactBusinessOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/GetContactBusiness?";
        if (personId === undefined || personId === null)
            throw new Error("The parameter 'personId' must be defined and cannot be null.");
        else
            url_ += "PersonId=" + encodeURIComponent("" + personId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactBusiness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactBusiness(<any>response_);
                } catch (e) {
                    return <Observable<GetContactBusinessOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactBusinessOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactBusiness(response: HttpResponseBase): Observable<GetContactBusinessOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetContactBusinessOutput.fromJS(resultData200) : new GetContactBusinessOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactBusinessOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactBusiness(body: CreateContactBusinessInput | null | undefined): Observable<CreateContactBusinessOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/CreateContactBusiness";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactBusiness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactBusiness(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactBusinessOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactBusinessOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactBusiness(response: HttpResponseBase): Observable<CreateContactBusinessOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactBusinessOutput.fromJS(resultData200) : new CreateContactBusinessOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactBusinessOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactBusiness(body: UpdateContactBusinessInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/UpdateContactBusiness";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactBusiness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactBusiness(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactBusiness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactBusiness(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/DeleteContactBusiness?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactBusiness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactBusiness(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactBusiness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPersonOrgRelationTypes(): Observable<PersonOrgRelationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactBusiness/GetPersonOrgRelationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonOrgRelationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonOrgRelationTypes(<any>response_);
                } catch (e) {
                    return <Observable<PersonOrgRelationTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PersonOrgRelationTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonOrgRelationTypes(response: HttpResponseBase): Observable<PersonOrgRelationTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PersonOrgRelationTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonOrgRelationTypeDto[]>(<any>null);
    }
}

@Injectable()
export class ContactEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactEmail(body: CreateContactEmailInput | null | undefined): Observable<CreateContactEmailOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/CreateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactEmailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactEmailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactEmail(response: HttpResponseBase): Observable<CreateContactEmailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactEmailOutput.fromJS(resultData200) : new CreateContactEmailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactEmailOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactEmail(body: UpdateContactEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/UpdateContactEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactEmail(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/DeleteContactEmail?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEmailUsageTypes(): Observable<EmailUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactEmail/GetEmailUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<EmailUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmailUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmailUsageTypes(response: HttpResponseBase): Observable<EmailUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmailUsageTypeDtoListResultDto.fromJS(resultData200) : new EmailUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailUsageTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactLink(body: CreateContactLinkInput | null | undefined): Observable<CreateContactLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/CreateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactLink(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactLink(response: HttpResponseBase): Observable<CreateContactLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactLinkOutput.fromJS(resultData200) : new CreateContactLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactLinkOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactLink(body: UpdateContactLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/UpdateContactLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactLink(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/DeleteContactLink?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getContactLinkTypes(): Observable<ContactLinkTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLink/GetContactLinkTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLinkTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLinkTypes(<any>response_);
                } catch (e) {
                    return <Observable<ContactLinkTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactLinkTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactLinkTypes(response: HttpResponseBase): Observable<ContactLinkTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactLinkTypeDtoListResultDto.fromJS(resultData200) : new ContactLinkTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLinkTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactListsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactLists(body: UpdateContactListsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/UpdateContactLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addContactsToLists(body: AddContactsToListsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/AddContactsToLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContactsToLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContactsToLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddContactsToLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactIds (optional) 
     * @listIds (optional) 
     * @return Success
     */
    removeContactsFromLists(contactIds: number[] | null | undefined, listIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/RemoveContactsFromLists?";
        if (contactIds !== undefined)
            contactIds && contactIds.forEach(item => { url_ += "ContactIds=" + encodeURIComponent("" + item) + "&"; });
        if (listIds !== undefined)
            listIds && listIds.forEach(item => { url_ += "ListIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveContactsFromLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveContactsFromLists(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveContactsFromLists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: UpdateContactListInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moveToListId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToListId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactLists/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToListId !== undefined)
            url_ += "MoveToListId=" + encodeURIComponent("" + moveToListId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactPhoneServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getContactPhones(contactId: number | null | undefined): Observable<ContactPhoneInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetContactPhones?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactPhones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactPhones(<any>response_);
                } catch (e) {
                    return <Observable<ContactPhoneInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactPhoneInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactPhones(response: HttpResponseBase): Observable<ContactPhoneInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactPhoneInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactPhoneInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactPhone(body: CreateContactPhoneInput | null | undefined): Observable<CreateContactPhoneOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/CreateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<CreateContactPhoneOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateContactPhoneOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactPhone(response: HttpResponseBase): Observable<CreateContactPhoneOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateContactPhoneOutput.fromJS(resultData200) : new CreateContactPhoneOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateContactPhoneOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactPhone(body: UpdateContactPhoneInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/UpdateContactPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @id (optional) 
     * @return Success
     */
    deleteContactPhone(contactId: number | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/DeleteContactPhone?";
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactPhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactPhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPhoneUsageTypes(): Observable<PhoneUsageTypeDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhone/GetPhoneUsageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhoneUsageTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhoneUsageTypes(<any>response_);
                } catch (e) {
                    return <Observable<PhoneUsageTypeDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhoneUsageTypeDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPhoneUsageTypes(response: HttpResponseBase): Observable<PhoneUsageTypeDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhoneUsageTypeDtoListResultDto.fromJS(resultData200) : new PhoneUsageTypeDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhoneUsageTypeDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class ContactPhotoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createContactPhoto(body: CreateContactPhotoInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/CreateContactPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContactPhoto(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContactPhoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearContactPhoto(contactId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactPhoto/ClearContactPhoto?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearContactPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearContactPhoto(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearContactPhoto(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactRatingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRatings(): Observable<ContactRatingInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/GetRatings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatings(<any>response_);
                } catch (e) {
                    return <Observable<ContactRatingInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactRatingInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatings(response: HttpResponseBase): Observable<ContactRatingInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactRatingInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactRatingInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rateContact(body: RateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rateContacts(body: RateContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactRatings/RateContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRateContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactStarsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markContact(body: MarkContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    markContacts(body: MarkContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactStars/MarkContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateContactTags(body: UpdateContactTagsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UpdateContactTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    tagContacts(body: TagContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/TagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTagContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    untagContacts(body: UntagContactsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/UntagContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUntagContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUntagContacts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUntagContacts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: UpdateContactTagInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moveToTagId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number, moveToTagId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/ContactTags/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToTagId !== undefined)
            url_ += "MoveToTagId=" + encodeURIComponent("" + moveToTagId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<CountryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(<any>null);
    }

    /**
     * @code (optional) 
     * @return Success
     */
    getCountryStates(code: string | null | undefined): Observable<CountryStateDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Country/GetCountryStates?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryStates(<any>response_);
                } catch (e) {
                    return <Observable<CountryStateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryStateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountryStates(response: HttpResponseBase): Observable<CountryStateDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CountryStateDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryStateDto[]>(<any>null);
    }
}

@Injectable()
export class CreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @reportId (optional) 
     * @return Success
     */
    downloadCreditReport(reportId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Reports/CreditReport/DownloadCreditReport?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadCreditReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @dateTime (optional) 
     * @return Success
     */
    getLastCreditReport(dateTime: moment.Moment | null | undefined): Observable<CreditReportOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetLastCreditReport?";
        if (dateTime !== undefined)
            url_ += "DateTime=" + encodeURIComponent(dateTime ? "" + dateTime.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<CreditReportOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreditReportOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCreditReport(response: HttpResponseBase): Observable<CreditReportOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreditReportOutput.fromJS(resultData200) : new CreditReportOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditReportOutput>(<any>null);
    }

    /**
     * @creditReport (optional) 
     * @accountIds (optional) 
     * @return Success
     */
    getAccountInfo(creditReport: number | null | undefined, accountIds: number[] | null | undefined): Observable<AccountInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetAccountInfo?";
        if (creditReport !== undefined)
            url_ += "creditReport=" + encodeURIComponent("" + creditReport) + "&"; 
        if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "accountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountInfo(<any>response_);
                } catch (e) {
                    return <Observable<AccountInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountInfo(response: HttpResponseBase): Observable<AccountInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AccountInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountInfoDto[]>(<any>null);
    }

    /**
     * @periodYears (optional) 
     * @reportId (optional) 
     * @return Success
     */
    getCreditReportHistory(periodYears: number | null | undefined, reportId: number | null | undefined): Observable<StringScoreHistoryDtoListKeyValuePair[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/GetCreditReportHistory?";
        if (periodYears !== undefined)
            url_ += "periodYears=" + encodeURIComponent("" + periodYears) + "&"; 
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReportHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReportHistory(<any>response_);
                } catch (e) {
                    return <Observable<StringScoreHistoryDtoListKeyValuePair[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringScoreHistoryDtoListKeyValuePair[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreditReportHistory(response: HttpResponseBase): Observable<StringScoreHistoryDtoListKeyValuePair[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(StringScoreHistoryDtoListKeyValuePair.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringScoreHistoryDtoListKeyValuePair[]>(<any>null);
    }

    /**
     * @return Success
     */
    loadAlerts(): Observable<AlertDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditReport/LoadAlerts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadAlerts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadAlerts(<any>response_);
                } catch (e) {
                    return <Observable<AlertDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AlertDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoadAlerts(response: HttpResponseBase): Observable<AlertDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AlertDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AlertDto[]>(<any>null);
    }
}

@Injectable()
export class CreditSimulatorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getScoreSimulatorInfo(): Observable<ScoreSimulatorInfoDto> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/GetScoreSimulatorInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScoreSimulatorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScoreSimulatorInfo(<any>response_);
                } catch (e) {
                    return <Observable<ScoreSimulatorInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScoreSimulatorInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScoreSimulatorInfo(response: HttpResponseBase): Observable<ScoreSimulatorInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScoreSimulatorInfoDto.fromJS(resultData200) : new ScoreSimulatorInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScoreSimulatorInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    simulateScore(body: ScoreSimulatorDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/CreditSimulator/SimulateScore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSimulateScore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSimulateScore(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSimulateScore(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CurrencyInfo[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Currency/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CurrencyInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CurrencyInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyInfo[]>(<any>null);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<EntityInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Customer/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityInfo[]>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIds (optional) 
     * @return Success
     */
    getAccountTotals(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountIds: number[] | null | undefined, currencyId: string): Observable<AccountTotals> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetAccountTotals?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountTotals(<any>response_);
                } catch (e) {
                    return <Observable<AccountTotals>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountTotals>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountTotals(response: HttpResponseBase): Observable<AccountTotals> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountTotals.fromJS(resultData200) : new AccountTotals();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountTotals>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIds (optional) 
     * @return Success
     */
    getCategorizationStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, currencyId: string, bankAccountIds: number[] | null | undefined): Observable<CategorizationStatus> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetCategorizationStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategorizationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategorizationStatus(<any>response_);
                } catch (e) {
                    return <Observable<CategorizationStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategorizationStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategorizationStatus(response: HttpResponseBase): Observable<CategorizationStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategorizationStatus.fromJS(resultData200) : new CategorizationStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategorizationStatus>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountIds (optional) 
     * @startDate (optional) 
     * @return Success
     */
    getDailyBalanceStats(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountIds: number[] | null | undefined, currencyId: string, startDate: moment.Moment | null | undefined, endDate: moment.Moment): Observable<GetDailyBalanceStatsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetDailyBalanceStats?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailyBalanceStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailyBalanceStats(<any>response_);
                } catch (e) {
                    return <Observable<GetDailyBalanceStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailyBalanceStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailyBalanceStats(response: HttpResponseBase): Observable<GetDailyBalanceStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDailyBalanceStatsOutput.fromJS(resultData200) : new GetDailyBalanceStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailyBalanceStatsOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @maxCount (optional) 
     * @bankAccountIds (optional) 
     * @startDate (optional) 
     * @return Success
     */
    getSpendingCategories(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, maxCount: number | null | undefined, bankAccountIds: number[] | null | undefined, currencyId: string, startDate: moment.Moment | null | undefined, endDate: moment.Moment): Observable<GetSpendingCategoriesOutput[]> {
        let url_ = this.baseUrl + "/api/services/CFO/Dashboard/GetSpendingCategories?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (maxCount !== undefined)
            url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&"; 
        if (bankAccountIds !== undefined)
            bankAccountIds && bankAccountIds.forEach(item => { url_ += "BankAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined and cannot be null.");
        else
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpendingCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpendingCategories(<any>response_);
                } catch (e) {
                    return <Observable<GetSpendingCategoriesOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSpendingCategoriesOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpendingCategories(response: HttpResponseBase): Observable<GetSpendingCategoriesOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetSpendingCategoriesOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSpendingCategoriesOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getTotals(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetTotalsOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetTotals?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotals(<any>response_);
                } catch (e) {
                    return <Observable<GetTotalsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTotalsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotals(response: HttpResponseBase): Observable<GetTotalsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTotalsOutput.fromJS(resultData200) : new GetTotalsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTotalsOutput>(<any>null);
    }

    /**
     * @groupBy (optional) 
     * @periodCount (optional) 
     * @isCumulative (optional) 
     * @return Success
     */
    getCustomerAndLeadStats(groupBy: GroupByPeriod | null | undefined, periodCount: number | null | undefined, isCumulative: boolean | null | undefined): Observable<GetCustomerAndLeadStatsOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomerAndLeadStats?";
        if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&"; 
        if (periodCount !== undefined)
            url_ += "PeriodCount=" + encodeURIComponent("" + periodCount) + "&"; 
        if (isCumulative !== undefined)
            url_ += "IsCumulative=" + encodeURIComponent("" + isCumulative) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAndLeadStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAndLeadStats(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerAndLeadStatsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAndLeadStats(response: HttpResponseBase): Observable<GetCustomerAndLeadStatsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCustomerAndLeadStatsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerAndLeadStatsOutput[]>(<any>null);
    }

    /**
     * @topCount (optional) 
     * @isProspective (optional) 
     * @return Success
     */
    getRecentlyCreatedCustomers(topCount: number | null | undefined, isProspective: boolean | null | undefined): Observable<GetRecentlyCreatedCustomersOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetRecentlyCreatedCustomers?";
        if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&"; 
        if (isProspective !== undefined)
            url_ += "isProspective=" + encodeURIComponent("" + isProspective) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedCustomers(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentlyCreatedCustomersOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentlyCreatedCustomersOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyCreatedCustomers(response: HttpResponseBase): Observable<GetRecentlyCreatedCustomersOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetRecentlyCreatedCustomersOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentlyCreatedCustomersOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getCustomersByCompanySize(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetCustomersByCompanySizeOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomersByCompanySize?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByCompanySize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByCompanySize(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomersByCompanySizeOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomersByCompanySizeOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersByCompanySize(response: HttpResponseBase): Observable<GetCustomersByCompanySizeOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCustomersByCompanySizeOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomersByCompanySizeOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getContactsByRegion(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetContactsByRegionOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsByRegion?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsByRegion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsByRegion(<any>response_);
                } catch (e) {
                    return <Observable<GetContactsByRegionOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactsByRegionOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsByRegion(response: HttpResponseBase): Observable<GetContactsByRegionOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetContactsByRegionOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactsByRegionOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getContactsCountByAge(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<ContactsCountAgeRangeGetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetContactsCountByAge?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsCountByAge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsCountByAge(<any>response_);
                } catch (e) {
                    return <Observable<ContactsCountAgeRangeGetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactsCountAgeRangeGetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsCountByAge(response: HttpResponseBase): Observable<ContactsCountAgeRangeGetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactsCountAgeRangeGetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactsCountAgeRangeGetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getLeadsCountByStage(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetLeadsCountByStage?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadsCountByStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadsCountByStage(<any>response_);
                } catch (e) {
                    return <Observable<GetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadsCountByStage(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getCustomersByRating(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetCountOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomersByRating?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByRating(<any>response_);
                } catch (e) {
                    return <Observable<GetCountOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersByRating(response: HttpResponseBase): Observable<GetCountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountOutput[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getCustomersByStar(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetCountByStarOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dashboard/GetCustomersByStar?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByStar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByStar(<any>response_);
                } catch (e) {
                    return <Observable<GetCountByStarOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountByStarOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersByStar(response: HttpResponseBase): Observable<GetCountByStarOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetCountByStarOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountByStarOutput[]>(<any>null);
    }
}

@Injectable()
export class DictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPartnerTypes(): Observable<PartnerTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetPartnerTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartnerTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartnerTypes(<any>response_);
                } catch (e) {
                    return <Observable<PartnerTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartnerTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartnerTypes(response: HttpResponseBase): Observable<PartnerTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartnerTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStars(): Observable<ContactStarInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetStars";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStars(<any>response_);
                } catch (e) {
                    return <Observable<ContactStarInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactStarInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStars(response: HttpResponseBase): Observable<ContactStarInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactStarInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactStarInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTags(): Observable<ContactTagInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<ContactTagInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactTagInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<ContactTagInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactTagInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactTagInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLists(): Observable<ContactListInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLists(<any>response_);
                } catch (e) {
                    return <Observable<ContactListInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLists(response: HttpResponseBase): Observable<ContactListInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ContactListInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListInfoDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationTypes(): Observable<OrganizationTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationTypes(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationTypes(response: HttpResponseBase): Observable<OrganizationTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getInterests(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetInterests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInterests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInterests(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInterests(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<OrganizationUnitShortDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Dictionary/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitShortDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitShortDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitShortDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitShortDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitShortDto[]>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getAll(contactId: number | null | undefined): Observable<DocumentInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetAll?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DocumentInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentInfo[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getContent(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetContent?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContent(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetContent(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUrl(id: string | null | undefined): Observable<GetUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetUrl?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUrlOutput.fromJS(resultData200) : new GetUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUrlOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    upload(body: UploadDocumentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateType(body: UpdateTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @documentId (optional) 
     * @return Success
     */
    getViewWopiRequestInfo(documentId: string | null | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetViewWopiRequestInfo?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViewWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViewWopiRequestInfo(<any>response_);
                } catch (e) {
                    return <Observable<WopiRequestOutcoming>><any>_observableThrow(e);
                }
            } else
                return <Observable<WopiRequestOutcoming>><any>_observableThrow(response_);
        }));
    }

    protected processGetViewWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WopiRequestOutcoming.fromJS(resultData200) : new WopiRequestOutcoming();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(<any>null);
    }

    /**
     * @documentId (optional) 
     * @return Success
     */
    getEditWopiRequestInfo(documentId: string | null | undefined): Observable<WopiRequestOutcoming> {
        let url_ = this.baseUrl + "/api/services/CRM/Document/GetEditWopiRequestInfo?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditWopiRequestInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditWopiRequestInfo(<any>response_);
                } catch (e) {
                    return <Observable<WopiRequestOutcoming>><any>_observableThrow(e);
                }
            } else
                return <Observable<WopiRequestOutcoming>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditWopiRequestInfo(response: HttpResponseBase): Observable<WopiRequestOutcoming> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WopiRequestOutcoming.fromJS(resultData200) : new WopiRequestOutcoming();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WopiRequestOutcoming>(<any>null);
    }
}

@Injectable()
export class DocumentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<DocumentTypeInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DocumentTypeInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentTypeInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DocumentTypeInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DocumentTypeInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateDocumentTypeInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateDocumentTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/DocumentType/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<EditionListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<EditionListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<EditionListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionListDtoListResultDto.fromJS(resultData200) : new EditionListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionListDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateEdition(body: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @selectedEditionId (optional) 
     * @addAllItem (optional) 
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class EmailingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    payload(recipientUserId: number, recipientHash: string, emailType: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Emailing/Payload?";
        if (recipientUserId === undefined || recipientUserId === null)
            throw new Error("The parameter 'recipientUserId' must be defined and cannot be null.");
        else
            url_ += "recipientUserId=" + encodeURIComponent("" + recipientUserId) + "&"; 
        if (recipientHash === undefined || recipientHash === null)
            throw new Error("The parameter 'recipientHash' must be defined and cannot be null.");
        else
            url_ += "recipientHash=" + encodeURIComponent("" + recipientHash) + "&"; 
        if (emailType === undefined || emailType === null)
            throw new Error("The parameter 'emailType' must be defined and cannot be null.");
        else
            url_ += "emailType=" + encodeURIComponent("" + emailType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPayload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    createIAgeMembers(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Emailing/CreateIAgeMembers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIAgeMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIAgeMembers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIAgeMembers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ExternalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @content (optional) 
     * @return Success
     */
    getBankCode(content: string | null | undefined): Observable<GetBankCodeResponse> {
        let url_ = this.baseUrl + "/api/services/CRM/External/GetBankCode?";
        if (content !== undefined)
            url_ += "content=" + encodeURIComponent("" + content) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankCode(<any>response_);
                } catch (e) {
                    return <Observable<GetBankCodeResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBankCodeResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankCode(response: HttpResponseBase): Observable<GetBankCodeResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBankCodeResponse.fromJS(resultData200) : new GetBankCodeResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankCodeResponse>(<any>null);
    }
}

@Injectable()
export class FeatureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<FlatFeatureDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Feature/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FlatFeatureDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatFeatureDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FlatFeatureDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FlatFeatureDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatFeatureDto[]>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    import(body: ImportInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getStatuses(id: number | null | undefined): Observable<GetImportStatusOutput[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetStatuses?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatuses(<any>response_);
                } catch (e) {
                    return <Observable<GetImportStatusOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetImportStatusOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatuses(response: HttpResponseBase): Observable<GetImportStatusOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetImportStatusOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetImportStatusOutput[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    cancel(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Cancel?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @importId (optional) 
     * @return Success
     */
    getFileUrl(importId: number | null | undefined): Observable<GetFileUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetFileUrl?";
        if (importId !== undefined)
            url_ += "importId=" + encodeURIComponent("" + importId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetFileUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFileUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFileUrl(response: HttpResponseBase): Observable<GetFileUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetFileUrlOutput.fromJS(resultData200) : new GetFileUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFileUrlOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getMappedFields(body: string[] | null | undefined): Observable<ImportFieldInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/GetMappedFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappedFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappedFields(<any>response_);
                } catch (e) {
                    return <Observable<ImportFieldInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportFieldInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMappedFields(response: HttpResponseBase): Observable<ImportFieldInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ImportFieldInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportFieldInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    importContact(body: ImportContactInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CRM/Import/ImportContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportContact(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImportContact(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class InstanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @invalidateCache (optional) 
     * @return Success
     */
    getStatus(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, invalidateCache: boolean | null | undefined): Observable<GetStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetStatus?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (invalidateCache !== undefined)
            url_ += "invalidateCache=" + encodeURIComponent("" + invalidateCache) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetStatusOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStatusOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<GetStatusOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStatusOutput.fromJS(resultData200) : new GetStatusOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStatusOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @accountingTreeType (optional) 
     * @return Success
     */
    setup(instanceType: InstanceType | null | undefined, accountingTreeType: AccountingTreeType | null | undefined): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/Setup?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (accountingTreeType !== undefined)
            url_ += "accountingTreeType=" + encodeURIComponent("" + accountingTreeType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<SetupOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetupOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<SetupOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetupOutput.fromJS(resultData200) : new SetupOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetupOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberInput | null | undefined): Observable<RegisterMemberOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(<any>response_);
                } catch (e) {
                    return <Observable<RegisterMemberOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterMemberOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<RegisterMemberOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterMemberOutput.fromJS(resultData200) : new RegisterMemberOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterMemberOutput>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getUserInstanceInfo(userId: number | null | undefined): Observable<GetUserInstanceInfoOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetUserInstanceInfo?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInstanceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInstanceInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetUserInstanceInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserInstanceInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInstanceInfo(response: HttpResponseBase): Observable<GetUserInstanceInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserInstanceInfoOutput.fromJS(resultData200) : new GetUserInstanceInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserInstanceInfoOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getMaxVisibleDate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetMaxVisibleDate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxVisibleDate(<any>response_);
                } catch (e) {
                    return <Observable<moment.Moment>><any>_observableThrow(e);
                }
            } else
                return <Observable<moment.Moment>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxVisibleDate(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<moment.Moment>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @maxVisibleDate (optional) 
     * @return Success
     */
    setMaxVisibleDate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, maxVisibleDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/SetMaxVisibleDate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (maxVisibleDate !== undefined)
            url_ += "maxVisibleDate=" + encodeURIComponent(maxVisibleDate ? "" + maxVisibleDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaxVisibleDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaxVisibleDate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetMaxVisibleDate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getInstanceOwnerEmailAddress(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/Instance/GetInstanceOwnerEmailAddress?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstanceOwnerEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstanceOwnerEmailAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstanceOwnerEmailAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreateInvoiceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceInfo> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceInfo.fromJS(resultData200) : new InvoiceInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceInfo>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdateInvoiceInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStatus(body: UpdateInvoiceStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteInvoice(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoice?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @ids (optional) 
     * @return Success
     */
    deleteInvoices(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/DeleteInvoices?";
        if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvoices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSettings(): Observable<InvoiceSettingsInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Invoice/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceSettingsInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceSettingsInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<InvoiceSettingsInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceSettingsInfoDto.fromJS(resultData200) : new InvoiceSettingsInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceSettingsInfoDto>(<any>null);
    }
}

@Injectable()
export class KBAServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    requestKBA(body: RequestKBAInput | null | undefined): Observable<RequestKBAOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/RequestKBA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestKBA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestKBA(<any>response_);
                } catch (e) {
                    return <Observable<RequestKBAOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestKBAOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRequestKBA(response: HttpResponseBase): Observable<RequestKBAOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestKBAOutput.fromJS(resultData200) : new RequestKBAOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestKBAOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    processKBAResponse(body: KBAResult | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/KBA/ProcessKBAResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessKBAResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessKBAResponse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessKBAResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<LanguageTextListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<LanguageTextListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LanguageTextListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<LanguageTextListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LanguageTextListDtoPagedResultDto.fromJS(resultData200) : new LanguageTextListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LanguageTextListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LeadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createLead(body: CreateLeadInput | null | undefined): Observable<CreateLeadOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/CreateLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLead(<any>response_);
                } catch (e) {
                    return <Observable<CreateLeadOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateLeadOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLead(response: HttpResponseBase): Observable<CreateLeadOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateLeadOutput.fromJS(resultData200) : new CreateLeadOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateLeadOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancelLead(body: CancelLeadInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/CancelLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getCancellationReasons(): Observable<LeadCancellationReasonDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetCancellationReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReasons(<any>response_);
                } catch (e) {
                    return <Observable<LeadCancellationReasonDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadCancellationReasonDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCancellationReasons(response: HttpResponseBase): Observable<LeadCancellationReasonDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadCancellationReasonDtoListResultDto.fromJS(resultData200) : new LeadCancellationReasonDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadCancellationReasonDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitTenancyRequest(body: SubmitTenancyRequestInput | null | undefined): Observable<SubmitTenancyRequestOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitTenancyRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitTenancyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitTenancyRequest(<any>response_);
                } catch (e) {
                    return <Observable<SubmitTenancyRequestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitTenancyRequestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitTenancyRequest(response: HttpResponseBase): Observable<SubmitTenancyRequestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitTenancyRequestOutput.fromJS(resultData200) : new SubmitTenancyRequestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitTenancyRequestOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitFreeTrialRequest(body: SubmitFreeTrialRequestInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/SubmitFreeTrialRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitFreeTrialRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitFreeTrialRequest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitFreeTrialRequest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLeadStage(body: UpdateLeadStageInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeadStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    processLead(body: ProcessLeadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/ProcessLead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @leadId (optional) 
     * @return Success
     */
    getLeadInfo(leadId: number | null | undefined): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLeadInfo?";
        if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadInfo(<any>response_);
                } catch (e) {
                    return <Observable<LeadInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadInfo(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadInfoDto.fromJS(resultData200) : new LeadInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(<any>null);
    }

    /**
     * @customerId (optional) 
     * @return Success
     */
    getLast(customerId: number | null | undefined): Observable<LeadInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetLast?";
        if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLast(<any>response_);
                } catch (e) {
                    return <Observable<LeadInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLast(response: HttpResponseBase): Observable<LeadInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LeadInfoDto.fromJS(resultData200) : new LeadInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateLeadInfo(body: UpdateLeadInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/UpdateLeadInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeadInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeadInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeadInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @leadId (optional) 
     * @return Success
     */
    deleteLead(leadId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLead?";
        if (leadId !== undefined)
            url_ += "leadId=" + encodeURIComponent("" + leadId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    deleteLeads(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/DeleteLeads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeads(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeads(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<EntityInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Lead/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityInfo[]>(<any>null);
    }
}

@Injectable()
export class LeadTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLeadTypes(): Observable<LeadTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/LeadType/GetLeadTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeadTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeadTypes(<any>response_);
                } catch (e) {
                    return <Observable<LeadTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeadTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeadTypes(response: HttpResponseBase): Observable<LeadTypeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LeadTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeadTypeDto[]>(<any>null);
    }
}

@Injectable()
export class LocalizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @sourceName (optional) 
     * @return Success
     */
    loadLocalizationSource(sourceName: string | null | undefined): Observable<LocalizationSourceDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Localization/LoadLocalizationSource?";
        if (sourceName !== undefined)
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadLocalizationSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadLocalizationSource(<any>response_);
                } catch (e) {
                    return <Observable<LocalizationSourceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalizationSourceDto>><any>_observableThrow(response_);
        }));
    }

    protected processLoadLocalizationSource(response: HttpResponseBase): Observable<LocalizationSourceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocalizationSourceDto.fromJS(resultData200) : new LocalizationSourceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalizationSourceDto>(<any>null);
    }
}

@Injectable()
export class ManageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    reScheduleApplications(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Manage/ReScheduleApplications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReScheduleApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReScheduleApplications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReScheduleApplications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @packageId (optional) 
     * @return Success
     */
    selectPackage(packageId: number | null | undefined): Observable<SelectPackageResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SelectPackage?";
        if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectPackage(<any>response_);
                } catch (e) {
                    return <Observable<SelectPackageResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectPackageResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processSelectPackage(response: HttpResponseBase): Observable<SelectPackageResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SelectPackageResponseDto.fromJS(resultData200) : new SelectPackageResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectPackageResponseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitMemberInfo(body: MemberInfoDto | null | undefined): Observable<SubmitMemberInfoResultDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/SubmitMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<SubmitMemberInfoResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitMemberInfoResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitMemberInfo(response: HttpResponseBase): Observable<SubmitMemberInfoResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitMemberInfoResultDto.fromJS(resultData200) : new SubmitMemberInfoResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitMemberInfoResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    paymentAuthorize(body: MemberPaymentAuthorizeRequestDto | null | undefined): Observable<PaymentAuthorizeResponseDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/PaymentAuthorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<PaymentAuthorizeResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentAuthorizeResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentAuthorize(response: HttpResponseBase): Observable<PaymentAuthorizeResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentAuthorizeResponseDto.fromJS(resultData200) : new PaymentAuthorizeResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentAuthorizeResponseDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    cancelMembership(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Member/CancelMembership";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelMembership(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMembership(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelMembership(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MyFinancesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserInstanceStatus(): Observable<GetStatusOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/MyFinances/GetUserInstanceStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInstanceStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInstanceStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetStatusOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStatusOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInstanceStatus(response: HttpResponseBase): Observable<GetStatusOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStatusOutput.fromJS(resultData200) : new GetStatusOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStatusOutput>(<any>null);
    }

    /**
     * @accountingTreeType (optional) 
     * @return Success
     */
    setupUserInstance(accountingTreeType: AccountingTreeType | null | undefined): Observable<SetupOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/MyFinances/SetupUserInstance?";
        if (accountingTreeType !== undefined)
            url_ += "accountingTreeType=" + encodeURIComponent("" + accountingTreeType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupUserInstance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupUserInstance(<any>response_);
                } catch (e) {
                    return <Observable<SetupOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetupOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSetupUserInstance(response: HttpResponseBase): Observable<SetupOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetupOutput.fromJS(resultData200) : new SetupOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetupOutput>(<any>null);
    }

    /**
     * @syncTypeId (optional) 
     * @return Success
     */
    createUserInstanceProviderUIToken(syncTypeId: string | null | undefined): Observable<GetProviderUITokenOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/MyFinances/CreateUserInstanceProviderUIToken?";
        if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserInstanceProviderUIToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserInstanceProviderUIToken(<any>response_);
                } catch (e) {
                    return <Observable<GetProviderUITokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProviderUITokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserInstanceProviderUIToken(response: HttpResponseBase): Observable<GetProviderUITokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProviderUITokenOutput.fromJS(resultData200) : new GetProviderUITokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProviderUITokenOutput>(<any>null);
    }

    /**
     * @forcedSync (optional) 
     * @newOnly (optional) 
     * @return Success
     */
    syncAllQuovoAccounts(forcedSync: boolean | null | undefined, newOnly: boolean | null | undefined): Observable<SyncAllAccountsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/MyFinances/SyncAllQuovoAccounts?";
        if (forcedSync !== undefined)
            url_ += "forcedSync=" + encodeURIComponent("" + forcedSync) + "&"; 
        if (newOnly !== undefined)
            url_ += "newOnly=" + encodeURIComponent("" + newOnly) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllQuovoAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllQuovoAccounts(<any>response_);
                } catch (e) {
                    return <Observable<SyncAllAccountsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAllAccountsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAllQuovoAccounts(response: HttpResponseBase): Observable<SyncAllAccountsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncAllAccountsOutput.fromJS(resultData200) : new SyncAllAccountsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAllAccountsOutput>(<any>null);
    }
}

@Injectable()
export class NotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getNotes(contactId: number | null | undefined): Observable<NoteInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/GetNotes?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotes(<any>response_);
                } catch (e) {
                    return <Observable<NoteInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NoteInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotes(response: HttpResponseBase): Observable<NoteInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NoteInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NoteInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createNote(body: CreateNoteInput | null | undefined): Observable<CreateNoteOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/CreateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNote(<any>response_);
                } catch (e) {
                    return <Observable<CreateNoteOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateNoteOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNote(response: HttpResponseBase): Observable<CreateNoteOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateNoteOutput.fromJS(resultData200) : new CreateNoteOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateNoteOutput>(<any>null);
    }

    /**
     * @return Success
     */
    deleteNote(contactId: number, id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/DeleteNote?";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined and cannot be null.");
        else
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateNote(body: UpdateNoteInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Notes/UpdateNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNote(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNote(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: GuidEntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    getAll(body: GetAllInput | null | undefined): Observable<OfferDto[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OfferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OfferDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OfferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDetails(testMode: boolean, campaignId: number): Observable<OfferDetailsDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetDetails?";
        if (testMode === undefined || testMode === null)
            throw new Error("The parameter 'testMode' must be defined and cannot be null.");
        else
            url_ += "TestMode=" + encodeURIComponent("" + testMode) + "&"; 
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<OfferDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<OfferDetailsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferDetailsDto.fromJS(resultData200) : new OfferDetailsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getApplicationDetails(): Observable<GetApplicationDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetApplicationDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationDetails(response: HttpResponseBase): Observable<GetApplicationDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetApplicationDetailsOutput.fromJS(resultData200) : new GetApplicationDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationDetailsOutput>(<any>null);
    }

    /**
     * @groupByPeriod (optional) 
     * @campaignId (optional) 
     * @from (optional) 
     * @to (optional) 
     * @return Success
     */
    getOffersStats(groupByPeriod: GroupByPeriod | null | undefined, campaignId: number | null | undefined, from: moment.Moment | null | undefined, to: moment.Moment | null | undefined): Observable<OfferApplicationGroup[]> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetOffersStats?";
        if (groupByPeriod !== undefined)
            url_ += "GroupByPeriod=" + encodeURIComponent("" + groupByPeriod) + "&"; 
        if (campaignId !== undefined)
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOffersStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOffersStats(<any>response_);
                } catch (e) {
                    return <Observable<OfferApplicationGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferApplicationGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOffersStats(response: HttpResponseBase): Observable<OfferApplicationGroup[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OfferApplicationGroup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferApplicationGroup[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitRequest(body: SubmitRequestInput | null | undefined): Observable<SubmitRequestOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitRequest(<any>response_);
                } catch (e) {
                    return <Observable<SubmitRequestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitRequestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitRequest(response: HttpResponseBase): Observable<SubmitRequestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitRequestOutput.fromJS(resultData200) : new SubmitRequestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitRequestOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitApplication(body: SubmitApplicationInput | null | undefined): Observable<SubmitApplicationOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/SubmitApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApplication(<any>response_);
                } catch (e) {
                    return <Observable<SubmitApplicationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubmitApplicationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitApplication(response: HttpResponseBase): Observable<SubmitApplicationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubmitApplicationOutput.fromJS(resultData200) : new SubmitApplicationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubmitApplicationOutput>(<any>null);
    }

    /**
     * @applicationId (optional) 
     * @return Success
     */
    finalizeApplication(applicationId: number | null | undefined): Observable<FinalizeApplicationResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/FinalizeApplication?";
        if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalizeApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalizeApplication(<any>response_);
                } catch (e) {
                    return <Observable<FinalizeApplicationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FinalizeApplicationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFinalizeApplication(response: HttpResponseBase): Observable<FinalizeApplicationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FinalizeApplicationResponse.fromJS(resultData200) : new FinalizeApplicationResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinalizeApplicationResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getMemberInfo(): Observable<GetMemberInfoResponse> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/GetMemberInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberInfoResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberInfoResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberInfo(response: HttpResponseBase): Observable<GetMemberInfoResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberInfoResponse.fromJS(resultData200) : new GetMemberInfoResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberInfoResponse>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rank(body: RankRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/Offer/Rank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRank(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRank(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferAnnouncementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendAnnouncement(body: SendAnnouncementRequest | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferAnnouncement/SendAnnouncement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAnnouncement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendAnnouncement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OfferManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @fetchAll (optional) 
     * @return Success
     */
    pull(fetchAll: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Pull?";
        if (fetchAll !== undefined)
            url_ += "fetchAll=" + encodeURIComponent("" + fetchAll) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPull(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPull(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDetailsForEdit(campaignId: number): Observable<OfferDetailsForEditDto> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/GetDetailsForEdit?";
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined and cannot be null.");
        else
            url_ += "CampaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<OfferDetailsForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OfferDetailsForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailsForEdit(response: HttpResponseBase): Observable<OfferDetailsForEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OfferDetailsForEditDto.fromJS(resultData200) : new OfferDetailsForEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OfferDetailsForEditDto>(<any>null);
    }

    /**
     * @campaignId (optional) 
     * @body (optional) 
     * @return Success
     */
    extend(campaignId: number | null | undefined, body: ExtendOfferDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/Extend?";
        if (campaignId !== undefined)
            url_ += "campaignId=" + encodeURIComponent("" + campaignId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtend(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @value (optional) 
     * @body (optional) 
     * @return Success
     */
    setAttribute(offerAttribute: OfferAttributeType, value: string | null | undefined, body: OfferFilter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetAttribute?";
        if (offerAttribute === undefined || offerAttribute === null)
            throw new Error("The parameter 'offerAttribute' must be defined and cannot be null.");
        else
            url_ += "offerAttribute=" + encodeURIComponent("" + offerAttribute) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAttribute(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSetAttribute(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @value (optional) 
     * @body (optional) 
     * @return Success
     */
    setFlag(offerFlag: OfferFlagType, value: boolean | null | undefined, body: OfferFilter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/SetFlag?";
        if (offerFlag === undefined || offerFlag === null)
            throw new Error("The parameter 'offerFlag' must be defined and cannot be null.");
        else
            url_ += "offerFlag=" + encodeURIComponent("" + offerFlag) + "&"; 
        if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFlag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFlag(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSetFlag(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    extendFromCSV(body: string | null | undefined): Observable<ExtendFromCSVOutput> {
        let url_ = this.baseUrl + "/api/services/PFM/OfferManagement/ExtendFromCSV";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendFromCSV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendFromCSV(<any>response_);
                } catch (e) {
                    return <Observable<ExtendFromCSVOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtendFromCSVOutput>><any>_observableThrow(response_);
        }));
    }

    protected processExtendFromCSV(response: HttpResponseBase): Observable<ExtendFromCSVOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExtendFromCSVOutput.fromJS(resultData200) : new ExtendFromCSVOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtendFromCSVOutput>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getHistory(id: number | null | undefined): Observable<OrderHistoryInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetHistory?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistory(<any>response_);
                } catch (e) {
                    return <Observable<OrderHistoryInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderHistoryInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistory(response: HttpResponseBase): Observable<OrderHistoryInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrderHistoryInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderHistoryInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setAmount(body: SetAmountInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/SetAmount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAmount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStage(body: UpdateOrderStageInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/UpdateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    process(body: ProcessOrderInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Process";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    cancel(body: CancelOrderInfo | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<EntityInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Order/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityInfo[]>(<any>null);
    }
}

@Injectable()
export class OrderSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getSubscriptionHistory(contactId: number | null | undefined): Observable<OrderSubscriptionDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/GetSubscriptionHistory?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionHistory(<any>response_);
                } catch (e) {
                    return <Observable<OrderSubscriptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderSubscriptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionHistory(response: HttpResponseBase): Observable<OrderSubscriptionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrderSubscriptionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSubscriptionDto[]>(<any>null);
    }

    /**
     * @orderSubscriptionId (optional) 
     * @return Success
     */
    cancel(orderSubscriptionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/Cancel?";
        if (orderSubscriptionId !== undefined)
            url_ += "orderSubscriptionId=" + encodeURIComponent("" + orderSubscriptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @isCaptured (optional) 
     * @return Success
     */
    completeManualSubscriptionPayment(trackingCode: string, isCaptured: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrderSubscription/CompleteManualSubscriptionPayment?";
        if (trackingCode === undefined || trackingCode === null)
            throw new Error("The parameter 'trackingCode' must be defined and cannot be null.");
        else
            url_ += "trackingCode=" + encodeURIComponent("" + trackingCode) + "&"; 
        if (isCaptured !== undefined)
            url_ += "isCaptured=" + encodeURIComponent("" + isCaptured) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteManualSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteManualSubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteManualSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getOrganizationContactInfo(contactId: number | null | undefined): Observable<OrganizationContactInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizationContactInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationContactInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationContactInfo(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationContactInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationContactInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationContactInfo(response: HttpResponseBase): Observable<OrganizationContactInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationContactInfoDto.fromJS(resultData200) : new OrganizationContactInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationContactInfoDto>(<any>null);
    }

    /**
     * @searchString (optional) 
     * @groupId (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getOrganizations(searchString: string | null | undefined, groupId: string | null | undefined, topCount: number | null | undefined): Observable<OrganizationShortInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/GetOrganizations?";
        if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&"; 
        if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&"; 
        if (topCount !== undefined)
            url_ += "topCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizations(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationShortInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationShortInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizations(response: HttpResponseBase): Observable<OrganizationShortInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationShortInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationShortInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrganization(body: CreateOrganizationInput | null | undefined): Observable<CreateOrganizationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/CreateOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganization(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrganizationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrganizationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganization(response: HttpResponseBase): Observable<CreateOrganizationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrganizationOutput.fromJS(resultData200) : new CreateOrganizationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrganizationOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOrganizationInfo(body: UpdateOrganizationInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/UpdateOrganizationInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number, currentPersonOrgRelationId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/OrganizationContact/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (currentPersonOrgRelationId === undefined || currentPersonOrgRelationId === null)
            throw new Error("The parameter 'currentPersonOrgRelationId' must be defined and cannot be null.");
        else
            url_ += "CurrentPersonOrgRelationId=" + encodeURIComponent("" + currentPersonOrgRelationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDtoListResultDto.fromJS(resultData200) : new OrganizationUnitDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200) : new OrganizationUnitUserListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitUserListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userId (optional) 
     * @organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | null | undefined): Observable<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<NameValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoPagedResultDto.fromJS(resultData200) : new NameValueDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class PackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<PackageDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/PFM/Package/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PackageDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackageDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PackageDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PackageDtoListResultDto.fromJS(resultData200) : new PackageDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackageDtoListResultDto>(<any>null);
    }

    /**
     * @module (optional) 
     * @return Success
     */
    getPackagesConfig(module: ModuleType | null | undefined): Observable<GetPackagesConfigOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Package/GetPackagesConfig?";
        if (module !== undefined)
            url_ += "Module=" + encodeURIComponent("" + module) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackagesConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackagesConfig(<any>response_);
                } catch (e) {
                    return <Observable<GetPackagesConfigOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPackagesConfigOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackagesConfig(response: HttpResponseBase): Observable<GetPackagesConfigOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPackagesConfigOutput.fromJS(resultData200) : new GetPackagesConfigOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPackagesConfigOutput>(<any>null);
    }
}

@Injectable()
export class PartnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<PartnerInfoDto> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/Get?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PartnerInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartnerInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PartnerInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PartnerInfoDto.fromJS(resultData200) : new PartnerInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerInfoDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateType(body: UpdatePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/UpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    bulkUpdateType(body: BulkUpdatePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/BulkUpdateType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkUpdateType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkUpdateType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBulkUpdateType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllByPhrase(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<EntityInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Partner/GetAllByPhrase?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByPhrase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByPhrase(<any>response_);
                } catch (e) {
                    return <Observable<EntityInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByPhrase(response: HttpResponseBase): Observable<EntityInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityInfo[]>(<any>null);
    }
}

@Injectable()
export class PartnerTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rename(body: RenamePartnerTypeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @moveToTypeId (optional) 
     * @deleteAllReferences (optional) 
     * @return Success
     */
    delete(id: number | null | undefined, moveToTypeId: number | null | undefined, deleteAllReferences: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PartnerType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (moveToTypeId !== undefined)
            url_ += "MoveToTypeId=" + encodeURIComponent("" + moveToTypeId) + "&"; 
        if (deleteAllReferences !== undefined)
            url_ += "DeleteAllReferences=" + encodeURIComponent("" + deleteAllReferences) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getPayments(contactId: number | null | undefined): Observable<MonthlyPaymentInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPayments?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayments(<any>response_);
                } catch (e) {
                    return <Observable<MonthlyPaymentInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MonthlyPaymentInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayments(response: HttpResponseBase): Observable<MonthlyPaymentInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MonthlyPaymentInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonthlyPaymentInfo[]>(<any>null);
    }

    /**
     * @contactId (optional) 
     * @return Success
     */
    getPaymentMethods(contactId: number | null | undefined): Observable<PaymentMethodInfo[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Payment/GetPaymentMethods?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentMethods(<any>response_);
                } catch (e) {
                    return <Observable<PaymentMethodInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentMethodInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentMethods(response: HttpResponseBase): Observable<PaymentMethodInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PaymentMethodInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentMethodInfo[]>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @includeIrrelevant (optional) 
     * @return Success
     */
    getAllPermissions(includeIrrelevant: boolean | null | undefined): Observable<FlatPermissionWithLevelDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Permission/GetAllPermissions?";
        if (includeIrrelevant !== undefined)
            url_ += "includeIrrelevant=" + encodeURIComponent("" + includeIrrelevant) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionWithLevelDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<FlatPermissionWithLevelDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FlatPermissionWithLevelDtoListResultDto.fromJS(resultData200) : new FlatPermissionWithLevelDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionWithLevelDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class PersonContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonInfo(body: UpdatePersonInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonBANKCode(body: UpdatePersonBANKCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonBANKCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonBANKCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonBANKCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonBANKCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePersonName(body: UpdatePersonNameInput | null | undefined): Observable<UpdatePersonNameOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/UpdatePersonName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonName(<any>response_);
                } catch (e) {
                    return <Observable<UpdatePersonNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdatePersonNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonName(response: HttpResponseBase): Observable<UpdatePersonNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdatePersonNameOutput.fromJS(resultData200) : new UpdatePersonNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdatePersonNameOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createUserForContact(body: CreateUserForContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonContact/CreateUserForContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserForContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserForContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUserForContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PersonOrgRelationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: CreatePersonOrgRelationInput | null | undefined): Observable<CreatePersonOrgRelationOutput> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreatePersonOrgRelationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreatePersonOrgRelationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreatePersonOrgRelationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreatePersonOrgRelationOutput.fromJS(resultData200) : new CreatePersonOrgRelationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreatePersonOrgRelationOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: UpdatePersonOrgRelationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    setPrimaryOrgRelation(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/SetPrimaryOrgRelation?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrimaryOrgRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrimaryOrgRelation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPrimaryOrgRelation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/PersonOrgRelation/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PipelineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @purposeId (optional) 
     * @contactGroupId (optional) 
     * @return Success
     */
    getPipelineDefinitions(purposeId: string | null | undefined, contactGroupId: string | null | undefined): Observable<PipelineDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/GetPipelineDefinitions?";
        if (purposeId !== undefined)
            url_ += "purposeId=" + encodeURIComponent("" + purposeId) + "&"; 
        if (contactGroupId !== undefined)
            url_ += "contactGroupId=" + encodeURIComponent("" + contactGroupId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPipelineDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPipelineDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<PipelineDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PipelineDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPipelineDefinitions(response: HttpResponseBase): Observable<PipelineDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PipelineDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PipelineDto[]>(<any>null);
    }

    /**
     * @pipelineId (optional) 
     * @entityId (optional) 
     * @sortOrder (optional) 
     * @return Success
     */
    updateEntitySortOrder(pipelineId: number | null | undefined, entityId: number | null | undefined, sortOrder: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Pipeline/UpdateEntitySortOrder?";
        if (pipelineId !== undefined)
            url_ += "pipelineId=" + encodeURIComponent("" + pipelineId) + "&"; 
        if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntitySortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntitySortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEntitySortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearProfilePicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ClearProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    downloadPicture(body: DownloadPictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/DownloadPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadPicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @userId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuestionnaireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @moduleName (optional) 
     * @identifier (optional) 
     * @return Success
     */
    get(moduleName: string | null | undefined, identifier: string | null | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/Get?";
        if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(<any>null);
    }

    /**
     * @moduleName (optional) 
     * @identifier (optional) 
     * @return Success
     */
    getInternal(moduleName: string | null | undefined, identifier: string | null | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/GetInternal?";
        if (moduleName !== undefined)
            url_ += "moduleName=" + encodeURIComponent("" + moduleName) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternal(<any>response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInternal(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitResponse(body: QuestionnaireResponseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    submitResponseInternal(body: QuestionnaireResponseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Questionnaire/SubmitResponseInternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitResponseInternal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitResponseInternal(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitResponseInternal(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuickBookServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @code (optional) 
     * @realmId (optional) 
     * @return Success
     */
    processResult(state: string | null | undefined, code: string | null | undefined, realmId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/QuickBook/ProcessResult?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (realmId !== undefined)
            url_ += "RealmId=" + encodeURIComponent("" + realmId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessResult(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProcessResult(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getQuickBookConnectionLink(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<QuickBookConnectionLinkResult> {
        let url_ = this.baseUrl + "/api/services/CFO/QuickBook/GetQuickBookConnectionLink?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuickBookConnectionLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuickBookConnectionLink(<any>response_);
                } catch (e) {
                    return <Observable<QuickBookConnectionLinkResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuickBookConnectionLinkResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuickBookConnectionLink(response: HttpResponseBase): Observable<QuickBookConnectionLinkResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuickBookConnectionLinkResult.fromJS(resultData200) : new QuickBookConnectionLinkResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuickBookConnectionLinkResult>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    checkToken(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/QuickBook/CheckToken?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckToken(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckToken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @isOverride (optional) 
     * @return Success
     */
    syncChartOfAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, isOverride: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/QuickBook/SyncChartOfAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (isOverride !== undefined)
            url_ += "isOverride=" + encodeURIComponent("" + isOverride) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncChartOfAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncChartOfAccounts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncChartOfAccounts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReportingCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getReportingAndCoACategorization(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/CFO/ReportingCategory/GetReportingAndCoACategorization?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportingAndCoACategorization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportingAndCoACategorization(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportingAndCoACategorization(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    getUrl(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: string | null | undefined): Observable<GetReportUrlOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/GetUrl?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrl(<any>response_);
                } catch (e) {
                    return <Observable<GetReportUrlOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportUrlOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUrl(response: HttpResponseBase): Observable<GetReportUrlOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetReportUrlOutput.fromJS(resultData200) : new GetReportUrlOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportUrlOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    generate(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: GenerateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Generate?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @id (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/Delete?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    sendReportNotification(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: SendReportNotificationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/Reports/SendReportNotification?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReportNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReportNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendReportNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @permission (optional) 
     * @moduleType (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined, moduleType: ModuleType | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (moduleType !== undefined)
            url_ += "ModuleType=" + encodeURIComponent("" + moduleType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleListDtoListResultDto.fromJS(resultData200) : new RoleListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SecurityManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @bankAccountId (optional) 
     * @userId (optional) 
     * @body (optional) 
     * @return Success
     */
    grantBankAccountPermissions(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, bankAccountId: number | null | undefined, userId: number | null | undefined, body: Permissions | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GrantBankAccountPermissions?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (bankAccountId !== undefined)
            url_ += "bankAccountId=" + encodeURIComponent("" + bankAccountId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantBankAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @userId (optional) 
     * @body (optional) 
     * @return Success
     */
    revokeBankAccountPermissions(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, userId: number | null | undefined, body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/RevokeBankAccountPermissions?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeBankAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeBankAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRevokeBankAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getBankAccountAssignedUsers(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<BankAccountUsers[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SecurityManagement/GetBankAccountAssignedUsers?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountAssignedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountAssignedUsers(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountUsers[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountUsers[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccountAssignedUsers(response: HttpResponseBase): Observable<BankAccountUsers[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BankAccountUsers.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountUsers[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }

    /**
     * @return Success
     */
    authTest(): Observable<AuthTestOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Session/AuthTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthTest(<any>response_);
                } catch (e) {
                    return <Observable<AuthTestOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthTestOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAuthTest(response: HttpResponseBase): Observable<AuthTestOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthTestOutput.fromJS(resultData200) : new AuthTestOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTestOutput>(<any>null);
    }
}

@Injectable()
export class StageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createStage(body: CreateStageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/CreateStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    renameStage(body: RenameStageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/RenameStage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenameStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    mergeStages(body: MergeStagesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/MergeStages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeStages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeStages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMergeStages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateStageSortOrder(body: UpdateSortOrderInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/Stage/UpdateStageSortOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStageSortOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStageSortOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStageSortOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncTypeId (optional) 
     * @return Success
     */
    createProviderUIToken(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncTypeId: string | null | undefined): Observable<GetProviderUITokenOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/CreateProviderUIToken?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProviderUIToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProviderUIToken(<any>response_);
                } catch (e) {
                    return <Observable<GetProviderUITokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProviderUITokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProviderUIToken(response: HttpResponseBase): Observable<GetProviderUITokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProviderUITokenOutput.fromJS(resultData200) : new GetProviderUITokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProviderUITokenOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncTypeId (optional) 
     * @css (optional) 
     * @errorPage (optional) 
     * @return Success
     */
    getSetupAccountsLink(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncTypeId: string | null | undefined, css: string | null | undefined, errorPage: string | null | undefined): Observable<GetSetupAccountsLinkOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/GetSetupAccountsLink?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&"; 
        if (css !== undefined)
            url_ += "css=" + encodeURIComponent("" + css) + "&"; 
        if (errorPage !== undefined)
            url_ += "errorPage=" + encodeURIComponent("" + errorPage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetupAccountsLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetupAccountsLink(<any>response_);
                } catch (e) {
                    return <Observable<GetSetupAccountsLinkOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSetupAccountsLinkOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetupAccountsLink(response: HttpResponseBase): Observable<GetSetupAccountsLinkOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSetupAccountsLinkOutput.fromJS(resultData200) : new GetSetupAccountsLinkOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSetupAccountsLinkOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @forcedSync (optional) 
     * @newOnly (optional) 
     * @syncType (optional) 
     * @return Success
     */
    syncAllAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, forcedSync: boolean | null | undefined, newOnly: boolean | null | undefined, syncType: string | null | undefined): Observable<SyncAllAccountsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAllAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (forcedSync !== undefined)
            url_ += "forcedSync=" + encodeURIComponent("" + forcedSync) + "&"; 
        if (newOnly !== undefined)
            url_ += "newOnly=" + encodeURIComponent("" + newOnly) + "&"; 
        if (syncType !== undefined)
            url_ += "syncType=" + encodeURIComponent("" + syncType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAllAccounts(<any>response_);
                } catch (e) {
                    return <Observable<SyncAllAccountsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAllAccountsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAllAccounts(response: HttpResponseBase): Observable<SyncAllAccountsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncAllAccountsOutput.fromJS(resultData200) : new SyncAllAccountsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAllAccountsOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncAccountId (optional) 
     * @return Success
     */
    syncAccount(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncAccountId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/SyncAccount?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncAccount(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getSyncProgress(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<SyncProgressOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/GetSyncProgress?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSyncProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSyncProgress(<any>response_);
                } catch (e) {
                    return <Observable<SyncProgressOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncProgressOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSyncProgress(response: HttpResponseBase): Observable<SyncProgressOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SyncProgressOutput.fromJS(resultData200) : new SyncProgressOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncProgressOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @fullResync (optional) 
     * @body (optional) 
     * @return Success
     */
    requestSyncForAccounts(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, fullResync: boolean | null | undefined, body: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Sync/RequestSyncForAccounts?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (fullResync !== undefined)
            url_ += "fullResync=" + encodeURIComponent("" + fullResync) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestSyncForAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestSyncForAccounts(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRequestSyncForAccounts(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class SyncAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncTypeId (optional) 
     * @return Success
     */
    getActive(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncTypeId: string | null | undefined): Observable<SyncAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/GetActive?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncTypeId !== undefined)
            url_ += "syncTypeId=" + encodeURIComponent("" + syncTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActive(<any>response_);
                } catch (e) {
                    return <Observable<SyncAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SyncAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActive(response: HttpResponseBase): Observable<SyncAccountDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SyncAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SyncAccountDto[]>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    create(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: CreateSyncAccountInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Create?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    update(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: UpdateSyncAccountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Update?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @body (optional) 
     * @return Success
     */
    rename(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, body: RenameSyncAccountInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Rename?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRename(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRename(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRename(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @syncAccountId (optional) 
     * @return Success
     */
    delete(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, syncAccountId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/Delete?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (syncAccountId !== undefined)
            url_ += "syncAccountId=" + encodeURIComponent("" + syncAccountId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    createIsAllowed(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/CFO/SyncAccount/CreateIsAllowed?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIsAllowed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIsAllowed(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIsAllowed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @editionIdSpecified (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<TenantListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<TenantListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<TenantListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantListDtoPagedResultDto.fromJS(resultData200) : new TenantListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantListDtoPagedResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomPrivacyPolicyDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomPrivacyPolicyDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomPrivacyPolicyDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomPrivacyPolicyDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomPrivacyPolicyDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomToSDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearCustomToSDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomToSDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomToSDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomToSDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearFavicons(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ClearFavicons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearFavicons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearFavicons(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearFavicons(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setCustomLayout(body: LayoutType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/SetCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCustomLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    validateCustomLayout(body: LayoutType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantCustomization/ValidateCustomLayout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCustomLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCustomLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCustomLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantHostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantAppHost(): Observable<TenantAppHostOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetTenantAppHost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantAppHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantAppHost(<any>response_);
                } catch (e) {
                    return <Observable<TenantAppHostOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantAppHostOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantAppHost(response: HttpResponseBase): Observable<TenantAppHostOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantAppHostOutput.fromJS(resultData200) : new TenantAppHostOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAppHostOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    checkHostNameDnsMapping(body: CheckHostNameDnsMappingInput | null | undefined): Observable<CheckHostNameDnsMappingOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/CheckHostNameDnsMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHostNameDnsMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHostNameDnsMapping(<any>response_);
                } catch (e) {
                    return <Observable<CheckHostNameDnsMappingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckHostNameDnsMappingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckHostNameDnsMapping(response: HttpResponseBase): Observable<CheckHostNameDnsMappingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckHostNameDnsMappingOutput.fromJS(resultData200) : new CheckHostNameDnsMappingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckHostNameDnsMappingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSslBindings(): Observable<TenantSslBindingInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/GetSslBindings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSslBindings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSslBindings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslBindingInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSslBindings(response: HttpResponseBase): Observable<TenantSslBindingInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslBindingInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addSslBinding(body: AddSslBindingInput | null | undefined): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/AddSslBinding";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSslBinding(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>_observableThrow(response_);
        }));
    }

    protected processAddSslBinding(response: HttpResponseBase): Observable<TenantSslBindingInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSslBindingCertificate(body: UpdateSslBindingCertificateInput | null | undefined): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBindingCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSslBindingCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSslBindingCertificate(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSslBindingCertificate(response: HttpResponseBase): Observable<TenantSslBindingInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateSslBindingIsActive(body: UpdateSslBindingIsActiveInput | null | undefined): Observable<TenantSslBindingInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/UpdateSslBindingIsActive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSslBindingIsActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSslBindingIsActive(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslBindingInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslBindingInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSslBindingIsActive(response: HttpResponseBase): Observable<TenantSslBindingInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslBindingInfo.fromJS(resultData200) : new TenantSslBindingInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslBindingInfo>(<any>null);
    }

    /**
     * @tenantHostType (optional) 
     * @return Success
     */
    deleteSslBinding(tenantHostType: TenantHostType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantHost/DeleteSslBinding?";
        if (tenantHostType !== undefined)
            url_ += "TenantHostType=" + encodeURIComponent("" + tenantHostType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSslBinding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSslBinding(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSslBinding(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantIntegrationsSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIntegrationsSettings(): Observable<IntegrationsSettings> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/GetIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIntegrationsSettings(<any>response_);
                } catch (e) {
                    return <Observable<IntegrationsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<IntegrationsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetIntegrationsSettings(response: HttpResponseBase): Observable<IntegrationsSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IntegrationsSettings.fromJS(resultData200) : new IntegrationsSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegrationsSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIntegrationsSettings(body: IntegrationsSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantIntegrationsSettings/UpdateIntegrationsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIntegrationsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIntegrationsSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIntegrationsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantOfferProviderSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEPCVIPOfferProviderSettings(): Observable<EPCVIPOfferProviderSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/GetEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPOfferProviderSettings(<any>response_);
                } catch (e) {
                    return <Observable<EPCVIPOfferProviderSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<EPCVIPOfferProviderSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<EPCVIPOfferProviderSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EPCVIPOfferProviderSettings.fromJS(resultData200) : new EPCVIPOfferProviderSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPOfferProviderSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEPCVIPOfferProviderSettings(body: EPCVIPOfferProviderSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantOfferProviderSettings/UpdateEPCVIPOfferProviderSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPOfferProviderSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPOfferProviderSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEPCVIPOfferProviderSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantPaymentSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBaseCommercePaymentSettings(): Observable<BaseCommercePaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaseCommercePaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<BaseCommercePaymentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<BaseCommercePaymentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetBaseCommercePaymentSettings(response: HttpResponseBase): Observable<BaseCommercePaymentSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BaseCommercePaymentSettings.fromJS(resultData200) : new BaseCommercePaymentSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BaseCommercePaymentSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBaseCommercePaymentSettings(body: BaseCommercePaymentSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBaseCommercePaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBaseCommercePaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBaseCommercePaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBaseCommercePaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getACHWorksSettings(): Observable<ACHWorksSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetACHWorksSettings(<any>response_);
                } catch (e) {
                    return <Observable<ACHWorksSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<ACHWorksSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetACHWorksSettings(response: HttpResponseBase): Observable<ACHWorksSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ACHWorksSettings.fromJS(resultData200) : new ACHWorksSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ACHWorksSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateACHWorksSettings(body: ACHWorksSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateACHWorksSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateACHWorksSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateACHWorksSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateACHWorksSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRecurlyPaymentSettings(): Observable<RecurlyPaymentSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurlyPaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<RecurlyPaymentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurlyPaymentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecurlyPaymentSettings(response: HttpResponseBase): Observable<RecurlyPaymentSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecurlyPaymentSettings.fromJS(resultData200) : new RecurlyPaymentSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurlyPaymentSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateRecurlyPaymentSettings(body: RecurlyPaymentSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateRecurlyPaymentSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRecurlyPaymentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRecurlyPaymentSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRecurlyPaymentSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<PayPalSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalSettings.fromJS(resultData200) : new PayPalSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePayPalSettings(body: PayPalSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdatePayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePayPalSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettings> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<BankTransferSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankTransferSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankTransferSettings.fromJS(resultData200) : new BankTransferSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateBankTransferSettings(body: BankTransferSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CRM/TenantPaymentSettings/UpdateBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankTransferSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEPCVIPMailerSettings(): Observable<EPCVIPMailerSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEPCVIPMailerSettings(<any>response_);
                } catch (e) {
                    return <Observable<EPCVIPMailerSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EPCVIPMailerSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEPCVIPMailerSettings(response: HttpResponseBase): Observable<EPCVIPMailerSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EPCVIPMailerSettingsEditDto.fromJS(resultData200) : new EPCVIPMailerSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EPCVIPMailerSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOngageSettings(): Observable<OngageSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOngageSettings(<any>response_);
                } catch (e) {
                    return <Observable<OngageSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OngageSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOngageSettings(response: HttpResponseBase): Observable<OngageSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OngageSettingsEditDto.fromJS(resultData200) : new OngageSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OngageSettingsEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    getIAgeSettings(): Observable<IAgeSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/GetIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIAgeSettings(<any>response_);
                } catch (e) {
                    return <Observable<IAgeSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IAgeSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIAgeSettings(response: HttpResponseBase): Observable<IAgeSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IAgeSettingsEditDto.fromJS(resultData200) : new IAgeSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IAgeSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEPCVIPMailerSettings(body: EPCVIPMailerSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateEPCVIPMailerSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEPCVIPMailerSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEPCVIPMailerSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEPCVIPMailerSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOngageSettings(body: OngageSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateOngageSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOngageSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOngageSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOngageSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIAgeSettings(body: IAgeSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/UpdateIAgeSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIAgeSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIAgeSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIAgeSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSettingsCreditReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getIdcsSettings(): Observable<IdcsSettings> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/GetIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdcsSettings(<any>response_);
                } catch (e) {
                    return <Observable<IdcsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdcsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetIdcsSettings(response: HttpResponseBase): Observable<IdcsSettings> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdcsSettings.fromJS(resultData200) : new IdcsSettings();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdcsSettings>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateIdcsSettings(body: IdcsSettings | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/PFM/TenantSettingsCreditReport/UpdateIdcsSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdcsSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdcsSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIdcsSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSslCertificateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTenantSslCertificates(): Observable<TenantSslCertificateInfo[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/GetTenantSslCertificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantSslCertificates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantSslCertificates(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantSslCertificates(response: HttpResponseBase): Observable<TenantSslCertificateInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TenantSslCertificateInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addTenantSslCertificate(body: AddTenantSslCertificateInput | null | undefined): Observable<TenantSslCertificateInfo> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/AddTenantSslCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTenantSslCertificate(<any>response_);
                } catch (e) {
                    return <Observable<TenantSslCertificateInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSslCertificateInfo>><any>_observableThrow(response_);
        }));
    }

    protected processAddTenantSslCertificate(response: HttpResponseBase): Observable<TenantSslCertificateInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSslCertificateInfo.fromJS(resultData200) : new TenantSslCertificateInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSslCertificateInfo>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTenantSslCertificate(sslCertificateId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSslCertificate/DeleteTenantSslCertificate?";
        if (sslCertificateId === undefined || sslCertificateId === null)
            throw new Error("The parameter 'sslCertificateId' must be defined and cannot be null.");
        else
            url_ += "SslCertificateId=" + encodeURIComponent("" + sslCertificateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenantSslCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenantSslCertificate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenantSslCertificate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addPaymentInfo(body: PaymentRequestInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/AddPaymentInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddPaymentInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    setupSubscription(body: SetupSubscriptionInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/SetupSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetupSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetupSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetupSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    requestPayment(body: RequestPaymentDto | null | undefined): Observable<RequestPaymentResult> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RequestPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPayment(<any>response_);
                } catch (e) {
                    return <Observable<RequestPaymentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestPaymentResult>><any>_observableThrow(response_);
        }));
    }

    protected processRequestPayment(response: HttpResponseBase): Observable<RequestPaymentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RequestPaymentResult.fromJS(resultData200) : new RequestPaymentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestPaymentResult>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    completeSubscriptionPayment(body: PaymentRequestInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteSubscriptionPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteSubscriptionPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteSubscriptionPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteSubscriptionPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    rejectPendingPayment(body: ModuleType | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/RejectPendingPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPendingPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPendingPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRejectPendingPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getModuleSubscriptions(): Observable<ModuleSubscriptionInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetModuleSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<ModuleSubscriptionInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleSubscriptionInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModuleSubscriptions(response: HttpResponseBase): Observable<ModuleSubscriptionInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ModuleSubscriptionInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleSubscriptionInfoDto[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    completeTenantRegistration(body: CompleteTenantRegistrationInput | null | undefined): Observable<CompleteTenantRegistrationOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/CompleteTenantRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTenantRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTenantRegistration(<any>response_);
                } catch (e) {
                    return <Observable<CompleteTenantRegistrationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompleteTenantRegistrationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteTenantRegistration(response: HttpResponseBase): Observable<CompleteTenantRegistrationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompleteTenantRegistrationOutput.fromJS(resultData200) : new CompleteTenantRegistrationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompleteTenantRegistrationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransferSettings(): Observable<BankTransferSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetBankTransferSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankTransferSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankTransferSettings(<any>response_);
                } catch (e) {
                    return <Observable<BankTransferSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankTransferSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankTransferSettings(response: HttpResponseBase): Observable<BankTransferSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankTransferSettingsDto.fromJS(resultData200) : new BankTransferSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankTransferSettingsDto>(<any>null);
    }

    /**
     * @return Success
     */
    getPayPalSettings(): Observable<PayPalSettingsDto> {
        let url_ = this.baseUrl + "/api/services/Platform/TenantSubscription/GetPayPalSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalSettings(<any>response_);
                } catch (e) {
                    return <Observable<PayPalSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayPalSettings(response: HttpResponseBase): Observable<PayPalSettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalSettingsDto.fromJS(resultData200) : new PayPalSettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalSettingsDto>(<any>null);
    }
}

@Injectable()
export class TestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @strings (optional) 
     * @return Success
     */
    getCommonPhrases(strings: string[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetCommonPhrases?";
        if (strings !== undefined)
            strings && strings.forEach(item => { url_ += "strings=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommonPhrases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonPhrases(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommonPhrases(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @text (optional) 
     * @return Success
     */
    getKeywords(text: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Test/GetKeywords?";
        if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKeywords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKeywords(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKeywords(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes | null | undefined): Observable<NameValueDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezones?";
        if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<NameValueDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NameValueDtoListResultDto.fromJS(resultData200) : new NameValueDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDtoListResultDto>(<any>null);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @secureId (optional) 
     * @return Success
     */
    impersonatedAuthenticate(secureId: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (secureId !== undefined)
            url_ += "secureId=" + encodeURIComponent("" + secureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TransactionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getFiltersInitialData(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<FiltersInitialData> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetFiltersInitialData?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiltersInitialData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiltersInitialData(<any>response_);
                } catch (e) {
                    return <Observable<FiltersInitialData>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiltersInitialData>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiltersInitialData(response: HttpResponseBase): Observable<FiltersInitialData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FiltersInitialData.fromJS(resultData200) : new FiltersInitialData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiltersInitialData>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @currencyId (optional) 
     * @accountIds (optional) 
     * @businessEntityIds (optional) 
     * @return Success
     */
    getStartingBalance(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, currencyId: string | null | undefined, accountIds: number[] | null | undefined, businessEntityIds: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetStartingBalance?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&"; 
        if (accountIds !== undefined)
            accountIds && accountIds.forEach(item => { url_ += "AccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (businessEntityIds !== undefined)
            businessEntityIds && businessEntityIds.forEach(item => { url_ += "BusinessEntityIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStartingBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStartingBalance(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStartingBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionAttributeTypes(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined): Observable<GetTransactionAttributeTypesOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionAttributeTypes?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionAttributeTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionAttributeTypes(<any>response_);
                } catch (e) {
                    return <Observable<GetTransactionAttributeTypesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTransactionAttributeTypesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionAttributeTypes(response: HttpResponseBase): Observable<GetTransactionAttributeTypesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionAttributeTypesOutput.fromJS(resultData200) : new GetTransactionAttributeTypesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionAttributeTypesOutput>(<any>null);
    }

    /**
     * @instanceType (optional) 
     * @instanceId (optional) 
     * @return Success
     */
    getTransactionDetails(instanceType: InstanceType | null | undefined, instanceId: number | null | undefined, transactionId: number): Observable<GetTransactionDetailsOutput> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionDetails?";
        if (instanceType !== undefined)
            url_ += "instanceType=" + encodeURIComponent("" + instanceType) + "&"; 
        if (instanceId !== undefined)
            url_ += "instanceId=" + encodeURIComponent("" + instanceId) + "&"; 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined and cannot be null.");
        else
            url_ += "TransactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetTransactionDetailsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTransactionDetailsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionDetails(response: HttpResponseBase): Observable<GetTransactionDetailsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTransactionDetailsOutput.fromJS(resultData200) : new GetTransactionDetailsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTransactionDetailsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactionTypesAndCategories(): Observable<TransactionTypesAndCategoriesDto> {
        let url_ = this.baseUrl + "/api/services/CFO/Transactions/GetTransactionTypesAndCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypesAndCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypesAndCategories(<any>response_);
                } catch (e) {
                    return <Observable<TransactionTypesAndCategoriesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionTypesAndCategoriesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypesAndCategories(response: HttpResponseBase): Observable<TransactionTypesAndCategoriesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TransactionTypesAndCategoriesDto.fromJS(resultData200) : new TransactionTypesAndCategoriesDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionTypesAndCategoriesDto>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @permissions (optional) 
     * @role (optional) 
     * @onlyLockedUsers (optional) 
     * @group (optional) 
     * @isActive (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, group: UserGroup | null | undefined, isActive: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<UserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (group !== undefined)
            url_ += "Group=" + encodeURIComponent("" + group) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserListDtoPagedResultDto.fromJS(resultData200) : new UserListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: Int64EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateUserPicture(body: UpdateUserPictureInput | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateUserPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    clearUserPicture(userId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ClearUserPicture?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    inviteUsers(body: InviteUserInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/InviteUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInviteUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInviteUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInviteUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlockUser(body: Int64EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateEmail(body: UpdateUserEmailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updatePhone(body: UpdateUserPhoneDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdatePhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePhone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePhone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    resetPassword(body: ResetUserPasswordDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    updateOptions(body: UpdateUserOptionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/UpdateOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    grantPermission(body: GrantPermissionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GrantPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGrantPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGrantPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGrantPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    prohibitPermission(body: ProhibitPermissionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/ProhibitPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProhibitPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProhibitPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processProhibitPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addToRole(body: UpdateUserRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/AddToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddToRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    removeFromRole(id: number | null | undefined, roleName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/User/RemoveFromRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined and cannot be null.");
        else
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveFromRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @moduleType (optional) 
     * @return Success
     */
    getAvailableUserCount(moduleType: ModuleType | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/Platform/User/GetAvailableUserCount?";
        if (moduleType !== undefined)
            url_ += "moduleType=" + encodeURIComponent("" + moduleType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableUserCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableUserCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class UserAssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchPhrase (optional) 
     * @topCount (optional) 
     * @return Success
     */
    getAllowedAssignableUsersForActivity(searchPhrase: string | null | undefined, topCount: number | null | undefined): Observable<UserInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/CRM/UserAssignment/GetAllowedAssignableUsersForActivity?";
        if (searchPhrase !== undefined)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&"; 
        if (topCount !== undefined)
            url_ += "TopCount=" + encodeURIComponent("" + topCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedAssignableUsersForActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedAssignableUsersForActivity(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllowedAssignableUsersForActivity(response: HttpResponseBase): Observable<UserInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoDto[]>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<LinkedUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<LinkedUserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkedUserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LinkedUserDtoPagedResultDto.fromJS(resultData200) : new LinkedUserDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkedUserDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<LinkedUserDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<LinkedUserDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LinkedUserDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<LinkedUserDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LinkedUserDtoListResultDto.fromJS(resultData200) : new LinkedUserDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LinkedUserDtoListResultDto>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<UserLoginAttemptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginAttemptDtoListResultDto.fromJS(resultData200) : new UserLoginAttemptDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginAttemptDtoListResultDto>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getRecentLoginAttemptsForOtherUser(userId: number | null | undefined): Observable<UserLoginAttemptDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/Platform/UserLogin/GetRecentLoginAttemptsForOtherUser?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentLoginAttemptsForOtherUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentLoginAttemptsForOtherUser(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLoginAttemptDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentLoginAttemptsForOtherUser(response: HttpResponseBase): Observable<UserLoginAttemptDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginAttemptDtoListResultDto.fromJS(resultData200) : new UserLoginAttemptDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginAttemptDtoListResultDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/Platform/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkflowEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    addRule(body: AddWorkflowRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/AddRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    editRule(body: EditWorkflowRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/EditRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @ruleId (optional) 
     * @return Success
     */
    deleteRule(ruleId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/DeleteRule?";
        if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRules(): Observable<WorkflowRuleDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetRules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRules(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowRuleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowRuleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRules(response: HttpResponseBase): Observable<WorkflowRuleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkflowRuleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowRuleDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTriggers(): Observable<WorkflowTriggerDto[]> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/GetTriggers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTriggers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTriggers(<any>response_);
                } catch (e) {
                    return <Observable<WorkflowTriggerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkflowTriggerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTriggers(response: HttpResponseBase): Observable<WorkflowTriggerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkflowTriggerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkflowTriggerDto[]>(<any>null);
    }

    /**
     * @ruleId (optional) 
     * @return Success
     */
    triggerRule(ruleId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/Platform/WorkflowEvents/TriggerRule?";
        if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTriggerRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class XeroServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCertificate(): Observable<void> {
        let url_ = this.baseUrl + "/api/Xero/GetCertificate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertificate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class SignUpMemberRequest implements ISignUpMemberRequest {
    firstName!: string;
    lastName!: string;
    email!: string;
    postalCode!: string | undefined;
    phoneNumber!: string | undefined;
    isUSCitizen!: boolean;
    pendingPasswordReset!: boolean | undefined;

    constructor(data?: ISignUpMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.postalCode = data["postalCode"];
            this.phoneNumber = data["phoneNumber"];
            this.isUSCitizen = data["isUSCitizen"];
            this.pendingPasswordReset = data["pendingPasswordReset"];
        }
    }

    static fromJS(data: any): SignUpMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["postalCode"] = this.postalCode;
        data["phoneNumber"] = this.phoneNumber;
        data["isUSCitizen"] = this.isUSCitizen;
        data["pendingPasswordReset"] = this.pendingPasswordReset;
        return data; 
    }
}

export interface ISignUpMemberRequest {
    firstName: string;
    lastName: string;
    email: string;
    postalCode: string | undefined;
    phoneNumber: string | undefined;
    isUSCitizen: boolean;
    pendingPasswordReset: boolean | undefined;
}

export class TenantModel implements ITenantModel {
    id!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TenantModel {
        data = typeof data === 'object' ? data : {};
        let result = new TenantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITenantModel {
    id: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
}

export class SignUpMemberResponse implements ISignUpMemberResponse {
    authenticateResult!: AuthenticateResultModel | undefined;

    constructor(data?: ISignUpMemberResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticateResult = data["authenticateResult"] ? AuthenticateResultModel.fromJS(data["authenticateResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SignUpMemberResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpMemberResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticateResult"] = this.authenticateResult ? this.authenticateResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISignUpMemberResponse {
    authenticateResult: AuthenticateResultModel | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;
    autoDetectTenancy!: boolean | undefined;
    features!: string[] | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
    autoDetectTenancy: boolean | undefined;
    features: string[] | undefined;
}

export class SendPasswordResetCodeOutput implements ISendPasswordResetCodeOutput {
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: ISendPasswordResetCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendPasswordResetCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISendPasswordResetCodeOutput {
    detectedTenancies: TenantModel[] | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export enum ActivityType {
    Task = "Task", 
    Event = "Event", 
}

export class ActivityDto implements IActivityDto {
    id!: number | undefined;
    creatorUserId!: number | undefined;
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creatorUserId = data["creatorUserId"];
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): ActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserId"] = this.creatorUserId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IActivityDto {
    id: number | undefined;
    creatorUserId: number | undefined;
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class CreateActivityDto implements ICreateActivityDto {
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ICreateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateActivityDto {
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class UpdateActivityDto implements IUpdateActivityDto {
    id!: number;
    type!: ActivityType | undefined;
    title!: string;
    description!: string | undefined;
    assignedUserIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    stageId!: number | undefined;
    leadId!: number | undefined;
    contactId!: number | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.title = data["title"];
            this.description = data["description"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.stageId = data["stageId"];
            this.leadId = data["leadId"];
            this.contactId = data["contactId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["stageId"] = this.stageId;
        data["leadId"] = this.leadId;
        data["contactId"] = this.contactId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateActivityDto {
    id: number;
    type: ActivityType | undefined;
    title: string;
    description: string | undefined;
    assignedUserIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    stageId: number | undefined;
    leadId: number | undefined;
    contactId: number | undefined;
    sortOrder: number | undefined;
}

export class MoveActivityDto implements IMoveActivityDto {
    id!: number;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    allDay!: boolean | undefined;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: IMoveActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.allDay = data["allDay"];
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): MoveActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["allDay"] = this.allDay;
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface IMoveActivityDto {
    id: number;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    allDay: boolean | undefined;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class TransitionActivityDto implements ITransitionActivityDto {
    id!: number;
    stageId!: number;
    sortOrder!: number | undefined;

    constructor(data?: ITransitionActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): TransitionActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ITransitionActivityDto {
    id: number;
    stageId: number;
    sortOrder: number | undefined;
}

export class AssignActivityUserDto implements IAssignActivityUserDto {
    id!: number;
    assignedUserIds!: number[] | undefined;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: IAssignActivityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): AssignActivityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignActivityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface IAssignActivityUserDto {
    id: number;
    assignedUserIds: number[] | undefined;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class UserInfoDto implements IUserInfoDto {
    id!: number | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    profileThumbnailId!: string | undefined;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.profileThumbnailId = data["profileThumbnailId"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["profileThumbnailId"] = this.profileThumbnailId;
        return data; 
    }
}

export interface IUserInfoDto {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    profileThumbnailId: string | undefined;
}

export class ApiKeyInfo implements IApiKeyInfo {
    id!: number | undefined;
    name!: string | undefined;
    key!: string | undefined;
    expirationDate!: moment.Moment | undefined;
    creationTime!: moment.Moment | undefined;
    userId!: number | undefined;
    userName!: string | undefined;

    constructor(data?: IApiKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.key = data["key"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ApiKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["key"] = this.key;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IApiKeyInfo {
    id: number | undefined;
    name: string | undefined;
    key: string | undefined;
    expirationDate: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    userId: number | undefined;
    userName: string | undefined;
}

export class GenerateApiKeyInput implements IGenerateApiKeyInput {
    name!: string;
    expirationDate!: moment.Moment | undefined;

    constructor(data?: IGenerateApiKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateApiKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateApiKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGenerateApiKeyInput {
    name: string;
    expirationDate: moment.Moment | undefined;
}

export enum OfferProviderType {
    EPCVIP = "EPCVIP", 
}

export enum DIOSVertical {
    Undefined = "Undefined", 
    PersonalLoans = "PersonalLoans", 
    Beauty = "Beauty", 
    Auto = "Auto", 
    Legal = "Legal", 
    CreditRepair = "CreditRepair", 
    CreditScore = "CreditScore", 
    Travel = "Travel", 
    Jobs = "Jobs", 
    BusinessLoans = "BusinessLoans", 
    HybridLoans = "HybridLoans", 
    DebtConsolidation = "DebtConsolidation", 
    CreditCards = "CreditCards", 
    MerchantServices = "MerchantServices", 
    Dating = "Dating", 
    Crypto = "Crypto", 
    CreditMonitoring = "CreditMonitoring", 
}

export class TrackingInformation implements ITrackingInformation {
    campaignId!: number | undefined;
    applicantId!: string;
    applicationId!: string;
    applicationDate!: moment.Moment | undefined;
    subId!: string | undefined;
    affiliateId!: number;
    vertical!: DIOSVertical | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    clickId!: string | undefined;

    constructor(data?: ITrackingInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.applicationDate = data["applicationDate"] ? moment(data["applicationDate"].toString()) : <any>undefined;
            this.subId = data["subId"];
            this.affiliateId = data["affiliateId"];
            this.vertical = data["vertical"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.clickId = data["clickId"];
        }
    }

    static fromJS(data: any): TrackingInformation {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["applicationDate"] = this.applicationDate ? this.applicationDate.toISOString() : <any>undefined;
        data["subId"] = this.subId;
        data["affiliateId"] = this.affiliateId;
        data["vertical"] = this.vertical;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["clickId"] = this.clickId;
        return data; 
    }
}

export interface ITrackingInformation {
    campaignId: number | undefined;
    applicantId: string;
    applicationId: string;
    applicationDate: moment.Moment | undefined;
    subId: string | undefined;
    affiliateId: number;
    vertical: DIOSVertical | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    clickId: string | undefined;
}

export enum TimeOfDay {
    Morning = "Morning", 
    Afternoon = "Afternoon", 
    Evening = "Evening", 
    Anytime = "Anytime", 
}

export enum CreditScoreRating {
    NotSure = "NotSure", 
    Excellent = "Excellent", 
    Good = "Good", 
    Fair = "Fair", 
    Poor = "Poor", 
}

export enum Gender {
    Female = "Female", 
    Male = "Male", 
}

export class PersonalInformationExtended implements IPersonalInformationExtended {
    address2!: string | undefined;
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address2 = data["address2"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.middleName = data["middleName"];
            this.email = data["email"];
            this.alternateEmail = data["alternateEmail"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.licenseNumber = data["licenseNumber"];
            this.licenseState = data["licenseState"];
            this.isActiveMilitary = data["isActiveMilitary"];
            this.phone = data["phone"];
            this.phoneMobile = data["phoneMobile"];
            this.preferredContactTOD = data["preferredContactTOD"];
            this.address1 = data["address1"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.postalCode = data["postalCode"];
            this.countryCode = data["countryCode"];
            this.isHomeOwner = data["isHomeOwner"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.creditScoreRating = data["creditScoreRating"];
            this.gender = data["gender"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address2"] = this.address2;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data; 
    }
}

export interface IPersonalInformationExtended {
    address2: string | undefined;
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class DebtInformation implements IDebtInformation {
    debtAmount!: number | undefined;
    creditCardDebtAmount!: number | undefined;
    studentDebtAmount!: number | undefined;

    constructor(data?: IDebtInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.debtAmount = data["debtAmount"];
            this.creditCardDebtAmount = data["creditCardDebtAmount"];
            this.studentDebtAmount = data["studentDebtAmount"];
        }
    }

    static fromJS(data: any): DebtInformation {
        data = typeof data === 'object' ? data : {};
        let result = new DebtInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtAmount"] = this.debtAmount;
        data["creditCardDebtAmount"] = this.creditCardDebtAmount;
        data["studentDebtAmount"] = this.studentDebtAmount;
        return data; 
    }
}

export interface IDebtInformation {
    debtAmount: number | undefined;
    creditCardDebtAmount: number | undefined;
    studentDebtAmount: number | undefined;
}

export enum LoanReason {
    DebtConsolidation = "DebtConsolidation", 
    EmergencySituation = "EmergencySituation", 
    AutoRepairs = "AutoRepairs", 
    AutoPurchase = "AutoPurchase", 
    Moving = "Moving", 
    HomeImprovement = "HomeImprovement", 
    Medical = "Medical", 
    Business = "Business", 
    Vacation = "Vacation", 
    RentOrMortgage = "RentOrMortgage", 
    Wedding = "Wedding", 
    MajorPurchases = "MajorPurchases", 
    Other = "Other", 
    CreditCardDebtRelief = "CreditCardDebtRelief", 
    StudentLoanDebtRelief = "StudentLoanDebtRelief", 
}

export class LoanInformationExtended implements ILoanInformationExtended {
    approvedLoanAmount!: number | undefined;
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvedLoanAmount = data["approvedLoanAmount"];
            this.requestedLoanAmount = data["requestedLoanAmount"];
            this.loanReason = data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedLoanAmount"] = this.approvedLoanAmount;
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data; 
    }
}

export interface ILoanInformationExtended {
    approvedLoanAmount: number | undefined;
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export enum PayFrequency {
    Weekly = "Weekly", 
    BiWeekly = "BiWeekly", 
    Monthly = "Monthly", 
    SemiMonthly = "SemiMonthly", 
}

export enum IncomeType {
    Employed = "Employed", 
    Benefits = "Benefits", 
    SelfEmployed = "SelfEmployed", 
}

export class EmploymentInformationExtended implements IEmploymentInformationExtended {
    employerAddress2!: string | undefined;
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformationExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employerAddress2 = data["employerAddress2"];
            this.isEmployed = data["isEmployed"];
            this.employerName = data["employerName"];
            this.jobTitle = data["jobTitle"];
            this.monthsAtEmployer = data["monthsAtEmployer"];
            this.phoneWork = data["phoneWork"];
            this.phoneWorkExtension = data["phoneWorkExtension"];
            this.employerAddress1 = data["employerAddress1"];
            this.employerCity = data["employerCity"];
            this.employerStateCode = data["employerStateCode"];
            this.employerPostalCode = data["employerPostalCode"];
            this.netMonthlyIncome = data["netMonthlyIncome"];
            this.payFrequency = data["payFrequency"];
            this.payNextDate = data["payNextDate"] ? moment(data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = data["payAfterNextDate"] ? moment(data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformationExtended {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformationExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employerAddress2"] = this.employerAddress2;
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data; 
    }
}

export interface IEmploymentInformationExtended {
    employerAddress2: string | undefined;
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export enum BankAccountType {
    Checking = "Checking", 
    Savings = "Savings", 
}

export class BankInformation implements IBankInformation {
    bankAccountType!: BankAccountType | undefined;
    bankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankABA!: string | undefined;
    bankPhone!: string | undefined;
    isDirectDeposit!: boolean | undefined;
    monthsAtBank!: number | undefined;

    constructor(data?: IBankInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountType = data["bankAccountType"];
            this.bankName = data["bankName"];
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankABA = data["bankABA"];
            this.bankPhone = data["bankPhone"];
            this.isDirectDeposit = data["isDirectDeposit"];
            this.monthsAtBank = data["monthsAtBank"];
        }
    }

    static fromJS(data: any): BankInformation {
        data = typeof data === 'object' ? data : {};
        let result = new BankInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountType"] = this.bankAccountType;
        data["bankName"] = this.bankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankABA"] = this.bankABA;
        data["bankPhone"] = this.bankPhone;
        data["isDirectDeposit"] = this.isDirectDeposit;
        data["monthsAtBank"] = this.monthsAtBank;
        return data; 
    }
}

export interface IBankInformation {
    bankAccountType: BankAccountType | undefined;
    bankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankABA: string | undefined;
    bankPhone: string | undefined;
    isDirectDeposit: boolean | undefined;
    monthsAtBank: number | undefined;
}

export class LegalInformation implements ILegalInformation {
    isTCPAChecked!: boolean | undefined;

    constructor(data?: ILegalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isTCPAChecked = data["isTCPAChecked"];
        }
    }

    static fromJS(data: any): LegalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LegalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTCPAChecked"] = this.isTCPAChecked;
        return data; 
    }
}

export interface ILegalInformation {
    isTCPAChecked: boolean | undefined;
}

export class RegisterApplicantRequest implements IRegisterApplicantRequest {
    systemType!: OfferProviderType;
    testMode!: boolean | undefined;
    newUserPassword!: string | undefined;
    finalizeLeadUrl!: string | undefined;
    sendWelcomeEmail!: boolean | undefined;
    returnNewUserInfo!: boolean | undefined;
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformationExtended | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformationExtended | undefined;
    employmentInformation!: EmploymentInformationExtended | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IRegisterApplicantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.testMode = data["testMode"];
            this.newUserPassword = data["newUserPassword"];
            this.finalizeLeadUrl = data["finalizeLeadUrl"];
            this.sendWelcomeEmail = data["sendWelcomeEmail"];
            this.returnNewUserInfo = data["returnNewUserInfo"];
            this.trackingInformation = data["trackingInformation"] ? TrackingInformation.fromJS(data["trackingInformation"]) : <any>undefined;
            this.personalInformation = data["personalInformation"] ? PersonalInformationExtended.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformationExtended.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformationExtended.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["testMode"] = this.testMode;
        data["newUserPassword"] = this.newUserPassword;
        data["finalizeLeadUrl"] = this.finalizeLeadUrl;
        data["sendWelcomeEmail"] = this.sendWelcomeEmail;
        data["returnNewUserInfo"] = this.returnNewUserInfo;
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterApplicantRequest {
    systemType: OfferProviderType;
    testMode: boolean | undefined;
    newUserPassword: string | undefined;
    finalizeLeadUrl: string | undefined;
    sendWelcomeEmail: boolean | undefined;
    returnNewUserInfo: boolean | undefined;
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformationExtended | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformationExtended | undefined;
    employmentInformation: EmploymentInformationExtended | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class UserInfo implements IUserInfo {
    userName!: string | undefined;
    password!: string | undefined;
    loginUrl!: string | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.loginUrl = data["loginUrl"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["loginUrl"] = this.loginUrl;
        return data; 
    }
}

export interface IUserInfo {
    userName: string | undefined;
    password: string | undefined;
    loginUrl: string | undefined;
}

export class RegisterApplicantResponse implements IRegisterApplicantResponse {
    applicantUserId!: number | undefined;
    newUserInfo!: UserInfo | undefined;

    constructor(data?: IRegisterApplicantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicantUserId = data["applicantUserId"];
            this.newUserInfo = data["newUserInfo"] ? UserInfo.fromJS(data["newUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterApplicantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterApplicantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantUserId"] = this.applicantUserId;
        data["newUserInfo"] = this.newUserInfo ? this.newUserInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterApplicantResponse {
    applicantUserId: number | undefined;
    newUserInfo: UserInfo | undefined;
}

export class PersonalInformation implements IPersonalInformation {
    firstName!: string;
    lastName!: string;
    middleName!: string | undefined;
    email!: string;
    alternateEmail!: string | undefined;
    doB!: moment.Moment | undefined;
    ssn!: string | undefined;
    licenseNumber!: string | undefined;
    licenseState!: string | undefined;
    isActiveMilitary!: boolean | undefined;
    phone!: string | undefined;
    phoneMobile!: string | undefined;
    preferredContactTOD!: TimeOfDay | undefined;
    address1!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    postalCode!: string | undefined;
    countryCode!: string | undefined;
    isHomeOwner!: boolean | undefined;
    monthsAtAddress!: number | undefined;
    creditScoreRating!: CreditScoreRating | undefined;
    gender!: Gender | undefined;
    timezone!: string | undefined;

    constructor(data?: IPersonalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.middleName = data["middleName"];
            this.email = data["email"];
            this.alternateEmail = data["alternateEmail"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.licenseNumber = data["licenseNumber"];
            this.licenseState = data["licenseState"];
            this.isActiveMilitary = data["isActiveMilitary"];
            this.phone = data["phone"];
            this.phoneMobile = data["phoneMobile"];
            this.preferredContactTOD = data["preferredContactTOD"];
            this.address1 = data["address1"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.postalCode = data["postalCode"];
            this.countryCode = data["countryCode"];
            this.isHomeOwner = data["isHomeOwner"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.creditScoreRating = data["creditScoreRating"];
            this.gender = data["gender"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): PersonalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["middleName"] = this.middleName;
        data["email"] = this.email;
        data["alternateEmail"] = this.alternateEmail;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["licenseNumber"] = this.licenseNumber;
        data["licenseState"] = this.licenseState;
        data["isActiveMilitary"] = this.isActiveMilitary;
        data["phone"] = this.phone;
        data["phoneMobile"] = this.phoneMobile;
        data["preferredContactTOD"] = this.preferredContactTOD;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["postalCode"] = this.postalCode;
        data["countryCode"] = this.countryCode;
        data["isHomeOwner"] = this.isHomeOwner;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["creditScoreRating"] = this.creditScoreRating;
        data["gender"] = this.gender;
        data["timezone"] = this.timezone;
        return data; 
    }
}

export interface IPersonalInformation {
    firstName: string;
    lastName: string;
    middleName: string | undefined;
    email: string;
    alternateEmail: string | undefined;
    doB: moment.Moment | undefined;
    ssn: string | undefined;
    licenseNumber: string | undefined;
    licenseState: string | undefined;
    isActiveMilitary: boolean | undefined;
    phone: string | undefined;
    phoneMobile: string | undefined;
    preferredContactTOD: TimeOfDay | undefined;
    address1: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    postalCode: string | undefined;
    countryCode: string | undefined;
    isHomeOwner: boolean | undefined;
    monthsAtAddress: number | undefined;
    creditScoreRating: CreditScoreRating | undefined;
    gender: Gender | undefined;
    timezone: string | undefined;
}

export class LoanInformation implements ILoanInformation {
    requestedLoanAmount!: number | undefined;
    loanReason!: LoanReason | undefined;

    constructor(data?: ILoanInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestedLoanAmount = data["requestedLoanAmount"];
            this.loanReason = data["loanReason"];
        }
    }

    static fromJS(data: any): LoanInformation {
        data = typeof data === 'object' ? data : {};
        let result = new LoanInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedLoanAmount"] = this.requestedLoanAmount;
        data["loanReason"] = this.loanReason;
        return data; 
    }
}

export interface ILoanInformation {
    requestedLoanAmount: number | undefined;
    loanReason: LoanReason | undefined;
}

export class EmploymentInformation implements IEmploymentInformation {
    isEmployed!: boolean | undefined;
    employerName!: string | undefined;
    jobTitle!: string | undefined;
    monthsAtEmployer!: number | undefined;
    phoneWork!: string | undefined;
    phoneWorkExtension!: string | undefined;
    employerAddress1!: string | undefined;
    employerCity!: string | undefined;
    employerStateCode!: string | undefined;
    employerPostalCode!: string | undefined;
    netMonthlyIncome!: number | undefined;
    payFrequency!: PayFrequency | undefined;
    payNextDate!: moment.Moment | undefined;
    payAfterNextDate!: moment.Moment | undefined;
    incomeType!: IncomeType | undefined;

    constructor(data?: IEmploymentInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmployed = data["isEmployed"];
            this.employerName = data["employerName"];
            this.jobTitle = data["jobTitle"];
            this.monthsAtEmployer = data["monthsAtEmployer"];
            this.phoneWork = data["phoneWork"];
            this.phoneWorkExtension = data["phoneWorkExtension"];
            this.employerAddress1 = data["employerAddress1"];
            this.employerCity = data["employerCity"];
            this.employerStateCode = data["employerStateCode"];
            this.employerPostalCode = data["employerPostalCode"];
            this.netMonthlyIncome = data["netMonthlyIncome"];
            this.payFrequency = data["payFrequency"];
            this.payNextDate = data["payNextDate"] ? moment(data["payNextDate"].toString()) : <any>undefined;
            this.payAfterNextDate = data["payAfterNextDate"] ? moment(data["payAfterNextDate"].toString()) : <any>undefined;
            this.incomeType = data["incomeType"];
        }
    }

    static fromJS(data: any): EmploymentInformation {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmployed"] = this.isEmployed;
        data["employerName"] = this.employerName;
        data["jobTitle"] = this.jobTitle;
        data["monthsAtEmployer"] = this.monthsAtEmployer;
        data["phoneWork"] = this.phoneWork;
        data["phoneWorkExtension"] = this.phoneWorkExtension;
        data["employerAddress1"] = this.employerAddress1;
        data["employerCity"] = this.employerCity;
        data["employerStateCode"] = this.employerStateCode;
        data["employerPostalCode"] = this.employerPostalCode;
        data["netMonthlyIncome"] = this.netMonthlyIncome;
        data["payFrequency"] = this.payFrequency;
        data["payNextDate"] = this.payNextDate ? this.payNextDate.toISOString() : <any>undefined;
        data["payAfterNextDate"] = this.payAfterNextDate ? this.payAfterNextDate.toISOString() : <any>undefined;
        data["incomeType"] = this.incomeType;
        return data; 
    }
}

export interface IEmploymentInformation {
    isEmployed: boolean | undefined;
    employerName: string | undefined;
    jobTitle: string | undefined;
    monthsAtEmployer: number | undefined;
    phoneWork: string | undefined;
    phoneWorkExtension: string | undefined;
    employerAddress1: string | undefined;
    employerCity: string | undefined;
    employerStateCode: string | undefined;
    employerPostalCode: string | undefined;
    netMonthlyIncome: number | undefined;
    payFrequency: PayFrequency | undefined;
    payNextDate: moment.Moment | undefined;
    payAfterNextDate: moment.Moment | undefined;
    incomeType: IncomeType | undefined;
}

export class OfferApplicationDto implements IOfferApplicationDto {
    trackingInformation!: TrackingInformation | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IOfferApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trackingInformation = data["trackingInformation"] ? TrackingInformation.fromJS(data["trackingInformation"]) : <any>undefined;
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OfferApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trackingInformation"] = this.trackingInformation ? this.trackingInformation.toJSON() : <any>undefined;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOfferApplicationDto {
    trackingInformation: TrackingInformation | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuditLogListDtoPagedResultDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export class EntityChangeListDtoPagedResultDto implements IEntityChangeListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IEntityChangeListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityChangeListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityChangeListDtoPagedResultDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class BankAccountDto implements IBankAccountDto {
    id!: number | undefined;
    typeId!: string | undefined;
    typeName!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    businessEntityName!: string | undefined;
    businessEntityId!: number | undefined;
    isActive!: boolean | undefined;
    balance!: number | undefined;
    totalCreditLine!: number | undefined;
    availableBalance!: number | undefined;
    utilized!: number | undefined;
    syncAccountId!: number | undefined;
    isUsed!: boolean | undefined;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.businessEntityName = data["businessEntityName"];
            this.businessEntityId = data["businessEntityId"];
            this.isActive = data["isActive"];
            this.balance = data["balance"];
            this.totalCreditLine = data["totalCreditLine"];
            this.availableBalance = data["availableBalance"];
            this.utilized = data["utilized"];
            this.syncAccountId = data["syncAccountId"];
            this.isUsed = data["isUsed"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["businessEntityName"] = this.businessEntityName;
        data["businessEntityId"] = this.businessEntityId;
        data["isActive"] = this.isActive;
        data["balance"] = this.balance;
        data["totalCreditLine"] = this.totalCreditLine;
        data["availableBalance"] = this.availableBalance;
        data["utilized"] = this.utilized;
        data["syncAccountId"] = this.syncAccountId;
        data["isUsed"] = this.isUsed;
        return data; 
    }
}

export interface IBankAccountDto {
    id: number | undefined;
    typeId: string | undefined;
    typeName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    businessEntityName: string | undefined;
    businessEntityId: number | undefined;
    isActive: boolean | undefined;
    balance: number | undefined;
    totalCreditLine: number | undefined;
    availableBalance: number | undefined;
    utilized: number | undefined;
    syncAccountId: number | undefined;
    isUsed: boolean | undefined;
}

export enum SyncProgressStatus {
    InProgress = "InProgress", 
    ActionRequired = "ActionRequired", 
    SyncPending = "SyncPending", 
    Unavailable = "Unavailable", 
    Completed = "Completed", 
}

export class SyncAccountBankDto implements ISyncAccountBankDto {
    syncAccountId!: number | undefined;
    bankId!: number | undefined;
    name!: string | undefined;
    balance!: number | undefined;
    lastSyncDate!: moment.Moment | undefined;
    bankAccounts!: BankAccountDto[] | undefined;
    syncAccountStatus!: SyncProgressStatus | undefined;
    syncRef!: string | undefined;
    syncTypeId!: string | undefined;

    constructor(data?: ISyncAccountBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncAccountId = data["syncAccountId"];
            this.bankId = data["bankId"];
            this.name = data["name"];
            this.balance = data["balance"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountDto.fromJS(item));
            }
            this.syncAccountStatus = data["syncAccountStatus"];
            this.syncRef = data["syncRef"];
            this.syncTypeId = data["syncTypeId"];
        }
    }

    static fromJS(data: any): SyncAccountBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        data["bankId"] = this.bankId;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        data["syncAccountStatus"] = this.syncAccountStatus;
        data["syncRef"] = this.syncRef;
        data["syncTypeId"] = this.syncTypeId;
        return data; 
    }
}

export interface ISyncAccountBankDto {
    syncAccountId: number | undefined;
    bankId: number | undefined;
    name: string | undefined;
    balance: number | undefined;
    lastSyncDate: moment.Moment | undefined;
    bankAccounts: BankAccountDto[] | undefined;
    syncAccountStatus: SyncProgressStatus | undefined;
    syncRef: string | undefined;
    syncTypeId: string | undefined;
}

export enum GroupByPeriod {
    Daily = "Daily", 
    Weekly = "Weekly", 
    Monthly = "Monthly", 
    Quarterly = "Quarterly", 
    Yearly = "Yearly", 
}

export class BankAccountDailyStatDto implements IBankAccountDailyStatDto {
    date!: moment.Moment | undefined;
    startingBalance!: number | undefined;
    startingBalanceAdjustments!: number | undefined;
    inflows!: number | undefined;
    outflows!: number | undefined;
    adjustments!: number | undefined;
    endingBalance!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    averageDailyBalance!: number | undefined;
    creditCount!: number | undefined;
    debitCount!: number | undefined;
    period!: GroupByPeriod | undefined;
    isForecast!: boolean | undefined;

    constructor(data?: IBankAccountDailyStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startingBalance = data["startingBalance"];
            this.startingBalanceAdjustments = data["startingBalanceAdjustments"];
            this.inflows = data["inflows"];
            this.outflows = data["outflows"];
            this.adjustments = data["adjustments"];
            this.endingBalance = data["endingBalance"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.averageDailyBalance = data["averageDailyBalance"];
            this.creditCount = data["creditCount"];
            this.debitCount = data["debitCount"];
            this.period = data["period"];
            this.isForecast = data["isForecast"];
        }
    }

    static fromJS(data: any): BankAccountDailyStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDailyStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startingBalance"] = this.startingBalance;
        data["startingBalanceAdjustments"] = this.startingBalanceAdjustments;
        data["inflows"] = this.inflows;
        data["outflows"] = this.outflows;
        data["adjustments"] = this.adjustments;
        data["endingBalance"] = this.endingBalance;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["averageDailyBalance"] = this.averageDailyBalance;
        data["creditCount"] = this.creditCount;
        data["debitCount"] = this.debitCount;
        data["period"] = this.period;
        data["isForecast"] = this.isForecast;
        return data; 
    }
}

export interface IBankAccountDailyStatDto {
    date: moment.Moment | undefined;
    startingBalance: number | undefined;
    startingBalanceAdjustments: number | undefined;
    inflows: number | undefined;
    outflows: number | undefined;
    adjustments: number | undefined;
    endingBalance: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    averageDailyBalance: number | undefined;
    creditCount: number | undefined;
    debitCount: number | undefined;
    period: GroupByPeriod | undefined;
    isForecast: boolean | undefined;
}

export class DiscardDiscrepanciesInput implements IDiscardDiscrepanciesInput {
    bankIds!: number[] | undefined;
    bankAccountIds!: number[] | undefined;
    currencyId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;

    constructor(data?: IDiscardDiscrepanciesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankIds"] && data["bankIds"].constructor === Array) {
                this.bankIds = [];
                for (let item of data["bankIds"])
                    this.bankIds.push(item);
            }
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.currencyId = data["currencyId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DiscardDiscrepanciesInput {
        data = typeof data === 'object' ? data : {};
        let result = new DiscardDiscrepanciesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankIds && this.bankIds.constructor === Array) {
            data["bankIds"] = [];
            for (let item of this.bankIds)
                data["bankIds"].push(item);
        }
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["currencyId"] = this.currencyId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDiscardDiscrepanciesInput {
    bankIds: number[] | undefined;
    bankAccountIds: number[] | undefined;
    currencyId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
}

export class UpdateBankAccountDto implements IUpdateBankAccountDto {
    id!: number;
    name!: string | undefined;
    typeId!: string | undefined;
    isActive!: boolean;
    businessEntityId!: number | undefined;

    constructor(data?: IUpdateBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.typeId = data["typeId"];
            this.isActive = data["isActive"];
            this.businessEntityId = data["businessEntityId"];
        }
    }

    static fromJS(data: any): UpdateBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["isActive"] = this.isActive;
        data["businessEntityId"] = this.businessEntityId;
        return data; 
    }
}

export interface IUpdateBankAccountDto {
    id: number;
    name: string | undefined;
    typeId: string | undefined;
    isActive: boolean;
    businessEntityId: number | undefined;
}

export class BusinessEntityDto implements IBusinessEntityDto {
    id!: number | undefined;
    name!: string | undefined;
    isDefault!: boolean | undefined;
    parentId!: number | undefined;
    hasChildren!: boolean | undefined;

    constructor(data?: IBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            this.parentId = data["parentId"];
            this.hasChildren = data["hasChildren"];
        }
    }

    static fromJS(data: any): BusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["parentId"] = this.parentId;
        data["hasChildren"] = this.hasChildren;
        return data; 
    }
}

export interface IBusinessEntityDto {
    id: number | undefined;
    name: string | undefined;
    isDefault: boolean | undefined;
    parentId: number | undefined;
    hasChildren: boolean | undefined;
}

export class BusinessEntityTypeDto implements IBusinessEntityTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IBusinessEntityTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BusinessEntityTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBusinessEntityTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class BusinessEntityInfoDto implements IBusinessEntityInfoDto {
    name!: string | undefined;
    parentId!: number | undefined;
    industry!: string | undefined;
    typeId!: string | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    statusId!: string | undefined;
    isDefault!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IBusinessEntityInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.typeId = data["typeId"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.address = data["address"];
            this.statusId = data["statusId"];
            this.isDefault = data["isDefault"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BusinessEntityInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["typeId"] = this.typeId;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["address"] = this.address;
        data["statusId"] = this.statusId;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessEntityInfoDto {
    name: string | undefined;
    parentId: number | undefined;
    industry: string | undefined;
    typeId: string | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    address: string | undefined;
    statusId: string | undefined;
    isDefault: boolean | undefined;
    id: number | undefined;
}

export class CreateBusinessEntityDto implements ICreateBusinessEntityDto {
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    typeId!: string | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: ICreateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.typeId = data["typeId"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.address = data["address"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): CreateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["typeId"] = this.typeId;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateBusinessEntityDto {
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    typeId: string | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    address: string | undefined;
    isDefault: boolean | undefined;
}

export class UpdateBusinessEntityDto implements IUpdateBusinessEntityDto {
    id!: number;
    statusId!: string | undefined;
    name!: string;
    parentId!: number | undefined;
    industry!: string | undefined;
    typeId!: string | undefined;
    taxNumber!: string | undefined;
    dateOpened!: moment.Moment | undefined;
    website!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    alternativeEmail!: string | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    address!: string | undefined;
    isDefault!: boolean | undefined;

    constructor(data?: IUpdateBusinessEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusId = data["statusId"];
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.industry = data["industry"];
            this.typeId = data["typeId"];
            this.taxNumber = data["taxNumber"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.website = data["website"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.email = data["email"];
            this.alternativeEmail = data["alternativeEmail"];
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.address = data["address"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateBusinessEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBusinessEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusId"] = this.statusId;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["industry"] = this.industry;
        data["typeId"] = this.typeId;
        data["taxNumber"] = this.taxNumber;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["alternativeEmail"] = this.alternativeEmail;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["address"] = this.address;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateBusinessEntityDto {
    id: number;
    statusId: string | undefined;
    name: string;
    parentId: number | undefined;
    industry: string | undefined;
    typeId: string | undefined;
    taxNumber: string | undefined;
    dateOpened: moment.Moment | undefined;
    website: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    alternativeEmail: string | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    address: string | undefined;
    isDefault: boolean | undefined;
}

export class BusinessEntityBankAccountDto implements IBusinessEntityBankAccountDto {
    bankAccountId!: number | undefined;
    bankName!: string | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    isLinked!: boolean | undefined;
    isUsed!: boolean | undefined;

    constructor(data?: IBusinessEntityBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.bankName = data["bankName"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.isLinked = data["isLinked"];
            this.isUsed = data["isUsed"];
        }
    }

    static fromJS(data: any): BusinessEntityBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["bankName"] = this.bankName;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["isLinked"] = this.isLinked;
        data["isUsed"] = this.isUsed;
        return data; 
    }
}

export interface IBusinessEntityBankAccountDto {
    bankAccountId: number | undefined;
    bankName: string | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    isLinked: boolean | undefined;
    isUsed: boolean | undefined;
}

export class BusinessEntityUpdateBankAccountsInput implements IBusinessEntityUpdateBankAccountsInput {
    businessEntityId!: number;
    bankAccountIds!: number[];
    isLinked!: boolean;

    constructor(data?: IBusinessEntityUpdateBankAccountsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bankAccountIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.businessEntityId = data["businessEntityId"];
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.isLinked = data["isLinked"];
        }
    }

    static fromJS(data: any): BusinessEntityUpdateBankAccountsInput {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessEntityUpdateBankAccountsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessEntityId"] = this.businessEntityId;
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["isLinked"] = this.isLinked;
        return data; 
    }
}

export interface IBusinessEntityUpdateBankAccountsInput {
    businessEntityId: number;
    bankAccountIds: number[];
    isLinked: boolean;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class CacheDtoListResultDto implements ICacheDtoListResultDto {
    items!: CacheDto[] | undefined;

    constructor(data?: ICacheDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CacheDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICacheDtoListResultDto {
    items: CacheDto[] | undefined;
}

export class StringEntityDto implements IStringEntityDto {
    id!: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IStringEntityDto {
    id: string | undefined;
}

export class Period implements IPeriod {
    start!: moment.Moment | undefined;
    end!: moment.Moment | undefined;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.start = data["start"] ? moment(data["start"].toString()) : <any>undefined;
            this.end = data["end"] ? moment(data["end"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPeriod {
    start: moment.Moment | undefined;
    end: moment.Moment | undefined;
}

export class StatsFilter implements IStatsFilter {
    forecastModelId!: number | undefined;
    showResolvedComments!: boolean | undefined;
    groupByPeriod!: GroupByPeriod | undefined;
    dailyPeriods!: Period[] | undefined;
    calculateStartingBalance!: boolean | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.showResolvedComments = false;
            this.calculateStartingBalance = true;
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.showResolvedComments = data["showResolvedComments"] !== undefined ? data["showResolvedComments"] : false;
            this.groupByPeriod = data["groupByPeriod"];
            if (data["dailyPeriods"] && data["dailyPeriods"].constructor === Array) {
                this.dailyPeriods = [];
                for (let item of data["dailyPeriods"])
                    this.dailyPeriods.push(Period.fromJS(item));
            }
            this.calculateStartingBalance = data["calculateStartingBalance"] !== undefined ? data["calculateStartingBalance"] : true;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["showResolvedComments"] = this.showResolvedComments;
        data["groupByPeriod"] = this.groupByPeriod;
        if (this.dailyPeriods && this.dailyPeriods.constructor === Array) {
            data["dailyPeriods"] = [];
            for (let item of this.dailyPeriods)
                data["dailyPeriods"].push(item.toJSON());
        }
        data["calculateStartingBalance"] = this.calculateStartingBalance;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsFilter {
    forecastModelId: number | undefined;
    showResolvedComments: boolean | undefined;
    groupByPeriod: GroupByPeriod | undefined;
    dailyPeriods: Period[] | undefined;
    calculateStartingBalance: boolean | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export enum AdjustmentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export class TransactionStatsDto implements ITransactionStatsDto {
    adjustmentType!: AdjustmentType | undefined;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    subCategoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    accountId!: number | undefined;
    currencyId!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;
    count!: number | undefined;
    comment!: string | undefined;
    forecastId!: number | undefined;

    constructor(data?: ITransactionStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adjustmentType = data["adjustmentType"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            this.currencyId = data["currencyId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.count = data["count"];
            this.comment = data["comment"];
            this.forecastId = data["forecastId"];
        }
    }

    static fromJS(data: any): TransactionStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        data["currencyId"] = this.currencyId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["count"] = this.count;
        data["comment"] = this.comment;
        data["forecastId"] = this.forecastId;
        return data; 
    }
}

export interface ITransactionStatsDto {
    adjustmentType: AdjustmentType | undefined;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    subCategoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number | undefined;
    currencyId: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
    count: number | undefined;
    comment: string | undefined;
    forecastId: number | undefined;
}

export class CashFlowCommentThreadDto implements ICashFlowCommentThreadDto {
    threadId!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    cashFlowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    subCategoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    accountId!: number | undefined;
    categorization!: { [key: string] : string; } | undefined;

    constructor(data?: ICashFlowCommentThreadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.accountId = data["accountId"];
            if (data["categorization"]) {
                this.categorization = {};
                for (let key in data["categorization"]) {
                    if (data["categorization"].hasOwnProperty(key))
                        this.categorization[key] = data["categorization"][key];
                }
            }
        }
    }

    static fromJS(data: any): CashFlowCommentThreadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowCommentThreadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["accountId"] = this.accountId;
        if (this.categorization) {
            data["categorization"] = {};
            for (let key in this.categorization) {
                if (this.categorization.hasOwnProperty(key))
                    data["categorization"][key] = this.categorization[key];
            }
        }
        return data; 
    }
}

export interface ICashFlowCommentThreadDto {
    threadId: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    cashFlowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    subCategoryId: number | undefined;
    transactionDescriptor: string | undefined;
    accountId: number | undefined;
    categorization: { [key: string] : string; } | undefined;
}

export class CashFlowStatsDto implements ICashFlowStatsDto {
    transactionStats!: TransactionStatsDto[] | undefined;
    commentThreads!: CashFlowCommentThreadDto[] | undefined;

    constructor(data?: ICashFlowStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionStats"] && data["transactionStats"].constructor === Array) {
                this.transactionStats = [];
                for (let item of data["transactionStats"])
                    this.transactionStats.push(TransactionStatsDto.fromJS(item));
            }
            if (data["commentThreads"] && data["commentThreads"].constructor === Array) {
                this.commentThreads = [];
                for (let item of data["commentThreads"])
                    this.commentThreads.push(CashFlowCommentThreadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionStats && this.transactionStats.constructor === Array) {
            data["transactionStats"] = [];
            for (let item of this.transactionStats)
                data["transactionStats"].push(item.toJSON());
        }
        if (this.commentThreads && this.commentThreads.constructor === Array) {
            data["commentThreads"] = [];
            for (let item of this.commentThreads)
                data["commentThreads"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowStatsDto {
    transactionStats: TransactionStatsDto[] | undefined;
    commentThreads: CashFlowCommentThreadDto[] | undefined;
}

export class BankDto implements IBankDto {
    id!: number | undefined;
    name!: string | undefined;
    bankAccounts!: BankAccountDto[] | undefined;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["bankAccounts"] && data["bankAccounts"].constructor === Array) {
                this.bankAccounts = [];
                for (let item of data["bankAccounts"])
                    this.bankAccounts.push(BankAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.bankAccounts && this.bankAccounts.constructor === Array) {
            data["bankAccounts"] = [];
            for (let item of this.bankAccounts)
                data["bankAccounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBankDto {
    id: number | undefined;
    name: string | undefined;
    bankAccounts: BankAccountDto[] | undefined;
}

export class BankAccountBalanceDto implements IBankAccountBalanceDto {
    bankAccountId!: number | undefined;
    currencyId!: string | undefined;
    balance!: number | undefined;
    balanceDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IBankAccountBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.currencyId = data["currencyId"];
            this.balance = data["balance"];
            this.balanceDate = data["balanceDate"] ? moment(data["balanceDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): BankAccountBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["currencyId"] = this.currencyId;
        data["balance"] = this.balance;
        data["balanceDate"] = this.balanceDate ? this.balanceDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IBankAccountBalanceDto {
    bankAccountId: number | undefined;
    currencyId: string | undefined;
    balance: number | undefined;
    balanceDate: moment.Moment | undefined;
    isActive: boolean | undefined;
}

export class CashFlowInitialData implements ICashFlowInitialData {
    banks!: BankDto[] | undefined;
    businessEntities!: BusinessEntityDto[] | undefined;
    cashflowTypes!: { [key: string] : string; } | undefined;
    bankAccountBalances!: BankAccountBalanceDto[] | undefined;

    constructor(data?: ICashFlowInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(BusinessEntityDto.fromJS(item));
            }
            if (data["cashflowTypes"]) {
                this.cashflowTypes = {};
                for (let key in data["cashflowTypes"]) {
                    if (data["cashflowTypes"].hasOwnProperty(key))
                        this.cashflowTypes[key] = data["cashflowTypes"][key];
                }
            }
            if (data["bankAccountBalances"] && data["bankAccountBalances"].constructor === Array) {
                this.bankAccountBalances = [];
                for (let item of data["bankAccountBalances"])
                    this.bankAccountBalances.push(BankAccountBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CashFlowInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        if (this.cashflowTypes) {
            data["cashflowTypes"] = {};
            for (let key in this.cashflowTypes) {
                if (this.cashflowTypes.hasOwnProperty(key))
                    data["cashflowTypes"][key] = this.cashflowTypes[key];
            }
        }
        if (this.bankAccountBalances && this.bankAccountBalances.constructor === Array) {
            data["bankAccountBalances"] = [];
            for (let item of this.bankAccountBalances)
                data["bankAccountBalances"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICashFlowInitialData {
    banks: BankDto[] | undefined;
    businessEntities: BusinessEntityDto[] | undefined;
    cashflowTypes: { [key: string] : string; } | undefined;
    bankAccountBalances: BankAccountBalanceDto[] | undefined;
}

export enum SectionGroup {
    Income = "Income", 
    CostOfSales = "CostOfSales", 
    Expense = "Expense", 
    OtherIncomeExpense = "OtherIncomeExpense", 
}

export class StatsDetailFilter implements IStatsDetailFilter {
    searchTerm!: string | undefined;
    forecastModelId!: number | undefined;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    subCategoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchTerm = data["searchTerm"];
            this.forecastModelId = data["forecastModelId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilter {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchTerm"] = this.searchTerm;
        data["forecastModelId"] = this.forecastModelId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilter {
    searchTerm: string | undefined;
    forecastModelId: number | undefined;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    subCategoryId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export enum Status {
    Historical = "Historical", 
    Partial = "Partial", 
    Projected = "Projected", 
    Completed = "Completed", 
}

export enum StatsType {
    Transaction = "Transaction", 
    Adjustment = "Adjustment", 
    Forecast = "Forecast", 
}

export class CashFlowStatsDetailDto implements ICashFlowStatsDetailDto {
    id!: number | undefined;
    date!: moment.Moment | undefined;
    businessEntityName!: string | undefined;
    cashflowTypeId!: string | undefined;
    categoryId!: number | undefined;
    categoryName!: string | undefined;
    descriptor!: string | undefined;
    isDescriptorCalculated!: boolean | undefined;
    bankName!: string | undefined;
    accountId!: number | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    currencyId!: string | undefined;
    credit!: number | undefined;
    debit!: number | undefined;
    amount!: number | undefined;
    description!: string | undefined;
    comment!: string | undefined;
    commentThreadId!: number | undefined;
    forecastId!: number | undefined;
    forecastDate!: moment.Moment | undefined;
    status!: Status | undefined;
    counterpartyName!: string | undefined;
    type!: StatsType | undefined;

    constructor(data?: ICashFlowStatsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.businessEntityName = data["businessEntityName"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.descriptor = data["descriptor"];
            this.isDescriptorCalculated = data["isDescriptorCalculated"];
            this.bankName = data["bankName"];
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.currencyId = data["currencyId"];
            this.credit = data["credit"];
            this.debit = data["debit"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.comment = data["comment"];
            this.commentThreadId = data["commentThreadId"];
            this.forecastId = data["forecastId"];
            this.forecastDate = data["forecastDate"] ? moment(data["forecastDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.counterpartyName = data["counterpartyName"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): CashFlowStatsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowStatsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["businessEntityName"] = this.businessEntityName;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["descriptor"] = this.descriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["bankName"] = this.bankName;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["currencyId"] = this.currencyId;
        data["credit"] = this.credit;
        data["debit"] = this.debit;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["comment"] = this.comment;
        data["commentThreadId"] = this.commentThreadId;
        data["forecastId"] = this.forecastId;
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["counterpartyName"] = this.counterpartyName;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICashFlowStatsDetailDto {
    id: number | undefined;
    date: moment.Moment | undefined;
    businessEntityName: string | undefined;
    cashflowTypeId: string | undefined;
    categoryId: number | undefined;
    categoryName: string | undefined;
    descriptor: string | undefined;
    isDescriptorCalculated: boolean | undefined;
    bankName: string | undefined;
    accountId: number | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    currencyId: string | undefined;
    credit: number | undefined;
    debit: number | undefined;
    amount: number | undefined;
    description: string | undefined;
    comment: string | undefined;
    commentThreadId: number | undefined;
    forecastId: number | undefined;
    forecastDate: moment.Moment | undefined;
    status: Status | undefined;
    counterpartyName: string | undefined;
    type: StatsType | undefined;
}

export enum PeriodScope {
    Days = "Days", 
    Weeks = "Weeks", 
    Months = "Months", 
    Quarters = "Quarters", 
    Years = "Years", 
    None = "None", 
}

export enum MonthPeriodScope {
    Days = "Days", 
    Weeks = "Weeks", 
}

export class CashflowGridGeneralSettingsDto implements ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals!: number;
    hideZeroValuesInCells!: number;
    showNegativeValuesInRed!: number;
    showColumnsWithZeroActivity!: PeriodScope;
    showNetChangeRow!: boolean;
    showBalanceDiscrepancy!: boolean;
    splitMonthType!: MonthPeriodScope;

    constructor(data?: ICashflowGridGeneralSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.showAmountsWithDecimals = data["showAmountsWithDecimals"];
            this.hideZeroValuesInCells = data["hideZeroValuesInCells"];
            this.showNegativeValuesInRed = data["showNegativeValuesInRed"];
            this.showColumnsWithZeroActivity = data["showColumnsWithZeroActivity"];
            this.showNetChangeRow = data["showNetChangeRow"];
            this.showBalanceDiscrepancy = data["showBalanceDiscrepancy"];
            this.splitMonthType = data["splitMonthType"];
        }
    }

    static fromJS(data: any): CashflowGridGeneralSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridGeneralSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAmountsWithDecimals"] = this.showAmountsWithDecimals;
        data["hideZeroValuesInCells"] = this.hideZeroValuesInCells;
        data["showNegativeValuesInRed"] = this.showNegativeValuesInRed;
        data["showColumnsWithZeroActivity"] = this.showColumnsWithZeroActivity;
        data["showNetChangeRow"] = this.showNetChangeRow;
        data["showBalanceDiscrepancy"] = this.showBalanceDiscrepancy;
        data["splitMonthType"] = this.splitMonthType;
        return data; 
    }
}

export interface ICashflowGridGeneralSettingsDto {
    showAmountsWithDecimals: number;
    hideZeroValuesInCells: number;
    showNegativeValuesInRed: number;
    showColumnsWithZeroActivity: PeriodScope;
    showNetChangeRow: boolean;
    showBalanceDiscrepancy: boolean;
    splitMonthType: MonthPeriodScope;
}

export class CashflowGridVisualSettingsDto implements ICashflowGridVisualSettingsDto {
    fontName!: string;
    fontSize!: string;
    cfoTheme!: string;
    showFooterBar!: boolean;

    constructor(data?: ICashflowGridVisualSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fontName = data["fontName"];
            this.fontSize = data["fontSize"];
            this.cfoTheme = data["cfoTheme"];
            this.showFooterBar = data["showFooterBar"];
        }
    }

    static fromJS(data: any): CashflowGridVisualSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashflowGridVisualSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fontName"] = this.fontName;
        data["fontSize"] = this.fontSize;
        data["cfoTheme"] = this.cfoTheme;
        data["showFooterBar"] = this.showFooterBar;
        return data; 
    }
}

export interface ICashflowGridVisualSettingsDto {
    fontName: string;
    fontSize: string;
    cfoTheme: string;
    showFooterBar: boolean;
}

export class LocalizationAndCurrencyDto implements ILocalizationAndCurrencyDto {
    numberFormatting!: string;
    currency!: string;

    constructor(data?: ILocalizationAndCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.numberFormatting = data["numberFormatting"];
            this.currency = data["currency"];
        }
    }

    static fromJS(data: any): LocalizationAndCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationAndCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberFormatting"] = this.numberFormatting;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface ILocalizationAndCurrencyDto {
    numberFormatting: string;
    currency: string;
}

export class CashFlowGridSettingsDto implements ICashFlowGridSettingsDto {
    general!: CashflowGridGeneralSettingsDto;
    visualPreferences!: CashflowGridVisualSettingsDto;
    localizationAndCurrency!: LocalizationAndCurrencyDto;

    constructor(data?: ICashFlowGridSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new CashflowGridGeneralSettingsDto();
            this.visualPreferences = new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = new LocalizationAndCurrencyDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? CashflowGridGeneralSettingsDto.fromJS(data["general"]) : new CashflowGridGeneralSettingsDto();
            this.visualPreferences = data["visualPreferences"] ? CashflowGridVisualSettingsDto.fromJS(data["visualPreferences"]) : new CashflowGridVisualSettingsDto();
            this.localizationAndCurrency = data["localizationAndCurrency"] ? LocalizationAndCurrencyDto.fromJS(data["localizationAndCurrency"]) : new LocalizationAndCurrencyDto();
        }
    }

    static fromJS(data: any): CashFlowGridSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowGridSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["visualPreferences"] = this.visualPreferences ? this.visualPreferences.toJSON() : <any>undefined;
        data["localizationAndCurrency"] = this.localizationAndCurrency ? this.localizationAndCurrency.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICashFlowGridSettingsDto {
    general: CashflowGridGeneralSettingsDto;
    visualPreferences: CashflowGridVisualSettingsDto;
    localizationAndCurrency: LocalizationAndCurrencyDto;
}

export class ForecastModelDto implements IForecastModelDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IForecastModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ForecastModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IForecastModelDto {
    id: number | undefined;
    name: string | undefined;
}

export class AddForecastInput implements IAddForecastInput {
    forecastModelId!: number;
    bankAccountId!: number;
    date!: moment.Moment;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    cashFlowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    currencyId!: string;
    amount!: number;
    description!: string | undefined;

    constructor(data?: IAddForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastModelId = data["forecastModelId"];
            this.bankAccountId = data["bankAccountId"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.currencyId = data["currencyId"];
            this.amount = data["amount"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): AddForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastModelId"] = this.forecastModelId;
        data["bankAccountId"] = this.bankAccountId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data; 
    }
}

export interface IAddForecastInput {
    forecastModelId: number;
    bankAccountId: number;
    date: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    cashFlowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    currencyId: string;
    amount: number;
    description: string | undefined;
}

export enum ImportForecastInputType {
    Inflows = "Inflows", 
    Outflows = "Outflows", 
}

export class ImportForecastInput implements IImportForecastInput {
    forecastDate!: moment.Moment;
    entity!: string;
    type!: ImportForecastInputType;
    categoryCoAId!: string | undefined;
    descriptor!: string | undefined;
    description!: string | undefined;
    model!: string | undefined;
    currencyId!: string;
    amount!: number;
    cashFlowTypeId!: string | undefined;

    constructor(data?: IImportForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.forecastDate = data["forecastDate"] ? moment(data["forecastDate"].toString()) : <any>undefined;
            this.entity = data["entity"];
            this.type = data["type"];
            this.categoryCoAId = data["categoryCoAId"];
            this.descriptor = data["descriptor"];
            this.description = data["description"];
            this.model = data["model"];
            this.currencyId = data["currencyId"];
            this.amount = data["amount"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
        }
    }

    static fromJS(data: any): ImportForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forecastDate"] = this.forecastDate ? this.forecastDate.toISOString() : <any>undefined;
        data["entity"] = this.entity;
        data["type"] = this.type;
        data["categoryCoAId"] = this.categoryCoAId;
        data["descriptor"] = this.descriptor;
        data["description"] = this.description;
        data["model"] = this.model;
        data["currencyId"] = this.currencyId;
        data["amount"] = this.amount;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        return data; 
    }
}

export interface IImportForecastInput {
    forecastDate: moment.Moment;
    entity: string;
    type: ImportForecastInputType;
    categoryCoAId: string | undefined;
    descriptor: string | undefined;
    description: string | undefined;
    model: string | undefined;
    currencyId: string;
    amount: number;
    cashFlowTypeId: string | undefined;
}

export class CreateForecastsInput implements ICreateForecastsInput {
    forecasts!: AddForecastInput[];

    constructor(data?: ICreateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["forecasts"] && data["forecasts"].constructor === Array) {
                this.forecasts = [];
                for (let item of data["forecasts"])
                    this.forecasts.push(AddForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.forecasts && this.forecasts.constructor === Array) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateForecastsInput {
    forecasts: AddForecastInput[];
}

export class UpdateForecastInput implements IUpdateForecastInput {
    id!: number;
    date!: moment.Moment | undefined;
    amount!: number | undefined;
    bankAccountId!: number | undefined;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    description!: string | undefined;
    transactionDescriptor!: string | undefined;

    constructor(data?: IUpdateForecastInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.transactionDescriptor = data["transactionDescriptor"];
        }
    }

    static fromJS(data: any): UpdateForecastInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["transactionDescriptor"] = this.transactionDescriptor;
        return data; 
    }
}

export interface IUpdateForecastInput {
    id: number;
    date: moment.Moment | undefined;
    amount: number | undefined;
    bankAccountId: number | undefined;
    cashflowTypeId: string;
    categoryId: number | undefined;
    description: string | undefined;
    transactionDescriptor: string | undefined;
}

export class UpdateForecastsInput implements IUpdateForecastsInput {
    forecasts!: UpdateForecastInput[];

    constructor(data?: IUpdateForecastsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecasts = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["forecasts"] && data["forecasts"].constructor === Array) {
                this.forecasts = [];
                for (let item of data["forecasts"])
                    this.forecasts.push(UpdateForecastInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateForecastsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.forecasts && this.forecasts.constructor === Array) {
            data["forecasts"] = [];
            for (let item of this.forecasts)
                data["forecasts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateForecastsInput {
    forecasts: UpdateForecastInput[];
}

export enum WeekDay {
    Sunday = "Sunday", 
    Monday = "Monday", 
    Tuesday = "Tuesday", 
    Wednesday = "Wednesday", 
    Thursday = "Thursday", 
    Friday = "Friday", 
    Saturday = "Saturday", 
}

export class CreateForecastScheduleDto implements ICreateForecastScheduleDto {
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: ICreateForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): CreateForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface ICreateForecastScheduleDto {
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class UpdateForecastScheduleInput implements IUpdateForecastScheduleInput {
    id!: number;
    bankAccountId!: number;
    cashflowTypeId!: string;
    categoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    forecastModelIds!: number[];
    startDate!: moment.Moment;
    frequencyId!: string;
    currencyId!: string;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IUpdateForecastScheduleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.forecastModelIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.currencyId = data["currencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): UpdateForecastScheduleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForecastScheduleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["currencyId"] = this.currencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IUpdateForecastScheduleInput {
    id: number;
    bankAccountId: number;
    cashflowTypeId: string;
    categoryId: number | undefined;
    transactionDescriptor: string | undefined;
    forecastModelIds: number[];
    startDate: moment.Moment;
    frequencyId: string;
    currencyId: string;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class ForecastScheduleDto implements IForecastScheduleDto {
    id!: number | undefined;
    bankAccountId!: number | undefined;
    categoryId!: number | undefined;
    forecastModelIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    frequencyId!: string | undefined;
    endDate!: moment.Moment | undefined;
    calculationTypeId!: string | undefined;
    amount!: number | undefined;
    monthNumber!: number | undefined;
    weekNumber!: number | undefined;
    dayNumber!: number | undefined;
    weekDayNumber!: WeekDay | undefined;

    constructor(data?: IForecastScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountId = data["bankAccountId"];
            this.categoryId = data["categoryId"];
            if (data["forecastModelIds"] && data["forecastModelIds"].constructor === Array) {
                this.forecastModelIds = [];
                for (let item of data["forecastModelIds"])
                    this.forecastModelIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.frequencyId = data["frequencyId"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.calculationTypeId = data["calculationTypeId"];
            this.amount = data["amount"];
            this.monthNumber = data["monthNumber"];
            this.weekNumber = data["weekNumber"];
            this.dayNumber = data["dayNumber"];
            this.weekDayNumber = data["weekDayNumber"];
        }
    }

    static fromJS(data: any): ForecastScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForecastScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountId"] = this.bankAccountId;
        data["categoryId"] = this.categoryId;
        if (this.forecastModelIds && this.forecastModelIds.constructor === Array) {
            data["forecastModelIds"] = [];
            for (let item of this.forecastModelIds)
                data["forecastModelIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["frequencyId"] = this.frequencyId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["calculationTypeId"] = this.calculationTypeId;
        data["amount"] = this.amount;
        data["monthNumber"] = this.monthNumber;
        data["weekNumber"] = this.weekNumber;
        data["dayNumber"] = this.dayNumber;
        data["weekDayNumber"] = this.weekDayNumber;
        return data; 
    }
}

export interface IForecastScheduleDto {
    id: number | undefined;
    bankAccountId: number | undefined;
    categoryId: number | undefined;
    forecastModelIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    frequencyId: string | undefined;
    endDate: moment.Moment | undefined;
    calculationTypeId: string | undefined;
    amount: number | undefined;
    monthNumber: number | undefined;
    weekNumber: number | undefined;
    dayNumber: number | undefined;
    weekDayNumber: WeekDay | undefined;
}

export class CreateForecastModelInput implements ICreateForecastModelInput {
    name!: string;

    constructor(data?: ICreateForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateForecastModelInput {
    name: string;
}

export class RenameForecastModelInput implements IRenameForecastModelInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameForecastModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): RenameForecastModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameForecastModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IRenameForecastModelInput {
    id: number;
    newName: string;
}

export class TypeDto implements ITypeDto {
    name!: string | undefined;

    constructor(data?: ITypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ITypeDto {
    name: string | undefined;
}

export class AccountingTypeDto implements IAccountingTypeDto {
    typeId!: string | undefined;
    name!: string | undefined;
    isSystem!: boolean | undefined;

    constructor(data?: IAccountingTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.name = data["name"];
            this.isSystem = data["isSystem"];
        }
    }

    static fromJS(data: any): AccountingTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["name"] = this.name;
        data["isSystem"] = this.isSystem;
        return data; 
    }
}

export interface IAccountingTypeDto {
    typeId: string | undefined;
    name: string | undefined;
    isSystem: boolean | undefined;
}

export class CategoryDto implements ICategoryDto {
    accountingTypeId!: number | undefined;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string | undefined;
    isActive!: boolean | undefined;
    reportingCategoryId!: number | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.coAID = data["coAID"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.reportingCategoryId = data["reportingCategoryId"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["reportingCategoryId"] = this.reportingCategoryId;
        return data; 
    }
}

export interface ICategoryDto {
    accountingTypeId: number | undefined;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    reportingCategoryId: number | undefined;
}

export class GetCategoryTreeOutput implements IGetCategoryTreeOutput {
    types!: { [key: string] : TypeDto; } | undefined;
    accountingTypes!: { [key: string] : AccountingTypeDto; } | undefined;
    categories!: { [key: string] : CategoryDto; } | undefined;

    constructor(data?: IGetCategoryTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"]) {
                this.types = {};
                for (let key in data["types"]) {
                    if (data["types"].hasOwnProperty(key))
                        this.types[key] = data["types"][key] ? TypeDto.fromJS(data["types"][key]) : new TypeDto();
                }
            }
            if (data["accountingTypes"]) {
                this.accountingTypes = {};
                for (let key in data["accountingTypes"]) {
                    if (data["accountingTypes"].hasOwnProperty(key))
                        this.accountingTypes[key] = data["accountingTypes"][key] ? AccountingTypeDto.fromJS(data["accountingTypes"][key]) : new AccountingTypeDto();
                }
            }
            if (data["categories"]) {
                this.categories = {};
                for (let key in data["categories"]) {
                    if (data["categories"].hasOwnProperty(key))
                        this.categories[key] = data["categories"][key] ? CategoryDto.fromJS(data["categories"][key]) : new CategoryDto();
                }
            }
        }
    }

    static fromJS(data: any): GetCategoryTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    data["types"][key] = this.types[key];
            }
        }
        if (this.accountingTypes) {
            data["accountingTypes"] = {};
            for (let key in this.accountingTypes) {
                if (this.accountingTypes.hasOwnProperty(key))
                    data["accountingTypes"][key] = this.accountingTypes[key];
            }
        }
        if (this.categories) {
            data["categories"] = {};
            for (let key in this.categories) {
                if (this.categories.hasOwnProperty(key))
                    data["categories"][key] = this.categories[key];
            }
        }
        return data; 
    }
}

export interface IGetCategoryTreeOutput {
    types: { [key: string] : TypeDto; } | undefined;
    accountingTypes: { [key: string] : AccountingTypeDto; } | undefined;
    categories: { [key: string] : CategoryDto; } | undefined;
}

export enum ReportTemplate {
    Personal = "Personal", 
}

export class ReportSectionDto implements IReportSectionDto {
    group!: SectionGroup | undefined;
    name!: string | undefined;

    constructor(data?: IReportSectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.group = data["group"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ReportSectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["name"] = this.name;
        return data; 
    }
}

export interface IReportSectionDto {
    group: SectionGroup | undefined;
    name: string | undefined;
}

export class GetReportTemplateDefinitionOutput implements IGetReportTemplateDefinitionOutput {
    sections!: { [key: string] : ReportSectionDto; } | undefined;
    categorySectionMap!: { [key: string] : number; } | undefined;

    constructor(data?: IGetReportTemplateDefinitionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["sections"]) {
                this.sections = {};
                for (let key in data["sections"]) {
                    if (data["sections"].hasOwnProperty(key))
                        this.sections[key] = data["sections"][key] ? ReportSectionDto.fromJS(data["sections"][key]) : new ReportSectionDto();
                }
            }
            if (data["categorySectionMap"]) {
                this.categorySectionMap = {};
                for (let key in data["categorySectionMap"]) {
                    if (data["categorySectionMap"].hasOwnProperty(key))
                        this.categorySectionMap[key] = data["categorySectionMap"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetReportTemplateDefinitionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDefinitionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sections) {
            data["sections"] = {};
            for (let key in this.sections) {
                if (this.sections.hasOwnProperty(key))
                    data["sections"][key] = this.sections[key];
            }
        }
        if (this.categorySectionMap) {
            data["categorySectionMap"] = {};
            for (let key in this.categorySectionMap) {
                if (this.categorySectionMap.hasOwnProperty(key))
                    data["categorySectionMap"][key] = this.categorySectionMap[key];
            }
        }
        return data; 
    }
}

export interface IGetReportTemplateDefinitionOutput {
    sections: { [key: string] : ReportSectionDto; } | undefined;
    categorySectionMap: { [key: string] : number; } | undefined;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    accountingTypeId!: number;
    parentId!: number | undefined;
    coAID!: string | undefined;
    name!: string;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
            this.coAID = data["coAID"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateCategoryInput {
    accountingTypeId: number;
    parentId: number | undefined;
    coAID: string | undefined;
    name: string;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    id!: number;
    coAID!: string | undefined;
    name!: string;
    accountingTypeId!: number;
    parentId!: number | undefined;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.coAID = data["coAID"];
            this.name = data["name"];
            this.accountingTypeId = data["accountingTypeId"];
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coAID"] = this.coAID;
        data["name"] = this.name;
        data["accountingTypeId"] = this.accountingTypeId;
        data["parentId"] = this.parentId;
        return data; 
    }
}

export interface IUpdateCategoryInput {
    id: number;
    coAID: string | undefined;
    name: string;
    accountingTypeId: number;
    parentId: number | undefined;
}

export class UpdateCategoryStatusInput implements IUpdateCategoryStatusInput {
    id!: number | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IUpdateCategoryStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateCategoryStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateCategoryStatusInput {
    id: number | undefined;
    isActive: boolean | undefined;
}

export class CreateAccountingTypeInput implements ICreateAccountingTypeInput {
    cashflowTypeId!: string | undefined;
    name!: string;
    sortOrder!: number | undefined;

    constructor(data?: ICreateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashflowTypeId = data["cashflowTypeId"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateAccountingTypeInput {
    cashflowTypeId: string | undefined;
    name: string;
    sortOrder: number | undefined;
}

export class UpdateAccountingTypeInput implements IUpdateAccountingTypeInput {
    id!: number;
    name!: string;
    cashflowTypeId!: string | undefined;

    constructor(data?: IUpdateAccountingTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.cashflowTypeId = data["cashflowTypeId"];
        }
    }

    static fromJS(data: any): UpdateAccountingTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountingTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cashflowTypeId"] = this.cashflowTypeId;
        return data; 
    }
}

export interface IUpdateAccountingTypeInput {
    id: number;
    name: string;
    cashflowTypeId: string | undefined;
}

export class SyncDto implements ISyncDto {
    syncAccountId!: number | undefined;

    constructor(data?: ISyncDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncAccountId = data["syncAccountId"];
        }
    }

    static fromJS(data: any): SyncDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncAccountId"] = this.syncAccountId;
        return data; 
    }
}

export interface ISyncDto {
    syncAccountId: number | undefined;
}

export class AccountingCategoryDto implements IAccountingCategoryDto {
    id!: string | undefined;
    coAID!: string | undefined;
    isActive!: boolean | undefined;
    cashType!: string | undefined;
    accountingType!: string;
    category!: string;
    parentCategory!: string | undefined;
    sortId!: number | undefined;
    reportingCategoryCode!: string | undefined;
    reportingCategoryName!: string | undefined;

    constructor(data?: IAccountingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.coAID = data["coAID"];
            this.isActive = data["isActive"];
            this.cashType = data["cashType"];
            this.accountingType = data["accountingType"];
            this.category = data["category"];
            this.parentCategory = data["parentCategory"];
            this.sortId = data["sortId"];
            this.reportingCategoryCode = data["reportingCategoryCode"];
            this.reportingCategoryName = data["reportingCategoryName"];
        }
    }

    static fromJS(data: any): AccountingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coAID"] = this.coAID;
        data["isActive"] = this.isActive;
        data["cashType"] = this.cashType;
        data["accountingType"] = this.accountingType;
        data["category"] = this.category;
        data["parentCategory"] = this.parentCategory;
        data["sortId"] = this.sortId;
        data["reportingCategoryCode"] = this.reportingCategoryCode;
        data["reportingCategoryName"] = this.reportingCategoryName;
        return data; 
    }
}

export interface IAccountingCategoryDto {
    id: string | undefined;
    coAID: string | undefined;
    isActive: boolean | undefined;
    cashType: string | undefined;
    accountingType: string;
    category: string;
    parentCategory: string | undefined;
    sortId: number | undefined;
    reportingCategoryCode: string | undefined;
    reportingCategoryName: string | undefined;
}

export enum FriendshipState {
    _1 = 1, 
    _2 = 2, 
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageReadState {
    _1 = 1, 
    _2 = 2, 
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export class ChatMessageDtoListResultDto implements IChatMessageDtoListResultDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IChatMessageDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatMessageDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChatMessageDtoListResultDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class GetRulesInput implements IGetRulesInput {

    constructor(data?: IGetRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): GetRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetRulesInput {
}

export class RuleDto implements IRuleDto {
    parentId!: number | undefined;
    name!: string | undefined;
    categoryId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    sortOrder!: number | undefined;
    isActive!: boolean | undefined;
    transactionCount!: number | undefined;
    id!: number | undefined;

    constructor(data?: IRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sortOrder = data["sortOrder"];
            this.isActive = data["isActive"];
            this.transactionCount = data["transactionCount"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sortOrder"] = this.sortOrder;
        data["isActive"] = this.isActive;
        data["transactionCount"] = this.transactionCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRuleDto {
    parentId: number | undefined;
    name: string | undefined;
    categoryId: number | undefined;
    creationTime: moment.Moment | undefined;
    sortOrder: number | undefined;
    isActive: boolean | undefined;
    transactionCount: number | undefined;
    id: number | undefined;
}

export enum CashFlowAmountFormat {
    Unspecified = "Unspecified", 
    Debits = "Debits", 
    Credits = "Credits", 
}

export enum CategorizationRuleConditionType {
    Exist = "Exist", 
    Equal = "Equal", 
}

export class ConditionAttributeDto implements IConditionAttributeDto {
    attributeTypeId!: string;
    conditionTypeId!: CategorizationRuleConditionType;
    conditionValue!: string | undefined;

    constructor(data?: IConditionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeTypeId = data["attributeTypeId"];
            this.conditionTypeId = data["conditionTypeId"];
            this.conditionValue = data["conditionValue"];
        }
    }

    static fromJS(data: any): ConditionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        data["conditionTypeId"] = this.conditionTypeId;
        data["conditionValue"] = this.conditionValue;
        return data; 
    }
}

export interface IConditionAttributeDto {
    attributeTypeId: string;
    conditionTypeId: CategorizationRuleConditionType;
    conditionValue: string | undefined;
}

export class ConditionDto implements IConditionDto {
    minAmount!: number | undefined;
    maxAmount!: number | undefined;
    cashFlowAmountFormat!: CashFlowAmountFormat | undefined;
    bankId!: number | undefined;
    bankAccountId!: number | undefined;
    transactionCategoryId!: string | undefined;
    descriptionWords!: string | undefined;
    attributes!: { [key: string] : ConditionAttributeDto; } | undefined;
    transactionTypes!: string[] | undefined;

    constructor(data?: IConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minAmount = data["minAmount"];
            this.maxAmount = data["maxAmount"];
            this.cashFlowAmountFormat = data["cashFlowAmountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.descriptionWords = data["descriptionWords"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? ConditionAttributeDto.fromJS(data["attributes"][key]) : new ConditionAttributeDto();
                }
            }
            if (data["transactionTypes"] && data["transactionTypes"].constructor === Array) {
                this.transactionTypes = [];
                for (let item of data["transactionTypes"])
                    this.transactionTypes.push(item);
            }
        }
    }

    static fromJS(data: any): ConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minAmount"] = this.minAmount;
        data["maxAmount"] = this.maxAmount;
        data["cashFlowAmountFormat"] = this.cashFlowAmountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["descriptionWords"] = this.descriptionWords;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        if (this.transactionTypes && this.transactionTypes.constructor === Array) {
            data["transactionTypes"] = [];
            for (let item of this.transactionTypes)
                data["transactionTypes"].push(item);
        }
        return data; 
    }
}

export interface IConditionDto {
    minAmount: number | undefined;
    maxAmount: number | undefined;
    cashFlowAmountFormat: CashFlowAmountFormat | undefined;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    transactionCategoryId: string | undefined;
    descriptionWords: string | undefined;
    attributes: { [key: string] : ConditionAttributeDto; } | undefined;
    transactionTypes: string[] | undefined;
}

export enum ApplyToTransactionsOption {
    None = "None", 
    MatchedAndUnclassified = "MatchedAndUnclassified", 
    SelectedOnly = "SelectedOnly", 
    AllExisting = "AllExisting", 
}

export class CreateRuleDto implements ICreateRuleDto {
    parentId!: number | undefined;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;

    constructor(data?: ICreateRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): CreateRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface ICreateRuleDto {
    parentId: number | undefined;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
}

export class EditRuleDto implements IEditRuleDto {
    id!: number;
    name!: string;
    categoryId!: number;
    transactionDescriptor!: string | undefined;
    transactionDescriptorAttributeTypeId!: string | undefined;
    condition!: ConditionDto;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;

    constructor(data?: IEditRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.condition = new ConditionDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.transactionDescriptorAttributeTypeId = data["transactionDescriptorAttributeTypeId"];
            this.condition = data["condition"] ? ConditionDto.fromJS(data["condition"]) : new ConditionDto();
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
        }
    }

    static fromJS(data: any): EditRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["transactionDescriptorAttributeTypeId"] = this.transactionDescriptorAttributeTypeId;
        data["condition"] = this.condition ? this.condition.toJSON() : <any>undefined;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        return data; 
    }
}

export interface IEditRuleDto {
    id: number;
    name: string;
    categoryId: number;
    transactionDescriptor: string | undefined;
    transactionDescriptorAttributeTypeId: string | undefined;
    condition: ConditionDto;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
}

export class MoveRuleDto implements IMoveRuleDto {
    parentId!: number | undefined;
    sortOrder!: number | undefined;
    isRecategorize!: boolean | undefined;
    sourceTransactionList!: number[] | undefined;
    applyOption!: ApplyToTransactionsOption | undefined;
    id!: number | undefined;

    constructor(data?: IMoveRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.sortOrder = data["sortOrder"];
            this.isRecategorize = data["isRecategorize"];
            if (data["sourceTransactionList"] && data["sourceTransactionList"].constructor === Array) {
                this.sourceTransactionList = [];
                for (let item of data["sourceTransactionList"])
                    this.sourceTransactionList.push(item);
            }
            this.applyOption = data["applyOption"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MoveRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isRecategorize"] = this.isRecategorize;
        if (this.sourceTransactionList && this.sourceTransactionList.constructor === Array) {
            data["sourceTransactionList"] = [];
            for (let item of this.sourceTransactionList)
                data["sourceTransactionList"].push(item);
        }
        data["applyOption"] = this.applyOption;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMoveRuleDto {
    parentId: number | undefined;
    sortOrder: number | undefined;
    isRecategorize: boolean | undefined;
    sourceTransactionList: number[] | undefined;
    applyOption: ApplyToTransactionsOption | undefined;
    id: number | undefined;
}

export class AddMappingDto implements IAddMappingDto {
    oldName!: string;
    newName!: string;

    constructor(data?: IAddMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldName = data["oldName"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): AddMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldName"] = this.oldName;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IAddMappingDto {
    oldName: string;
    newName: string;
}

export class RecategorizeInput implements IRecategorizeInput {
    parseDescription!: boolean | undefined;
    bankAccountIds!: number[] | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    ruleId!: number | undefined;

    constructor(data?: IRecategorizeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parseDescription = data["parseDescription"];
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.ruleId = data["ruleId"];
        }
    }

    static fromJS(data: any): RecategorizeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecategorizeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parseDescription"] = this.parseDescription;
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["ruleId"] = this.ruleId;
        return data; 
    }
}

export interface IRecategorizeInput {
    parseDescription: boolean | undefined;
    bankAccountIds: number[] | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    ruleId: number | undefined;
}

export class ResetClassificationDto implements IResetClassificationDto {
    unclassify!: boolean | undefined;
    removeRules!: boolean | undefined;
    removeCategoryTree!: boolean | undefined;
    removeForecasts!: boolean | undefined;
    recalculateTransactionAttributes!: boolean | undefined;

    constructor(data?: IResetClassificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.unclassify = false;
            this.removeRules = false;
            this.removeCategoryTree = false;
            this.removeForecasts = false;
            this.recalculateTransactionAttributes = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.unclassify = data["unclassify"] !== undefined ? data["unclassify"] : false;
            this.removeRules = data["removeRules"] !== undefined ? data["removeRules"] : false;
            this.removeCategoryTree = data["removeCategoryTree"] !== undefined ? data["removeCategoryTree"] : false;
            this.removeForecasts = data["removeForecasts"] !== undefined ? data["removeForecasts"] : false;
            this.recalculateTransactionAttributes = data["recalculateTransactionAttributes"] !== undefined ? data["recalculateTransactionAttributes"] : false;
        }
    }

    static fromJS(data: any): ResetClassificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetClassificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unclassify"] = this.unclassify;
        data["removeRules"] = this.removeRules;
        data["removeCategoryTree"] = this.removeCategoryTree;
        data["removeForecasts"] = this.removeForecasts;
        data["recalculateTransactionAttributes"] = this.recalculateTransactionAttributes;
        return data; 
    }
}

export interface IResetClassificationDto {
    unclassify: boolean | undefined;
    removeRules: boolean | undefined;
    removeCategoryTree: boolean | undefined;
    removeForecasts: boolean | undefined;
    recalculateTransactionAttributes: boolean | undefined;
}

export class UpdateTransactionsCategoryInput implements IUpdateTransactionsCategoryInput {
    transactionIds!: number[] | undefined;
    categoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean | undefined;

    constructor(data?: IUpdateTransactionsCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
            this.categoryId = data["categoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = data["suppressCashflowMismatch"] !== undefined ? data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryInput {
    transactionIds: number[] | undefined;
    categoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean | undefined;
}

export class StatsDetailFilterBase implements IStatsDetailFilterBase {
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    subCategoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: IStatsDetailFilterBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): StatsDetailFilterBase {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDetailFilterBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface IStatsDetailFilterBase {
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    subCategoryId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class UpdateTransactionsCategoryWithFilterInput implements IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter!: StatsDetailFilterBase | undefined;
    destinationCategoryId!: number | undefined;
    standardDescriptor!: string | undefined;
    descriptorAttributeTypeId!: string | undefined;
    suppressCashflowMismatch!: boolean | undefined;

    constructor(data?: IUpdateTransactionsCategoryWithFilterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppressCashflowMismatch = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionFilter = data["transactionFilter"] ? StatsDetailFilterBase.fromJS(data["transactionFilter"]) : <any>undefined;
            this.destinationCategoryId = data["destinationCategoryId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.descriptorAttributeTypeId = data["descriptorAttributeTypeId"];
            this.suppressCashflowMismatch = data["suppressCashflowMismatch"] !== undefined ? data["suppressCashflowMismatch"] : false;
        }
    }

    static fromJS(data: any): UpdateTransactionsCategoryWithFilterInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionsCategoryWithFilterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionFilter"] = this.transactionFilter ? this.transactionFilter.toJSON() : <any>undefined;
        data["destinationCategoryId"] = this.destinationCategoryId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["descriptorAttributeTypeId"] = this.descriptorAttributeTypeId;
        data["suppressCashflowMismatch"] = this.suppressCashflowMismatch;
        return data; 
    }
}

export interface IUpdateTransactionsCategoryWithFilterInput {
    transactionFilter: StatsDetailFilterBase | undefined;
    destinationCategoryId: number | undefined;
    standardDescriptor: string | undefined;
    descriptorAttributeTypeId: string | undefined;
    suppressCashflowMismatch: boolean | undefined;
}

export class GetTransactionCommonDetailsInput implements IGetTransactionCommonDetailsInput {
    transactionIds!: number[] | undefined;

    constructor(data?: IGetTransactionCommonDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetTransactionCommonDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionCommonDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data; 
    }
}

export interface IGetTransactionCommonDetailsInput {
    transactionIds: number[] | undefined;
}

export enum AmountFormat {
    Debits = "Debits", 
    Credits = "Credits", 
}

export class TransactionAttributeDto implements ITransactionAttributeDto {
    typeId!: string | undefined;
    value!: string | undefined;

    constructor(data?: ITransactionAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TransactionAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITransactionAttributeDto {
    typeId: string | undefined;
    value: string | undefined;
}

export class TransactionCommonDetailsDto implements ITransactionCommonDetailsDto {
    amountFormat!: AmountFormat | undefined;
    bankId!: number | undefined;
    bankAccountId!: number | undefined;
    standardDescriptor!: string | undefined;
    transactionCategoryId!: string | undefined;
    transactionTypeId!: string | undefined;
    descriptionPhrases!: string[] | undefined;
    attributes!: TransactionAttributeDto[] | undefined;
    sourceTransactionsAreMatchingExistingRules!: boolean | undefined;

    constructor(data?: ITransactionCommonDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amountFormat = data["amountFormat"];
            this.bankId = data["bankId"];
            this.bankAccountId = data["bankAccountId"];
            this.standardDescriptor = data["standardDescriptor"];
            this.transactionCategoryId = data["transactionCategoryId"];
            this.transactionTypeId = data["transactionTypeId"];
            if (data["descriptionPhrases"] && data["descriptionPhrases"].constructor === Array) {
                this.descriptionPhrases = [];
                for (let item of data["descriptionPhrases"])
                    this.descriptionPhrases.push(item);
            }
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
            this.sourceTransactionsAreMatchingExistingRules = data["sourceTransactionsAreMatchingExistingRules"];
        }
    }

    static fromJS(data: any): TransactionCommonDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommonDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountFormat"] = this.amountFormat;
        data["bankId"] = this.bankId;
        data["bankAccountId"] = this.bankAccountId;
        data["standardDescriptor"] = this.standardDescriptor;
        data["transactionCategoryId"] = this.transactionCategoryId;
        data["transactionTypeId"] = this.transactionTypeId;
        if (this.descriptionPhrases && this.descriptionPhrases.constructor === Array) {
            data["descriptionPhrases"] = [];
            for (let item of this.descriptionPhrases)
                data["descriptionPhrases"].push(item);
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        data["sourceTransactionsAreMatchingExistingRules"] = this.sourceTransactionsAreMatchingExistingRules;
        return data; 
    }
}

export interface ITransactionCommonDetailsDto {
    amountFormat: AmountFormat | undefined;
    bankId: number | undefined;
    bankAccountId: number | undefined;
    standardDescriptor: string | undefined;
    transactionCategoryId: string | undefined;
    transactionTypeId: string | undefined;
    descriptionPhrases: string[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
    sourceTransactionsAreMatchingExistingRules: boolean | undefined;
}

export class AutoClassifyDto implements IAutoClassifyDto {
    bankAccountIds!: number[] | undefined;

    constructor(data?: IAutoClassifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
        }
    }

    static fromJS(data: any): AutoClassifyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AutoClassifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        return data; 
    }
}

export interface IAutoClassifyDto {
    bankAccountIds: number[] | undefined;
}

export class ChangeCategoryForRulesInput implements IChangeCategoryForRulesInput {
    ruleIds!: number[] | undefined;
    categotyId!: number;
    reclassifyTransactions!: boolean | undefined;

    constructor(data?: IChangeCategoryForRulesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reclassifyTransactions = false;
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ruleIds"] && data["ruleIds"].constructor === Array) {
                this.ruleIds = [];
                for (let item of data["ruleIds"])
                    this.ruleIds.push(item);
            }
            this.categotyId = data["categotyId"];
            this.reclassifyTransactions = data["reclassifyTransactions"] !== undefined ? data["reclassifyTransactions"] : false;
        }
    }

    static fromJS(data: any): ChangeCategoryForRulesInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeCategoryForRulesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleIds && this.ruleIds.constructor === Array) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["categotyId"] = this.categotyId;
        data["reclassifyTransactions"] = this.reclassifyTransactions;
        return data; 
    }
}

export interface IChangeCategoryForRulesInput {
    ruleIds: number[] | undefined;
    categotyId: number;
    reclassifyTransactions: boolean | undefined;
}

export class GetKeyAttributeValuesInput implements IGetKeyAttributeValuesInput {
    ruleId!: number | undefined;
    transactionIds!: number[] | undefined;

    constructor(data?: IGetKeyAttributeValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleId = data["ruleId"];
            if (data["transactionIds"] && data["transactionIds"].constructor === Array) {
                this.transactionIds = [];
                for (let item of data["transactionIds"])
                    this.transactionIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetKeyAttributeValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetKeyAttributeValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        if (this.transactionIds && this.transactionIds.constructor === Array) {
            data["transactionIds"] = [];
            for (let item of this.transactionIds)
                data["transactionIds"].push(item);
        }
        return data; 
    }
}

export interface IGetKeyAttributeValuesInput {
    ruleId: number | undefined;
    transactionIds: number[] | undefined;
}

export class AttributeValuesDto implements IAttributeValuesDto {
    attributeTypeId!: string | undefined;
    attributeValues!: string[] | undefined;

    constructor(data?: IAttributeValuesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeTypeId = data["attributeTypeId"];
            if (data["attributeValues"] && data["attributeValues"].constructor === Array) {
                this.attributeValues = [];
                for (let item of data["attributeValues"])
                    this.attributeValues.push(item);
            }
        }
    }

    static fromJS(data: any): AttributeValuesDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeValuesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeTypeId"] = this.attributeTypeId;
        if (this.attributeValues && this.attributeValues.constructor === Array) {
            data["attributeValues"] = [];
            for (let item of this.attributeValues)
                data["attributeValues"].push(item);
        }
        return data; 
    }
}

export interface IAttributeValuesDto {
    attributeTypeId: string | undefined;
    attributeValues: string[] | undefined;
}

export class UserKeyInfo implements IUserKeyInfo {
    id!: number | undefined;
    userName!: string | undefined;
    fullName!: string | undefined;

    constructor(data?: IUserKeyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UserKeyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserKeyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUserKeyInfo {
    id: number | undefined;
    userName: string | undefined;
    fullName: string | undefined;
}

export class CommentDto implements ICommentDto {
    threadId!: number | undefined;
    comment!: string | undefined;
    createdByUser!: UserKeyInfo | undefined;
    creationTime!: moment.Moment | undefined;
    updatedByUser!: UserKeyInfo | undefined;
    lastModificationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
            this.createdByUser = data["createdByUser"] ? UserKeyInfo.fromJS(data["createdByUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.updatedByUser = data["updatedByUser"] ? UserKeyInfo.fromJS(data["updatedByUser"]) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICommentDto {
    threadId: number | undefined;
    comment: string | undefined;
    createdByUser: UserKeyInfo | undefined;
    creationTime: moment.Moment | undefined;
    updatedByUser: UserKeyInfo | undefined;
    lastModificationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateCommentInput implements ICreateCommentInput {
    threadId!: number | undefined;
    comment!: string;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateCommentInput {
    threadId: number | undefined;
    comment: string;
}

export class CreateCommentOutput implements ICreateCommentOutput {
    id!: number | undefined;

    constructor(data?: ICreateCommentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCommentOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCommentOutput {
    id: number | undefined;
}

export class UpdateCommentInput implements IUpdateCommentInput {
    comment!: string;
    id!: number | undefined;

    constructor(data?: IUpdateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UpdateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateCommentInput {
    comment: string;
    id: number | undefined;
}

export class CreateTransactionCommentThreadInput implements ICreateTransactionCommentThreadInput {
    transactionId!: number;
    comment!: string;

    constructor(data?: ICreateTransactionCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadInput {
    transactionId: number;
    comment: string;
}

export class CreateTransactionCommentThreadOutput implements ICreateTransactionCommentThreadOutput {
    threadId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateTransactionCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateTransactionCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateTransactionCommentThreadOutput {
    threadId: number | undefined;
    id: number | undefined;
}

export class CreateCashFlowCommentThreadInput implements ICreateCashFlowCommentThreadInput {
    accountId!: number | undefined;
    comment!: string;
    cashflowTypeId!: string | undefined;
    accountingTypeId!: number | undefined;
    categoryId!: number | undefined;
    reportSectionGroup!: SectionGroup | undefined;
    reportSectionId!: number | undefined;
    subCategoryId!: number | undefined;
    transactionDescriptor!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    currencyId!: string | undefined;
    accountIds!: number[] | undefined;
    businessEntityIds!: number[] | undefined;

    constructor(data?: ICreateCashFlowCommentThreadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.comment = data["comment"];
            this.cashflowTypeId = data["cashflowTypeId"];
            this.accountingTypeId = data["accountingTypeId"];
            this.categoryId = data["categoryId"];
            this.reportSectionGroup = data["reportSectionGroup"];
            this.reportSectionId = data["reportSectionId"];
            this.subCategoryId = data["subCategoryId"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.currencyId = data["currencyId"];
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["comment"] = this.comment;
        data["cashflowTypeId"] = this.cashflowTypeId;
        data["accountingTypeId"] = this.accountingTypeId;
        data["categoryId"] = this.categoryId;
        data["reportSectionGroup"] = this.reportSectionGroup;
        data["reportSectionId"] = this.reportSectionId;
        data["subCategoryId"] = this.subCategoryId;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["currencyId"] = this.currencyId;
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadInput {
    accountId: number | undefined;
    comment: string;
    cashflowTypeId: string | undefined;
    accountingTypeId: number | undefined;
    categoryId: number | undefined;
    reportSectionGroup: SectionGroup | undefined;
    reportSectionId: number | undefined;
    subCategoryId: number | undefined;
    transactionDescriptor: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    currencyId: string | undefined;
    accountIds: number[] | undefined;
    businessEntityIds: number[] | undefined;
}

export class CreateCashFlowCommentThreadOutput implements ICreateCashFlowCommentThreadOutput {
    threadId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateCashFlowCommentThreadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCashFlowCommentThreadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashFlowCommentThreadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateCashFlowCommentThreadOutput {
    threadId: number | undefined;
    id: number | undefined;
}

export class SetResolvedInput implements ISetResolvedInput {
    threadId!: number;
    isResolved!: boolean;

    constructor(data?: ISetResolvedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.threadId = data["threadId"];
            this.isResolved = data["isResolved"];
        }
    }

    static fromJS(data: any): SetResolvedInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetResolvedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["threadId"] = this.threadId;
        data["isResolved"] = this.isResolved;
        return data; 
    }
}

export interface ISetResolvedInput {
    threadId: number;
    isResolved: boolean;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    packageName!: string | undefined;
    moduleId!: string | undefined;
    moduleName!: string | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.packageName = data["packageName"];
            this.moduleId = data["moduleId"];
            this.moduleName = data["moduleName"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["packageName"] = this.packageName;
        data["moduleId"] = this.moduleId;
        data["moduleName"] = this.moduleName;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    packageName: string | undefined;
    moduleId: string | undefined;
    moduleName: string | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class SubscribableEditionComboboxItemDtoListResultDto implements ISubscribableEditionComboboxItemDtoListResultDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDtoListResultDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: INameValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INameValueDtoPagedResultDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export enum MaritalStatus {
    Single = "Single", 
    Married = "Married", 
    Divorced = "Divorced", 
    Widowed = "Widowed", 
    Separated = "Separated", 
}

export class PersonInfoDto implements IPersonInfoDto {
    namePrefix!: string | undefined;
    middleName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    identityConfirmationDate!: moment.Moment | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    contactId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;

    constructor(data?: IPersonInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namePrefix = data["namePrefix"];
            this.middleName = data["middleName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.identityConfirmationDate = data["identityConfirmationDate"] ? moment(data["identityConfirmationDate"].toString()) : <any>undefined;
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.contactId = data["contactId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
        }
    }

    static fromJS(data: any): PersonInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["middleName"] = this.middleName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["identityConfirmationDate"] = this.identityConfirmationDate ? this.identityConfirmationDate.toISOString() : <any>undefined;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IPersonInfoDto {
    namePrefix: string | undefined;
    middleName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    identityConfirmationDate: moment.Moment | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    contactId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
}

export class OrganizationShortInfo implements IOrganizationShortInfo {
    id!: number | undefined;
    name!: string | undefined;
    thumbnail!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IOrganizationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.thumbnail = data["thumbnail"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): OrganizationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["thumbnail"] = this.thumbnail;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IOrganizationShortInfo {
    id: number | undefined;
    name: string | undefined;
    thumbnail: string | undefined;
    organizationUnitId: number | undefined;
}

export class PersonOrgRelationTypeInfo implements IPersonOrgRelationTypeInfo {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IPersonOrgRelationTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PersonOrgRelationTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPersonOrgRelationTypeInfo {
    id: string | undefined;
    name: string | undefined;
}

export class PersonOrgRelationShortInfo implements IPersonOrgRelationShortInfo {
    id!: number | undefined;
    isActive!: boolean | undefined;
    isPrimary!: boolean | undefined;
    organization!: OrganizationShortInfo | undefined;
    relationType!: PersonOrgRelationTypeInfo | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IPersonOrgRelationShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
            this.isPrimary = data["isPrimary"];
            this.organization = data["organization"] ? OrganizationShortInfo.fromJS(data["organization"]) : <any>undefined;
            this.relationType = data["relationType"] ? PersonOrgRelationTypeInfo.fromJS(data["relationType"]) : <any>undefined;
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): PersonOrgRelationShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isPrimary"] = this.isPrimary;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["relationType"] = this.relationType ? this.relationType.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface IPersonOrgRelationShortInfo {
    id: number | undefined;
    isActive: boolean | undefined;
    isPrimary: boolean | undefined;
    organization: OrganizationShortInfo | undefined;
    relationType: PersonOrgRelationTypeInfo | undefined;
    jobTitle: string | undefined;
}

export class ContactEmailDto implements IContactEmailDto {
    usageTypeId!: string | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactEmailDto {
    usageTypeId: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactPhoneDto implements IContactPhoneDto {
    usageTypeId!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactPhoneDto {
    usageTypeId: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactAddressDto implements IContactAddressDto {
    usageTypeId!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    zip!: string | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageTypeId = data["usageTypeId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.zip = data["zip"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageTypeId"] = this.usageTypeId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zip"] = this.zip;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactAddressDto {
    usageTypeId: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zip: string | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactLinkDto implements IContactLinkDto {
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isSocialNetwork!: boolean | undefined;
    isActive!: boolean | undefined;
    comment!: string | undefined;
    contactId!: number | undefined;
    id!: number | undefined;
    isConfirmed!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;

    constructor(data?: IContactLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
            this.isSocialNetwork = data["isSocialNetwork"];
            this.isActive = data["isActive"];
            this.comment = data["comment"];
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.isConfirmed = data["isConfirmed"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isSocialNetwork"] = this.isSocialNetwork;
        data["isActive"] = this.isActive;
        data["comment"] = this.comment;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["isConfirmed"] = this.isConfirmed;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactLinkDto {
    linkTypeId: string | undefined;
    url: string | undefined;
    isSocialNetwork: boolean | undefined;
    isActive: boolean | undefined;
    comment: string | undefined;
    contactId: number | undefined;
    id: number | undefined;
    isConfirmed: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
}

export class ContactInfoDetailsDto implements IContactInfoDetailsDto {
    contactId!: number | undefined;
    emails!: ContactEmailDto[] | undefined;
    phones!: ContactPhoneDto[] | undefined;
    addresses!: ContactAddressDto[] | undefined;
    links!: ContactLinkDto[] | undefined;

    constructor(data?: IContactInfoDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [];
                for (let item of data["emails"])
                    this.emails.push(ContactEmailDto.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhoneDto.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(ContactAddressDto.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactInfoDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactInfoDetailsDto {
    contactId: number | undefined;
    emails: ContactEmailDto[] | undefined;
    phones: ContactPhoneDto[] | undefined;
    addresses: ContactAddressDto[] | undefined;
    links: ContactLinkDto[] | undefined;
}

export class PersonContactInfoDto implements IPersonContactInfoDto {
    person!: PersonInfoDto | undefined;
    jobTitle!: string | undefined;
    orgRelationId!: number | undefined;
    orgRelations!: PersonOrgRelationShortInfo[] | undefined;
    id!: number | undefined;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IPersonContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.person = data["person"] ? PersonInfoDto.fromJS(data["person"]) : <any>undefined;
            this.jobTitle = data["jobTitle"];
            this.orgRelationId = data["orgRelationId"];
            if (data["orgRelations"] && data["orgRelations"].constructor === Array) {
                this.orgRelations = [];
                for (let item of data["orgRelations"])
                    this.orgRelations.push(PersonOrgRelationShortInfo.fromJS(item));
            }
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.userId = data["userId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryAddressId = data["primaryAddressId"];
            this.primaryPhoto = data["primaryPhoto"];
            this.details = data["details"] ? ContactInfoDetailsDto.fromJS(data["details"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): PersonContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["orgRelationId"] = this.orgRelationId;
        if (this.orgRelations && this.orgRelations.constructor === Array) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IPersonContactInfoDto {
    person: PersonInfoDto | undefined;
    jobTitle: string | undefined;
    orgRelationId: number | undefined;
    orgRelations: PersonOrgRelationShortInfo[] | undefined;
    id: number | undefined;
    fullName: string | undefined;
    userId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export class ContactInfoDto implements IContactInfoDto {
    id!: number | undefined;
    statusId!: string | undefined;
    groupId!: string | undefined;
    assignedUserId!: number | undefined;
    starId!: number | undefined;
    ratingId!: number | undefined;
    tags!: number[] | undefined;
    lists!: number[] | undefined;
    personContactInfo!: PersonContactInfoDto | undefined;
    primaryOrganizationContactId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusId = data["statusId"];
            this.groupId = data["groupId"];
            this.assignedUserId = data["assignedUserId"];
            this.starId = data["starId"];
            this.ratingId = data["ratingId"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(item);
            }
            this.personContactInfo = data["personContactInfo"] ? PersonContactInfoDto.fromJS(data["personContactInfo"]) : <any>undefined;
            this.primaryOrganizationContactId = data["primaryOrganizationContactId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusId"] = this.statusId;
        data["groupId"] = this.groupId;
        data["assignedUserId"] = this.assignedUserId;
        data["starId"] = this.starId;
        data["ratingId"] = this.ratingId;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        data["personContactInfo"] = this.personContactInfo ? this.personContactInfo.toJSON() : <any>undefined;
        data["primaryOrganizationContactId"] = this.primaryOrganizationContactId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IContactInfoDto {
    id: number | undefined;
    statusId: string | undefined;
    groupId: string | undefined;
    assignedUserId: number | undefined;
    starId: number | undefined;
    ratingId: number | undefined;
    tags: number[] | undefined;
    lists: number[] | undefined;
    personContactInfo: PersonContactInfoDto | undefined;
    primaryOrganizationContactId: number | undefined;
    organizationUnitId: number | undefined;
}

export class ContactPhotoInfo implements IContactPhotoInfo {
    original!: string | undefined;
    thumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IContactPhotoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): ContactPhotoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IContactPhotoInfo {
    original: string | undefined;
    thumbnail: string | undefined;
    source: string | undefined;
}

export class ContactShortInfo implements IContactShortInfo {
    photo!: ContactPhotoInfo | undefined;
    ratingId!: number | undefined;
    groupId!: string | undefined;
    statusId!: string | undefined;
    id!: number | undefined;
    fullName!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IContactShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.photo = data["photo"] ? ContactPhotoInfo.fromJS(data["photo"]) : <any>undefined;
            this.ratingId = data["ratingId"];
            this.groupId = data["groupId"];
            this.statusId = data["statusId"];
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["ratingId"] = this.ratingId;
        data["groupId"] = this.groupId;
        data["statusId"] = this.statusId;
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContactShortInfo {
    photo: ContactPhotoInfo | undefined;
    ratingId: number | undefined;
    groupId: string | undefined;
    statusId: string | undefined;
    id: number | undefined;
    fullName: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class CreateContactEmailInput implements ICreateContactEmailInput {
    contactId!: number;
    emailAddress!: string;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactEmailInput {
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactPhoneInput implements ICreateContactPhoneInput {
    contactId!: number;
    phoneNumber!: string;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: ICreateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): CreateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface ICreateContactPhoneInput {
    contactId: number;
    phoneNumber: string;
    phoneExtension: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class CreateContactAddressInput implements ICreateContactAddressInput {
    contactId!: number;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;

    constructor(data?: ICreateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
        }
    }

    static fromJS(data: any): CreateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        return data; 
    }
}

export interface ICreateContactAddressInput {
    contactId: number;
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
}

export class CreateContactLinkInput implements ICreateContactLinkInput {
    contactId!: number;
    url!: string;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;
    isCompany!: boolean;

    constructor(data?: ICreateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): CreateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface ICreateContactLinkInput {
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
    isCompany: boolean;
}

export class ContactPhotoInput implements IContactPhotoInput {
    original!: string;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactPhotoInput {
    original: string;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class ContactTagInput implements IContactTagInput {
    name!: string;

    constructor(data?: IContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactTagInput {
    name: string;
}

export class ContactListInput implements IContactListInput {
    name!: string;

    constructor(data?: IContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactListInput {
    name: string;
}

export class CreateContactInput implements ICreateContactInput {
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInput[] | undefined;
    phoneNumbers!: CreateContactPhoneInput[] | undefined;
    addresses!: CreateContactAddressInput[] | undefined;
    links!: CreateContactLinkInput[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    organizationUnitId!: number | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    partnerTypeName!: string | undefined;

    constructor(data?: ICreateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(CreateContactEmailInput.fromJS(item));
            }
            if (data["phoneNumbers"] && data["phoneNumbers"].constructor === Array) {
                this.phoneNumbers = [];
                for (let item of data["phoneNumbers"])
                    this.phoneNumbers.push(CreateContactPhoneInput.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(CreateContactAddressInput.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(CreateContactLinkInput.fromJS(item));
            }
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.bankCode = data["bankCode"];
            this.gender = data["gender"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.note = data["note"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.companyName = data["companyName"];
            this.industry = data["industry"];
            this.photo = data["photo"] ? ContactPhotoInput.fromJS(data["photo"]) : <any>undefined;
            this.organizationUnitId = data["organizationUnitId"];
            this.title = data["title"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.contactGroupId = data["contactGroupId"];
            this.partnerTypeName = data["partnerTypeName"];
        }
    }

    static fromJS(data: any): CreateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (this.phoneNumbers && this.phoneNumbers.constructor === Array) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["organizationUnitId"] = this.organizationUnitId;
        data["title"] = this.title;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["partnerTypeName"] = this.partnerTypeName;
        return data; 
    }
}

export interface ICreateContactInput {
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInput[] | undefined;
    phoneNumbers: CreateContactPhoneInput[] | undefined;
    addresses: CreateContactAddressInput[] | undefined;
    links: CreateContactLinkInput[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    organizationUnitId: number | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    partnerTypeName: string | undefined;
}

export class CreateContactOutput implements ICreateContactOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactOutput {
    id: number | undefined;
}

export class SimilarContactOutput implements ISimilarContactOutput {
    id!: number | undefined;
    name!: string | undefined;
    photo!: string | undefined;
    companyName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    score!: number | undefined;

    constructor(data?: ISimilarContactOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.photo = data["photo"];
            this.companyName = data["companyName"];
            this.jobTitle = data["jobTitle"];
            this.ratingId = data["ratingId"];
            this.score = data["score"];
        }
    }

    static fromJS(data: any): SimilarContactOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SimilarContactOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["photo"] = this.photo;
        data["companyName"] = this.companyName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["score"] = this.score;
        return data; 
    }
}

export interface ISimilarContactOutput {
    id: number | undefined;
    name: string | undefined;
    photo: string | undefined;
    companyName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    score: number | undefined;
}

export class UpdateContactStatusInput implements IUpdateContactStatusInput {
    contactId!: number;
    statusId!: string;

    constructor(data?: IUpdateContactStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.statusId = data["statusId"];
        }
    }

    static fromJS(data: any): UpdateContactStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IUpdateContactStatusInput {
    contactId: number;
    statusId: string;
}

export class UpdateContactStatusesInput implements IUpdateContactStatusesInput {
    contactIds!: number[];
    statusId!: string;

    constructor(data?: IUpdateContactStatusesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.statusId = data["statusId"];
        }
    }

    static fromJS(data: any): UpdateContactStatusesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactStatusesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IUpdateContactStatusesInput {
    contactIds: number[];
    statusId: string;
}

export class ContactGroupDto implements IContactGroupDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IContactGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactGroupDto {
    id: string | undefined;
    name: string | undefined;
}

export class ContactStatusDto implements IContactStatusDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IContactStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactStatusDto {
    id: string | undefined;
    name: string | undefined;
}

export class AssignUserInput implements IAssignUserInput {
    id!: number;
    userId!: number | undefined;

    constructor(data?: IAssignUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AssignUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IAssignUserInput {
    id: number;
    userId: number | undefined;
}

export class AssignUserForEachInput implements IAssignUserForEachInput {
    ids!: number[];
    userId!: number | undefined;

    constructor(data?: IAssignUserForEachInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AssignUserForEachInput {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserForEachInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IAssignUserForEachInput {
    ids: number[];
    userId: number | undefined;
}

export class UpdateContactOrganizationUnitInput implements IUpdateContactOrganizationUnitInput {
    contactId!: number;
    organizationUnitId!: number;

    constructor(data?: IUpdateContactOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateContactOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateContactOrganizationUnitInput {
    contactId: number;
    organizationUnitId: number;
}

export class CreateContactAddressOutput implements ICreateContactAddressOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactAddressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactAddressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactAddressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactAddressOutput {
    id: number | undefined;
}

export class UpdateContactAddressInput implements IUpdateContactAddressInput {
    id!: number;
    contactId!: number;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;

    constructor(data?: IUpdateContactAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        return data; 
    }
}

export interface IUpdateContactAddressInput {
    id: number;
    contactId: number;
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
}

export class AddressUsageTypeDto implements IAddressUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IAddressUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): AddressUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IAddressUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class AddressUsageTypeDtoListResultDto implements IAddressUsageTypeDtoListResultDto {
    items!: AddressUsageTypeDto[] | undefined;

    constructor(data?: IAddressUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddressUsageTypeDtoListResultDto {
    items: AddressUsageTypeDto[] | undefined;
}

export class AddressOwnershipTypeDto implements IAddressOwnershipTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IAddressOwnershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAddressOwnershipTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class AddressOwnershipTypeDtoListResultDto implements IAddressOwnershipTypeDtoListResultDto {
    items!: AddressOwnershipTypeDto[] | undefined;

    constructor(data?: IAddressOwnershipTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AddressOwnershipTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddressOwnershipTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddressOwnershipTypeDtoListResultDto {
    items: AddressOwnershipTypeDto[] | undefined;
}

export class ContactBusinessInfo implements IContactBusinessInfo {
    id!: number | undefined;
    orgId!: number;
    relationTypeId!: string;
    jobTitle!: string;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;

    constructor(data?: IContactBusinessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.orgId = data["orgId"];
            this.relationTypeId = data["relationTypeId"];
            this.jobTitle = data["jobTitle"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactBusinessInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactBusinessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        data["relationTypeId"] = this.relationTypeId;
        data["jobTitle"] = this.jobTitle;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactBusinessInfo {
    id: number | undefined;
    orgId: number;
    relationTypeId: string;
    jobTitle: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
}

export class AddressInfo implements IAddressInfo {
    id!: number | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    state!: string | undefined;
    zip!: string | undefined;
    countryId!: string | undefined;
    country!: string | undefined;
    usageTypeId!: string | undefined;
    startDate!: moment.Moment | undefined;
    ownershipTypeId!: string | undefined;

    constructor(data?: IAddressInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.state = data["state"];
            this.zip = data["zip"];
            this.countryId = data["countryId"];
            this.country = data["country"];
            this.usageTypeId = data["usageTypeId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.ownershipTypeId = data["ownershipTypeId"];
        }
    }

    static fromJS(data: any): AddressInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AddressInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["countryId"] = this.countryId;
        data["country"] = this.country;
        data["usageTypeId"] = this.usageTypeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["ownershipTypeId"] = this.ownershipTypeId;
        return data; 
    }
}

export interface IAddressInfo {
    id: number | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    state: string | undefined;
    zip: string | undefined;
    countryId: string | undefined;
    country: string | undefined;
    usageTypeId: string | undefined;
    startDate: moment.Moment | undefined;
    ownershipTypeId: string | undefined;
}

export class ContactEmailInfo implements IContactEmailInfo {
    id!: number | undefined;
    emailAddress!: string | undefined;
    usageTypeId!: string | undefined;
    isPrimary!: boolean | undefined;

    constructor(data?: IContactEmailInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
            this.usageTypeId = data["usageTypeId"];
            this.isPrimary = data["isPrimary"];
        }
    }

    static fromJS(data: any): ContactEmailInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["usageTypeId"] = this.usageTypeId;
        data["isPrimary"] = this.isPrimary;
        return data; 
    }
}

export interface IContactEmailInfo {
    id: number | undefined;
    emailAddress: string | undefined;
    usageTypeId: string | undefined;
    isPrimary: boolean | undefined;
}

export class ContactPhoneInfo implements IContactPhoneInfo {
    id!: number | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IContactPhoneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): ContactPhoneInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IContactPhoneInfo {
    id: number | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    usageTypeId: string | undefined;
}

export class ContactLinkInfo implements IContactLinkInfo {
    linkTypeId!: string | undefined;
    link!: string | undefined;

    constructor(data?: IContactLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.linkTypeId = data["linkTypeId"];
            this.link = data["link"];
        }
    }

    static fromJS(data: any): ContactLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["link"] = this.link;
        return data; 
    }
}

export interface IContactLinkInfo {
    linkTypeId: string | undefined;
    link: string | undefined;
}

export class AddressOwnershipType implements IAddressOwnershipType {
    name!: string | undefined;
    contactAddresses!: ContactAddress[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IAddressOwnershipType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddress.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddressOwnershipType {
        data = typeof data === 'object' ? data : {};
        let result = new AddressOwnershipType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAddressOwnershipType {
    name: string | undefined;
    contactAddresses: ContactAddress[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AddressUsageType implements IAddressUsageType {
    name!: string | undefined;
    isCompany!: boolean | undefined;
    sortOrder!: number | undefined;
    contactAddresses!: ContactAddress[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IAddressUsageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isCompany = data["isCompany"];
            this.sortOrder = data["sortOrder"];
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddress.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddressUsageType {
        data = typeof data === 'object' ? data : {};
        let result = new AddressUsageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        data["sortOrder"] = this.sortOrder;
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAddressUsageType {
    name: string | undefined;
    isCompany: boolean | undefined;
    sortOrder: number | undefined;
    contactAddresses: ContactAddress[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OrganizationType implements IOrganizationType {
    name!: string | undefined;
    organizations!: Organization[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IOrganizationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["organizations"] && data["organizations"].constructor === Array) {
                this.organizations = [];
                for (let item of data["organizations"])
                    this.organizations.push(Organization.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationType {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.organizations && this.organizations.constructor === Array) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationType {
    name: string | undefined;
    organizations: Organization[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PersonRelationType implements IPersonRelationType {
    name!: string | undefined;
    reverseId!: string | undefined;
    relations!: PersonRelation[] | undefined;
    reverseType!: PersonRelationType | undefined;
    inverseReverseTypes!: PersonRelationType[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IPersonRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.reverseId = data["reverseId"];
            if (data["relations"] && data["relations"].constructor === Array) {
                this.relations = [];
                for (let item of data["relations"])
                    this.relations.push(PersonRelation.fromJS(item));
            }
            this.reverseType = data["reverseType"] ? PersonRelationType.fromJS(data["reverseType"]) : <any>undefined;
            if (data["inverseReverseTypes"] && data["inverseReverseTypes"].constructor === Array) {
                this.inverseReverseTypes = [];
                for (let item of data["inverseReverseTypes"])
                    this.inverseReverseTypes.push(PersonRelationType.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PersonRelationType {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["reverseId"] = this.reverseId;
        if (this.relations && this.relations.constructor === Array) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        data["reverseType"] = this.reverseType ? this.reverseType.toJSON() : <any>undefined;
        if (this.inverseReverseTypes && this.inverseReverseTypes.constructor === Array) {
            data["inverseReverseTypes"] = [];
            for (let item of this.inverseReverseTypes)
                data["inverseReverseTypes"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPersonRelationType {
    name: string | undefined;
    reverseId: string | undefined;
    relations: PersonRelation[] | undefined;
    reverseType: PersonRelationType | undefined;
    inverseReverseTypes: PersonRelationType[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PersonRelation implements IPersonRelation {
    tenantId!: number | undefined;
    personId!: number | undefined;
    relatedPersonId!: number | undefined;
    relationTypeId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    relationType!: PersonRelationType | undefined;
    person!: Person | undefined;
    relatedPerson!: Person | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPersonRelation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.personId = data["personId"];
            this.relatedPersonId = data["relatedPersonId"];
            this.relationTypeId = data["relationTypeId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.relationType = data["relationType"] ? PersonRelationType.fromJS(data["relationType"]) : <any>undefined;
            this.person = data["person"] ? Person.fromJS(data["person"]) : <any>undefined;
            this.relatedPerson = data["relatedPerson"] ? Person.fromJS(data["relatedPerson"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PersonRelation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["personId"] = this.personId;
        data["relatedPersonId"] = this.relatedPersonId;
        data["relationTypeId"] = this.relationTypeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["relationType"] = this.relationType ? this.relationType.toJSON() : <any>undefined;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["relatedPerson"] = this.relatedPerson ? this.relatedPerson.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPersonRelation {
    tenantId: number | undefined;
    personId: number | undefined;
    relatedPersonId: number | undefined;
    relationTypeId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    relationType: PersonRelationType | undefined;
    person: Person | undefined;
    relatedPerson: Person | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Interest implements IInterest {
    tenantId!: number | undefined;
    name!: string;
    personInterests!: PersonInterest[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IInterest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["personInterests"] && data["personInterests"].constructor === Array) {
                this.personInterests = [];
                for (let item of data["personInterests"])
                    this.personInterests.push(PersonInterest.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Interest {
        data = typeof data === 'object' ? data : {};
        let result = new Interest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.personInterests && this.personInterests.constructor === Array) {
            data["personInterests"] = [];
            for (let item of this.personInterests)
                data["personInterests"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInterest {
    tenantId: number | undefined;
    name: string;
    personInterests: PersonInterest[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PersonInterest implements IPersonInterest {
    tenantId!: number | undefined;
    personId!: number | undefined;
    interestId!: number | undefined;
    person!: Person | undefined;
    interest!: Interest | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPersonInterest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.personId = data["personId"];
            this.interestId = data["interestId"];
            this.person = data["person"] ? Person.fromJS(data["person"]) : <any>undefined;
            this.interest = data["interest"] ? Interest.fromJS(data["interest"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PersonInterest {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInterest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["personId"] = this.personId;
        data["interestId"] = this.interestId;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["interest"] = this.interest ? this.interest.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPersonInterest {
    tenantId: number | undefined;
    personId: number | undefined;
    interestId: number | undefined;
    person: Person | undefined;
    interest: Interest | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Person implements IPerson {
    tenantId!: number | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    primaryOrgRelationId!: number | undefined;
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    identityConfirmationDate!: moment.Moment | undefined;
    identityConfirmedByUserId!: number | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    orgRelations!: PersonOrgRelation[] | undefined;
    personRelations!: PersonRelation[] | undefined;
    reverseRelations!: PersonRelation[] | undefined;
    personInterests!: PersonInterest[] | undefined;
    contact!: Contact | undefined;
    citizenshipCountry!: Country | undefined;
    primaryOrgRelation!: PersonOrgRelation | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.primaryOrgRelationId = data["primaryOrgRelationId"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.identityConfirmationDate = data["identityConfirmationDate"] ? moment(data["identityConfirmationDate"].toString()) : <any>undefined;
            this.identityConfirmedByUserId = data["identityConfirmedByUserId"];
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            if (data["orgRelations"] && data["orgRelations"].constructor === Array) {
                this.orgRelations = [];
                for (let item of data["orgRelations"])
                    this.orgRelations.push(PersonOrgRelation.fromJS(item));
            }
            if (data["personRelations"] && data["personRelations"].constructor === Array) {
                this.personRelations = [];
                for (let item of data["personRelations"])
                    this.personRelations.push(PersonRelation.fromJS(item));
            }
            if (data["reverseRelations"] && data["reverseRelations"].constructor === Array) {
                this.reverseRelations = [];
                for (let item of data["reverseRelations"])
                    this.reverseRelations.push(PersonRelation.fromJS(item));
            }
            if (data["personInterests"] && data["personInterests"].constructor === Array) {
                this.personInterests = [];
                for (let item of data["personInterests"])
                    this.personInterests.push(PersonInterest.fromJS(item));
            }
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.citizenshipCountry = data["citizenshipCountry"] ? Country.fromJS(data["citizenshipCountry"]) : <any>undefined;
            this.primaryOrgRelation = data["primaryOrgRelation"] ? PersonOrgRelation.fromJS(data["primaryOrgRelation"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["primaryOrgRelationId"] = this.primaryOrgRelationId;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["identityConfirmationDate"] = this.identityConfirmationDate ? this.identityConfirmationDate.toISOString() : <any>undefined;
        data["identityConfirmedByUserId"] = this.identityConfirmedByUserId;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (this.orgRelations && this.orgRelations.constructor === Array) {
            data["orgRelations"] = [];
            for (let item of this.orgRelations)
                data["orgRelations"].push(item.toJSON());
        }
        if (this.personRelations && this.personRelations.constructor === Array) {
            data["personRelations"] = [];
            for (let item of this.personRelations)
                data["personRelations"].push(item.toJSON());
        }
        if (this.reverseRelations && this.reverseRelations.constructor === Array) {
            data["reverseRelations"] = [];
            for (let item of this.reverseRelations)
                data["reverseRelations"].push(item.toJSON());
        }
        if (this.personInterests && this.personInterests.constructor === Array) {
            data["personInterests"] = [];
            for (let item of this.personInterests)
                data["personInterests"].push(item.toJSON());
        }
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["citizenshipCountry"] = this.citizenshipCountry ? this.citizenshipCountry.toJSON() : <any>undefined;
        data["primaryOrgRelation"] = this.primaryOrgRelation ? this.primaryOrgRelation.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPerson {
    tenantId: number | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    primaryOrgRelationId: number | undefined;
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    identityConfirmationDate: moment.Moment | undefined;
    identityConfirmedByUserId: number | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    orgRelations: PersonOrgRelation[] | undefined;
    personRelations: PersonRelation[] | undefined;
    reverseRelations: PersonRelation[] | undefined;
    personInterests: PersonInterest[] | undefined;
    contact: Contact | undefined;
    citizenshipCountry: Country | undefined;
    primaryOrgRelation: PersonOrgRelation | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PersonOrgRelationType implements IPersonOrgRelationType {
    name!: string | undefined;
    relations!: PersonOrgRelation[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IPersonOrgRelationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["relations"] && data["relations"].constructor === Array) {
                this.relations = [];
                for (let item of data["relations"])
                    this.relations.push(PersonOrgRelation.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PersonOrgRelationType {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.relations && this.relations.constructor === Array) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPersonOrgRelationType {
    name: string | undefined;
    relations: PersonOrgRelation[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PersonOrgRelation implements IPersonOrgRelation {
    tenantId!: number | undefined;
    personId!: number | undefined;
    orgId!: number | undefined;
    relationTypeId!: string;
    jobTitle!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    person!: Person | undefined;
    organization!: Organization | undefined;
    relationType!: PersonOrgRelationType | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPersonOrgRelation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.personId = data["personId"];
            this.orgId = data["orgId"];
            this.relationTypeId = data["relationTypeId"];
            this.jobTitle = data["jobTitle"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.person = data["person"] ? Person.fromJS(data["person"]) : <any>undefined;
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.relationType = data["relationType"] ? PersonOrgRelationType.fromJS(data["relationType"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PersonOrgRelation {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["personId"] = this.personId;
        data["orgId"] = this.orgId;
        data["relationTypeId"] = this.relationTypeId;
        data["jobTitle"] = this.jobTitle;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["relationType"] = this.relationType ? this.relationType.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPersonOrgRelation {
    tenantId: number | undefined;
    personId: number | undefined;
    orgId: number | undefined;
    relationTypeId: string;
    jobTitle: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    person: Person | undefined;
    organization: Organization | undefined;
    relationType: PersonOrgRelationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrganizationAlias implements IOrganizationAlias {
    tenantId!: number | undefined;
    alias!: string;
    orgId!: number | undefined;
    organization!: Organization | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationAlias) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.alias = data["alias"];
            this.orgId = data["orgId"];
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationAlias {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationAlias();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["alias"] = this.alias;
        data["orgId"] = this.orgId;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationAlias {
    tenantId: number | undefined;
    alias: string;
    orgId: number | undefined;
    organization: Organization | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class BusinessCategory implements IBusinessCategory {
    tenantId!: number | undefined;
    name!: string;
    organizationBusinessCategories!: OrganizationBusinessCategory[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBusinessCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["organizationBusinessCategories"] && data["organizationBusinessCategories"].constructor === Array) {
                this.organizationBusinessCategories = [];
                for (let item of data["organizationBusinessCategories"])
                    this.organizationBusinessCategories.push(OrganizationBusinessCategory.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BusinessCategory {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.organizationBusinessCategories && this.organizationBusinessCategories.constructor === Array) {
            data["organizationBusinessCategories"] = [];
            for (let item of this.organizationBusinessCategories)
                data["organizationBusinessCategories"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusinessCategory {
    tenantId: number | undefined;
    name: string;
    organizationBusinessCategories: OrganizationBusinessCategory[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrganizationBusinessCategory implements IOrganizationBusinessCategory {
    tenantId!: number | undefined;
    orgId!: number | undefined;
    businessCategoryId!: number | undefined;
    organization!: Organization | undefined;
    businessCategory!: BusinessCategory | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationBusinessCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.orgId = data["orgId"];
            this.businessCategoryId = data["businessCategoryId"];
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.businessCategory = data["businessCategory"] ? BusinessCategory.fromJS(data["businessCategory"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationBusinessCategory {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationBusinessCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["orgId"] = this.orgId;
        data["businessCategoryId"] = this.businessCategoryId;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["businessCategory"] = this.businessCategory ? this.businessCategory.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationBusinessCategory {
    tenantId: number | undefined;
    orgId: number | undefined;
    businessCategoryId: number | undefined;
    organization: Organization | undefined;
    businessCategory: BusinessCategory | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PipelinePurpose implements IPipelinePurpose {
    name!: string;
    pipelines!: Pipeline[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IPipelinePurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["pipelines"] && data["pipelines"].constructor === Array) {
                this.pipelines = [];
                for (let item of data["pipelines"])
                    this.pipelines.push(Pipeline.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PipelinePurpose {
        data = typeof data === 'object' ? data : {};
        let result = new PipelinePurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.pipelines && this.pipelines.constructor === Array) {
            data["pipelines"] = [];
            for (let item of this.pipelines)
                data["pipelines"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPipelinePurpose {
    name: string;
    pipelines: Pipeline[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LeadType implements ILeadType {
    tenantId!: number | undefined;
    name!: string;
    sysId!: string | undefined;
    leads!: Lead[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeadType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            if (data["leads"] && data["leads"].constructor === Array) {
                this.leads = [];
                for (let item of data["leads"])
                    this.leads.push(Lead.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeadType {
        data = typeof data === 'object' ? data : {};
        let result = new LeadType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        if (this.leads && this.leads.constructor === Array) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeadType {
    tenantId: number | undefined;
    name: string;
    sysId: string | undefined;
    leads: Lead[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum PaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export class LeadInterest implements ILeadInterest {
    tenantId!: number | undefined;
    leadRequestId!: number | undefined;
    productId!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    quantity!: number | undefined;
    amount!: number | undefined;
    leadRequest!: LeadRequest | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeadInterest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.leadRequestId = data["leadRequestId"];
            this.productId = data["productId"];
            this.name = data["name"];
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.leadRequest = data["leadRequest"] ? LeadRequest.fromJS(data["leadRequest"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeadInterest {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInterest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["leadRequestId"] = this.leadRequestId;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["leadRequest"] = this.leadRequest ? this.leadRequest.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeadInterest {
    tenantId: number | undefined;
    leadRequestId: number | undefined;
    productId: number | undefined;
    name: string | undefined;
    description: string | undefined;
    quantity: number | undefined;
    amount: number | undefined;
    leadRequest: LeadRequest | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class LeadPersonalInfo implements ILeadPersonalInfo {
    tenantId!: number | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    title!: string | undefined;
    companyName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    ssn!: string | undefined;
    dob!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    website!: string | undefined;
    profileSummary!: string | undefined;
    leadRequest!: LeadRequest | undefined;
    citizenshipCountry!: Country | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    zip!: string | undefined;
    country!: Country | undefined;
    state!: CountryState | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeadPersonalInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            this.title = data["title"];
            this.companyName = data["companyName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.ssn = data["ssn"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.website = data["website"];
            this.profileSummary = data["profileSummary"];
            this.leadRequest = data["leadRequest"] ? LeadRequest.fromJS(data["leadRequest"]) : <any>undefined;
            this.citizenshipCountry = data["citizenshipCountry"] ? Country.fromJS(data["citizenshipCountry"]) : <any>undefined;
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.country = data["country"] ? Country.fromJS(data["country"]) : <any>undefined;
            this.state = data["state"] ? CountryState.fromJS(data["state"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeadPersonalInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LeadPersonalInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        data["title"] = this.title;
        data["companyName"] = this.companyName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["ssn"] = this.ssn;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["website"] = this.website;
        data["profileSummary"] = this.profileSummary;
        data["leadRequest"] = this.leadRequest ? this.leadRequest.toJSON() : <any>undefined;
        data["citizenshipCountry"] = this.citizenshipCountry ? this.citizenshipCountry.toJSON() : <any>undefined;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeadPersonalInfo {
    tenantId: number | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    title: string | undefined;
    companyName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    ssn: string | undefined;
    dob: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    website: string | undefined;
    profileSummary: string | undefined;
    leadRequest: LeadRequest | undefined;
    citizenshipCountry: Country | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    zip: string | undefined;
    country: Country | undefined;
    state: CountryState | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UTMParameter implements IUTMParameter {
    tenantId!: number | undefined;
    source!: string | undefined;
    medium!: string | undefined;
    campaign!: string | undefined;
    term!: string | undefined;
    content!: string | undefined;
    keyword!: string | undefined;
    adGroup!: string | undefined;
    name!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUTMParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.source = data["source"];
            this.medium = data["medium"];
            this.campaign = data["campaign"];
            this.term = data["term"];
            this.content = data["content"];
            this.keyword = data["keyword"];
            this.adGroup = data["adGroup"];
            this.name = data["name"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UTMParameter {
        data = typeof data === 'object' ? data : {};
        let result = new UTMParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["source"] = this.source;
        data["medium"] = this.medium;
        data["campaign"] = this.campaign;
        data["term"] = this.term;
        data["content"] = this.content;
        data["keyword"] = this.keyword;
        data["adGroup"] = this.adGroup;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUTMParameter {
    tenantId: number | undefined;
    source: string | undefined;
    medium: string | undefined;
    campaign: string | undefined;
    term: string | undefined;
    content: string | undefined;
    keyword: string | undefined;
    adGroup: string | undefined;
    name: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum PaymentInfoType {
    BankCard = "BankCard", 
    ACH = "ACH", 
    PayPal = "PayPal", 
}

export class PaymentInfoBankCard implements IPaymentInfoBankCard {
    tenantId!: number | undefined;
    holderName!: string;
    cardNumber!: string;
    expirationMonth!: string;
    expirationYear!: string;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingCountryCode!: string | undefined;
    paymentInfo!: PaymentInfo | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPaymentInfoBankCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingCountryCode = data["billingCountryCode"];
            this.paymentInfo = data["paymentInfo"] ? PaymentInfo.fromJS(data["paymentInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentInfoBankCard {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoBankCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingCountryCode"] = this.billingCountryCode;
        data["paymentInfo"] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentInfoBankCard {
    tenantId: number | undefined;
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingCountryCode: string | undefined;
    paymentInfo: PaymentInfo | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum CustomerAccountingType {
    _0 = 0, 
    _1 = 1, 
}

export class PaymentInfoACHCustomer implements IPaymentInfoACHCustomer {
    tenantId!: number | undefined;
    customerAcctType!: CustomerAccountingType | undefined;
    dln!: string | undefined;
    dlnState!: string | undefined;
    ssn!: string | undefined;
    paymentInfo!: PaymentInfo | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPaymentInfoACHCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.customerAcctType = data["customerAcctType"];
            this.dln = data["dln"];
            this.dlnState = data["dlnState"];
            this.ssn = data["ssn"];
            this.paymentInfo = data["paymentInfo"] ? PaymentInfo.fromJS(data["paymentInfo"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentInfoACHCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoACHCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["customerAcctType"] = this.customerAcctType;
        data["dln"] = this.dln;
        data["dlnState"] = this.dlnState;
        data["ssn"] = this.ssn;
        data["paymentInfo"] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentInfoACHCustomer {
    tenantId: number | undefined;
    customerAcctType: CustomerAccountingType | undefined;
    dln: string | undefined;
    dlnState: string | undefined;
    ssn: string | undefined;
    paymentInfo: PaymentInfo | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentInfo implements IPaymentInfo {
    tenantId!: number | undefined;
    userId!: number | undefined;
    gatewayName!: string;
    gatewayToken!: string;
    type!: PaymentInfoType | undefined;
    contactId!: number | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    dateOfBirth!: moment.Moment | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    zipCode!: string | undefined;
    bankCard!: PaymentInfoBankCard | undefined;
    achCustomer!: PaymentInfoACHCustomer | undefined;
    contact!: Contact | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.gatewayName = data["gatewayName"];
            this.gatewayToken = data["gatewayToken"];
            this.type = data["type"];
            this.contactId = data["contactId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.state = data["state"];
            this.country = data["country"];
            this.zipCode = data["zipCode"];
            this.bankCard = data["bankCard"] ? PaymentInfoBankCard.fromJS(data["bankCard"]) : <any>undefined;
            this.achCustomer = data["achCustomer"] ? PaymentInfoACHCustomer.fromJS(data["achCustomer"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["gatewayName"] = this.gatewayName;
        data["gatewayToken"] = this.gatewayToken;
        data["type"] = this.type;
        data["contactId"] = this.contactId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentInfo {
    tenantId: number | undefined;
    userId: number | undefined;
    gatewayName: string;
    gatewayToken: string;
    type: PaymentInfoType | undefined;
    contactId: number | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipCode: string | undefined;
    bankCard: PaymentInfoBankCard | undefined;
    achCustomer: PaymentInfoACHCustomer | undefined;
    contact: Contact | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum PaymentTransactionType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum PaymentTransactionStatus {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum RecurringPaymentFrequency {
    _0 = 0, 
    _1 = 1, 
}

export class SubscriptionStatus implements ISubscriptionStatus {
    name!: string;
    billingSubscriptions!: BillingSubscription[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ISubscriptionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["billingSubscriptions"] && data["billingSubscriptions"].constructor === Array) {
                this.billingSubscriptions = [];
                for (let item of data["billingSubscriptions"])
                    this.billingSubscriptions.push(BillingSubscription.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.billingSubscriptions && this.billingSubscriptions.constructor === Array) {
            data["billingSubscriptions"] = [];
            for (let item of this.billingSubscriptions)
                data["billingSubscriptions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionStatus {
    name: string;
    billingSubscriptions: BillingSubscription[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BillingSubscription implements IBillingSubscription {
    tenantId!: number | undefined;
    userId!: number | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    fee!: number;
    frequencyString!: string;
    frequency!: RecurringPaymentFrequency | undefined;
    gatewayName!: string;
    paymentInfoId!: number | undefined;
    paymentInfo!: PaymentInfo | undefined;
    gatewaySubscriptionId!: string | undefined;
    originator!: string | undefined;
    description!: string | undefined;
    messages!: string | undefined;
    errors!: string | undefined;
    statusId!: string;
    status!: SubscriptionStatus | undefined;
    transactions!: Transaction[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBillingSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.fee = data["fee"];
            this.frequencyString = data["frequencyString"];
            this.frequency = data["frequency"];
            this.gatewayName = data["gatewayName"];
            this.paymentInfoId = data["paymentInfoId"];
            this.paymentInfo = data["paymentInfo"] ? PaymentInfo.fromJS(data["paymentInfo"]) : <any>undefined;
            this.gatewaySubscriptionId = data["gatewaySubscriptionId"];
            this.originator = data["originator"];
            this.description = data["description"];
            this.messages = data["messages"];
            this.errors = data["errors"];
            this.statusId = data["statusId"];
            this.status = data["status"] ? SubscriptionStatus.fromJS(data["status"]) : <any>undefined;
            if (data["transactions"] && data["transactions"].constructor === Array) {
                this.transactions = [];
                for (let item of data["transactions"])
                    this.transactions.push(Transaction.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new BillingSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["fee"] = this.fee;
        data["frequencyString"] = this.frequencyString;
        data["frequency"] = this.frequency;
        data["gatewayName"] = this.gatewayName;
        data["paymentInfoId"] = this.paymentInfoId;
        data["paymentInfo"] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
        data["gatewaySubscriptionId"] = this.gatewaySubscriptionId;
        data["originator"] = this.originator;
        data["description"] = this.description;
        data["messages"] = this.messages;
        data["errors"] = this.errors;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        if (this.transactions && this.transactions.constructor === Array) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingSubscription {
    tenantId: number | undefined;
    userId: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    fee: number;
    frequencyString: string;
    frequency: RecurringPaymentFrequency | undefined;
    gatewayName: string;
    paymentInfoId: number | undefined;
    paymentInfo: PaymentInfo | undefined;
    gatewaySubscriptionId: string | undefined;
    originator: string | undefined;
    description: string | undefined;
    messages: string | undefined;
    errors: string | undefined;
    statusId: string;
    status: SubscriptionStatus | undefined;
    transactions: Transaction[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class TransactionLink implements ITransactionLink {
    tenantId!: number | undefined;
    linkType!: string;
    linkRef!: string;
    transactionId!: number | undefined;
    transaction!: Transaction | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITransactionLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.linkType = data["linkType"];
            this.linkRef = data["linkRef"];
            this.transactionId = data["transactionId"];
            this.transaction = data["transaction"] ? Transaction.fromJS(data["transaction"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TransactionLink {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["linkType"] = this.linkType;
        data["linkRef"] = this.linkRef;
        data["transactionId"] = this.transactionId;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITransactionLink {
    tenantId: number | undefined;
    linkType: string;
    linkRef: string;
    transactionId: number | undefined;
    transaction: Transaction | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class TransactionAction implements ITransactionAction {
    tenantId!: number | undefined;
    transactionId!: number | undefined;
    transaction!: Transaction | undefined;
    typeString!: string | undefined;
    type!: PaymentTransactionType | undefined;
    success!: boolean | undefined;
    errors!: string | undefined;
    gatewayTransactionId!: string | undefined;
    statusString!: string | undefined;
    status!: PaymentTransactionStatus | undefined;
    authorizationCode!: string | undefined;
    responseCode!: string | undefined;
    responseMessage!: string | undefined;
    messages!: string | undefined;
    avsResponseCode!: string | undefined;
    cvvResponseCode!: string | undefined;
    gatewayCreationDate!: moment.Moment | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITransactionAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.transactionId = data["transactionId"];
            this.transaction = data["transaction"] ? Transaction.fromJS(data["transaction"]) : <any>undefined;
            this.typeString = data["typeString"];
            this.type = data["type"];
            this.success = data["success"];
            this.errors = data["errors"];
            this.gatewayTransactionId = data["gatewayTransactionId"];
            this.statusString = data["statusString"];
            this.status = data["status"];
            this.authorizationCode = data["authorizationCode"];
            this.responseCode = data["responseCode"];
            this.responseMessage = data["responseMessage"];
            this.messages = data["messages"];
            this.avsResponseCode = data["avsResponseCode"];
            this.cvvResponseCode = data["cvvResponseCode"];
            this.gatewayCreationDate = data["gatewayCreationDate"] ? moment(data["gatewayCreationDate"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TransactionAction {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["transactionId"] = this.transactionId;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["typeString"] = this.typeString;
        data["type"] = this.type;
        data["success"] = this.success;
        data["errors"] = this.errors;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["statusString"] = this.statusString;
        data["status"] = this.status;
        data["authorizationCode"] = this.authorizationCode;
        data["responseCode"] = this.responseCode;
        data["responseMessage"] = this.responseMessage;
        data["messages"] = this.messages;
        data["avsResponseCode"] = this.avsResponseCode;
        data["cvvResponseCode"] = this.cvvResponseCode;
        data["gatewayCreationDate"] = this.gatewayCreationDate ? this.gatewayCreationDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITransactionAction {
    tenantId: number | undefined;
    transactionId: number | undefined;
    transaction: Transaction | undefined;
    typeString: string | undefined;
    type: PaymentTransactionType | undefined;
    success: boolean | undefined;
    errors: string | undefined;
    gatewayTransactionId: string | undefined;
    statusString: string | undefined;
    status: PaymentTransactionStatus | undefined;
    authorizationCode: string | undefined;
    responseCode: string | undefined;
    responseMessage: string | undefined;
    messages: string | undefined;
    avsResponseCode: string | undefined;
    cvvResponseCode: string | undefined;
    gatewayCreationDate: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrderSubscription implements IOrderSubscription {
    tenantId!: number | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    fee!: number;
    serviceType!: string | undefined;
    serviceId!: string | undefined;
    serviceTypeId!: number | undefined;
    serviceName!: string | undefined;
    serviceCapacity!: number | undefined;
    orderId!: number | undefined;
    frequencyString!: string | undefined;
    frequency!: RecurringPaymentFrequency | undefined;
    trialDayCount!: number | undefined;
    statusId!: string;
    isTrial!: boolean | undefined;
    isLocked!: boolean;
    hasRecurringBilling!: boolean | undefined;
    previousOrderSubscriptionId!: number | undefined;
    lastExpiryNotificationDate!: moment.Moment | undefined;
    order!: Order | undefined;
    status!: SubscriptionStatus | undefined;
    previousOrderSubscription!: OrderSubscription | undefined;
    orderSubscriptionPayments!: OrderSubscriptionPayment[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrderSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.fee = data["fee"];
            this.serviceType = data["serviceType"];
            this.serviceId = data["serviceId"];
            this.serviceTypeId = data["serviceTypeId"];
            this.serviceName = data["serviceName"];
            this.serviceCapacity = data["serviceCapacity"];
            this.orderId = data["orderId"];
            this.frequencyString = data["frequencyString"];
            this.frequency = data["frequency"];
            this.trialDayCount = data["trialDayCount"];
            this.statusId = data["statusId"];
            this.isTrial = data["isTrial"];
            this.isLocked = data["isLocked"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.previousOrderSubscriptionId = data["previousOrderSubscriptionId"];
            this.lastExpiryNotificationDate = data["lastExpiryNotificationDate"] ? moment(data["lastExpiryNotificationDate"].toString()) : <any>undefined;
            this.order = data["order"] ? Order.fromJS(data["order"]) : <any>undefined;
            this.status = data["status"] ? SubscriptionStatus.fromJS(data["status"]) : <any>undefined;
            this.previousOrderSubscription = data["previousOrderSubscription"] ? OrderSubscription.fromJS(data["previousOrderSubscription"]) : <any>undefined;
            if (data["orderSubscriptionPayments"] && data["orderSubscriptionPayments"].constructor === Array) {
                this.orderSubscriptionPayments = [];
                for (let item of data["orderSubscriptionPayments"])
                    this.orderSubscriptionPayments.push(OrderSubscriptionPayment.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["fee"] = this.fee;
        data["serviceType"] = this.serviceType;
        data["serviceId"] = this.serviceId;
        data["serviceTypeId"] = this.serviceTypeId;
        data["serviceName"] = this.serviceName;
        data["serviceCapacity"] = this.serviceCapacity;
        data["orderId"] = this.orderId;
        data["frequencyString"] = this.frequencyString;
        data["frequency"] = this.frequency;
        data["trialDayCount"] = this.trialDayCount;
        data["statusId"] = this.statusId;
        data["isTrial"] = this.isTrial;
        data["isLocked"] = this.isLocked;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["previousOrderSubscriptionId"] = this.previousOrderSubscriptionId;
        data["lastExpiryNotificationDate"] = this.lastExpiryNotificationDate ? this.lastExpiryNotificationDate.toISOString() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["previousOrderSubscription"] = this.previousOrderSubscription ? this.previousOrderSubscription.toJSON() : <any>undefined;
        if (this.orderSubscriptionPayments && this.orderSubscriptionPayments.constructor === Array) {
            data["orderSubscriptionPayments"] = [];
            for (let item of this.orderSubscriptionPayments)
                data["orderSubscriptionPayments"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderSubscription {
    tenantId: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    fee: number;
    serviceType: string | undefined;
    serviceId: string | undefined;
    serviceTypeId: number | undefined;
    serviceName: string | undefined;
    serviceCapacity: number | undefined;
    orderId: number | undefined;
    frequencyString: string | undefined;
    frequency: RecurringPaymentFrequency | undefined;
    trialDayCount: number | undefined;
    statusId: string;
    isTrial: boolean | undefined;
    isLocked: boolean;
    hasRecurringBilling: boolean | undefined;
    previousOrderSubscriptionId: number | undefined;
    lastExpiryNotificationDate: moment.Moment | undefined;
    order: Order | undefined;
    status: SubscriptionStatus | undefined;
    previousOrderSubscription: OrderSubscription | undefined;
    orderSubscriptionPayments: OrderSubscriptionPayment[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrderSubscriptionPayment implements IOrderSubscriptionPayment {
    tenantId!: number | undefined;
    orderSubscriptionId!: number | undefined;
    startDate!: moment.Moment;
    endDate!: moment.Moment | undefined;
    status!: string | undefined;
    transactionId!: number | undefined;
    billingSubscriptionId!: number | undefined;
    orderSubscription!: OrderSubscription | undefined;
    transaction!: Transaction | undefined;
    billingSubscription!: BillingSubscription | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrderSubscriptionPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.orderSubscriptionId = data["orderSubscriptionId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.transactionId = data["transactionId"];
            this.billingSubscriptionId = data["billingSubscriptionId"];
            this.orderSubscription = data["orderSubscription"] ? OrderSubscription.fromJS(data["orderSubscription"]) : <any>undefined;
            this.transaction = data["transaction"] ? Transaction.fromJS(data["transaction"]) : <any>undefined;
            this.billingSubscription = data["billingSubscription"] ? BillingSubscription.fromJS(data["billingSubscription"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderSubscriptionPayment {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSubscriptionPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["orderSubscriptionId"] = this.orderSubscriptionId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["transactionId"] = this.transactionId;
        data["billingSubscriptionId"] = this.billingSubscriptionId;
        data["orderSubscription"] = this.orderSubscription ? this.orderSubscription.toJSON() : <any>undefined;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["billingSubscription"] = this.billingSubscription ? this.billingSubscription.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderSubscriptionPayment {
    tenantId: number | undefined;
    orderSubscriptionId: number | undefined;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    status: string | undefined;
    transactionId: number | undefined;
    billingSubscriptionId: number | undefined;
    orderSubscription: OrderSubscription | undefined;
    transaction: Transaction | undefined;
    billingSubscription: BillingSubscription | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Transaction implements ITransaction {
    tenantId!: number | undefined;
    userId!: number | undefined;
    paymentInfoId!: number | undefined;
    paymentInfo!: PaymentInfo | undefined;
    ipAddress!: string | undefined;
    originTransactionId!: number | undefined;
    originTransaction!: Transaction | undefined;
    amount!: number | undefined;
    typeString!: string | undefined;
    type!: PaymentTransactionType | undefined;
    success!: boolean | undefined;
    errors!: string | undefined;
    gatewayName!: string | undefined;
    gatewayTransactionId!: string | undefined;
    gatewayOriginTransactionId!: string | undefined;
    statusString!: string | undefined;
    status!: PaymentTransactionStatus | undefined;
    authorizationCode!: string | undefined;
    responseCode!: string | undefined;
    responseMessage!: string | undefined;
    messages!: string | undefined;
    avsResponseCode!: string | undefined;
    cvvResponseCode!: string | undefined;
    gatewayCreationDate!: moment.Moment | undefined;
    originator!: string | undefined;
    description!: string | undefined;
    billingSubscriptionId!: number | undefined;
    billingSubscription!: BillingSubscription | undefined;
    childTransactions!: Transaction[] | undefined;
    transactionLinks!: TransactionLink[] | undefined;
    transactionActions!: TransactionAction[] | undefined;
    orderSubscriptionPayments!: OrderSubscriptionPayment[] | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.paymentInfoId = data["paymentInfoId"];
            this.paymentInfo = data["paymentInfo"] ? PaymentInfo.fromJS(data["paymentInfo"]) : <any>undefined;
            this.ipAddress = data["ipAddress"];
            this.originTransactionId = data["originTransactionId"];
            this.originTransaction = data["originTransaction"] ? Transaction.fromJS(data["originTransaction"]) : <any>undefined;
            this.amount = data["amount"];
            this.typeString = data["typeString"];
            this.type = data["type"];
            this.success = data["success"];
            this.errors = data["errors"];
            this.gatewayName = data["gatewayName"];
            this.gatewayTransactionId = data["gatewayTransactionId"];
            this.gatewayOriginTransactionId = data["gatewayOriginTransactionId"];
            this.statusString = data["statusString"];
            this.status = data["status"];
            this.authorizationCode = data["authorizationCode"];
            this.responseCode = data["responseCode"];
            this.responseMessage = data["responseMessage"];
            this.messages = data["messages"];
            this.avsResponseCode = data["avsResponseCode"];
            this.cvvResponseCode = data["cvvResponseCode"];
            this.gatewayCreationDate = data["gatewayCreationDate"] ? moment(data["gatewayCreationDate"].toString()) : <any>undefined;
            this.originator = data["originator"];
            this.description = data["description"];
            this.billingSubscriptionId = data["billingSubscriptionId"];
            this.billingSubscription = data["billingSubscription"] ? BillingSubscription.fromJS(data["billingSubscription"]) : <any>undefined;
            if (data["childTransactions"] && data["childTransactions"].constructor === Array) {
                this.childTransactions = [];
                for (let item of data["childTransactions"])
                    this.childTransactions.push(Transaction.fromJS(item));
            }
            if (data["transactionLinks"] && data["transactionLinks"].constructor === Array) {
                this.transactionLinks = [];
                for (let item of data["transactionLinks"])
                    this.transactionLinks.push(TransactionLink.fromJS(item));
            }
            if (data["transactionActions"] && data["transactionActions"].constructor === Array) {
                this.transactionActions = [];
                for (let item of data["transactionActions"])
                    this.transactionActions.push(TransactionAction.fromJS(item));
            }
            if (data["orderSubscriptionPayments"] && data["orderSubscriptionPayments"].constructor === Array) {
                this.orderSubscriptionPayments = [];
                for (let item of data["orderSubscriptionPayments"])
                    this.orderSubscriptionPayments.push(OrderSubscriptionPayment.fromJS(item));
            }
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["paymentInfoId"] = this.paymentInfoId;
        data["paymentInfo"] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
        data["ipAddress"] = this.ipAddress;
        data["originTransactionId"] = this.originTransactionId;
        data["originTransaction"] = this.originTransaction ? this.originTransaction.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["typeString"] = this.typeString;
        data["type"] = this.type;
        data["success"] = this.success;
        data["errors"] = this.errors;
        data["gatewayName"] = this.gatewayName;
        data["gatewayTransactionId"] = this.gatewayTransactionId;
        data["gatewayOriginTransactionId"] = this.gatewayOriginTransactionId;
        data["statusString"] = this.statusString;
        data["status"] = this.status;
        data["authorizationCode"] = this.authorizationCode;
        data["responseCode"] = this.responseCode;
        data["responseMessage"] = this.responseMessage;
        data["messages"] = this.messages;
        data["avsResponseCode"] = this.avsResponseCode;
        data["cvvResponseCode"] = this.cvvResponseCode;
        data["gatewayCreationDate"] = this.gatewayCreationDate ? this.gatewayCreationDate.toISOString() : <any>undefined;
        data["originator"] = this.originator;
        data["description"] = this.description;
        data["billingSubscriptionId"] = this.billingSubscriptionId;
        data["billingSubscription"] = this.billingSubscription ? this.billingSubscription.toJSON() : <any>undefined;
        if (this.childTransactions && this.childTransactions.constructor === Array) {
            data["childTransactions"] = [];
            for (let item of this.childTransactions)
                data["childTransactions"].push(item.toJSON());
        }
        if (this.transactionLinks && this.transactionLinks.constructor === Array) {
            data["transactionLinks"] = [];
            for (let item of this.transactionLinks)
                data["transactionLinks"].push(item.toJSON());
        }
        if (this.transactionActions && this.transactionActions.constructor === Array) {
            data["transactionActions"] = [];
            for (let item of this.transactionActions)
                data["transactionActions"].push(item.toJSON());
        }
        if (this.orderSubscriptionPayments && this.orderSubscriptionPayments.constructor === Array) {
            data["orderSubscriptionPayments"] = [];
            for (let item of this.orderSubscriptionPayments)
                data["orderSubscriptionPayments"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITransaction {
    tenantId: number | undefined;
    userId: number | undefined;
    paymentInfoId: number | undefined;
    paymentInfo: PaymentInfo | undefined;
    ipAddress: string | undefined;
    originTransactionId: number | undefined;
    originTransaction: Transaction | undefined;
    amount: number | undefined;
    typeString: string | undefined;
    type: PaymentTransactionType | undefined;
    success: boolean | undefined;
    errors: string | undefined;
    gatewayName: string | undefined;
    gatewayTransactionId: string | undefined;
    gatewayOriginTransactionId: string | undefined;
    statusString: string | undefined;
    status: PaymentTransactionStatus | undefined;
    authorizationCode: string | undefined;
    responseCode: string | undefined;
    responseMessage: string | undefined;
    messages: string | undefined;
    avsResponseCode: string | undefined;
    cvvResponseCode: string | undefined;
    gatewayCreationDate: moment.Moment | undefined;
    originator: string | undefined;
    description: string | undefined;
    billingSubscriptionId: number | undefined;
    billingSubscription: BillingSubscription | undefined;
    childTransactions: Transaction[] | undefined;
    transactionLinks: TransactionLink[] | undefined;
    transactionActions: TransactionAction[] | undefined;
    orderSubscriptionPayments: OrderSubscriptionPayment[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class LeadRequest implements ILeadRequest {
    tenantId!: number | undefined;
    leadId!: number | undefined;
    leadRequestDate!: moment.Moment | undefined;
    channelCode!: string | undefined;
    campaignCode!: string | undefined;
    sourceCode!: string | undefined;
    affiliateCode!: string | undefined;
    clientXref!: string | undefined;
    clientIp!: string | undefined;
    leadRequestXref!: string | undefined;
    userAgent!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    utmParameterId!: number | undefined;
    gclId!: string | undefined;
    lastTransactionId!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    clickId!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    isHelpNeeded!: boolean | undefined;
    comments!: string | undefined;
    lead!: Lead | undefined;
    leadInterests!: LeadInterest[] | undefined;
    leadPersonalInfo!: LeadPersonalInfo | undefined;
    utmParameter!: UTMParameter | undefined;
    lastTransaction!: Transaction | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.leadId = data["leadId"];
            this.leadRequestDate = data["leadRequestDate"] ? moment(data["leadRequestDate"].toString()) : <any>undefined;
            this.channelCode = data["channelCode"];
            this.campaignCode = data["campaignCode"];
            this.sourceCode = data["sourceCode"];
            this.affiliateCode = data["affiliateCode"];
            this.clientXref = data["clientXref"];
            this.clientIp = data["clientIp"];
            this.leadRequestXref = data["leadRequestXref"];
            this.userAgent = data["userAgent"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.utmParameterId = data["utmParameterId"];
            this.gclId = data["gclId"];
            this.lastTransactionId = data["lastTransactionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.clickId = data["clickId"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.isHelpNeeded = data["isHelpNeeded"];
            this.comments = data["comments"];
            this.lead = data["lead"] ? Lead.fromJS(data["lead"]) : <any>undefined;
            if (data["leadInterests"] && data["leadInterests"].constructor === Array) {
                this.leadInterests = [];
                for (let item of data["leadInterests"])
                    this.leadInterests.push(LeadInterest.fromJS(item));
            }
            this.leadPersonalInfo = data["leadPersonalInfo"] ? LeadPersonalInfo.fromJS(data["leadPersonalInfo"]) : <any>undefined;
            this.utmParameter = data["utmParameter"] ? UTMParameter.fromJS(data["utmParameter"]) : <any>undefined;
            this.lastTransaction = data["lastTransaction"] ? Transaction.fromJS(data["lastTransaction"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["leadId"] = this.leadId;
        data["leadRequestDate"] = this.leadRequestDate ? this.leadRequestDate.toISOString() : <any>undefined;
        data["channelCode"] = this.channelCode;
        data["campaignCode"] = this.campaignCode;
        data["sourceCode"] = this.sourceCode;
        data["affiliateCode"] = this.affiliateCode;
        data["clientXref"] = this.clientXref;
        data["clientIp"] = this.clientIp;
        data["leadRequestXref"] = this.leadRequestXref;
        data["userAgent"] = this.userAgent;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["utmParameterId"] = this.utmParameterId;
        data["gclId"] = this.gclId;
        data["lastTransactionId"] = this.lastTransactionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["clickId"] = this.clickId;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["isHelpNeeded"] = this.isHelpNeeded;
        data["comments"] = this.comments;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        if (this.leadInterests && this.leadInterests.constructor === Array) {
            data["leadInterests"] = [];
            for (let item of this.leadInterests)
                data["leadInterests"].push(item.toJSON());
        }
        data["leadPersonalInfo"] = this.leadPersonalInfo ? this.leadPersonalInfo.toJSON() : <any>undefined;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["lastTransaction"] = this.lastTransaction ? this.lastTransaction.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeadRequest {
    tenantId: number | undefined;
    leadId: number | undefined;
    leadRequestDate: moment.Moment | undefined;
    channelCode: string | undefined;
    campaignCode: string | undefined;
    sourceCode: string | undefined;
    affiliateCode: string | undefined;
    clientXref: string | undefined;
    clientIp: string | undefined;
    leadRequestXref: string | undefined;
    userAgent: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    utmParameterId: number | undefined;
    gclId: string | undefined;
    lastTransactionId: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    clickId: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    isHelpNeeded: boolean | undefined;
    comments: string | undefined;
    lead: Lead | undefined;
    leadInterests: LeadInterest[] | undefined;
    leadPersonalInfo: LeadPersonalInfo | undefined;
    utmParameter: UTMParameter | undefined;
    lastTransaction: Transaction | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActionAccessibilityMapping implements IActionAccessibilityMapping {
    tenantId!: number | undefined;
    pipelineId!: number | undefined;
    actionId!: number | undefined;
    stageId!: number | undefined;
    pipeline!: Pipeline | undefined;
    action!: WorkflowAction | undefined;
    stage!: Stage | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActionAccessibilityMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.pipelineId = data["pipelineId"];
            this.actionId = data["actionId"];
            this.stageId = data["stageId"];
            this.pipeline = data["pipeline"] ? Pipeline.fromJS(data["pipeline"]) : <any>undefined;
            this.action = data["action"] ? WorkflowAction.fromJS(data["action"]) : <any>undefined;
            this.stage = data["stage"] ? Stage.fromJS(data["stage"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActionAccessibilityMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ActionAccessibilityMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["pipelineId"] = this.pipelineId;
        data["actionId"] = this.actionId;
        data["stageId"] = this.stageId;
        data["pipeline"] = this.pipeline ? this.pipeline.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["stage"] = this.stage ? this.stage.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActionAccessibilityMapping {
    tenantId: number | undefined;
    pipelineId: number | undefined;
    actionId: number | undefined;
    stageId: number | undefined;
    pipeline: Pipeline | undefined;
    action: WorkflowAction | undefined;
    stage: Stage | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActionLog implements IActionLog {
    tenantId!: number | undefined;
    entityType!: string;
    entityId!: number | undefined;
    actionId!: number | undefined;
    prevStageId!: number | undefined;
    nextStageId!: number | undefined;
    action!: WorkflowAction | undefined;
    prevStage!: Stage | undefined;
    nextStage!: Stage | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActionLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.entityType = data["entityType"];
            this.entityId = data["entityId"];
            this.actionId = data["actionId"];
            this.prevStageId = data["prevStageId"];
            this.nextStageId = data["nextStageId"];
            this.action = data["action"] ? WorkflowAction.fromJS(data["action"]) : <any>undefined;
            this.prevStage = data["prevStage"] ? Stage.fromJS(data["prevStage"]) : <any>undefined;
            this.nextStage = data["nextStage"] ? Stage.fromJS(data["nextStage"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActionLog {
        data = typeof data === 'object' ? data : {};
        let result = new ActionLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["actionId"] = this.actionId;
        data["prevStageId"] = this.prevStageId;
        data["nextStageId"] = this.nextStageId;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["prevStage"] = this.prevStage ? this.prevStage.toJSON() : <any>undefined;
        data["nextStage"] = this.nextStage ? this.nextStage.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActionLog {
    tenantId: number | undefined;
    entityType: string;
    entityId: number | undefined;
    actionId: number | undefined;
    prevStageId: number | undefined;
    nextStageId: number | undefined;
    action: WorkflowAction | undefined;
    prevStage: Stage | undefined;
    nextStage: Stage | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class WorkflowAction implements IWorkflowAction {
    tenantId!: number | undefined;
    name!: string;
    sysId!: string | undefined;
    actionTransitionMappings!: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings!: ActionAccessibilityMapping[] | undefined;
    actionLogs!: ActionLog[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWorkflowAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            if (data["actionTransitionMappings"] && data["actionTransitionMappings"].constructor === Array) {
                this.actionTransitionMappings = [];
                for (let item of data["actionTransitionMappings"])
                    this.actionTransitionMappings.push(ActionTransitionMapping.fromJS(item));
            }
            if (data["actionAccessibilityMappings"] && data["actionAccessibilityMappings"].constructor === Array) {
                this.actionAccessibilityMappings = [];
                for (let item of data["actionAccessibilityMappings"])
                    this.actionAccessibilityMappings.push(ActionAccessibilityMapping.fromJS(item));
            }
            if (data["actionLogs"] && data["actionLogs"].constructor === Array) {
                this.actionLogs = [];
                for (let item of data["actionLogs"])
                    this.actionLogs.push(ActionLog.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkflowAction {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        if (this.actionTransitionMappings && this.actionTransitionMappings.constructor === Array) {
            data["actionTransitionMappings"] = [];
            for (let item of this.actionTransitionMappings)
                data["actionTransitionMappings"].push(item.toJSON());
        }
        if (this.actionAccessibilityMappings && this.actionAccessibilityMappings.constructor === Array) {
            data["actionAccessibilityMappings"] = [];
            for (let item of this.actionAccessibilityMappings)
                data["actionAccessibilityMappings"].push(item.toJSON());
        }
        if (this.actionLogs && this.actionLogs.constructor === Array) {
            data["actionLogs"] = [];
            for (let item of this.actionLogs)
                data["actionLogs"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkflowAction {
    tenantId: number | undefined;
    name: string;
    sysId: string | undefined;
    actionTransitionMappings: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings: ActionAccessibilityMapping[] | undefined;
    actionLogs: ActionLog[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActionTransitionMapping implements IActionTransitionMapping {
    tenantId!: number | undefined;
    pipelineId!: number | undefined;
    actionId!: number | undefined;
    stageId!: number | undefined;
    pipeline!: Pipeline | undefined;
    action!: WorkflowAction | undefined;
    stage!: Stage | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IActionTransitionMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.pipelineId = data["pipelineId"];
            this.actionId = data["actionId"];
            this.stageId = data["stageId"];
            this.pipeline = data["pipeline"] ? Pipeline.fromJS(data["pipeline"]) : <any>undefined;
            this.action = data["action"] ? WorkflowAction.fromJS(data["action"]) : <any>undefined;
            this.stage = data["stage"] ? Stage.fromJS(data["stage"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActionTransitionMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ActionTransitionMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["pipelineId"] = this.pipelineId;
        data["actionId"] = this.actionId;
        data["stageId"] = this.stageId;
        data["pipeline"] = this.pipeline ? this.pipeline.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["stage"] = this.stage ? this.stage.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IActionTransitionMapping {
    tenantId: number | undefined;
    pipelineId: number | undefined;
    actionId: number | undefined;
    stageId: number | undefined;
    pipeline: Pipeline | undefined;
    action: WorkflowAction | undefined;
    stage: Stage | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Stage implements IStage {
    tenantId!: number | undefined;
    pipelineId!: number | undefined;
    name!: string;
    color!: string | undefined;
    sortOrder!: number | undefined;
    isFinal!: boolean;
    pipeline!: Pipeline | undefined;
    actionTransitionMappings!: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings!: ActionAccessibilityMapping[] | undefined;
    leads!: Lead[] | undefined;
    orders!: Order[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IStage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.pipelineId = data["pipelineId"];
            this.name = data["name"];
            this.color = data["color"];
            this.sortOrder = data["sortOrder"];
            this.isFinal = data["isFinal"];
            this.pipeline = data["pipeline"] ? Pipeline.fromJS(data["pipeline"]) : <any>undefined;
            if (data["actionTransitionMappings"] && data["actionTransitionMappings"].constructor === Array) {
                this.actionTransitionMappings = [];
                for (let item of data["actionTransitionMappings"])
                    this.actionTransitionMappings.push(ActionTransitionMapping.fromJS(item));
            }
            if (data["actionAccessibilityMappings"] && data["actionAccessibilityMappings"].constructor === Array) {
                this.actionAccessibilityMappings = [];
                for (let item of data["actionAccessibilityMappings"])
                    this.actionAccessibilityMappings.push(ActionAccessibilityMapping.fromJS(item));
            }
            if (data["leads"] && data["leads"].constructor === Array) {
                this.leads = [];
                for (let item of data["leads"])
                    this.leads.push(Lead.fromJS(item));
            }
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(Order.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Stage {
        data = typeof data === 'object' ? data : {};
        let result = new Stage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["pipelineId"] = this.pipelineId;
        data["name"] = this.name;
        data["color"] = this.color;
        data["sortOrder"] = this.sortOrder;
        data["isFinal"] = this.isFinal;
        data["pipeline"] = this.pipeline ? this.pipeline.toJSON() : <any>undefined;
        if (this.actionTransitionMappings && this.actionTransitionMappings.constructor === Array) {
            data["actionTransitionMappings"] = [];
            for (let item of this.actionTransitionMappings)
                data["actionTransitionMappings"].push(item.toJSON());
        }
        if (this.actionAccessibilityMappings && this.actionAccessibilityMappings.constructor === Array) {
            data["actionAccessibilityMappings"] = [];
            for (let item of this.actionAccessibilityMappings)
                data["actionAccessibilityMappings"].push(item.toJSON());
        }
        if (this.leads && this.leads.constructor === Array) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStage {
    tenantId: number | undefined;
    pipelineId: number | undefined;
    name: string;
    color: string | undefined;
    sortOrder: number | undefined;
    isFinal: boolean;
    pipeline: Pipeline | undefined;
    actionTransitionMappings: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings: ActionAccessibilityMapping[] | undefined;
    leads: Lead[] | undefined;
    orders: Order[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class LeadCancellationReason implements ILeadCancellationReason {
    name!: string | undefined;
    isCommentRequired!: boolean | undefined;
    sortOrder!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ILeadCancellationReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isCommentRequired = data["isCommentRequired"];
            this.sortOrder = data["sortOrder"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeadCancellationReason {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isCommentRequired"] = this.isCommentRequired;
        data["sortOrder"] = this.sortOrder;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeadCancellationReason {
    name: string | undefined;
    isCommentRequired: boolean | undefined;
    sortOrder: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Lead implements ILead {
    pipelinePurposeId!: string | undefined;
    tenantId!: number | undefined;
    typeId!: number | undefined;
    contactGroupId!: string;
    contactId!: number | undefined;
    orderId!: number | undefined;
    primaryLeadRequestId!: number | undefined;
    stageId!: number | undefined;
    sortOrder!: number | undefined;
    dateCompleted!: moment.Moment | undefined;
    cancellationReasonId!: string | undefined;
    cancellationComment!: string | undefined;
    leadType!: LeadType | undefined;
    contactGroup!: ContactGroup | undefined;
    customer!: Contact | undefined;
    order!: Order | undefined;
    primaryLeadRequest!: LeadRequest | undefined;
    stage!: Stage | undefined;
    cancellationReason!: LeadCancellationReason | undefined;
    leadRequests!: LeadRequest[] | undefined;
    orders!: Order[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelinePurposeId = data["pipelinePurposeId"];
            this.tenantId = data["tenantId"];
            this.typeId = data["typeId"];
            this.contactGroupId = data["contactGroupId"];
            this.contactId = data["contactId"];
            this.orderId = data["orderId"];
            this.primaryLeadRequestId = data["primaryLeadRequestId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
            this.dateCompleted = data["dateCompleted"] ? moment(data["dateCompleted"].toString()) : <any>undefined;
            this.cancellationReasonId = data["cancellationReasonId"];
            this.cancellationComment = data["cancellationComment"];
            this.leadType = data["leadType"] ? LeadType.fromJS(data["leadType"]) : <any>undefined;
            this.contactGroup = data["contactGroup"] ? ContactGroup.fromJS(data["contactGroup"]) : <any>undefined;
            this.customer = data["customer"] ? Contact.fromJS(data["customer"]) : <any>undefined;
            this.order = data["order"] ? Order.fromJS(data["order"]) : <any>undefined;
            this.primaryLeadRequest = data["primaryLeadRequest"] ? LeadRequest.fromJS(data["primaryLeadRequest"]) : <any>undefined;
            this.stage = data["stage"] ? Stage.fromJS(data["stage"]) : <any>undefined;
            this.cancellationReason = data["cancellationReason"] ? LeadCancellationReason.fromJS(data["cancellationReason"]) : <any>undefined;
            if (data["leadRequests"] && data["leadRequests"].constructor === Array) {
                this.leadRequests = [];
                for (let item of data["leadRequests"])
                    this.leadRequests.push(LeadRequest.fromJS(item));
            }
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(Order.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Lead {
        data = typeof data === 'object' ? data : {};
        let result = new Lead();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelinePurposeId"] = this.pipelinePurposeId;
        data["tenantId"] = this.tenantId;
        data["typeId"] = this.typeId;
        data["contactGroupId"] = this.contactGroupId;
        data["contactId"] = this.contactId;
        data["orderId"] = this.orderId;
        data["primaryLeadRequestId"] = this.primaryLeadRequestId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["cancellationReasonId"] = this.cancellationReasonId;
        data["cancellationComment"] = this.cancellationComment;
        data["leadType"] = this.leadType ? this.leadType.toJSON() : <any>undefined;
        data["contactGroup"] = this.contactGroup ? this.contactGroup.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["primaryLeadRequest"] = this.primaryLeadRequest ? this.primaryLeadRequest.toJSON() : <any>undefined;
        data["stage"] = this.stage ? this.stage.toJSON() : <any>undefined;
        data["cancellationReason"] = this.cancellationReason ? this.cancellationReason.toJSON() : <any>undefined;
        if (this.leadRequests && this.leadRequests.constructor === Array) {
            data["leadRequests"] = [];
            for (let item of this.leadRequests)
                data["leadRequests"].push(item.toJSON());
        }
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILead {
    pipelinePurposeId: string | undefined;
    tenantId: number | undefined;
    typeId: number | undefined;
    contactGroupId: string;
    contactId: number | undefined;
    orderId: number | undefined;
    primaryLeadRequestId: number | undefined;
    stageId: number | undefined;
    sortOrder: number | undefined;
    dateCompleted: moment.Moment | undefined;
    cancellationReasonId: string | undefined;
    cancellationComment: string | undefined;
    leadType: LeadType | undefined;
    contactGroup: ContactGroup | undefined;
    customer: Contact | undefined;
    order: Order | undefined;
    primaryLeadRequest: LeadRequest | undefined;
    stage: Stage | undefined;
    cancellationReason: LeadCancellationReason | undefined;
    leadRequests: LeadRequest[] | undefined;
    orders: Order[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactGroup implements IContactGroup {
    name!: string | undefined;
    contacts!: Contact[] | undefined;
    leads!: Lead[] | undefined;
    pipelines!: Pipeline[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IContactGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            if (data["leads"] && data["leads"].constructor === Array) {
                this.leads = [];
                for (let item of data["leads"])
                    this.leads.push(Lead.fromJS(item));
            }
            if (data["pipelines"] && data["pipelines"].constructor === Array) {
                this.pipelines = [];
                for (let item of data["pipelines"])
                    this.pipelines.push(Pipeline.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (this.leads && this.leads.constructor === Array) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        if (this.pipelines && this.pipelines.constructor === Array) {
            data["pipelines"] = [];
            for (let item of this.pipelines)
                data["pipelines"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactGroup {
    name: string | undefined;
    contacts: Contact[] | undefined;
    leads: Lead[] | undefined;
    pipelines: Pipeline[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Pipeline implements IPipeline {
    tenantId!: number | undefined;
    name!: string;
    purposeId!: string;
    contactGroupId!: string | undefined;
    purpose!: PipelinePurpose | undefined;
    contactGroup!: ContactGroup | undefined;
    stages!: Stage[] | undefined;
    actionTransitionMappings!: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings!: ActionAccessibilityMapping[] | undefined;
    orderTypes!: OrderType[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.purposeId = data["purposeId"];
            this.contactGroupId = data["contactGroupId"];
            this.purpose = data["purpose"] ? PipelinePurpose.fromJS(data["purpose"]) : <any>undefined;
            this.contactGroup = data["contactGroup"] ? ContactGroup.fromJS(data["contactGroup"]) : <any>undefined;
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(Stage.fromJS(item));
            }
            if (data["actionTransitionMappings"] && data["actionTransitionMappings"].constructor === Array) {
                this.actionTransitionMappings = [];
                for (let item of data["actionTransitionMappings"])
                    this.actionTransitionMappings.push(ActionTransitionMapping.fromJS(item));
            }
            if (data["actionAccessibilityMappings"] && data["actionAccessibilityMappings"].constructor === Array) {
                this.actionAccessibilityMappings = [];
                for (let item of data["actionAccessibilityMappings"])
                    this.actionAccessibilityMappings.push(ActionAccessibilityMapping.fromJS(item));
            }
            if (data["orderTypes"] && data["orderTypes"].constructor === Array) {
                this.orderTypes = [];
                for (let item of data["orderTypes"])
                    this.orderTypes.push(OrderType.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Pipeline {
        data = typeof data === 'object' ? data : {};
        let result = new Pipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["purposeId"] = this.purposeId;
        data["contactGroupId"] = this.contactGroupId;
        data["purpose"] = this.purpose ? this.purpose.toJSON() : <any>undefined;
        data["contactGroup"] = this.contactGroup ? this.contactGroup.toJSON() : <any>undefined;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        if (this.actionTransitionMappings && this.actionTransitionMappings.constructor === Array) {
            data["actionTransitionMappings"] = [];
            for (let item of this.actionTransitionMappings)
                data["actionTransitionMappings"].push(item.toJSON());
        }
        if (this.actionAccessibilityMappings && this.actionAccessibilityMappings.constructor === Array) {
            data["actionAccessibilityMappings"] = [];
            for (let item of this.actionAccessibilityMappings)
                data["actionAccessibilityMappings"].push(item.toJSON());
        }
        if (this.orderTypes && this.orderTypes.constructor === Array) {
            data["orderTypes"] = [];
            for (let item of this.orderTypes)
                data["orderTypes"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPipeline {
    tenantId: number | undefined;
    name: string;
    purposeId: string;
    contactGroupId: string | undefined;
    purpose: PipelinePurpose | undefined;
    contactGroup: ContactGroup | undefined;
    stages: Stage[] | undefined;
    actionTransitionMappings: ActionTransitionMapping[] | undefined;
    actionAccessibilityMappings: ActionAccessibilityMapping[] | undefined;
    orderTypes: OrderType[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrderType implements IOrderType {
    tenantId!: number | undefined;
    name!: string;
    sysId!: string | undefined;
    pipelineId!: number | undefined;
    pipeline!: Pipeline | undefined;
    orders!: Order[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrderType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            this.pipelineId = data["pipelineId"];
            this.pipeline = data["pipeline"] ? Pipeline.fromJS(data["pipeline"]) : <any>undefined;
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(Order.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderType {
        data = typeof data === 'object' ? data : {};
        let result = new OrderType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        data["pipelineId"] = this.pipelineId;
        data["pipeline"] = this.pipeline ? this.pipeline.toJSON() : <any>undefined;
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderType {
    tenantId: number | undefined;
    name: string;
    sysId: string | undefined;
    pipelineId: number | undefined;
    pipeline: Pipeline | undefined;
    orders: Order[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum InvoiceStatus {
    Draft = "Draft", 
    Final = "Final", 
    Sent = "Sent", 
    Paid = "Paid", 
    Canceled = "Canceled", 
}

export class InvoiceLineUnit implements IInvoiceLineUnit {
    name!: string;
    lines!: InvoiceLine[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IInvoiceLineUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLine.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): InvoiceLineUnit {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInvoiceLineUnit {
    name: string;
    lines: InvoiceLine[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class InvoiceLine implements IInvoiceLine {
    tenantId!: number | undefined;
    invoiceId!: number | undefined;
    quantity!: number | undefined;
    rate!: number | undefined;
    unitId!: string;
    amount!: number | undefined;
    description!: string | undefined;
    sortOrder!: number | undefined;
    invoice!: Invoice | undefined;
    unit!: InvoiceLineUnit | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IInvoiceLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.invoiceId = data["invoiceId"];
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.unitId = data["unitId"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
            this.invoice = data["invoice"] ? Invoice.fromJS(data["invoice"]) : <any>undefined;
            this.unit = data["unit"] ? InvoiceLineUnit.fromJS(data["unit"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): InvoiceLine {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["invoiceId"] = this.invoiceId;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInvoiceLine {
    tenantId: number | undefined;
    invoiceId: number | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    unitId: string;
    amount: number | undefined;
    description: string | undefined;
    sortOrder: number | undefined;
    invoice: Invoice | undefined;
    unit: InvoiceLineUnit | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Invoice implements IInvoice {
    tenantId!: number | undefined;
    orderId!: number | undefined;
    status!: InvoiceStatus;
    number!: string;
    amount!: number | undefined;
    date!: moment.Moment | undefined;
    dueDate!: moment.Moment | undefined;
    description!: string | undefined;
    note!: string | undefined;
    order!: Order | undefined;
    lines!: InvoiceLine[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.orderId = data["orderId"];
            this.status = data["status"];
            this.number = data["number"];
            this.amount = data["amount"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            this.order = data["order"] ? Order.fromJS(data["order"]) : <any>undefined;
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLine.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        data["number"] = this.number;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInvoice {
    tenantId: number | undefined;
    orderId: number | undefined;
    status: InvoiceStatus;
    number: string;
    amount: number | undefined;
    date: moment.Moment | undefined;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    note: string | undefined;
    order: Order | undefined;
    lines: InvoiceLine[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export enum NoteType {
    Note = "Note", 
    IncomingCall = "IncomingCall", 
    OutcomingCall = "OutcomingCall", 
}

export class PhoneUsageType implements IPhoneUsageType {
    name!: string | undefined;
    isCompany!: boolean | undefined;
    sortOrder!: number | undefined;
    phones!: ContactPhone[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IPhoneUsageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isCompany = data["isCompany"];
            this.sortOrder = data["sortOrder"];
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [];
                for (let item of data["phones"])
                    this.phones.push(ContactPhone.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PhoneUsageType {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        data["sortOrder"] = this.sortOrder;
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPhoneUsageType {
    name: string | undefined;
    isCompany: boolean | undefined;
    sortOrder: number | undefined;
    phones: ContactPhone[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactPhone implements IContactPhone {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    usageTypeId!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    usageType!: PhoneUsageType | undefined;
    contact!: Contact | undefined;
    contactPrimary!: Contact | undefined;
    notes!: Note[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.usageTypeId = data["usageTypeId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.usageType = data["usageType"] ? PhoneUsageType.fromJS(data["usageType"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactPrimary = data["contactPrimary"] ? Contact.fromJS(data["contactPrimary"]) : <any>undefined;
            if (data["notes"] && data["notes"].constructor === Array) {
                this.notes = [];
                for (let item of data["notes"])
                    this.notes.push(Note.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactPhone {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["usageTypeId"] = this.usageTypeId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["usageType"] = this.usageType ? this.usageType.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactPrimary"] = this.contactPrimary ? this.contactPrimary.toJSON() : <any>undefined;
        if (this.notes && this.notes.constructor === Array) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactPhone {
    tenantId: number | undefined;
    contactId: number | undefined;
    usageTypeId: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    usageType: PhoneUsageType | undefined;
    contact: Contact | undefined;
    contactPrimary: Contact | undefined;
    notes: Note[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Note implements INote {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    text!: string | undefined;
    noteType!: NoteType | undefined;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;
    contact!: Contact | undefined;
    contactPhone!: ContactPhone | undefined;
    order!: Order | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.contactPhoneId = data["contactPhoneId"];
            this.orderId = data["orderId"];
            this.text = data["text"];
            this.noteType = data["noteType"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactPhone = data["contactPhone"] ? ContactPhone.fromJS(data["contactPhone"]) : <any>undefined;
            this.order = data["order"] ? Order.fromJS(data["order"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["text"] = this.text;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactPhone"] = this.contactPhone ? this.contactPhone.toJSON() : <any>undefined;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface INote {
    tenantId: number | undefined;
    contactId: number | undefined;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    text: string | undefined;
    noteType: NoteType | undefined;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
    contact: Contact | undefined;
    contactPhone: ContactPhone | undefined;
    order: Order | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Order implements IOrder {
    pipelinePurposeId!: string | undefined;
    contactGroupId!: string | undefined;
    tenantId!: number | undefined;
    contactId!: number | undefined;
    organizationId!: number | undefined;
    typeId!: number | undefined;
    stageId!: number | undefined;
    sortOrder!: number | undefined;
    leadId!: number | undefined;
    dateProcessed!: moment.Moment | undefined;
    organizationUnitId!: number | undefined;
    amount!: number | undefined;
    systemType!: string | undefined;
    systemMemberId!: string | undefined;
    number!: string;
    cancellationComment!: string | undefined;
    contact!: Contact | undefined;
    organization!: Organization | undefined;
    orderType!: OrderType | undefined;
    stage!: Stage | undefined;
    lead!: Lead | undefined;
    leads!: Lead[] | undefined;
    orderSubscriptions!: OrderSubscription[] | undefined;
    invoices!: Invoice[] | undefined;
    notes!: Note[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelinePurposeId = data["pipelinePurposeId"];
            this.contactGroupId = data["contactGroupId"];
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.organizationId = data["organizationId"];
            this.typeId = data["typeId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
            this.leadId = data["leadId"];
            this.dateProcessed = data["dateProcessed"] ? moment(data["dateProcessed"].toString()) : <any>undefined;
            this.organizationUnitId = data["organizationUnitId"];
            this.amount = data["amount"];
            this.systemType = data["systemType"];
            this.systemMemberId = data["systemMemberId"];
            this.number = data["number"];
            this.cancellationComment = data["cancellationComment"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.orderType = data["orderType"] ? OrderType.fromJS(data["orderType"]) : <any>undefined;
            this.stage = data["stage"] ? Stage.fromJS(data["stage"]) : <any>undefined;
            this.lead = data["lead"] ? Lead.fromJS(data["lead"]) : <any>undefined;
            if (data["leads"] && data["leads"].constructor === Array) {
                this.leads = [];
                for (let item of data["leads"])
                    this.leads.push(Lead.fromJS(item));
            }
            if (data["orderSubscriptions"] && data["orderSubscriptions"].constructor === Array) {
                this.orderSubscriptions = [];
                for (let item of data["orderSubscriptions"])
                    this.orderSubscriptions.push(OrderSubscription.fromJS(item));
            }
            if (data["invoices"] && data["invoices"].constructor === Array) {
                this.invoices = [];
                for (let item of data["invoices"])
                    this.invoices.push(Invoice.fromJS(item));
            }
            if (data["notes"] && data["notes"].constructor === Array) {
                this.notes = [];
                for (let item of data["notes"])
                    this.notes.push(Note.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelinePurposeId"] = this.pipelinePurposeId;
        data["contactGroupId"] = this.contactGroupId;
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["organizationId"] = this.organizationId;
        data["typeId"] = this.typeId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        data["leadId"] = this.leadId;
        data["dateProcessed"] = this.dateProcessed ? this.dateProcessed.toISOString() : <any>undefined;
        data["organizationUnitId"] = this.organizationUnitId;
        data["amount"] = this.amount;
        data["systemType"] = this.systemType;
        data["systemMemberId"] = this.systemMemberId;
        data["number"] = this.number;
        data["cancellationComment"] = this.cancellationComment;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["orderType"] = this.orderType ? this.orderType.toJSON() : <any>undefined;
        data["stage"] = this.stage ? this.stage.toJSON() : <any>undefined;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        if (this.leads && this.leads.constructor === Array) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        if (this.orderSubscriptions && this.orderSubscriptions.constructor === Array) {
            data["orderSubscriptions"] = [];
            for (let item of this.orderSubscriptions)
                data["orderSubscriptions"].push(item.toJSON());
        }
        if (this.invoices && this.invoices.constructor === Array) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (this.notes && this.notes.constructor === Array) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrder {
    pipelinePurposeId: string | undefined;
    contactGroupId: string | undefined;
    tenantId: number | undefined;
    contactId: number | undefined;
    organizationId: number | undefined;
    typeId: number | undefined;
    stageId: number | undefined;
    sortOrder: number | undefined;
    leadId: number | undefined;
    dateProcessed: moment.Moment | undefined;
    organizationUnitId: number | undefined;
    amount: number | undefined;
    systemType: string | undefined;
    systemMemberId: string | undefined;
    number: string;
    cancellationComment: string | undefined;
    contact: Contact | undefined;
    organization: Organization | undefined;
    orderType: OrderType | undefined;
    stage: Stage | undefined;
    lead: Lead | undefined;
    leads: Lead[] | undefined;
    orderSubscriptions: OrderSubscription[] | undefined;
    invoices: Invoice[] | undefined;
    notes: Note[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Organization implements IOrganization {
    tenantId!: number | undefined;
    shortname!: string | undefined;
    companyName!: string;
    typeId!: string;
    industry!: string | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    ein!: string | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    formedDate!: moment.Moment | undefined;
    annualRevenue!: number | undefined;
    businessSicCode!: number | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    description!: string | undefined;
    organizationUnitId!: number | undefined;
    affiliateCode!: string | undefined;
    orgType!: OrganizationType | undefined;
    contact!: Contact | undefined;
    formedCountry!: Country | undefined;
    formedState!: CountryState | undefined;
    personOrgRelations!: PersonOrgRelation[] | undefined;
    organizationAliases!: OrganizationAlias[] | undefined;
    organizationBusinessCategories!: OrganizationBusinessCategory[] | undefined;
    orders!: Order[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.shortname = data["shortname"];
            this.companyName = data["companyName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.ein = data["ein"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.annualRevenue = data["annualRevenue"];
            this.businessSicCode = data["businessSicCode"];
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.description = data["description"];
            this.organizationUnitId = data["organizationUnitId"];
            this.affiliateCode = data["affiliateCode"];
            this.orgType = data["orgType"] ? OrganizationType.fromJS(data["orgType"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.formedCountry = data["formedCountry"] ? Country.fromJS(data["formedCountry"]) : <any>undefined;
            this.formedState = data["formedState"] ? CountryState.fromJS(data["formedState"]) : <any>undefined;
            if (data["personOrgRelations"] && data["personOrgRelations"].constructor === Array) {
                this.personOrgRelations = [];
                for (let item of data["personOrgRelations"])
                    this.personOrgRelations.push(PersonOrgRelation.fromJS(item));
            }
            if (data["organizationAliases"] && data["organizationAliases"].constructor === Array) {
                this.organizationAliases = [];
                for (let item of data["organizationAliases"])
                    this.organizationAliases.push(OrganizationAlias.fromJS(item));
            }
            if (data["organizationBusinessCategories"] && data["organizationBusinessCategories"].constructor === Array) {
                this.organizationBusinessCategories = [];
                for (let item of data["organizationBusinessCategories"])
                    this.organizationBusinessCategories.push(OrganizationBusinessCategory.fromJS(item));
            }
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(Order.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["shortname"] = this.shortname;
        data["companyName"] = this.companyName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["ein"] = this.ein;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["annualRevenue"] = this.annualRevenue;
        data["businessSicCode"] = this.businessSicCode;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["description"] = this.description;
        data["organizationUnitId"] = this.organizationUnitId;
        data["affiliateCode"] = this.affiliateCode;
        data["orgType"] = this.orgType ? this.orgType.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["formedCountry"] = this.formedCountry ? this.formedCountry.toJSON() : <any>undefined;
        data["formedState"] = this.formedState ? this.formedState.toJSON() : <any>undefined;
        if (this.personOrgRelations && this.personOrgRelations.constructor === Array) {
            data["personOrgRelations"] = [];
            for (let item of this.personOrgRelations)
                data["personOrgRelations"].push(item.toJSON());
        }
        if (this.organizationAliases && this.organizationAliases.constructor === Array) {
            data["organizationAliases"] = [];
            for (let item of this.organizationAliases)
                data["organizationAliases"].push(item.toJSON());
        }
        if (this.organizationBusinessCategories && this.organizationBusinessCategories.constructor === Array) {
            data["organizationBusinessCategories"] = [];
            for (let item of this.organizationBusinessCategories)
                data["organizationBusinessCategories"].push(item.toJSON());
        }
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganization {
    tenantId: number | undefined;
    shortname: string | undefined;
    companyName: string;
    typeId: string;
    industry: string | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    ein: string | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    formedDate: moment.Moment | undefined;
    annualRevenue: number | undefined;
    businessSicCode: number | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    description: string | undefined;
    organizationUnitId: number | undefined;
    affiliateCode: string | undefined;
    orgType: OrganizationType | undefined;
    contact: Contact | undefined;
    formedCountry: Country | undefined;
    formedState: CountryState | undefined;
    personOrgRelations: PersonOrgRelation[] | undefined;
    organizationAliases: OrganizationAlias[] | undefined;
    organizationBusinessCategories: OrganizationBusinessCategory[] | undefined;
    orders: Order[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CountryState implements ICountryState {
    id!: string | undefined;
    countryId!: string | undefined;
    name!: string | undefined;
    contactAddresses!: ContactAddress[] | undefined;
    formedOrganizations!: Organization[] | undefined;
    country!: Country | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;

    constructor(data?: ICountryState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.countryId = data["countryId"];
            this.name = data["name"];
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddress.fromJS(item));
            }
            if (data["formedOrganizations"] && data["formedOrganizations"].constructor === Array) {
                this.formedOrganizations = [];
                for (let item of data["formedOrganizations"])
                    this.formedOrganizations.push(Organization.fromJS(item));
            }
            this.country = data["country"] ? Country.fromJS(data["country"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
        }
    }

    static fromJS(data: any): CountryState {
        data = typeof data === 'object' ? data : {};
        let result = new CountryState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["name"] = this.name;
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        if (this.formedOrganizations && this.formedOrganizations.constructor === Array) {
            data["formedOrganizations"] = [];
            for (let item of this.formedOrganizations)
                data["formedOrganizations"].push(item.toJSON());
        }
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        return data; 
    }
}

export interface ICountryState {
    id: string | undefined;
    countryId: string | undefined;
    name: string | undefined;
    contactAddresses: ContactAddress[] | undefined;
    formedOrganizations: Organization[] | undefined;
    country: Country | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
}

export class Country implements ICountry {
    name!: string | undefined;
    countryStates!: CountryState[] | undefined;
    contactAddresses!: ContactAddress[] | undefined;
    formedOrganizations!: Organization[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["countryStates"] && data["countryStates"].constructor === Array) {
                this.countryStates = [];
                for (let item of data["countryStates"])
                    this.countryStates.push(CountryState.fromJS(item));
            }
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddress.fromJS(item));
            }
            if (data["formedOrganizations"] && data["formedOrganizations"].constructor === Array) {
                this.formedOrganizations = [];
                for (let item of data["formedOrganizations"])
                    this.formedOrganizations.push(Organization.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.countryStates && this.countryStates.constructor === Array) {
            data["countryStates"] = [];
            for (let item of this.countryStates)
                data["countryStates"].push(item.toJSON());
        }
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        if (this.formedOrganizations && this.formedOrganizations.constructor === Array) {
            data["formedOrganizations"] = [];
            for (let item of this.formedOrganizations)
                data["formedOrganizations"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICountry {
    name: string | undefined;
    countryStates: CountryState[] | undefined;
    contactAddresses: ContactAddress[] | undefined;
    formedOrganizations: Organization[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactAddress implements IContactAddress {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    usageTypeId!: string | undefined;
    ownershipTypeId!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    ownershipType!: AddressOwnershipType | undefined;
    usageType!: AddressUsageType | undefined;
    contact!: Contact | undefined;
    contactPrimary!: Contact | undefined;
    countryId!: string | undefined;
    stateId!: string | undefined;
    city!: string | undefined;
    streetAddress!: string | undefined;
    zip!: string | undefined;
    country!: Country | undefined;
    state!: CountryState | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.usageTypeId = data["usageTypeId"];
            this.ownershipTypeId = data["ownershipTypeId"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.ownershipType = data["ownershipType"] ? AddressOwnershipType.fromJS(data["ownershipType"]) : <any>undefined;
            this.usageType = data["usageType"] ? AddressUsageType.fromJS(data["usageType"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactPrimary = data["contactPrimary"] ? Contact.fromJS(data["contactPrimary"]) : <any>undefined;
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.city = data["city"];
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.country = data["country"] ? Country.fromJS(data["country"]) : <any>undefined;
            this.state = data["state"] ? CountryState.fromJS(data["state"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["usageTypeId"] = this.usageTypeId;
        data["ownershipTypeId"] = this.ownershipTypeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["ownershipType"] = this.ownershipType ? this.ownershipType.toJSON() : <any>undefined;
        data["usageType"] = this.usageType ? this.usageType.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactPrimary"] = this.contactPrimary ? this.contactPrimary.toJSON() : <any>undefined;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["city"] = this.city;
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactAddress {
    tenantId: number | undefined;
    contactId: number | undefined;
    usageTypeId: string | undefined;
    ownershipTypeId: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    ownershipType: AddressOwnershipType | undefined;
    usageType: AddressUsageType | undefined;
    contact: Contact | undefined;
    contactPrimary: Contact | undefined;
    countryId: string | undefined;
    stateId: string | undefined;
    city: string | undefined;
    streetAddress: string | undefined;
    zip: string | undefined;
    country: Country | undefined;
    state: CountryState | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class EmailUsageType implements IEmailUsageType {
    name!: string | undefined;
    isCompany!: boolean | undefined;
    sortOrder!: number | undefined;
    contactEmails!: ContactEmail[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IEmailUsageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isCompany = data["isCompany"];
            this.sortOrder = data["sortOrder"];
            if (data["contactEmails"] && data["contactEmails"].constructor === Array) {
                this.contactEmails = [];
                for (let item of data["contactEmails"])
                    this.contactEmails.push(ContactEmail.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EmailUsageType {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        data["sortOrder"] = this.sortOrder;
        if (this.contactEmails && this.contactEmails.constructor === Array) {
            data["contactEmails"] = [];
            for (let item of this.contactEmails)
                data["contactEmails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmailUsageType {
    name: string | undefined;
    isCompany: boolean | undefined;
    sortOrder: number | undefined;
    contactEmails: ContactEmail[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactEmail implements IContactEmail {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    usageTypeId!: string | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    usageType!: EmailUsageType | undefined;
    contact!: Contact | undefined;
    contactPrimary!: Contact | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.usageTypeId = data["usageTypeId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.usageType = data["usageType"] ? EmailUsageType.fromJS(data["usageType"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactPrimary = data["contactPrimary"] ? Contact.fromJS(data["contactPrimary"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["usageTypeId"] = this.usageTypeId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["usageType"] = this.usageType ? this.usageType.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactPrimary"] = this.contactPrimary ? this.contactPrimary.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactEmail {
    tenantId: number | undefined;
    contactId: number | undefined;
    usageTypeId: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    usageType: EmailUsageType | undefined;
    contact: Contact | undefined;
    contactPrimary: Contact | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactLinkType implements IContactLinkType {
    name!: string | undefined;
    isSocialNetwork!: boolean | undefined;
    links!: ContactLink[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IContactLinkType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSocialNetwork = data["isSocialNetwork"];
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(ContactLink.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactLinkType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSocialNetwork"] = this.isSocialNetwork;
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactLinkType {
    name: string | undefined;
    isSocialNetwork: boolean | undefined;
    links: ContactLink[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactLink implements IContactLink {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    linkTypeId!: string | undefined;
    url!: string | undefined;
    isActive!: boolean | undefined;
    confirmationDate!: moment.Moment | undefined;
    confirmedByUserId!: number | undefined;
    comment!: string | undefined;
    linkType!: ContactLinkType | undefined;
    contact!: Contact | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.linkTypeId = data["linkTypeId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.confirmationDate = data["confirmationDate"] ? moment(data["confirmationDate"].toString()) : <any>undefined;
            this.confirmedByUserId = data["confirmedByUserId"];
            this.comment = data["comment"];
            this.linkType = data["linkType"] ? ContactLinkType.fromJS(data["linkType"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactLink {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["linkTypeId"] = this.linkTypeId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["confirmationDate"] = this.confirmationDate ? this.confirmationDate.toISOString() : <any>undefined;
        data["confirmedByUserId"] = this.confirmedByUserId;
        data["comment"] = this.comment;
        data["linkType"] = this.linkType ? this.linkType.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactLink {
    tenantId: number | undefined;
    contactId: number | undefined;
    linkTypeId: string | undefined;
    url: string | undefined;
    isActive: boolean | undefined;
    confirmationDate: moment.Moment | undefined;
    confirmedByUserId: number | undefined;
    comment: string | undefined;
    linkType: ContactLinkType | undefined;
    contact: Contact | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactPhoto implements IContactPhoto {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    publicId!: string | undefined;
    source!: string | undefined;
    original!: string | undefined;
    thumbnail!: string | undefined;
    comment!: string | undefined;
    contact!: Contact | undefined;
    contactPrimary!: Contact | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.publicId = data["publicId"];
            this.source = data["source"];
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.comment = data["comment"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactPrimary = data["contactPrimary"] ? Contact.fromJS(data["contactPrimary"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactPhoto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["publicId"] = this.publicId;
        data["source"] = this.source;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["comment"] = this.comment;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactPrimary"] = this.contactPrimary ? this.contactPrimary.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactPhoto {
    tenantId: number | undefined;
    contactId: number | undefined;
    publicId: string | undefined;
    source: string | undefined;
    original: string | undefined;
    thumbnail: string | undefined;
    comment: string | undefined;
    contact: Contact | undefined;
    contactPrimary: Contact | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactStatus implements IContactStatus {
    name!: string | undefined;
    contacts!: Contact[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IContactStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactStatus {
    name: string | undefined;
    contacts: Contact[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactType implements IContactType {
    name!: string | undefined;
    contacts!: Contact[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IContactType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactType {
    name: string | undefined;
    contacts: Contact[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactList implements IContactList {
    tenantId!: number | undefined;
    name!: string;
    contactListAssignments!: ContactListAssignment[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["contactListAssignments"] && data["contactListAssignments"].constructor === Array) {
                this.contactListAssignments = [];
                for (let item of data["contactListAssignments"])
                    this.contactListAssignments.push(ContactListAssignment.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactList {
        data = typeof data === 'object' ? data : {};
        let result = new ContactList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.contactListAssignments && this.contactListAssignments.constructor === Array) {
            data["contactListAssignments"] = [];
            for (let item of this.contactListAssignments)
                data["contactListAssignments"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactList {
    tenantId: number | undefined;
    name: string;
    contactListAssignments: ContactListAssignment[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactListAssignment implements IContactListAssignment {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    contactListId!: number | undefined;
    contact!: Contact | undefined;
    contactList!: ContactList | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactListAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.contactListId = data["contactListId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactList = data["contactList"] ? ContactList.fromJS(data["contactList"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactListAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactListId"] = this.contactListId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactList"] = this.contactList ? this.contactList.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactListAssignment {
    tenantId: number | undefined;
    contactId: number | undefined;
    contactListId: number | undefined;
    contact: Contact | undefined;
    contactList: ContactList | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DocumentType implements IDocumentType {
    tenantId!: number | undefined;
    name!: string;
    documents!: Document[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["documents"] && data["documents"].constructor === Array) {
                this.documents = [];
                for (let item of data["documents"])
                    this.documents.push(Document.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.documents && this.documents.constructor === Array) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDocumentType {
    tenantId: number | undefined;
    name: string;
    documents: Document[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Document implements IDocument {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    fileName!: string;
    size!: number | undefined;
    typeId!: number | undefined;
    contact!: Contact | undefined;
    documentType!: DocumentType | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.fileName = data["fileName"];
            this.size = data["size"];
            this.typeId = data["typeId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.documentType = data["documentType"] ? DocumentType.fromJS(data["documentType"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["typeId"] = this.typeId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDocument {
    tenantId: number | undefined;
    contactId: number | undefined;
    fileName: string;
    size: number | undefined;
    typeId: number | undefined;
    contact: Contact | undefined;
    documentType: DocumentType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum ContactStarColorType {
    Green = "Green", 
    Blue = "Blue", 
    Yellow = "Yellow", 
    Red = "Red", 
    Purple = "Purple", 
    Gradient1 = "Gradient1", 
    Gradient2 = "Gradient2", 
    Gradient3 = "Gradient3", 
    Gradient4 = "Gradient4", 
    Gradient5 = "Gradient5", 
}

export class ContactStar implements IContactStar {
    tenantId!: number | undefined;
    name!: string;
    colorType!: ContactStarColorType | undefined;
    contacts!: Contact[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactStar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.colorType = data["colorType"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactStar {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["colorType"] = this.colorType;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactStar {
    tenantId: number | undefined;
    name: string;
    colorType: ContactStarColorType | undefined;
    contacts: Contact[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactRating implements IContactRating {
    name!: string;
    contacts!: Contact[] | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactRating) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactRating {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRating();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactRating {
    name: string;
    contacts: Contact[] | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PartnerType implements IPartnerType {
    tenantId!: number | undefined;
    name!: string | undefined;
    partners!: Partner[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPartnerType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["partners"] && data["partners"].constructor === Array) {
                this.partners = [];
                for (let item of data["partners"])
                    this.partners.push(Partner.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PartnerType {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.partners && this.partners.constructor === Array) {
            data["partners"] = [];
            for (let item of this.partners)
                data["partners"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPartnerType {
    tenantId: number | undefined;
    name: string | undefined;
    partners: Partner[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Partner implements IPartner {
    tenantId!: number | undefined;
    typeId!: number | undefined;
    contact!: Contact | undefined;
    type!: PartnerType | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPartner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.typeId = data["typeId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.type = data["type"] ? PartnerType.fromJS(data["type"]) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Partner {
        data = typeof data === 'object' ? data : {};
        let result = new Partner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["typeId"] = this.typeId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPartner {
    tenantId: number | undefined;
    typeId: number | undefined;
    contact: Contact | undefined;
    type: PartnerType | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Contact implements IContact {
    isAssignablePermission!: string | undefined;
    tenantId!: number | undefined;
    typeId!: string | undefined;
    groupId!: string | undefined;
    statusId!: string | undefined;
    fullName!: string | undefined;
    terminationDate!: moment.Moment | undefined;
    comment!: string | undefined;
    userId!: number | undefined;
    organizationUnitId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryEmailId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryPhotoId!: number | undefined;
    assignedUserId!: number | undefined;
    starId!: number | undefined;
    ratingId!: number | undefined;
    xref!: string | undefined;
    contactAddresses!: ContactAddress[] | undefined;
    contactEmails!: ContactEmail[] | undefined;
    contactLinks!: ContactLink[] | undefined;
    contactPhones!: ContactPhone[] | undefined;
    contactPhotos!: ContactPhoto[] | undefined;
    person!: Person | undefined;
    organization!: Organization | undefined;
    status!: ContactStatus | undefined;
    type!: ContactType | undefined;
    group!: ContactGroup | undefined;
    primaryAddress!: ContactAddress | undefined;
    primaryEmail!: ContactEmail | undefined;
    primaryPhone!: ContactPhone | undefined;
    primaryPhoto!: ContactPhoto | undefined;
    contactOrders!: Order[] | undefined;
    leads!: Lead[] | undefined;
    notes!: Note[] | undefined;
    contactTagAssignments!: ContactTagAssignment[] | undefined;
    contactListAssignments!: ContactListAssignment[] | undefined;
    documents!: Document[] | undefined;
    star!: ContactStar | undefined;
    rating!: ContactRating | undefined;
    partner!: Partner | undefined;
    assignedUserIds!: number[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAssignablePermission = data["isAssignablePermission"];
            this.tenantId = data["tenantId"];
            this.typeId = data["typeId"];
            this.groupId = data["groupId"];
            this.statusId = data["statusId"];
            this.fullName = data["fullName"];
            this.terminationDate = data["terminationDate"] ? moment(data["terminationDate"].toString()) : <any>undefined;
            this.comment = data["comment"];
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.primaryAddressId = data["primaryAddressId"];
            this.primaryEmailId = data["primaryEmailId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryPhotoId = data["primaryPhotoId"];
            this.assignedUserId = data["assignedUserId"];
            this.starId = data["starId"];
            this.ratingId = data["ratingId"];
            this.xref = data["xref"];
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(ContactAddress.fromJS(item));
            }
            if (data["contactEmails"] && data["contactEmails"].constructor === Array) {
                this.contactEmails = [];
                for (let item of data["contactEmails"])
                    this.contactEmails.push(ContactEmail.fromJS(item));
            }
            if (data["contactLinks"] && data["contactLinks"].constructor === Array) {
                this.contactLinks = [];
                for (let item of data["contactLinks"])
                    this.contactLinks.push(ContactLink.fromJS(item));
            }
            if (data["contactPhones"] && data["contactPhones"].constructor === Array) {
                this.contactPhones = [];
                for (let item of data["contactPhones"])
                    this.contactPhones.push(ContactPhone.fromJS(item));
            }
            if (data["contactPhotos"] && data["contactPhotos"].constructor === Array) {
                this.contactPhotos = [];
                for (let item of data["contactPhotos"])
                    this.contactPhotos.push(ContactPhoto.fromJS(item));
            }
            this.person = data["person"] ? Person.fromJS(data["person"]) : <any>undefined;
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.status = data["status"] ? ContactStatus.fromJS(data["status"]) : <any>undefined;
            this.type = data["type"] ? ContactType.fromJS(data["type"]) : <any>undefined;
            this.group = data["group"] ? ContactGroup.fromJS(data["group"]) : <any>undefined;
            this.primaryAddress = data["primaryAddress"] ? ContactAddress.fromJS(data["primaryAddress"]) : <any>undefined;
            this.primaryEmail = data["primaryEmail"] ? ContactEmail.fromJS(data["primaryEmail"]) : <any>undefined;
            this.primaryPhone = data["primaryPhone"] ? ContactPhone.fromJS(data["primaryPhone"]) : <any>undefined;
            this.primaryPhoto = data["primaryPhoto"] ? ContactPhoto.fromJS(data["primaryPhoto"]) : <any>undefined;
            if (data["contactOrders"] && data["contactOrders"].constructor === Array) {
                this.contactOrders = [];
                for (let item of data["contactOrders"])
                    this.contactOrders.push(Order.fromJS(item));
            }
            if (data["leads"] && data["leads"].constructor === Array) {
                this.leads = [];
                for (let item of data["leads"])
                    this.leads.push(Lead.fromJS(item));
            }
            if (data["notes"] && data["notes"].constructor === Array) {
                this.notes = [];
                for (let item of data["notes"])
                    this.notes.push(Note.fromJS(item));
            }
            if (data["contactTagAssignments"] && data["contactTagAssignments"].constructor === Array) {
                this.contactTagAssignments = [];
                for (let item of data["contactTagAssignments"])
                    this.contactTagAssignments.push(ContactTagAssignment.fromJS(item));
            }
            if (data["contactListAssignments"] && data["contactListAssignments"].constructor === Array) {
                this.contactListAssignments = [];
                for (let item of data["contactListAssignments"])
                    this.contactListAssignments.push(ContactListAssignment.fromJS(item));
            }
            if (data["documents"] && data["documents"].constructor === Array) {
                this.documents = [];
                for (let item of data["documents"])
                    this.documents.push(Document.fromJS(item));
            }
            this.star = data["star"] ? ContactStar.fromJS(data["star"]) : <any>undefined;
            this.rating = data["rating"] ? ContactRating.fromJS(data["rating"]) : <any>undefined;
            this.partner = data["partner"] ? Partner.fromJS(data["partner"]) : <any>undefined;
            if (data["assignedUserIds"] && data["assignedUserIds"].constructor === Array) {
                this.assignedUserIds = [];
                for (let item of data["assignedUserIds"])
                    this.assignedUserIds.push(item);
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAssignablePermission"] = this.isAssignablePermission;
        data["tenantId"] = this.tenantId;
        data["typeId"] = this.typeId;
        data["groupId"] = this.groupId;
        data["statusId"] = this.statusId;
        data["fullName"] = this.fullName;
        data["terminationDate"] = this.terminationDate ? this.terminationDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryEmailId"] = this.primaryEmailId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryPhotoId"] = this.primaryPhotoId;
        data["assignedUserId"] = this.assignedUserId;
        data["starId"] = this.starId;
        data["ratingId"] = this.ratingId;
        data["xref"] = this.xref;
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        if (this.contactEmails && this.contactEmails.constructor === Array) {
            data["contactEmails"] = [];
            for (let item of this.contactEmails)
                data["contactEmails"].push(item.toJSON());
        }
        if (this.contactLinks && this.contactLinks.constructor === Array) {
            data["contactLinks"] = [];
            for (let item of this.contactLinks)
                data["contactLinks"].push(item.toJSON());
        }
        if (this.contactPhones && this.contactPhones.constructor === Array) {
            data["contactPhones"] = [];
            for (let item of this.contactPhones)
                data["contactPhones"].push(item.toJSON());
        }
        if (this.contactPhotos && this.contactPhotos.constructor === Array) {
            data["contactPhotos"] = [];
            for (let item of this.contactPhotos)
                data["contactPhotos"].push(item.toJSON());
        }
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["primaryAddress"] = this.primaryAddress ? this.primaryAddress.toJSON() : <any>undefined;
        data["primaryEmail"] = this.primaryEmail ? this.primaryEmail.toJSON() : <any>undefined;
        data["primaryPhone"] = this.primaryPhone ? this.primaryPhone.toJSON() : <any>undefined;
        data["primaryPhoto"] = this.primaryPhoto ? this.primaryPhoto.toJSON() : <any>undefined;
        if (this.contactOrders && this.contactOrders.constructor === Array) {
            data["contactOrders"] = [];
            for (let item of this.contactOrders)
                data["contactOrders"].push(item.toJSON());
        }
        if (this.leads && this.leads.constructor === Array) {
            data["leads"] = [];
            for (let item of this.leads)
                data["leads"].push(item.toJSON());
        }
        if (this.notes && this.notes.constructor === Array) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (this.contactTagAssignments && this.contactTagAssignments.constructor === Array) {
            data["contactTagAssignments"] = [];
            for (let item of this.contactTagAssignments)
                data["contactTagAssignments"].push(item.toJSON());
        }
        if (this.contactListAssignments && this.contactListAssignments.constructor === Array) {
            data["contactListAssignments"] = [];
            for (let item of this.contactListAssignments)
                data["contactListAssignments"].push(item.toJSON());
        }
        if (this.documents && this.documents.constructor === Array) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["star"] = this.star ? this.star.toJSON() : <any>undefined;
        data["rating"] = this.rating ? this.rating.toJSON() : <any>undefined;
        data["partner"] = this.partner ? this.partner.toJSON() : <any>undefined;
        if (this.assignedUserIds && this.assignedUserIds.constructor === Array) {
            data["assignedUserIds"] = [];
            for (let item of this.assignedUserIds)
                data["assignedUserIds"].push(item);
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContact {
    isAssignablePermission: string | undefined;
    tenantId: number | undefined;
    typeId: string | undefined;
    groupId: string | undefined;
    statusId: string | undefined;
    fullName: string | undefined;
    terminationDate: moment.Moment | undefined;
    comment: string | undefined;
    userId: number | undefined;
    organizationUnitId: number | undefined;
    primaryAddressId: number | undefined;
    primaryEmailId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryPhotoId: number | undefined;
    assignedUserId: number | undefined;
    starId: number | undefined;
    ratingId: number | undefined;
    xref: string | undefined;
    contactAddresses: ContactAddress[] | undefined;
    contactEmails: ContactEmail[] | undefined;
    contactLinks: ContactLink[] | undefined;
    contactPhones: ContactPhone[] | undefined;
    contactPhotos: ContactPhoto[] | undefined;
    person: Person | undefined;
    organization: Organization | undefined;
    status: ContactStatus | undefined;
    type: ContactType | undefined;
    group: ContactGroup | undefined;
    primaryAddress: ContactAddress | undefined;
    primaryEmail: ContactEmail | undefined;
    primaryPhone: ContactPhone | undefined;
    primaryPhoto: ContactPhoto | undefined;
    contactOrders: Order[] | undefined;
    leads: Lead[] | undefined;
    notes: Note[] | undefined;
    contactTagAssignments: ContactTagAssignment[] | undefined;
    contactListAssignments: ContactListAssignment[] | undefined;
    documents: Document[] | undefined;
    star: ContactStar | undefined;
    rating: ContactRating | undefined;
    partner: Partner | undefined;
    assignedUserIds: number[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactTagAssignment implements IContactTagAssignment {
    tenantId!: number | undefined;
    contactId!: number | undefined;
    contactTagId!: number | undefined;
    contact!: Contact | undefined;
    contactTag!: ContactTag | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactTagAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.contactId = data["contactId"];
            this.contactTagId = data["contactTagId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.contactTag = data["contactTag"] ? ContactTag.fromJS(data["contactTag"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactTagAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["contactId"] = this.contactId;
        data["contactTagId"] = this.contactTagId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactTag"] = this.contactTag ? this.contactTag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactTagAssignment {
    tenantId: number | undefined;
    contactId: number | undefined;
    contactTagId: number | undefined;
    contact: Contact | undefined;
    contactTag: ContactTag | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ContactTag implements IContactTag {
    tenantId!: number | undefined;
    name!: string;
    contactTagAssignments!: ContactTagAssignment[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            if (data["contactTagAssignments"] && data["contactTagAssignments"].constructor === Array) {
                this.contactTagAssignments = [];
                for (let item of data["contactTagAssignments"])
                    this.contactTagAssignments.push(ContactTagAssignment.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactTag {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        if (this.contactTagAssignments && this.contactTagAssignments.constructor === Array) {
            data["contactTagAssignments"] = [];
            for (let item of this.contactTagAssignments)
                data["contactTagAssignments"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactTag {
    tenantId: number | undefined;
    name: string;
    contactTagAssignments: ContactTagAssignment[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrganizationBusinessInfo implements IOrganizationBusinessInfo {
    companyName!: string | undefined;
    shortname!: string | undefined;
    typeId!: string | undefined;
    typeName!: string | undefined;
    industry!: string | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    description!: string | undefined;
    ein!: string | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    formedDate!: moment.Moment | undefined;
    annualRevenue!: number | undefined;
    businessSicCode!: number | undefined;
    note!: string | undefined;
    contactId!: number | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    address!: AddressInfo | undefined;
    photo!: ContactPhotoInfo | undefined;
    contactEmails!: ContactEmailInfo[] | undefined;
    contactPhones!: ContactPhoneInfo[] | undefined;
    contactAddresses!: AddressInfo[] | undefined;
    contactLinks!: ContactLinkInfo[] | undefined;
    tags!: ContactTag[] | undefined;
    lists!: ContactList[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IOrganizationBusinessInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.shortname = data["shortname"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.industry = data["industry"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.description = data["description"];
            this.ein = data["ein"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.annualRevenue = data["annualRevenue"];
            this.businessSicCode = data["businessSicCode"];
            this.note = data["note"];
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.address = data["address"] ? AddressInfo.fromJS(data["address"]) : <any>undefined;
            this.photo = data["photo"] ? ContactPhotoInfo.fromJS(data["photo"]) : <any>undefined;
            if (data["contactEmails"] && data["contactEmails"].constructor === Array) {
                this.contactEmails = [];
                for (let item of data["contactEmails"])
                    this.contactEmails.push(ContactEmailInfo.fromJS(item));
            }
            if (data["contactPhones"] && data["contactPhones"].constructor === Array) {
                this.contactPhones = [];
                for (let item of data["contactPhones"])
                    this.contactPhones.push(ContactPhoneInfo.fromJS(item));
            }
            if (data["contactAddresses"] && data["contactAddresses"].constructor === Array) {
                this.contactAddresses = [];
                for (let item of data["contactAddresses"])
                    this.contactAddresses.push(AddressInfo.fromJS(item));
            }
            if (data["contactLinks"] && data["contactLinks"].constructor === Array) {
                this.contactLinks = [];
                for (let item of data["contactLinks"])
                    this.contactLinks.push(ContactLinkInfo.fromJS(item));
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTag.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactList.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): OrganizationBusinessInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationBusinessInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["shortname"] = this.shortname;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["industry"] = this.industry;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["description"] = this.description;
        data["ein"] = this.ein;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["annualRevenue"] = this.annualRevenue;
        data["businessSicCode"] = this.businessSicCode;
        data["note"] = this.note;
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        if (this.contactEmails && this.contactEmails.constructor === Array) {
            data["contactEmails"] = [];
            for (let item of this.contactEmails)
                data["contactEmails"].push(item.toJSON());
        }
        if (this.contactPhones && this.contactPhones.constructor === Array) {
            data["contactPhones"] = [];
            for (let item of this.contactPhones)
                data["contactPhones"].push(item.toJSON());
        }
        if (this.contactAddresses && this.contactAddresses.constructor === Array) {
            data["contactAddresses"] = [];
            for (let item of this.contactAddresses)
                data["contactAddresses"].push(item.toJSON());
        }
        if (this.contactLinks && this.contactLinks.constructor === Array) {
            data["contactLinks"] = [];
            for (let item of this.contactLinks)
                data["contactLinks"].push(item.toJSON());
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IOrganizationBusinessInfo {
    companyName: string | undefined;
    shortname: string | undefined;
    typeId: string | undefined;
    typeName: string | undefined;
    industry: string | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    description: string | undefined;
    ein: string | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    formedDate: moment.Moment | undefined;
    annualRevenue: number | undefined;
    businessSicCode: number | undefined;
    note: string | undefined;
    contactId: number | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    address: AddressInfo | undefined;
    photo: ContactPhotoInfo | undefined;
    contactEmails: ContactEmailInfo[] | undefined;
    contactPhones: ContactPhoneInfo[] | undefined;
    contactAddresses: AddressInfo[] | undefined;
    contactLinks: ContactLinkInfo[] | undefined;
    tags: ContactTag[] | undefined;
    lists: ContactList[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    userId: number | undefined;
}

export class GetContactBusinessOutput implements IGetContactBusinessOutput {
    contactBusinessInfo!: ContactBusinessInfo | undefined;
    organizationBusinessInfo!: OrganizationBusinessInfo | undefined;

    constructor(data?: IGetContactBusinessOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactBusinessInfo = data["contactBusinessInfo"] ? ContactBusinessInfo.fromJS(data["contactBusinessInfo"]) : <any>undefined;
            this.organizationBusinessInfo = data["organizationBusinessInfo"] ? OrganizationBusinessInfo.fromJS(data["organizationBusinessInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContactBusinessOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactBusinessOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactBusinessInfo"] = this.contactBusinessInfo ? this.contactBusinessInfo.toJSON() : <any>undefined;
        data["organizationBusinessInfo"] = this.organizationBusinessInfo ? this.organizationBusinessInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetContactBusinessOutput {
    contactBusinessInfo: ContactBusinessInfo | undefined;
    organizationBusinessInfo: OrganizationBusinessInfo | undefined;
}

export class ContactBusinessCreateInfo implements IContactBusinessCreateInfo {
    personId!: number;
    orgId!: number;
    relationTypeId!: string;
    jobTitle!: string;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;

    constructor(data?: IContactBusinessCreateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.orgId = data["orgId"];
            this.relationTypeId = data["relationTypeId"];
            this.jobTitle = data["jobTitle"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ContactBusinessCreateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ContactBusinessCreateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["orgId"] = this.orgId;
        data["relationTypeId"] = this.relationTypeId;
        data["jobTitle"] = this.jobTitle;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IContactBusinessCreateInfo {
    personId: number;
    orgId: number;
    relationTypeId: string;
    jobTitle: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
}

export class CreateContactBusinessInput implements ICreateContactBusinessInput {
    contactBusinessCreateInfo!: ContactBusinessCreateInfo;

    constructor(data?: ICreateContactBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactBusinessCreateInfo = new ContactBusinessCreateInfo();
        }
    }

    init(data?: any) {
        if (data) {
            this.contactBusinessCreateInfo = data["contactBusinessCreateInfo"] ? ContactBusinessCreateInfo.fromJS(data["contactBusinessCreateInfo"]) : new ContactBusinessCreateInfo();
        }
    }

    static fromJS(data: any): CreateContactBusinessInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactBusinessCreateInfo"] = this.contactBusinessCreateInfo ? this.contactBusinessCreateInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateContactBusinessInput {
    contactBusinessCreateInfo: ContactBusinessCreateInfo;
}

export class CreateContactBusinessOutput implements ICreateContactBusinessOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactBusinessOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactBusinessOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactBusinessOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactBusinessOutput {
    id: number | undefined;
}

export class PersonOrgRelationInfo implements IPersonOrgRelationInfo {
    orgId!: number;
    relationTypeId!: string;
    jobTitle!: string;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;

    constructor(data?: IPersonOrgRelationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orgId = data["orgId"];
            this.relationTypeId = data["relationTypeId"];
            this.jobTitle = data["jobTitle"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): PersonOrgRelationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orgId"] = this.orgId;
        data["relationTypeId"] = this.relationTypeId;
        data["jobTitle"] = this.jobTitle;
        data["startDate"] = this.startDate ? this.startDate.format('YYYY-MM-DD') : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.format('YYYY-MM-DD') : <any>undefined;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IPersonOrgRelationInfo {
    orgId: number;
    relationTypeId: string;
    jobTitle: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
}

export class UpdateContactBusinessInput implements IUpdateContactBusinessInput {
    id!: number;
    contactBusinessEditInfo!: PersonOrgRelationInfo;

    constructor(data?: IUpdateContactBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contactBusinessEditInfo = new PersonOrgRelationInfo();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactBusinessEditInfo = data["contactBusinessEditInfo"] ? PersonOrgRelationInfo.fromJS(data["contactBusinessEditInfo"]) : new PersonOrgRelationInfo();
        }
    }

    static fromJS(data: any): UpdateContactBusinessInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactBusinessEditInfo"] = this.contactBusinessEditInfo ? this.contactBusinessEditInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateContactBusinessInput {
    id: number;
    contactBusinessEditInfo: PersonOrgRelationInfo;
}

export class PersonOrgRelationTypeDto implements IPersonOrgRelationTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isDeleted!: boolean | undefined;

    constructor(data?: IPersonOrgRelationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isDeleted = data["isDeleted"];
        }
    }

    static fromJS(data: any): PersonOrgRelationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonOrgRelationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IPersonOrgRelationTypeDto {
    id: string | undefined;
    name: string | undefined;
    isDeleted: boolean | undefined;
}

export class CreateContactEmailOutput implements ICreateContactEmailOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactEmailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactEmailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactEmailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactEmailOutput {
    id: number | undefined;
}

export class UpdateContactEmailInput implements IUpdateContactEmailInput {
    id!: number;
    contactId!: number;
    emailAddress!: string;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactEmailInput {
    id: number;
    contactId: number;
    emailAddress: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class EmailUsageTypeDto implements IEmailUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IEmailUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): EmailUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IEmailUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class EmailUsageTypeDtoListResultDto implements IEmailUsageTypeDtoListResultDto {
    items!: EmailUsageTypeDto[] | undefined;

    constructor(data?: IEmailUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EmailUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEmailUsageTypeDtoListResultDto {
    items: EmailUsageTypeDto[] | undefined;
}

export class CreateContactLinkOutput implements ICreateContactLinkOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactLinkOutput {
    id: number | undefined;
}

export class UpdateContactLinkInput implements IUpdateContactLinkInput {
    id!: number;
    contactId!: number;
    url!: string;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    linkTypeId!: string | undefined;
    isCompany!: boolean;

    constructor(data?: IUpdateContactLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.url = data["url"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.linkTypeId = data["linkTypeId"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): UpdateContactLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["url"] = this.url;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["linkTypeId"] = this.linkTypeId;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IUpdateContactLinkInput {
    id: number;
    contactId: number;
    url: string;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    linkTypeId: string | undefined;
    isCompany: boolean;
}

export class ContactLinkTypeDto implements IContactLinkTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isSocialNetwork!: boolean | undefined;

    constructor(data?: IContactLinkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isSocialNetwork = data["isSocialNetwork"];
        }
    }

    static fromJS(data: any): ContactLinkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isSocialNetwork"] = this.isSocialNetwork;
        return data; 
    }
}

export interface IContactLinkTypeDto {
    id: string | undefined;
    name: string | undefined;
    isSocialNetwork: boolean | undefined;
}

export class ContactLinkTypeDtoListResultDto implements IContactLinkTypeDtoListResultDto {
    items!: ContactLinkTypeDto[] | undefined;

    constructor(data?: IContactLinkTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactLinkTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactLinkTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLinkTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactLinkTypeDtoListResultDto {
    items: ContactLinkTypeDto[] | undefined;
}

export class UpdateContactListsInput implements IUpdateContactListsInput {
    contactId!: number;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IUpdateContactListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateContactListsInput {
    contactId: number;
    lists: ContactListInput[] | undefined;
}

export class AddContactsToListsInput implements IAddContactsToListsInput {
    contactIds!: number[] | undefined;
    lists!: ContactListInput[] | undefined;

    constructor(data?: IAddContactsToListsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddContactsToListsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactsToListsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddContactsToListsInput {
    contactIds: number[] | undefined;
    lists: ContactListInput[] | undefined;
}

export class UpdateContactListInput implements IUpdateContactListInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateContactListInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateContactListInput {
    id: number;
    name: string;
}

export class CreateContactPhoneOutput implements ICreateContactPhoneOutput {
    id!: number | undefined;

    constructor(data?: ICreateContactPhoneOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateContactPhoneOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhoneOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateContactPhoneOutput {
    id: number | undefined;
}

export class UpdateContactPhoneInput implements IUpdateContactPhoneInput {
    id!: number;
    contactId!: number;
    phoneNumber!: string;
    phoneExtension!: string | undefined;
    isActive!: boolean;
    isConfirmed!: boolean;
    comment!: string | undefined;
    usageTypeId!: string | undefined;

    constructor(data?: IUpdateContactPhoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.isActive = data["isActive"];
            this.isConfirmed = data["isConfirmed"];
            this.comment = data["comment"];
            this.usageTypeId = data["usageTypeId"];
        }
    }

    static fromJS(data: any): UpdateContactPhoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactPhoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["isActive"] = this.isActive;
        data["isConfirmed"] = this.isConfirmed;
        data["comment"] = this.comment;
        data["usageTypeId"] = this.usageTypeId;
        return data; 
    }
}

export interface IUpdateContactPhoneInput {
    id: number;
    contactId: number;
    phoneNumber: string;
    phoneExtension: string | undefined;
    isActive: boolean;
    isConfirmed: boolean;
    comment: string | undefined;
    usageTypeId: string | undefined;
}

export class PhoneUsageTypeDto implements IPhoneUsageTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    isCompany!: boolean | undefined;

    constructor(data?: IPhoneUsageTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCompany = data["isCompany"];
        }
    }

    static fromJS(data: any): PhoneUsageTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCompany"] = this.isCompany;
        return data; 
    }
}

export interface IPhoneUsageTypeDto {
    id: string | undefined;
    name: string | undefined;
    isCompany: boolean | undefined;
}

export class PhoneUsageTypeDtoListResultDto implements IPhoneUsageTypeDtoListResultDto {
    items!: PhoneUsageTypeDto[] | undefined;

    constructor(data?: IPhoneUsageTypeDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhoneUsageTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhoneUsageTypeDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneUsageTypeDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPhoneUsageTypeDtoListResultDto {
    items: PhoneUsageTypeDto[] | undefined;
}

export class CreateContactPhotoInput implements ICreateContactPhotoInput {
    contactId!: number;
    original!: string;
    thumbnail!: string | undefined;
    source!: string | undefined;
    comment!: string | undefined;

    constructor(data?: ICreateContactPhotoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.original = data["original"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CreateContactPhotoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactPhotoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["original"] = this.original;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateContactPhotoInput {
    contactId: number;
    original: string;
    thumbnail: string | undefined;
    source: string | undefined;
    comment: string | undefined;
}

export class ContactRatingInfoDto implements IContactRatingInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactRatingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactRatingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactRatingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactRatingInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class RateContactInput implements IRateContactInput {
    contactId!: number;
    ratingId!: number | undefined;

    constructor(data?: IRateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.ratingId = data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["ratingId"] = this.ratingId;
        return data; 
    }
}

export interface IRateContactInput {
    contactId: number;
    ratingId: number | undefined;
}

export class RateContactsInput implements IRateContactsInput {
    contactIds!: number[] | undefined;
    ratingId!: number | undefined;

    constructor(data?: IRateContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.ratingId = data["ratingId"];
        }
    }

    static fromJS(data: any): RateContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new RateContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["ratingId"] = this.ratingId;
        return data; 
    }
}

export interface IRateContactsInput {
    contactIds: number[] | undefined;
    ratingId: number | undefined;
}

export class MarkContactInput implements IMarkContactInput {
    contactId!: number;
    starId!: number | undefined;

    constructor(data?: IMarkContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.starId = data["starId"];
        }
    }

    static fromJS(data: any): MarkContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["starId"] = this.starId;
        return data; 
    }
}

export interface IMarkContactInput {
    contactId: number;
    starId: number | undefined;
}

export class MarkContactsInput implements IMarkContactsInput {
    contactIds!: number[] | undefined;
    starId!: number | undefined;

    constructor(data?: IMarkContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            this.starId = data["starId"];
        }
    }

    static fromJS(data: any): MarkContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        data["starId"] = this.starId;
        return data; 
    }
}

export interface IMarkContactsInput {
    contactIds: number[] | undefined;
    starId: number | undefined;
}

export class UpdateContactTagsInput implements IUpdateContactTagsInput {
    contactId!: number;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: IUpdateContactTagsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactTagsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateContactTagsInput {
    contactId: number;
    tags: ContactTagInput[] | undefined;
}

export class TagContactsInput implements ITagContactsInput {
    contactIds!: number[] | undefined;
    tags!: ContactTagInput[] | undefined;

    constructor(data?: ITagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new TagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagContactsInput {
    contactIds: number[] | undefined;
    tags: ContactTagInput[] | undefined;
}

export class UntagContactsInput implements IUntagContactsInput {
    contactIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUntagContactsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contactIds"] && data["contactIds"].constructor === Array) {
                this.contactIds = [];
                for (let item of data["contactIds"])
                    this.contactIds.push(item);
            }
            if (data["tagIds"] && data["tagIds"].constructor === Array) {
                this.tagIds = [];
                for (let item of data["tagIds"])
                    this.tagIds.push(item);
            }
        }
    }

    static fromJS(data: any): UntagContactsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UntagContactsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contactIds && this.contactIds.constructor === Array) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        if (this.tagIds && this.tagIds.constructor === Array) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUntagContactsInput {
    contactIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class UpdateContactTagInput implements IUpdateContactTagInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateContactTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateContactTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateContactTagInput {
    id: number;
    name: string;
}

export class CountryDto implements ICountryDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryDto {
    code: string | undefined;
    name: string | undefined;
}

export class CountryStateDto implements ICountryStateDto {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICountryStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CountryStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICountryStateDto {
    code: string | undefined;
    name: string | undefined;
}

export enum CreditScoreRank {
    Poor = "Poor", 
    Fair = "Fair", 
    Good = "Good", 
    Excellent = "Excellent", 
}

export class CreditScoreDto implements ICreditScoreDto {
    score!: number | undefined;
    scoreRank!: CreditScoreRank | undefined;
    populationRank!: number | undefined;
    qualitativeRank!: number | undefined;
    scoreDate!: moment.Moment | undefined;
    nextUpdate!: number | undefined;

    constructor(data?: ICreditScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.score = data["score"];
            this.scoreRank = data["scoreRank"];
            this.populationRank = data["populationRank"];
            this.qualitativeRank = data["qualitativeRank"];
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.nextUpdate = data["nextUpdate"];
        }
    }

    static fromJS(data: any): CreditScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["score"] = this.score;
        data["scoreRank"] = this.scoreRank;
        data["populationRank"] = this.populationRank;
        data["qualitativeRank"] = this.qualitativeRank;
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["nextUpdate"] = this.nextUpdate;
        return data; 
    }
}

export interface ICreditScoreDto {
    score: number | undefined;
    scoreRank: CreditScoreRank | undefined;
    populationRank: number | undefined;
    qualitativeRank: number | undefined;
    scoreDate: moment.Moment | undefined;
    nextUpdate: number | undefined;
}

export class CreditSummaryDto implements ICreditSummaryDto {
    totalAccounts!: number | undefined;
    openAccounts!: number | undefined;
    closedAccounts!: number | undefined;
    deliquent!: number | undefined;
    derogatory!: number | undefined;
    balances!: number | undefined;
    payments!: number | undefined;
    publicRecords!: number | undefined;
    inquiries2Years!: number | undefined;

    constructor(data?: ICreditSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalAccounts = data["totalAccounts"];
            this.openAccounts = data["openAccounts"];
            this.closedAccounts = data["closedAccounts"];
            this.deliquent = data["deliquent"];
            this.derogatory = data["derogatory"];
            this.balances = data["balances"];
            this.payments = data["payments"];
            this.publicRecords = data["publicRecords"];
            this.inquiries2Years = data["inquiries2Years"];
        }
    }

    static fromJS(data: any): CreditSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAccounts"] = this.totalAccounts;
        data["openAccounts"] = this.openAccounts;
        data["closedAccounts"] = this.closedAccounts;
        data["deliquent"] = this.deliquent;
        data["derogatory"] = this.derogatory;
        data["balances"] = this.balances;
        data["payments"] = this.payments;
        data["publicRecords"] = this.publicRecords;
        data["inquiries2Years"] = this.inquiries2Years;
        return data; 
    }
}

export interface ICreditSummaryDto {
    totalAccounts: number | undefined;
    openAccounts: number | undefined;
    closedAccounts: number | undefined;
    deliquent: number | undefined;
    derogatory: number | undefined;
    balances: number | undefined;
    payments: number | undefined;
    publicRecords: number | undefined;
    inquiries2Years: number | undefined;
}

export class AddressDto implements IAddressDto {
    line1!: string | undefined;
    line2!: string | undefined;
    line3!: string | undefined;
    line4!: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.line3 = data["line3"];
            this.line4 = data["line4"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        return data; 
    }
}

export interface IAddressDto {
    line1: string | undefined;
    line2: string | undefined;
    line3: string | undefined;
    line4: string | undefined;
}

export class EmployerDto implements IEmployerDto {
    name!: string | undefined;
    date!: moment.Moment | undefined;
    type!: string | undefined;

    constructor(data?: IEmployerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): EmployerDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEmployerDto {
    name: string | undefined;
    date: moment.Moment | undefined;
    type: string | undefined;
}

export class PersonalInfoDto implements IPersonalInfoDto {
    name!: string | undefined;
    doB!: moment.Moment | undefined;
    currentAddress!: AddressDto | undefined;
    previousAddresses!: AddressDto[] | undefined;
    employers!: EmployerDto[] | undefined;

    constructor(data?: IPersonalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.currentAddress = data["currentAddress"] ? AddressDto.fromJS(data["currentAddress"]) : <any>undefined;
            if (data["previousAddresses"] && data["previousAddresses"].constructor === Array) {
                this.previousAddresses = [];
                for (let item of data["previousAddresses"])
                    this.previousAddresses.push(AddressDto.fromJS(item));
            }
            if (data["employers"] && data["employers"].constructor === Array) {
                this.employers = [];
                for (let item of data["employers"])
                    this.employers.push(EmployerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["currentAddress"] = this.currentAddress ? this.currentAddress.toJSON() : <any>undefined;
        if (this.previousAddresses && this.previousAddresses.constructor === Array) {
            data["previousAddresses"] = [];
            for (let item of this.previousAddresses)
                data["previousAddresses"].push(item.toJSON());
        }
        if (this.employers && this.employers.constructor === Array) {
            data["employers"] = [];
            for (let item of this.employers)
                data["employers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalInfoDto {
    name: string | undefined;
    doB: moment.Moment | undefined;
    currentAddress: AddressDto | undefined;
    previousAddresses: AddressDto[] | undefined;
    employers: EmployerDto[] | undefined;
}

export class InquiryDto implements IInquiryDto {
    creditorName!: string | undefined;
    industry!: string | undefined;
    dateOfInquiry!: moment.Moment | undefined;

    constructor(data?: IInquiryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditorName = data["creditorName"];
            this.industry = data["industry"];
            this.dateOfInquiry = data["dateOfInquiry"] ? moment(data["dateOfInquiry"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InquiryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquiryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditorName"] = this.creditorName;
        data["industry"] = this.industry;
        data["dateOfInquiry"] = this.dateOfInquiry ? this.dateOfInquiry.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IInquiryDto {
    creditorName: string | undefined;
    industry: string | undefined;
    dateOfInquiry: moment.Moment | undefined;
}

export class ScoreFactorDto implements IScoreFactorDto {
    isPositive!: boolean | undefined;
    text!: string | undefined;

    constructor(data?: IScoreFactorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isPositive = data["isPositive"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): ScoreFactorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreFactorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isPositive"] = this.isPositive;
        data["text"] = this.text;
        return data; 
    }
}

export interface IScoreFactorDto {
    isPositive: boolean | undefined;
    text: string | undefined;
}

export class CreditBureauReportDto implements ICreditBureauReportDto {
    bureau!: string | undefined;
    creditScore!: CreditScoreDto | undefined;
    creditSummary!: CreditSummaryDto | undefined;
    personalInfo!: PersonalInfoDto | undefined;
    inquiries!: InquiryDto[] | undefined;
    scoreFactors!: ScoreFactorDto[] | undefined;

    constructor(data?: ICreditBureauReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.creditScore = data["creditScore"] ? CreditScoreDto.fromJS(data["creditScore"]) : <any>undefined;
            this.creditSummary = data["creditSummary"] ? CreditSummaryDto.fromJS(data["creditSummary"]) : <any>undefined;
            this.personalInfo = data["personalInfo"] ? PersonalInfoDto.fromJS(data["personalInfo"]) : <any>undefined;
            if (data["inquiries"] && data["inquiries"].constructor === Array) {
                this.inquiries = [];
                for (let item of data["inquiries"])
                    this.inquiries.push(InquiryDto.fromJS(item));
            }
            if (data["scoreFactors"] && data["scoreFactors"].constructor === Array) {
                this.scoreFactors = [];
                for (let item of data["scoreFactors"])
                    this.scoreFactors.push(ScoreFactorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditBureauReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditBureauReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["creditScore"] = this.creditScore ? this.creditScore.toJSON() : <any>undefined;
        data["creditSummary"] = this.creditSummary ? this.creditSummary.toJSON() : <any>undefined;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        if (this.inquiries && this.inquiries.constructor === Array) {
            data["inquiries"] = [];
            for (let item of this.inquiries)
                data["inquiries"].push(item.toJSON());
        }
        if (this.scoreFactors && this.scoreFactors.constructor === Array) {
            data["scoreFactors"] = [];
            for (let item of this.scoreFactors)
                data["scoreFactors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditBureauReportDto {
    bureau: string | undefined;
    creditScore: CreditScoreDto | undefined;
    creditSummary: CreditSummaryDto | undefined;
    personalInfo: PersonalInfoDto | undefined;
    inquiries: InquiryDto[] | undefined;
    scoreFactors: ScoreFactorDto[] | undefined;
}

export enum AccountState {
    _0 = 0, 
    _1 = 1, 
}

export enum AccountStatus {
    _0 = 0, 
    _1 = 1, 
}

export enum AccountCreditHistoryStatusDto {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
}

export class AccountCreditHistoryDto implements IAccountCreditHistoryDto {
    year!: number | undefined;
    month!: number | undefined;
    status!: string | undefined;
    isPositiveStatus!: boolean | undefined;
    statusType!: AccountCreditHistoryStatusDto | undefined;

    constructor(data?: IAccountCreditHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.year = data["year"];
            this.month = data["month"];
            this.status = data["status"];
            this.isPositiveStatus = data["isPositiveStatus"];
            this.statusType = data["statusType"];
        }
    }

    static fromJS(data: any): AccountCreditHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountCreditHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["status"] = this.status;
        data["isPositiveStatus"] = this.isPositiveStatus;
        data["statusType"] = this.statusType;
        return data; 
    }
}

export interface IAccountCreditHistoryDto {
    year: number | undefined;
    month: number | undefined;
    status: string | undefined;
    isPositiveStatus: boolean | undefined;
    statusType: AccountCreditHistoryStatusDto | undefined;
}

export class AccountInfoDto implements IAccountInfoDto {
    bureau!: string | undefined;
    status!: AccountStatus | undefined;
    totalCreditLimit!: number | undefined;
    availableCredit!: number | undefined;
    creditUtilization!: number | undefined;
    accountName!: string | undefined;
    accountNumber!: string | undefined;
    balance!: number | undefined;
    pastDue!: number | undefined;
    dateOpened!: moment.Moment | undefined;
    moPayment!: number | undefined;
    paymentStatus!: string | undefined;
    terms!: string | undefined;
    comment!: string | undefined;
    maxAccountHistoryDate!: moment.Moment | undefined;
    twoYearHistory!: AccountCreditHistoryDto[] | undefined;

    constructor(data?: IAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.status = data["status"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.availableCredit = data["availableCredit"];
            this.creditUtilization = data["creditUtilization"];
            this.accountName = data["accountName"];
            this.accountNumber = data["accountNumber"];
            this.balance = data["balance"];
            this.pastDue = data["pastDue"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            this.moPayment = data["moPayment"];
            this.paymentStatus = data["paymentStatus"];
            this.terms = data["terms"];
            this.comment = data["comment"];
            this.maxAccountHistoryDate = data["maxAccountHistoryDate"] ? moment(data["maxAccountHistoryDate"].toString()) : <any>undefined;
            if (data["twoYearHistory"] && data["twoYearHistory"].constructor === Array) {
                this.twoYearHistory = [];
                for (let item of data["twoYearHistory"])
                    this.twoYearHistory.push(AccountCreditHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["status"] = this.status;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["availableCredit"] = this.availableCredit;
        data["creditUtilization"] = this.creditUtilization;
        data["accountName"] = this.accountName;
        data["accountNumber"] = this.accountNumber;
        data["balance"] = this.balance;
        data["pastDue"] = this.pastDue;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        data["moPayment"] = this.moPayment;
        data["paymentStatus"] = this.paymentStatus;
        data["terms"] = this.terms;
        data["comment"] = this.comment;
        data["maxAccountHistoryDate"] = this.maxAccountHistoryDate ? this.maxAccountHistoryDate.toISOString() : <any>undefined;
        if (this.twoYearHistory && this.twoYearHistory.constructor === Array) {
            data["twoYearHistory"] = [];
            for (let item of this.twoYearHistory)
                data["twoYearHistory"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountInfoDto {
    bureau: string | undefined;
    status: AccountStatus | undefined;
    totalCreditLimit: number | undefined;
    availableCredit: number | undefined;
    creditUtilization: number | undefined;
    accountName: string | undefined;
    accountNumber: string | undefined;
    balance: number | undefined;
    pastDue: number | undefined;
    dateOpened: moment.Moment | undefined;
    moPayment: number | undefined;
    paymentStatus: string | undefined;
    terms: string | undefined;
    comment: string | undefined;
    maxAccountHistoryDate: moment.Moment | undefined;
    twoYearHistory: AccountCreditHistoryDto[] | undefined;
}

export class AccountDto implements IAccountDto {
    accountIds!: number[] | undefined;
    accountName!: string | undefined;
    state!: AccountState | undefined;
    creditLimit!: number | undefined;
    availableCredit!: number | undefined;
    outstandingBalance!: number | undefined;
    ratio!: number | undefined;
    dateOpened!: moment.Moment | undefined;
    accountDetails!: AccountInfoDto[] | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accountIds"] && data["accountIds"].constructor === Array) {
                this.accountIds = [];
                for (let item of data["accountIds"])
                    this.accountIds.push(item);
            }
            this.accountName = data["accountName"];
            this.state = data["state"];
            this.creditLimit = data["creditLimit"];
            this.availableCredit = data["availableCredit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.ratio = data["ratio"];
            this.dateOpened = data["dateOpened"] ? moment(data["dateOpened"].toString()) : <any>undefined;
            if (data["accountDetails"] && data["accountDetails"].constructor === Array) {
                this.accountDetails = [];
                for (let item of data["accountDetails"])
                    this.accountDetails.push(AccountInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accountIds && this.accountIds.constructor === Array) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["accountName"] = this.accountName;
        data["state"] = this.state;
        data["creditLimit"] = this.creditLimit;
        data["availableCredit"] = this.availableCredit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["ratio"] = this.ratio;
        data["dateOpened"] = this.dateOpened ? this.dateOpened.toISOString() : <any>undefined;
        if (this.accountDetails && this.accountDetails.constructor === Array) {
            data["accountDetails"] = [];
            for (let item of this.accountDetails)
                data["accountDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountDto {
    accountIds: number[] | undefined;
    accountName: string | undefined;
    state: AccountState | undefined;
    creditLimit: number | undefined;
    availableCredit: number | undefined;
    outstandingBalance: number | undefined;
    ratio: number | undefined;
    dateOpened: moment.Moment | undefined;
    accountDetails: AccountInfoDto[] | undefined;
}

export enum AlertType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export class AlertDto implements IAlertDto {
    type!: AlertType | undefined;
    bureau!: string | undefined;
    date!: moment.Moment | undefined;
    text!: string | undefined;

    constructor(data?: IAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.text = data["text"];
        }
    }

    static fromJS(data: any): AlertDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["text"] = this.text;
        return data; 
    }
}

export interface IAlertDto {
    type: AlertType | undefined;
    bureau: string | undefined;
    date: moment.Moment | undefined;
    text: string | undefined;
}

export class RecommendationDto implements IRecommendationDto {
    header!: string | undefined;
    text!: string | undefined;
    isPositive!: boolean | undefined;

    constructor(data?: IRecommendationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.header = data["header"];
            this.text = data["text"];
            this.isPositive = data["isPositive"];
        }
    }

    static fromJS(data: any): RecommendationDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["text"] = this.text;
        data["isPositive"] = this.isPositive;
        return data; 
    }
}

export interface IRecommendationDto {
    header: string | undefined;
    text: string | undefined;
    isPositive: boolean | undefined;
}

export class CreditorContactDto implements ICreditorContactDto {
    name!: string | undefined;
    address!: AddressDto | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: ICreditorContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"] ? AddressDto.fromJS(data["address"]) : <any>undefined;
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreditorContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditorContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ICreditorContactDto {
    name: string | undefined;
    address: AddressDto | undefined;
    phoneNumber: string | undefined;
}

export class ConsumerStatementDto implements IConsumerStatementDto {
    bureau!: string | undefined;
    date!: moment.Moment | undefined;
    statement!: string | undefined;

    constructor(data?: IConsumerStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.statement = data["statement"];
        }
    }

    static fromJS(data: any): ConsumerStatementDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerStatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statement"] = this.statement;
        return data; 
    }
}

export interface IConsumerStatementDto {
    bureau: string | undefined;
    date: moment.Moment | undefined;
    statement: string | undefined;
}

export class PublicRecordBureauInfoDto implements IPublicRecordBureauInfoDto {
    bureau!: string | undefined;
    title!: string | undefined;
    type!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateFiledOrReported!: moment.Moment | undefined;
    referenceNo!: string | undefined;
    court!: string | undefined;
    dateVerified!: moment.Moment | undefined;
    dateUpdated!: moment.Moment | undefined;
    dateReleased!: moment.Moment | undefined;
    remarks!: string | undefined;

    constructor(data?: IPublicRecordBureauInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bureau = data["bureau"];
            this.title = data["title"];
            this.type = data["type"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateFiledOrReported = data["dateFiledOrReported"] ? moment(data["dateFiledOrReported"].toString()) : <any>undefined;
            this.referenceNo = data["referenceNo"];
            this.court = data["court"];
            this.dateVerified = data["dateVerified"] ? moment(data["dateVerified"].toString()) : <any>undefined;
            this.dateUpdated = data["dateUpdated"] ? moment(data["dateUpdated"].toString()) : <any>undefined;
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
        }
    }

    static fromJS(data: any): PublicRecordBureauInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordBureauInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bureau"] = this.bureau;
        data["title"] = this.title;
        data["type"] = this.type;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateFiledOrReported"] = this.dateFiledOrReported ? this.dateFiledOrReported.toISOString() : <any>undefined;
        data["referenceNo"] = this.referenceNo;
        data["court"] = this.court;
        data["dateVerified"] = this.dateVerified ? this.dateVerified.toISOString() : <any>undefined;
        data["dateUpdated"] = this.dateUpdated ? this.dateUpdated.toISOString() : <any>undefined;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        return data; 
    }
}

export interface IPublicRecordBureauInfoDto {
    bureau: string | undefined;
    title: string | undefined;
    type: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateFiledOrReported: moment.Moment | undefined;
    referenceNo: string | undefined;
    court: string | undefined;
    dateVerified: moment.Moment | undefined;
    dateUpdated: moment.Moment | undefined;
    dateReleased: moment.Moment | undefined;
    remarks: string | undefined;
}

export class PublicRecordDto implements IPublicRecordDto {
    title!: string | undefined;
    status!: string | undefined;
    amount!: number | undefined;
    dateReleased!: moment.Moment | undefined;
    publicRecordDetails!: PublicRecordBureauInfoDto[] | undefined;

    constructor(data?: IPublicRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.status = data["status"];
            this.amount = data["amount"];
            this.dateReleased = data["dateReleased"] ? moment(data["dateReleased"].toString()) : <any>undefined;
            if (data["publicRecordDetails"] && data["publicRecordDetails"].constructor === Array) {
                this.publicRecordDetails = [];
                for (let item of data["publicRecordDetails"])
                    this.publicRecordDetails.push(PublicRecordBureauInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublicRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublicRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["dateReleased"] = this.dateReleased ? this.dateReleased.toISOString() : <any>undefined;
        if (this.publicRecordDetails && this.publicRecordDetails.constructor === Array) {
            data["publicRecordDetails"] = [];
            for (let item of this.publicRecordDetails)
                data["publicRecordDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPublicRecordDto {
    title: string | undefined;
    status: string | undefined;
    amount: number | undefined;
    dateReleased: moment.Moment | undefined;
    publicRecordDetails: PublicRecordBureauInfoDto[] | undefined;
}

export class CreditReportDto implements ICreditReportDto {
    creditReportId!: number | undefined;
    minScoreValue!: number | undefined;
    maxScoreValue!: number | undefined;
    bureauReports!: CreditBureauReportDto[] | undefined;
    accounts!: AccountDto[] | undefined;
    alerts!: AlertDto[] | undefined;
    recommendations!: RecommendationDto[] | undefined;
    creditorContacts!: CreditorContactDto[] | undefined;
    consumerStatements!: ConsumerStatementDto[] | undefined;
    publicInformation!: PublicRecordDto[] | undefined;

    constructor(data?: ICreditReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creditReportId = data["creditReportId"];
            this.minScoreValue = data["minScoreValue"];
            this.maxScoreValue = data["maxScoreValue"];
            if (data["bureauReports"] && data["bureauReports"].constructor === Array) {
                this.bureauReports = [];
                for (let item of data["bureauReports"])
                    this.bureauReports.push(CreditBureauReportDto.fromJS(item));
            }
            if (data["accounts"] && data["accounts"].constructor === Array) {
                this.accounts = [];
                for (let item of data["accounts"])
                    this.accounts.push(AccountDto.fromJS(item));
            }
            if (data["alerts"] && data["alerts"].constructor === Array) {
                this.alerts = [];
                for (let item of data["alerts"])
                    this.alerts.push(AlertDto.fromJS(item));
            }
            if (data["recommendations"] && data["recommendations"].constructor === Array) {
                this.recommendations = [];
                for (let item of data["recommendations"])
                    this.recommendations.push(RecommendationDto.fromJS(item));
            }
            if (data["creditorContacts"] && data["creditorContacts"].constructor === Array) {
                this.creditorContacts = [];
                for (let item of data["creditorContacts"])
                    this.creditorContacts.push(CreditorContactDto.fromJS(item));
            }
            if (data["consumerStatements"] && data["consumerStatements"].constructor === Array) {
                this.consumerStatements = [];
                for (let item of data["consumerStatements"])
                    this.consumerStatements.push(ConsumerStatementDto.fromJS(item));
            }
            if (data["publicInformation"] && data["publicInformation"].constructor === Array) {
                this.publicInformation = [];
                for (let item of data["publicInformation"])
                    this.publicInformation.push(PublicRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreditReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditReportId"] = this.creditReportId;
        data["minScoreValue"] = this.minScoreValue;
        data["maxScoreValue"] = this.maxScoreValue;
        if (this.bureauReports && this.bureauReports.constructor === Array) {
            data["bureauReports"] = [];
            for (let item of this.bureauReports)
                data["bureauReports"].push(item.toJSON());
        }
        if (this.accounts && this.accounts.constructor === Array) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        if (this.alerts && this.alerts.constructor === Array) {
            data["alerts"] = [];
            for (let item of this.alerts)
                data["alerts"].push(item.toJSON());
        }
        if (this.recommendations && this.recommendations.constructor === Array) {
            data["recommendations"] = [];
            for (let item of this.recommendations)
                data["recommendations"].push(item.toJSON());
        }
        if (this.creditorContacts && this.creditorContacts.constructor === Array) {
            data["creditorContacts"] = [];
            for (let item of this.creditorContacts)
                data["creditorContacts"].push(item.toJSON());
        }
        if (this.consumerStatements && this.consumerStatements.constructor === Array) {
            data["consumerStatements"] = [];
            for (let item of this.consumerStatements)
                data["consumerStatements"].push(item.toJSON());
        }
        if (this.publicInformation && this.publicInformation.constructor === Array) {
            data["publicInformation"] = [];
            for (let item of this.publicInformation)
                data["publicInformation"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreditReportDto {
    creditReportId: number | undefined;
    minScoreValue: number | undefined;
    maxScoreValue: number | undefined;
    bureauReports: CreditBureauReportDto[] | undefined;
    accounts: AccountDto[] | undefined;
    alerts: AlertDto[] | undefined;
    recommendations: RecommendationDto[] | undefined;
    creditorContacts: CreditorContactDto[] | undefined;
    consumerStatements: ConsumerStatementDto[] | undefined;
    publicInformation: PublicRecordDto[] | undefined;
}

export class CreditReportOutput implements ICreditReportOutput {
    memberExists!: boolean | undefined;
    uncompletedPackageId!: number | undefined;
    kbaPassed!: boolean | undefined;
    creditReport!: CreditReportDto | undefined;
    updatable!: boolean | undefined;
    isPaymentDelayed!: boolean | undefined;
    isSubscriptionCancelled!: boolean | undefined;
    previousReportExists!: boolean | undefined;
    refreshErrorMessage!: string | undefined;
    memberFullName!: string | undefined;
    providerCreatedDate!: moment.Moment | undefined;

    constructor(data?: ICreditReportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberExists = data["memberExists"];
            this.uncompletedPackageId = data["uncompletedPackageId"];
            this.kbaPassed = data["kbaPassed"];
            this.creditReport = data["creditReport"] ? CreditReportDto.fromJS(data["creditReport"]) : <any>undefined;
            this.updatable = data["updatable"];
            this.isPaymentDelayed = data["isPaymentDelayed"];
            this.isSubscriptionCancelled = data["isSubscriptionCancelled"];
            this.previousReportExists = data["previousReportExists"];
            this.refreshErrorMessage = data["refreshErrorMessage"];
            this.memberFullName = data["memberFullName"];
            this.providerCreatedDate = data["providerCreatedDate"] ? moment(data["providerCreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditReportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberExists"] = this.memberExists;
        data["uncompletedPackageId"] = this.uncompletedPackageId;
        data["kbaPassed"] = this.kbaPassed;
        data["creditReport"] = this.creditReport ? this.creditReport.toJSON() : <any>undefined;
        data["updatable"] = this.updatable;
        data["isPaymentDelayed"] = this.isPaymentDelayed;
        data["isSubscriptionCancelled"] = this.isSubscriptionCancelled;
        data["previousReportExists"] = this.previousReportExists;
        data["refreshErrorMessage"] = this.refreshErrorMessage;
        data["memberFullName"] = this.memberFullName;
        data["providerCreatedDate"] = this.providerCreatedDate ? this.providerCreatedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreditReportOutput {
    memberExists: boolean | undefined;
    uncompletedPackageId: number | undefined;
    kbaPassed: boolean | undefined;
    creditReport: CreditReportDto | undefined;
    updatable: boolean | undefined;
    isPaymentDelayed: boolean | undefined;
    isSubscriptionCancelled: boolean | undefined;
    previousReportExists: boolean | undefined;
    refreshErrorMessage: string | undefined;
    memberFullName: string | undefined;
    providerCreatedDate: moment.Moment | undefined;
}

export class ScoreHistoryDto implements IScoreHistoryDto {
    scoreDate!: moment.Moment | undefined;
    score!: number | undefined;

    constructor(data?: IScoreHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scoreDate = data["scoreDate"] ? moment(data["scoreDate"].toString()) : <any>undefined;
            this.score = data["score"];
        }
    }

    static fromJS(data: any): ScoreHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scoreDate"] = this.scoreDate ? this.scoreDate.toISOString() : <any>undefined;
        data["score"] = this.score;
        return data; 
    }
}

export interface IScoreHistoryDto {
    scoreDate: moment.Moment | undefined;
    score: number | undefined;
}

export class StringScoreHistoryDtoListKeyValuePair implements IStringScoreHistoryDtoListKeyValuePair {
    key!: string | undefined;
    value!: ScoreHistoryDto[] | undefined;

    constructor(data?: IStringScoreHistoryDtoListKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            if (data["value"] && data["value"].constructor === Array) {
                this.value = [];
                for (let item of data["value"])
                    this.value.push(ScoreHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StringScoreHistoryDtoListKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringScoreHistoryDtoListKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (this.value && this.value.constructor === Array) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStringScoreHistoryDtoListKeyValuePair {
    key: string | undefined;
    value: ScoreHistoryDto[] | undefined;
}

export enum MemberSimulatorAccessStatus {
    Ok = "Ok", 
    NoMember = "NoMember", 
    MemberIsCancelled = "MemberIsCancelled", 
    KbaIsNotPassed = "KbaIsNotPassed", 
    UnsupportedPackage = "UnsupportedPackage", 
    NoPayment = "NoPayment", 
}

export class ScoreSimulatorInfoDto implements IScoreSimulatorInfoDto {
    initialScore!: number | undefined;
    totalCreditLimit!: number | undefined;
    outstandingBalance!: number | undefined;
    accessStatus!: MemberSimulatorAccessStatus | undefined;

    constructor(data?: IScoreSimulatorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.initialScore = data["initialScore"];
            this.totalCreditLimit = data["totalCreditLimit"];
            this.outstandingBalance = data["outstandingBalance"];
            this.accessStatus = data["accessStatus"];
        }
    }

    static fromJS(data: any): ScoreSimulatorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialScore"] = this.initialScore;
        data["totalCreditLimit"] = this.totalCreditLimit;
        data["outstandingBalance"] = this.outstandingBalance;
        data["accessStatus"] = this.accessStatus;
        return data; 
    }
}

export interface IScoreSimulatorInfoDto {
    initialScore: number | undefined;
    totalCreditLimit: number | undefined;
    outstandingBalance: number | undefined;
    accessStatus: MemberSimulatorAccessStatus | undefined;
}

export class ScoreSimulatorDto implements IScoreSimulatorDto {
    onTimePayment!: number | undefined;
    closeOldestCreditCard!: boolean | undefined;
    oneAccountPastDue!: number | undefined;
    allAccountsPastDue!: number | undefined;
    increaseCreditBalance!: number | undefined;
    decreaseCreditBalance!: number | undefined;
    increaseCreditCardLimit!: number | undefined;
    moveOneAccountToCollection!: boolean | undefined;
    addTaxLienPublicRecord!: boolean | undefined;
    addForeClosurePublicRecord!: boolean | undefined;
    addChildSupportPublicRecord!: boolean | undefined;
    addWageGarnishmentPublicRecord!: boolean | undefined;
    declareBankruptcy!: boolean | undefined;
    payOffAllCreditCards!: boolean | undefined;
    applyForCreditCard!: number | undefined;
    obtainCreditCard!: number | undefined;
    obtainMortgage!: number | undefined;
    obtainAutoLoan!: number | undefined;
    obtainPersonalLoan!: number | undefined;
    transferCreditBalances!: number | undefined;

    constructor(data?: IScoreSimulatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.onTimePayment = data["onTimePayment"];
            this.closeOldestCreditCard = data["closeOldestCreditCard"];
            this.oneAccountPastDue = data["oneAccountPastDue"];
            this.allAccountsPastDue = data["allAccountsPastDue"];
            this.increaseCreditBalance = data["increaseCreditBalance"];
            this.decreaseCreditBalance = data["decreaseCreditBalance"];
            this.increaseCreditCardLimit = data["increaseCreditCardLimit"];
            this.moveOneAccountToCollection = data["moveOneAccountToCollection"];
            this.addTaxLienPublicRecord = data["addTaxLienPublicRecord"];
            this.addForeClosurePublicRecord = data["addForeClosurePublicRecord"];
            this.addChildSupportPublicRecord = data["addChildSupportPublicRecord"];
            this.addWageGarnishmentPublicRecord = data["addWageGarnishmentPublicRecord"];
            this.declareBankruptcy = data["declareBankruptcy"];
            this.payOffAllCreditCards = data["payOffAllCreditCards"];
            this.applyForCreditCard = data["applyForCreditCard"];
            this.obtainCreditCard = data["obtainCreditCard"];
            this.obtainMortgage = data["obtainMortgage"];
            this.obtainAutoLoan = data["obtainAutoLoan"];
            this.obtainPersonalLoan = data["obtainPersonalLoan"];
            this.transferCreditBalances = data["transferCreditBalances"];
        }
    }

    static fromJS(data: any): ScoreSimulatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreSimulatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTimePayment"] = this.onTimePayment;
        data["closeOldestCreditCard"] = this.closeOldestCreditCard;
        data["oneAccountPastDue"] = this.oneAccountPastDue;
        data["allAccountsPastDue"] = this.allAccountsPastDue;
        data["increaseCreditBalance"] = this.increaseCreditBalance;
        data["decreaseCreditBalance"] = this.decreaseCreditBalance;
        data["increaseCreditCardLimit"] = this.increaseCreditCardLimit;
        data["moveOneAccountToCollection"] = this.moveOneAccountToCollection;
        data["addTaxLienPublicRecord"] = this.addTaxLienPublicRecord;
        data["addForeClosurePublicRecord"] = this.addForeClosurePublicRecord;
        data["addChildSupportPublicRecord"] = this.addChildSupportPublicRecord;
        data["addWageGarnishmentPublicRecord"] = this.addWageGarnishmentPublicRecord;
        data["declareBankruptcy"] = this.declareBankruptcy;
        data["payOffAllCreditCards"] = this.payOffAllCreditCards;
        data["applyForCreditCard"] = this.applyForCreditCard;
        data["obtainCreditCard"] = this.obtainCreditCard;
        data["obtainMortgage"] = this.obtainMortgage;
        data["obtainAutoLoan"] = this.obtainAutoLoan;
        data["obtainPersonalLoan"] = this.obtainPersonalLoan;
        data["transferCreditBalances"] = this.transferCreditBalances;
        return data; 
    }
}

export interface IScoreSimulatorDto {
    onTimePayment: number | undefined;
    closeOldestCreditCard: boolean | undefined;
    oneAccountPastDue: number | undefined;
    allAccountsPastDue: number | undefined;
    increaseCreditBalance: number | undefined;
    decreaseCreditBalance: number | undefined;
    increaseCreditCardLimit: number | undefined;
    moveOneAccountToCollection: boolean | undefined;
    addTaxLienPublicRecord: boolean | undefined;
    addForeClosurePublicRecord: boolean | undefined;
    addChildSupportPublicRecord: boolean | undefined;
    addWageGarnishmentPublicRecord: boolean | undefined;
    declareBankruptcy: boolean | undefined;
    payOffAllCreditCards: boolean | undefined;
    applyForCreditCard: number | undefined;
    obtainCreditCard: number | undefined;
    obtainMortgage: number | undefined;
    obtainAutoLoan: number | undefined;
    obtainPersonalLoan: number | undefined;
    transferCreditBalances: number | undefined;
}

export class CurrencyInfo implements ICurrencyInfo {
    id!: string | undefined;
    name!: string | undefined;
    symbol!: string | undefined;

    constructor(data?: ICurrencyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.symbol = data["symbol"];
        }
    }

    static fromJS(data: any): CurrencyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        return data; 
    }
}

export interface ICurrencyInfo {
    id: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
}

export class EntityInfo implements IEntityInfo {
    id!: number | undefined;
    name!: string | undefined;
    email!: string | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IEntityInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.email = data["email"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): EntityInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntityInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IEntityInfo {
    id: number | undefined;
    name: string | undefined;
    email: string | undefined;
    isActive: boolean | undefined;
}

export class AccountTotals implements IAccountTotals {
    bankAccountCount!: number | undefined;
    totalNetWorth!: number | undefined;
    totalPending!: number | undefined;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountCount = data["bankAccountCount"];
            this.totalNetWorth = data["totalNetWorth"];
            this.totalPending = data["totalPending"];
        }
    }

    static fromJS(data: any): AccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountCount"] = this.bankAccountCount;
        data["totalNetWorth"] = this.totalNetWorth;
        data["totalPending"] = this.totalPending;
        return data; 
    }
}

export interface IAccountTotals {
    bankAccountCount: number | undefined;
    totalNetWorth: number | undefined;
    totalPending: number | undefined;
}

export class CategorizationStatus implements ICategorizationStatus {
    classifiedTransactionCount!: number | undefined;
    classifiedTransactionPercent!: number | undefined;
    unclassifiedTransactionCount!: number | undefined;
    unclassifiedTransactionPercent!: number | undefined;

    constructor(data?: ICategorizationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classifiedTransactionCount = data["classifiedTransactionCount"];
            this.classifiedTransactionPercent = data["classifiedTransactionPercent"];
            this.unclassifiedTransactionCount = data["unclassifiedTransactionCount"];
            this.unclassifiedTransactionPercent = data["unclassifiedTransactionPercent"];
        }
    }

    static fromJS(data: any): CategorizationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CategorizationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classifiedTransactionCount"] = this.classifiedTransactionCount;
        data["classifiedTransactionPercent"] = this.classifiedTransactionPercent;
        data["unclassifiedTransactionCount"] = this.unclassifiedTransactionCount;
        data["unclassifiedTransactionPercent"] = this.unclassifiedTransactionPercent;
        return data; 
    }
}

export interface ICategorizationStatus {
    classifiedTransactionCount: number | undefined;
    classifiedTransactionPercent: number | undefined;
    unclassifiedTransactionCount: number | undefined;
    unclassifiedTransactionPercent: number | undefined;
}

export class GetDailyBalanceStatsOutput implements IGetDailyBalanceStatsOutput {
    minBalance!: number | undefined;
    avarageBalance!: number | undefined;
    maxBalance!: number | undefined;
    count!: number | undefined;

    constructor(data?: IGetDailyBalanceStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.minBalance = data["minBalance"];
            this.avarageBalance = data["avarageBalance"];
            this.maxBalance = data["maxBalance"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetDailyBalanceStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailyBalanceStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minBalance"] = this.minBalance;
        data["avarageBalance"] = this.avarageBalance;
        data["maxBalance"] = this.maxBalance;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetDailyBalanceStatsOutput {
    minBalance: number | undefined;
    avarageBalance: number | undefined;
    maxBalance: number | undefined;
    count: number | undefined;
}

export class GetSpendingCategoriesOutput implements IGetSpendingCategoriesOutput {
    name!: string | undefined;
    fullName!: string | undefined;
    amount!: number | undefined;

    constructor(data?: IGetSpendingCategoriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.fullName = data["fullName"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetSpendingCategoriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSpendingCategoriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetSpendingCategoriesOutput {
    name: string | undefined;
    fullName: string | undefined;
    amount: number | undefined;
}

export class GetTotalsOutput implements IGetTotalsOutput {
    newOrderAmount!: number | undefined;
    newLeadCount!: number | undefined;
    newClientCount!: number | undefined;
    totalOrderAmount!: number | undefined;
    totalLeadCount!: number | undefined;
    totalClientCount!: number | undefined;

    constructor(data?: IGetTotalsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newOrderAmount = data["newOrderAmount"];
            this.newLeadCount = data["newLeadCount"];
            this.newClientCount = data["newClientCount"];
            this.totalOrderAmount = data["totalOrderAmount"];
            this.totalLeadCount = data["totalLeadCount"];
            this.totalClientCount = data["totalClientCount"];
        }
    }

    static fromJS(data: any): GetTotalsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTotalsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newOrderAmount"] = this.newOrderAmount;
        data["newLeadCount"] = this.newLeadCount;
        data["newClientCount"] = this.newClientCount;
        data["totalOrderAmount"] = this.totalOrderAmount;
        data["totalLeadCount"] = this.totalLeadCount;
        data["totalClientCount"] = this.totalClientCount;
        return data; 
    }
}

export interface IGetTotalsOutput {
    newOrderAmount: number | undefined;
    newLeadCount: number | undefined;
    newClientCount: number | undefined;
    totalOrderAmount: number | undefined;
    totalLeadCount: number | undefined;
    totalClientCount: number | undefined;
}

export class GetCustomerAndLeadStatsOutput implements IGetCustomerAndLeadStatsOutput {
    date!: moment.Moment | undefined;
    customerCount!: number | undefined;
    leadTotalCount!: number | undefined;
    leadStageCount!: { [key: string] : number; } | undefined;

    constructor(data?: IGetCustomerAndLeadStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.customerCount = data["customerCount"];
            this.leadTotalCount = data["leadTotalCount"];
            if (data["leadStageCount"]) {
                this.leadStageCount = {};
                for (let key in data["leadStageCount"]) {
                    if (data["leadStageCount"].hasOwnProperty(key))
                        this.leadStageCount[key] = data["leadStageCount"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetCustomerAndLeadStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerAndLeadStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerCount"] = this.customerCount;
        data["leadTotalCount"] = this.leadTotalCount;
        if (this.leadStageCount) {
            data["leadStageCount"] = {};
            for (let key in this.leadStageCount) {
                if (this.leadStageCount.hasOwnProperty(key))
                    data["leadStageCount"][key] = this.leadStageCount[key];
            }
        }
        return data; 
    }
}

export interface IGetCustomerAndLeadStatsOutput {
    date: moment.Moment | undefined;
    customerCount: number | undefined;
    leadTotalCount: number | undefined;
    leadStageCount: { [key: string] : number; } | undefined;
}

export class GetRecentlyCreatedCustomersOutput implements IGetRecentlyCreatedCustomersOutput {
    id!: number | undefined;
    fullName!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IGetRecentlyCreatedCustomersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRecentlyCreatedCustomersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentlyCreatedCustomersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetRecentlyCreatedCustomersOutput {
    id: number | undefined;
    fullName: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetCustomersByCompanySizeOutput implements IGetCustomersByCompanySizeOutput {
    customerCount!: number | undefined;
    companySizeRange!: string | undefined;

    constructor(data?: IGetCustomersByCompanySizeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerCount = data["customerCount"];
            this.companySizeRange = data["companySizeRange"];
        }
    }

    static fromJS(data: any): GetCustomersByCompanySizeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomersByCompanySizeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerCount"] = this.customerCount;
        data["companySizeRange"] = this.companySizeRange;
        return data; 
    }
}

export interface IGetCustomersByCompanySizeOutput {
    customerCount: number | undefined;
    companySizeRange: string | undefined;
}

export class GetContactsByRegionOutput implements IGetContactsByRegionOutput {
    countryId!: string | undefined;
    stateId!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetContactsByRegionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.stateId = data["stateId"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetContactsByRegionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactsByRegionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetContactsByRegionOutput {
    countryId: string | undefined;
    stateId: string | undefined;
    count: number | undefined;
}

export enum ContactsCountAgeRange {
    UpTo30Days = "UpTo30Days", 
    UpTo60Days = "UpTo60Days", 
    UpTo90Days = "UpTo90Days", 
    UpTo6Months = "UpTo6Months", 
    UpTo12Months = "UpTo12Months", 
    MoreThanYear = "MoreThanYear", 
}

export class ContactsCountAgeRangeGetCountOutput implements IContactsCountAgeRangeGetCountOutput {
    key!: ContactsCountAgeRange | undefined;
    count!: number | undefined;

    constructor(data?: IContactsCountAgeRangeGetCountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): ContactsCountAgeRangeGetCountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactsCountAgeRangeGetCountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IContactsCountAgeRangeGetCountOutput {
    key: ContactsCountAgeRange | undefined;
    count: number | undefined;
}

export class GetCountOutput implements IGetCountOutput {
    key!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetCountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetCountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetCountOutput {
    key: string | undefined;
    count: number | undefined;
}

export class GetCountByStarOutput implements IGetCountByStarOutput {
    colorType!: ContactStarColorType | undefined;
    key!: string | undefined;
    count!: number | undefined;

    constructor(data?: IGetCountByStarOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.colorType = data["colorType"];
            this.key = data["key"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): GetCountByStarOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountByStarOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colorType"] = this.colorType;
        data["key"] = this.key;
        data["count"] = this.count;
        return data; 
    }
}

export interface IGetCountByStarOutput {
    colorType: ContactStarColorType | undefined;
    key: string | undefined;
    count: number | undefined;
}

export class PartnerTypeDto implements IPartnerTypeDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IPartnerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PartnerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPartnerTypeDto {
    id: number | undefined;
    name: string | undefined;
}

export class ContactStarInfoDto implements IContactStarInfoDto {
    id!: number | undefined;
    name!: string | undefined;
    colorType!: ContactStarColorType | undefined;

    constructor(data?: IContactStarInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.colorType = data["colorType"];
        }
    }

    static fromJS(data: any): ContactStarInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStarInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["colorType"] = this.colorType;
        return data; 
    }
}

export interface IContactStarInfoDto {
    id: number | undefined;
    name: string | undefined;
    colorType: ContactStarColorType | undefined;
}

export class ContactTagInfoDto implements IContactTagInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactTagInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactTagInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactTagInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class ContactListInfoDto implements IContactListInfoDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IContactListInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ContactListInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IContactListInfoDto {
    id: number | undefined;
    name: string | undefined;
}

export class OrganizationTypeDto implements IOrganizationTypeDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IOrganizationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): OrganizationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IOrganizationTypeDto {
    id: string | undefined;
    name: string | undefined;
}

export class OrganizationUnitShortDto implements IOrganizationUnitShortDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IOrganizationUnitShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): OrganizationUnitShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IOrganizationUnitShortDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class DocumentInfo implements IDocumentInfo {
    id!: string | undefined;
    typeId!: number | undefined;
    typeName!: string | undefined;
    fileName!: string | undefined;
    size!: string | undefined;
    creationTime!: moment.Moment | undefined;
    isViewSupportedByWopi!: boolean | undefined;
    isEditSupportedByWopi!: boolean | undefined;

    constructor(data?: IDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.typeName = data["typeName"];
            this.fileName = data["fileName"];
            this.size = data["size"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isViewSupportedByWopi = data["isViewSupportedByWopi"];
            this.isEditSupportedByWopi = data["isEditSupportedByWopi"];
        }
    }

    static fromJS(data: any): DocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["typeName"] = this.typeName;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isViewSupportedByWopi"] = this.isViewSupportedByWopi;
        data["isEditSupportedByWopi"] = this.isEditSupportedByWopi;
        return data; 
    }
}

export interface IDocumentInfo {
    id: string | undefined;
    typeId: number | undefined;
    typeName: string | undefined;
    fileName: string | undefined;
    size: string | undefined;
    creationTime: moment.Moment | undefined;
    isViewSupportedByWopi: boolean | undefined;
    isEditSupportedByWopi: boolean | undefined;
}

export class GetUrlOutput implements IGetUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IGetUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IGetUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class UploadDocumentInput implements IUploadDocumentInput {
    typeId!: number | undefined;
    contactId!: number;
    fileName!: string;
    size!: number;
    file!: string;

    constructor(data?: IUploadDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.contactId = data["contactId"];
            this.fileName = data["fileName"];
            this.size = data["size"];
            this.file = data["file"];
        }
    }

    static fromJS(data: any): UploadDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["contactId"] = this.contactId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        data["file"] = this.file;
        return data; 
    }
}

export interface IUploadDocumentInput {
    typeId: number | undefined;
    contactId: number;
    fileName: string;
    size: number;
    file: string;
}

export class UpdateTypeInput implements IUpdateTypeInput {
    documentId!: string;
    typeId!: number | undefined;

    constructor(data?: IUpdateTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentId = data["documentId"];
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): UpdateTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IUpdateTypeInput {
    documentId: string;
    typeId: number | undefined;
}

export class WopiRequestOutcoming implements IWopiRequestOutcoming {
    accessToken!: string | undefined;
    accessTokenTtl!: number | undefined;
    wopiUrlsrc!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IWopiRequestOutcoming) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.accessTokenTtl = data["accessTokenTtl"];
            this.wopiUrlsrc = data["wopiUrlsrc"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): WopiRequestOutcoming {
        data = typeof data === 'object' ? data : {};
        let result = new WopiRequestOutcoming();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenTtl"] = this.accessTokenTtl;
        data["wopiUrlsrc"] = this.wopiUrlsrc;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IWopiRequestOutcoming {
    accessToken: string | undefined;
    accessTokenTtl: number | undefined;
    wopiUrlsrc: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export class DocumentTypeInfo implements IDocumentTypeInfo {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IDocumentTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): DocumentTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDocumentTypeInfo {
    id: number | undefined;
    name: string | undefined;
}

export class CreateDocumentTypeInput implements ICreateDocumentTypeInput {
    name!: string;

    constructor(data?: ICreateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateDocumentTypeInput {
    name: string;
}

export class UpdateDocumentTypeInput implements IUpdateDocumentTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IUpdateDocumentTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UpdateDocumentTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUpdateDocumentTypeInput {
    id: number;
    name: string;
}

export enum ModuleType {
    CFO = "CFO", 
    CRM = "CRM", 
    CFO_CRM = "CFO_CRM", 
    PFM = "PFM", 
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment | undefined;
    module!: ModuleType | undefined;
    packageName!: string | undefined;
    isForPartner!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.module = data["module"];
            this.packageName = data["packageName"];
            this.isForPartner = data["isForPartner"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["module"] = this.module;
        data["packageName"] = this.packageName;
        data["isForPartner"] = this.isForPartner;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    module: ModuleType | undefined;
    packageName: string | undefined;
    isForPartner: boolean | undefined;
    id: number | undefined;
}

export class EditionListDtoListResultDto implements IEditionListDtoListResultDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IEditionListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionListDtoListResultDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class IValueValidator implements IIValueValidator {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export enum DimentionName {
    Action = "Action", 
    Blueprint = "Blueprint", 
    Nurturing = "Nurturing", 
    Knowledge = "Knowledge", 
}

export class Dimmension implements IDimmension {
    name!: DimentionName | undefined;
    value!: number | undefined;

    constructor(data?: IDimmension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Dimmension {
        data = typeof data === 'object' ? data : {};
        let result = new Dimmension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IDimmension {
    name: DimentionName | undefined;
    value: number | undefined;
}

export class GetBankCodeResponse implements IGetBankCodeResponse {
    dimmensions!: Dimmension[] | undefined;

    constructor(data?: IGetBankCodeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dimmensions"] && data["dimmensions"].constructor === Array) {
                this.dimmensions = [];
                for (let item of data["dimmensions"])
                    this.dimmensions.push(Dimmension.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetBankCodeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankCodeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dimmensions && this.dimmensions.constructor === Array) {
            data["dimmensions"] = [];
            for (let item of this.dimmensions)
                data["dimmensions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetBankCodeResponse {
    dimmensions: Dimmension[] | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export enum ChartDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;
    zendeskAccountUrl!: string | undefined;
    publicSiteUrl!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
            this.zendeskAccountUrl = data["zendeskAccountUrl"];
            this.publicSiteUrl = data["publicSiteUrl"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        data["zendeskAccountUrl"] = this.zendeskAccountUrl;
        data["publicSiteUrl"] = this.publicSiteUrl;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
    zendeskAccountUrl: string | undefined;
    publicSiteUrl: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class BugsnagSettingsDto implements IBugsnagSettingsDto {
    appApiKey!: string | undefined;
    uiApiKey!: string | undefined;

    constructor(data?: IBugsnagSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appApiKey = data["appApiKey"];
            this.uiApiKey = data["uiApiKey"];
        }
    }

    static fromJS(data: any): BugsnagSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BugsnagSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appApiKey"] = this.appApiKey;
        data["uiApiKey"] = this.uiApiKey;
        return data; 
    }
}

export interface IBugsnagSettingsDto {
    appApiKey: string | undefined;
    uiApiKey: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    bugsnag!: BugsnagSettingsDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.bugsnag = data["bugsnag"] ? BugsnagSettingsDto.fromJS(data["bugsnag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["bugsnag"] = this.bugsnag ? this.bugsnag.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    bugsnag: BugsnagSettingsDto | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class ImportFullName implements IImportFullName {
    prefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nickName!: string | undefined;
    suffix!: string | undefined;

    constructor(data?: IImportFullName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prefix = data["prefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nickName = data["nickName"];
            this.suffix = data["suffix"];
        }
    }

    static fromJS(data: any): ImportFullName {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFullName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prefix"] = this.prefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nickName"] = this.nickName;
        data["suffix"] = this.suffix;
        return data; 
    }
}

export interface IImportFullName {
    prefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nickName: string | undefined;
    suffix: string | undefined;
}

export class ImportAddressInput implements IImportAddressInput {
    street!: string | undefined;
    city!: string | undefined;
    stateName!: string | undefined;
    stateCode!: string | undefined;
    zipCode!: string | undefined;
    countryName!: string | undefined;
    countryCode!: string | undefined;

    constructor(data?: IImportAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.street = data["street"];
            this.city = data["city"];
            this.stateName = data["stateName"];
            this.stateCode = data["stateCode"];
            this.zipCode = data["zipCode"];
            this.countryName = data["countryName"];
            this.countryCode = data["countryCode"];
        }
    }

    static fromJS(data: any): ImportAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["city"] = this.city;
        data["stateName"] = this.stateName;
        data["stateCode"] = this.stateCode;
        data["zipCode"] = this.zipCode;
        data["countryName"] = this.countryName;
        data["countryCode"] = this.countryCode;
        return data; 
    }
}

export interface IImportAddressInput {
    street: string | undefined;
    city: string | undefined;
    stateName: string | undefined;
    stateCode: string | undefined;
    zipCode: string | undefined;
    countryName: string | undefined;
    countryCode: string | undefined;
}

export class ImportPersonalInput implements IImportPersonalInput {
    fullName!: ImportFullName | undefined;
    doB!: moment.Moment | undefined;
    mobilePhone!: string | undefined;
    mobilePhoneExt!: string | undefined;
    homePhone!: string | undefined;
    homePhoneExt!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    ssn!: string | undefined;
    bankCode!: string | undefined;
    email1!: string | undefined;
    email2!: string | undefined;
    email3!: string | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    gender!: Gender | undefined;
    fullAddress!: ImportAddressInput | undefined;
    isUSCitizen!: boolean | undefined;
    webSiteUrl!: string | undefined;
    facebookUrl!: string | undefined;
    linkedInUrl!: string | undefined;
    instagramUrl!: string | undefined;
    twitterUrl!: string | undefined;
    googlePlusUrl!: string | undefined;
    angelListUrl!: string | undefined;
    photoUrl!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    interests!: string[] | undefined;

    constructor(data?: IImportPersonalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"] ? ImportFullName.fromJS(data["fullName"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.mobilePhone = data["mobilePhone"];
            this.mobilePhoneExt = data["mobilePhoneExt"];
            this.homePhone = data["homePhone"];
            this.homePhoneExt = data["homePhoneExt"];
            this.preferredToD = data["preferredToD"];
            this.ssn = data["ssn"];
            this.bankCode = data["bankCode"];
            this.email1 = data["email1"];
            this.email2 = data["email2"];
            this.email3 = data["email3"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            this.gender = data["gender"];
            this.fullAddress = data["fullAddress"] ? ImportAddressInput.fromJS(data["fullAddress"]) : <any>undefined;
            this.isUSCitizen = data["isUSCitizen"];
            this.webSiteUrl = data["webSiteUrl"];
            this.facebookUrl = data["facebookUrl"];
            this.linkedInUrl = data["linkedInUrl"];
            this.instagramUrl = data["instagramUrl"];
            this.twitterUrl = data["twitterUrl"];
            this.googlePlusUrl = data["googlePlusUrl"];
            this.angelListUrl = data["angelListUrl"];
            this.photoUrl = data["photoUrl"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
        }
    }

    static fromJS(data: any): ImportPersonalInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPersonalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName ? this.fullName.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["mobilePhoneExt"] = this.mobilePhoneExt;
        data["homePhone"] = this.homePhone;
        data["homePhoneExt"] = this.homePhoneExt;
        data["preferredToD"] = this.preferredToD;
        data["ssn"] = this.ssn;
        data["bankCode"] = this.bankCode;
        data["email1"] = this.email1;
        data["email2"] = this.email2;
        data["email3"] = this.email3;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        data["gender"] = this.gender;
        data["fullAddress"] = this.fullAddress ? this.fullAddress.toJSON() : <any>undefined;
        data["isUSCitizen"] = this.isUSCitizen;
        data["webSiteUrl"] = this.webSiteUrl;
        data["facebookUrl"] = this.facebookUrl;
        data["linkedInUrl"] = this.linkedInUrl;
        data["instagramUrl"] = this.instagramUrl;
        data["twitterUrl"] = this.twitterUrl;
        data["googlePlusUrl"] = this.googlePlusUrl;
        data["angelListUrl"] = this.angelListUrl;
        data["photoUrl"] = this.photoUrl;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        return data; 
    }
}

export interface IImportPersonalInput {
    fullName: ImportFullName | undefined;
    doB: moment.Moment | undefined;
    mobilePhone: string | undefined;
    mobilePhoneExt: string | undefined;
    homePhone: string | undefined;
    homePhoneExt: string | undefined;
    preferredToD: TimeOfDay | undefined;
    ssn: string | undefined;
    bankCode: string | undefined;
    email1: string | undefined;
    email2: string | undefined;
    email3: string | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    gender: Gender | undefined;
    fullAddress: ImportAddressInput | undefined;
    isUSCitizen: boolean | undefined;
    webSiteUrl: string | undefined;
    facebookUrl: string | undefined;
    linkedInUrl: string | undefined;
    instagramUrl: string | undefined;
    twitterUrl: string | undefined;
    googlePlusUrl: string | undefined;
    angelListUrl: string | undefined;
    photoUrl: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    interests: string[] | undefined;
}

export class ImportBusinessInput implements IImportBusinessInput {
    companyName!: string | undefined;
    organizationType!: string | undefined;
    jobTitle!: string | undefined;
    isEmployed!: boolean | undefined;
    employmentStartDate!: moment.Moment | undefined;
    employeeCount!: number | undefined;
    dateFounded!: moment.Moment | undefined;
    ein!: string | undefined;
    annualRevenue!: number | undefined;
    industry!: string | undefined;
    companyPhone!: string | undefined;
    companyPhoneExt!: string | undefined;
    companyFaxNumber!: string | undefined;
    companyEmail!: string | undefined;
    companyFullAddress!: ImportAddressInput | undefined;
    companyWebSiteUrl!: string | undefined;
    companyFacebookUrl!: string | undefined;
    companyLinkedInUrl!: string | undefined;
    companyInstagramUrl!: string | undefined;
    companyTwitterUrl!: string | undefined;
    companyGooglePlusUrl!: string | undefined;
    companyCrunchbaseUrl!: string | undefined;
    companyBBBUrl!: string | undefined;
    companyLogoUrl!: string | undefined;
    workPhone1!: string | undefined;
    workPhone1Ext!: string | undefined;
    workPhone2!: string | undefined;
    workPhone2Ext!: string | undefined;
    workEmail1!: string | undefined;
    workEmail2!: string | undefined;
    workEmail3!: string | undefined;
    workFullAddress!: ImportAddressInput | undefined;

    constructor(data?: IImportBusinessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.organizationType = data["organizationType"];
            this.jobTitle = data["jobTitle"];
            this.isEmployed = data["isEmployed"];
            this.employmentStartDate = data["employmentStartDate"] ? moment(data["employmentStartDate"].toString()) : <any>undefined;
            this.employeeCount = data["employeeCount"];
            this.dateFounded = data["dateFounded"] ? moment(data["dateFounded"].toString()) : <any>undefined;
            this.ein = data["ein"];
            this.annualRevenue = data["annualRevenue"];
            this.industry = data["industry"];
            this.companyPhone = data["companyPhone"];
            this.companyPhoneExt = data["companyPhoneExt"];
            this.companyFaxNumber = data["companyFaxNumber"];
            this.companyEmail = data["companyEmail"];
            this.companyFullAddress = data["companyFullAddress"] ? ImportAddressInput.fromJS(data["companyFullAddress"]) : <any>undefined;
            this.companyWebSiteUrl = data["companyWebSiteUrl"];
            this.companyFacebookUrl = data["companyFacebookUrl"];
            this.companyLinkedInUrl = data["companyLinkedInUrl"];
            this.companyInstagramUrl = data["companyInstagramUrl"];
            this.companyTwitterUrl = data["companyTwitterUrl"];
            this.companyGooglePlusUrl = data["companyGooglePlusUrl"];
            this.companyCrunchbaseUrl = data["companyCrunchbaseUrl"];
            this.companyBBBUrl = data["companyBBBUrl"];
            this.companyLogoUrl = data["companyLogoUrl"];
            this.workPhone1 = data["workPhone1"];
            this.workPhone1Ext = data["workPhone1Ext"];
            this.workPhone2 = data["workPhone2"];
            this.workPhone2Ext = data["workPhone2Ext"];
            this.workEmail1 = data["workEmail1"];
            this.workEmail2 = data["workEmail2"];
            this.workEmail3 = data["workEmail3"];
            this.workFullAddress = data["workFullAddress"] ? ImportAddressInput.fromJS(data["workFullAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportBusinessInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportBusinessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["organizationType"] = this.organizationType;
        data["jobTitle"] = this.jobTitle;
        data["isEmployed"] = this.isEmployed;
        data["employmentStartDate"] = this.employmentStartDate ? this.employmentStartDate.toISOString() : <any>undefined;
        data["employeeCount"] = this.employeeCount;
        data["dateFounded"] = this.dateFounded ? this.dateFounded.toISOString() : <any>undefined;
        data["ein"] = this.ein;
        data["annualRevenue"] = this.annualRevenue;
        data["industry"] = this.industry;
        data["companyPhone"] = this.companyPhone;
        data["companyPhoneExt"] = this.companyPhoneExt;
        data["companyFaxNumber"] = this.companyFaxNumber;
        data["companyEmail"] = this.companyEmail;
        data["companyFullAddress"] = this.companyFullAddress ? this.companyFullAddress.toJSON() : <any>undefined;
        data["companyWebSiteUrl"] = this.companyWebSiteUrl;
        data["companyFacebookUrl"] = this.companyFacebookUrl;
        data["companyLinkedInUrl"] = this.companyLinkedInUrl;
        data["companyInstagramUrl"] = this.companyInstagramUrl;
        data["companyTwitterUrl"] = this.companyTwitterUrl;
        data["companyGooglePlusUrl"] = this.companyGooglePlusUrl;
        data["companyCrunchbaseUrl"] = this.companyCrunchbaseUrl;
        data["companyBBBUrl"] = this.companyBBBUrl;
        data["companyLogoUrl"] = this.companyLogoUrl;
        data["workPhone1"] = this.workPhone1;
        data["workPhone1Ext"] = this.workPhone1Ext;
        data["workPhone2"] = this.workPhone2;
        data["workPhone2Ext"] = this.workPhone2Ext;
        data["workEmail1"] = this.workEmail1;
        data["workEmail2"] = this.workEmail2;
        data["workEmail3"] = this.workEmail3;
        data["workFullAddress"] = this.workFullAddress ? this.workFullAddress.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IImportBusinessInput {
    companyName: string | undefined;
    organizationType: string | undefined;
    jobTitle: string | undefined;
    isEmployed: boolean | undefined;
    employmentStartDate: moment.Moment | undefined;
    employeeCount: number | undefined;
    dateFounded: moment.Moment | undefined;
    ein: string | undefined;
    annualRevenue: number | undefined;
    industry: string | undefined;
    companyPhone: string | undefined;
    companyPhoneExt: string | undefined;
    companyFaxNumber: string | undefined;
    companyEmail: string | undefined;
    companyFullAddress: ImportAddressInput | undefined;
    companyWebSiteUrl: string | undefined;
    companyFacebookUrl: string | undefined;
    companyLinkedInUrl: string | undefined;
    companyInstagramUrl: string | undefined;
    companyTwitterUrl: string | undefined;
    companyGooglePlusUrl: string | undefined;
    companyCrunchbaseUrl: string | undefined;
    companyBBBUrl: string | undefined;
    companyLogoUrl: string | undefined;
    workPhone1: string | undefined;
    workPhone1Ext: string | undefined;
    workPhone2: string | undefined;
    workPhone2Ext: string | undefined;
    workEmail1: string | undefined;
    workEmail2: string | undefined;
    workEmail3: string | undefined;
    workFullAddress: ImportAddressInput | undefined;
}

export class ImportItemInput implements IImportItemInput {
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadSource!: string | undefined;
    affiliateId!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    referrerURL!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;

    constructor(data?: IImportItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personalInfo = data["personalInfo"] ? ImportPersonalInput.fromJS(data["personalInfo"]) : <any>undefined;
            this.businessInfo = data["businessInfo"] ? ImportBusinessInput.fromJS(data["businessInfo"]) : <any>undefined;
            this.notes = data["notes"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.leadSource = data["leadSource"];
            this.affiliateId = data["affiliateId"];
            this.campaignId = data["campaignId"];
            this.channelId = data["channelId"];
            this.gclId = data["gclId"];
            this.referrerURL = data["referrerURL"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.utmSource = data["utmSource"];
            this.utmMedium = data["utmMedium"];
            this.utmCampaign = data["utmCampaign"];
            this.utmTerm = data["utmTerm"];
            this.utmContent = data["utmContent"];
            this.utmKeyword = data["utmKeyword"];
            this.utmAdGroup = data["utmAdGroup"];
            this.utmName = data["utmName"];
        }
    }

    static fromJS(data: any): ImportItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadSource"] = this.leadSource;
        data["affiliateId"] = this.affiliateId;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["referrerURL"] = this.referrerURL;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        return data; 
    }
}

export interface IImportItemInput {
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadSource: string | undefined;
    affiliateId: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    referrerURL: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
}

export class ImportFieldInfoDto implements IImportFieldInfoDto {
    inputFieldName!: string;
    outputFieldName!: string;

    constructor(data?: IImportFieldInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inputFieldName = data["inputFieldName"];
            this.outputFieldName = data["outputFieldName"];
        }
    }

    static fromJS(data: any): ImportFieldInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportFieldInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputFieldName"] = this.inputFieldName;
        data["outputFieldName"] = this.outputFieldName;
        return data; 
    }
}

export interface IImportFieldInfoDto {
    inputFieldName: string;
    outputFieldName: string;
}

export enum ImportTypeInput {
    Lead = "Lead", 
    Client = "Client", 
    Partner = "Partner", 
    Investor = "Investor", 
    Vendor = "Vendor", 
    Employee = "Employee", 
    Order = "Order", 
}

export class ImportInput implements IImportInput {
    items!: ImportItemInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    tags!: ContactTagInput[] | undefined;
    fields!: ImportFieldInfoDto[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    starId!: number | undefined;
    leadStageId!: number | undefined;
    importType!: ImportTypeInput | undefined;
    partnerTypeName!: string | undefined;
    fileName!: string;
    fileSize!: number;
    fileContent!: string;
    ignoreInvalidValues!: boolean | undefined;

    constructor(data?: IImportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ImportItemInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["fields"] && data["fields"].constructor === Array) {
                this.fields = [];
                for (let item of data["fields"])
                    this.fields.push(ImportFieldInfoDto.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.starId = data["starId"];
            this.leadStageId = data["leadStageId"];
            this.importType = data["importType"];
            this.partnerTypeName = data["partnerTypeName"];
            this.fileName = data["fileName"];
            this.fileSize = data["fileSize"];
            this.fileContent = data["fileContent"];
            this.ignoreInvalidValues = data["ignoreInvalidValues"];
        }
    }

    static fromJS(data: any): ImportInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.fields && this.fields.constructor === Array) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["starId"] = this.starId;
        data["leadStageId"] = this.leadStageId;
        data["importType"] = this.importType;
        data["partnerTypeName"] = this.partnerTypeName;
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        data["fileContent"] = this.fileContent;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        return data; 
    }
}

export interface IImportInput {
    items: ImportItemInput[] | undefined;
    lists: ContactListInput[] | undefined;
    tags: ContactTagInput[] | undefined;
    fields: ImportFieldInfoDto[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    starId: number | undefined;
    leadStageId: number | undefined;
    importType: ImportTypeInput | undefined;
    partnerTypeName: string | undefined;
    fileName: string;
    fileSize: number;
    fileContent: string;
    ignoreInvalidValues: boolean | undefined;
}

export class GetImportStatusOutput implements IGetImportStatusOutput {
    id!: number | undefined;
    statusId!: string | undefined;
    fileName!: string | undefined;
    totalCount!: number | undefined;
    importedCount!: number | undefined;
    failedCount!: number | undefined;

    constructor(data?: IGetImportStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusId = data["statusId"];
            this.fileName = data["fileName"];
            this.totalCount = data["totalCount"];
            this.importedCount = data["importedCount"];
            this.failedCount = data["failedCount"];
        }
    }

    static fromJS(data: any): GetImportStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImportStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusId"] = this.statusId;
        data["fileName"] = this.fileName;
        data["totalCount"] = this.totalCount;
        data["importedCount"] = this.importedCount;
        data["failedCount"] = this.failedCount;
        return data; 
    }
}

export interface IGetImportStatusOutput {
    id: number | undefined;
    statusId: string | undefined;
    fileName: string | undefined;
    totalCount: number | undefined;
    importedCount: number | undefined;
    failedCount: number | undefined;
}

export class GetFileUrlOutput implements IGetFileUrlOutput {
    url!: string | undefined;
    validityPeriod!: string | undefined;

    constructor(data?: IGetFileUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriod = data["validityPeriod"];
        }
    }

    static fromJS(data: any): GetFileUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriod"] = this.validityPeriod;
        return data; 
    }
}

export interface IGetFileUrlOutput {
    url: string | undefined;
    validityPeriod: string | undefined;
}

export class ImportContactInput implements IImportContactInput {
    contactId!: number | undefined;
    contactXref!: string | undefined;
    lists!: string[] | undefined;
    tags!: string[] | undefined;
    rating!: number | undefined;
    star!: string | undefined;
    leadStageName!: string | undefined;
    importType!: ImportTypeInput | undefined;
    partnerTypeName!: string | undefined;
    ignoreInvalidValues!: boolean | undefined;
    overrideLists!: boolean | undefined;
    personalInfo!: ImportPersonalInput | undefined;
    businessInfo!: ImportBusinessInput | undefined;
    notes!: string | undefined;
    dateCreated!: moment.Moment | undefined;
    leadSource!: string | undefined;
    affiliateId!: string | undefined;
    campaignId!: string | undefined;
    channelId!: string | undefined;
    gclId!: string | undefined;
    referrerURL!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    ipAddress!: string | undefined;
    userAgent!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    utmSource!: string | undefined;
    utmMedium!: string | undefined;
    utmCampaign!: string | undefined;
    utmTerm!: string | undefined;
    utmContent!: string | undefined;
    utmKeyword!: string | undefined;
    utmAdGroup!: string | undefined;
    utmName!: string | undefined;

    constructor(data?: IImportContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.overrideLists = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.contactXref = data["contactXref"];
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(item);
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            this.rating = data["rating"];
            this.star = data["star"];
            this.leadStageName = data["leadStageName"];
            this.importType = data["importType"];
            this.partnerTypeName = data["partnerTypeName"];
            this.ignoreInvalidValues = data["ignoreInvalidValues"];
            this.overrideLists = data["overrideLists"] !== undefined ? data["overrideLists"] : false;
            this.personalInfo = data["personalInfo"] ? ImportPersonalInput.fromJS(data["personalInfo"]) : <any>undefined;
            this.businessInfo = data["businessInfo"] ? ImportBusinessInput.fromJS(data["businessInfo"]) : <any>undefined;
            this.notes = data["notes"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.leadSource = data["leadSource"];
            this.affiliateId = data["affiliateId"];
            this.campaignId = data["campaignId"];
            this.channelId = data["channelId"];
            this.gclId = data["gclId"];
            this.referrerURL = data["referrerURL"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.ipAddress = data["ipAddress"];
            this.userAgent = data["userAgent"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.utmSource = data["utmSource"];
            this.utmMedium = data["utmMedium"];
            this.utmCampaign = data["utmCampaign"];
            this.utmTerm = data["utmTerm"];
            this.utmContent = data["utmContent"];
            this.utmKeyword = data["utmKeyword"];
            this.utmAdGroup = data["utmAdGroup"];
            this.utmName = data["utmName"];
        }
    }

    static fromJS(data: any): ImportContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["contactXref"] = this.contactXref;
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item);
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["rating"] = this.rating;
        data["star"] = this.star;
        data["leadStageName"] = this.leadStageName;
        data["importType"] = this.importType;
        data["partnerTypeName"] = this.partnerTypeName;
        data["ignoreInvalidValues"] = this.ignoreInvalidValues;
        data["overrideLists"] = this.overrideLists;
        data["personalInfo"] = this.personalInfo ? this.personalInfo.toJSON() : <any>undefined;
        data["businessInfo"] = this.businessInfo ? this.businessInfo.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["leadSource"] = this.leadSource;
        data["affiliateId"] = this.affiliateId;
        data["campaignId"] = this.campaignId;
        data["channelId"] = this.channelId;
        data["gclId"] = this.gclId;
        data["referrerURL"] = this.referrerURL;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["utmSource"] = this.utmSource;
        data["utmMedium"] = this.utmMedium;
        data["utmCampaign"] = this.utmCampaign;
        data["utmTerm"] = this.utmTerm;
        data["utmContent"] = this.utmContent;
        data["utmKeyword"] = this.utmKeyword;
        data["utmAdGroup"] = this.utmAdGroup;
        data["utmName"] = this.utmName;
        return data; 
    }
}

export interface IImportContactInput {
    contactId: number | undefined;
    contactXref: string | undefined;
    lists: string[] | undefined;
    tags: string[] | undefined;
    rating: number | undefined;
    star: string | undefined;
    leadStageName: string | undefined;
    importType: ImportTypeInput | undefined;
    partnerTypeName: string | undefined;
    ignoreInvalidValues: boolean | undefined;
    overrideLists: boolean | undefined;
    personalInfo: ImportPersonalInput | undefined;
    businessInfo: ImportBusinessInput | undefined;
    notes: string | undefined;
    dateCreated: moment.Moment | undefined;
    leadSource: string | undefined;
    affiliateId: string | undefined;
    campaignId: string | undefined;
    channelId: string | undefined;
    gclId: string | undefined;
    referrerURL: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    ipAddress: string | undefined;
    userAgent: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    utmSource: string | undefined;
    utmMedium: string | undefined;
    utmCampaign: string | undefined;
    utmTerm: string | undefined;
    utmContent: string | undefined;
    utmKeyword: string | undefined;
    utmAdGroup: string | undefined;
    utmName: string | undefined;
}

export enum InstanceType {
    User = "User", 
    Main = "Main", 
}

export enum InstanceStatus {
    NotInitialized = "NotInitialized", 
    Active = "Active", 
    Inactive = "Inactive", 
}

export class GetStatusOutput implements IGetStatusOutput {
    status!: InstanceStatus | undefined;
    userId!: number | undefined;
    hasSyncAccounts!: boolean | undefined;
    hasTransactions!: boolean | undefined;

    constructor(data?: IGetStatusOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.userId = data["userId"];
            this.hasSyncAccounts = data["hasSyncAccounts"];
            this.hasTransactions = data["hasTransactions"];
        }
    }

    static fromJS(data: any): GetStatusOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatusOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["hasSyncAccounts"] = this.hasSyncAccounts;
        data["hasTransactions"] = this.hasTransactions;
        return data; 
    }
}

export interface IGetStatusOutput {
    status: InstanceStatus | undefined;
    userId: number | undefined;
    hasSyncAccounts: boolean | undefined;
    hasTransactions: boolean | undefined;
}

export enum AccountingTreeType {
    Simple = "Simple", 
    Standard = "Standard", 
}

export class SetupOutput implements ISetupOutput {
    userId!: number | undefined;
    alreadyInitialized!: boolean | undefined;

    constructor(data?: ISetupOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.alreadyInitialized = data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): SetupOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SetupOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data; 
    }
}

export interface ISetupOutput {
    userId: number | undefined;
    alreadyInitialized: boolean | undefined;
}

export class RegisterMemberInput implements IRegisterMemberInput {
    contactId!: number;
    channelCode!: string;
    accountingTreeType!: AccountingTreeType | undefined;

    constructor(data?: IRegisterMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.channelCode = data["channelCode"];
            this.accountingTreeType = data["accountingTreeType"];
        }
    }

    static fromJS(data: any): RegisterMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["channelCode"] = this.channelCode;
        data["accountingTreeType"] = this.accountingTreeType;
        return data; 
    }
}

export interface IRegisterMemberInput {
    contactId: number;
    channelCode: string;
    accountingTreeType: AccountingTreeType | undefined;
}

export class RegisterMemberOutput implements IRegisterMemberOutput {
    userId!: number | undefined;
    alreadyInitialized!: boolean | undefined;

    constructor(data?: IRegisterMemberOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.alreadyInitialized = data["alreadyInitialized"];
        }
    }

    static fromJS(data: any): RegisterMemberOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["alreadyInitialized"] = this.alreadyInitialized;
        return data; 
    }
}

export interface IRegisterMemberOutput {
    userId: number | undefined;
    alreadyInitialized: boolean | undefined;
}

export class GetUserInstanceInfoOutput implements IGetUserInstanceInfoOutput {
    id!: number | undefined;
    status!: InstanceStatus | undefined;

    constructor(data?: IGetUserInstanceInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): GetUserInstanceInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserInstanceInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IGetUserInstanceInfoOutput {
    id: number | undefined;
    status: InstanceStatus | undefined;
}

export class CreateInvoiceLineInput implements ICreateInvoiceLineInput {
    quantity!: number;
    rate!: number;
    unitId!: string;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: ICreateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.unitId = data["unitId"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateInvoiceLineInput {
    quantity: number;
    rate: number;
    unitId: string;
    description: string | undefined;
    sortOrder: number;
}

export class CreateInvoiceInput implements ICreateInvoiceInput {
    contactId!: number;
    orderId!: number | undefined;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment;
    description!: string | undefined;
    note!: string | undefined;
    lines!: CreateInvoiceLineInput[] | undefined;

    constructor(data?: ICreateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.orderId = data["orderId"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(CreateInvoiceLineInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateInvoiceInput {
    contactId: number;
    orderId: number | undefined;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment;
    description: string | undefined;
    note: string | undefined;
    lines: CreateInvoiceLineInput[] | undefined;
}

export class InvoiceLineInfo implements IInvoiceLineInfo {
    id!: number | undefined;
    quantity!: number | undefined;
    rate!: number | undefined;
    unitId!: string | undefined;
    amount!: number | undefined;
    description!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IInvoiceLineInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.unitId = data["unitId"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): InvoiceLineInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLineInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IInvoiceLineInfo {
    id: number | undefined;
    quantity: number | undefined;
    rate: number | undefined;
    unitId: string | undefined;
    amount: number | undefined;
    description: string | undefined;
    sortOrder: number | undefined;
}

export class InvoiceInfo implements IInvoiceInfo {
    contactName!: string | undefined;
    orderNumber!: string | undefined;
    status!: InvoiceStatus | undefined;
    number!: string | undefined;
    date!: moment.Moment | undefined;
    dueDate!: moment.Moment | undefined;
    description!: string | undefined;
    note!: string | undefined;
    lines!: InvoiceLineInfo[] | undefined;

    constructor(data?: IInvoiceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactName = data["contactName"];
            this.orderNumber = data["orderNumber"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLineInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["orderNumber"] = this.orderNumber;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoiceInfo {
    contactName: string | undefined;
    orderNumber: string | undefined;
    status: InvoiceStatus | undefined;
    number: string | undefined;
    date: moment.Moment | undefined;
    dueDate: moment.Moment | undefined;
    description: string | undefined;
    note: string | undefined;
    lines: InvoiceLineInfo[] | undefined;
}

export class UpdateInvoiceLineInput implements IUpdateInvoiceLineInput {
    id!: number | undefined;
    quantity!: number;
    rate!: number;
    unitId!: string;
    description!: string | undefined;
    sortOrder!: number;

    constructor(data?: IUpdateInvoiceLineInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.quantity = data["quantity"];
            this.rate = data["rate"];
            this.unitId = data["unitId"];
            this.description = data["description"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateInvoiceLineInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceLineInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["rate"] = this.rate;
        data["unitId"] = this.unitId;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateInvoiceLineInput {
    id: number | undefined;
    quantity: number;
    rate: number;
    unitId: string;
    description: string | undefined;
    sortOrder: number;
}

export class UpdateInvoiceInput implements IUpdateInvoiceInput {
    id!: number;
    status!: InvoiceStatus;
    number!: string | undefined;
    date!: moment.Moment;
    dueDate!: moment.Moment;
    description!: string | undefined;
    note!: string | undefined;
    lines!: UpdateInvoiceLineInput[] | undefined;

    constructor(data?: IUpdateInvoiceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
            this.number = data["number"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.note = data["note"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(UpdateInvoiceLineInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateInvoiceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["note"] = this.note;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateInvoiceInput {
    id: number;
    status: InvoiceStatus;
    number: string | undefined;
    date: moment.Moment;
    dueDate: moment.Moment;
    description: string | undefined;
    note: string | undefined;
    lines: UpdateInvoiceLineInput[] | undefined;
}

export class UpdateInvoiceStatusInput implements IUpdateInvoiceStatusInput {
    id!: number;
    status!: InvoiceStatus;

    constructor(data?: IUpdateInvoiceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): UpdateInvoiceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateInvoiceStatusInput {
    id: number;
    status: InvoiceStatus;
}

export class InvoiceSettingsInfoDto implements IInvoiceSettingsInfoDto {
    nextInvoiceNumber!: string | undefined;
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: IInvoiceSettingsInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nextInvoiceNumber = data["nextInvoiceNumber"];
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): InvoiceSettingsInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingsInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextInvoiceNumber"] = this.nextInvoiceNumber;
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface IInvoiceSettingsInfoDto {
    nextInvoiceNumber: string | undefined;
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class RequestKBAInput implements IRequestKBAInput {
    redirectUrl!: string;
    cssUrl!: string | undefined;

    constructor(data?: IRequestKBAInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.redirectUrl = data["redirectUrl"];
            this.cssUrl = data["cssUrl"];
        }
    }

    static fromJS(data: any): RequestKBAInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["cssUrl"] = this.cssUrl;
        return data; 
    }
}

export interface IRequestKBAInput {
    redirectUrl: string;
    cssUrl: string | undefined;
}

export class RequestKBAOutput implements IRequestKBAOutput {
    kbaAlreadyPassed!: boolean | undefined;
    kbaUrl!: string | undefined;

    constructor(data?: IRequestKBAOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kbaAlreadyPassed = data["kbaAlreadyPassed"];
            this.kbaUrl = data["kbaUrl"];
        }
    }

    static fromJS(data: any): RequestKBAOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestKBAOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kbaAlreadyPassed"] = this.kbaAlreadyPassed;
        data["kbaUrl"] = this.kbaUrl;
        return data; 
    }
}

export interface IRequestKBAOutput {
    kbaAlreadyPassed: boolean | undefined;
    kbaUrl: string | undefined;
}

export class KBAResult implements IKBAResult {
    memberId!: string;
    passed!: boolean;
    error!: string | undefined;

    constructor(data?: IKBAResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.passed = data["passed"];
            this.error = data["error"];
        }
    }

    static fromJS(data: any): KBAResult {
        data = typeof data === 'object' ? data : {};
        let result = new KBAResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["passed"] = this.passed;
        data["error"] = this.error;
        return data; 
    }
}

export interface IKBAResult {
    memberId: string;
    passed: boolean;
    error: string | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LanguageTextListDtoPagedResultDto implements ILanguageTextListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: ILanguageTextListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LanguageTextListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILanguageTextListDtoPagedResultDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class CreateLeadInput implements ICreateLeadInput {
    leadTypeId!: number | undefined;
    stageId!: number | undefined;
    matchByEmail!: boolean | undefined;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;
    emailAddresses!: CreateContactEmailInput[] | undefined;
    phoneNumbers!: CreateContactPhoneInput[] | undefined;
    addresses!: CreateContactAddressInput[] | undefined;
    links!: CreateContactLinkInput[] | undefined;
    dob!: moment.Moment | undefined;
    bankCode!: string | undefined;
    gender!: Gender | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    note!: string | undefined;
    interests!: string[] | undefined;
    companyName!: string | undefined;
    industry!: string | undefined;
    photo!: ContactPhotoInput | undefined;
    organizationUnitId!: number | undefined;
    title!: string | undefined;
    tags!: ContactTagInput[] | undefined;
    lists!: ContactListInput[] | undefined;
    assignedUserId!: number | undefined;
    ratingId!: number | undefined;
    contactGroupId!: string;
    partnerTypeName!: string | undefined;

    constructor(data?: ICreateLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadTypeId = data["leadTypeId"];
            this.stageId = data["stageId"];
            this.matchByEmail = data["matchByEmail"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(CreateContactEmailInput.fromJS(item));
            }
            if (data["phoneNumbers"] && data["phoneNumbers"].constructor === Array) {
                this.phoneNumbers = [];
                for (let item of data["phoneNumbers"])
                    this.phoneNumbers.push(CreateContactPhoneInput.fromJS(item));
            }
            if (data["addresses"] && data["addresses"].constructor === Array) {
                this.addresses = [];
                for (let item of data["addresses"])
                    this.addresses.push(CreateContactAddressInput.fromJS(item));
            }
            if (data["links"] && data["links"].constructor === Array) {
                this.links = [];
                for (let item of data["links"])
                    this.links.push(CreateContactLinkInput.fromJS(item));
            }
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.bankCode = data["bankCode"];
            this.gender = data["gender"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.note = data["note"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.companyName = data["companyName"];
            this.industry = data["industry"];
            this.photo = data["photo"] ? ContactPhotoInput.fromJS(data["photo"]) : <any>undefined;
            this.organizationUnitId = data["organizationUnitId"];
            this.title = data["title"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(ContactTagInput.fromJS(item));
            }
            if (data["lists"] && data["lists"].constructor === Array) {
                this.lists = [];
                for (let item of data["lists"])
                    this.lists.push(ContactListInput.fromJS(item));
            }
            this.assignedUserId = data["assignedUserId"];
            this.ratingId = data["ratingId"];
            this.contactGroupId = data["contactGroupId"];
            this.partnerTypeName = data["partnerTypeName"];
        }
    }

    static fromJS(data: any): CreateLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadTypeId"] = this.leadTypeId;
        data["stageId"] = this.stageId;
        data["matchByEmail"] = this.matchByEmail;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item.toJSON());
        }
        if (this.phoneNumbers && this.phoneNumbers.constructor === Array) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (this.addresses && this.addresses.constructor === Array) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (this.links && this.links.constructor === Array) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["bankCode"] = this.bankCode;
        data["gender"] = this.gender;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["note"] = this.note;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["companyName"] = this.companyName;
        data["industry"] = this.industry;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>undefined;
        data["organizationUnitId"] = this.organizationUnitId;
        data["title"] = this.title;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (this.lists && this.lists.constructor === Array) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        data["assignedUserId"] = this.assignedUserId;
        data["ratingId"] = this.ratingId;
        data["contactGroupId"] = this.contactGroupId;
        data["partnerTypeName"] = this.partnerTypeName;
        return data; 
    }
}

export interface ICreateLeadInput {
    leadTypeId: number | undefined;
    stageId: number | undefined;
    matchByEmail: boolean | undefined;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
    emailAddresses: CreateContactEmailInput[] | undefined;
    phoneNumbers: CreateContactPhoneInput[] | undefined;
    addresses: CreateContactAddressInput[] | undefined;
    links: CreateContactLinkInput[] | undefined;
    dob: moment.Moment | undefined;
    bankCode: string | undefined;
    gender: Gender | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    note: string | undefined;
    interests: string[] | undefined;
    companyName: string | undefined;
    industry: string | undefined;
    photo: ContactPhotoInput | undefined;
    organizationUnitId: number | undefined;
    title: string | undefined;
    tags: ContactTagInput[] | undefined;
    lists: ContactListInput[] | undefined;
    assignedUserId: number | undefined;
    ratingId: number | undefined;
    contactGroupId: string;
    partnerTypeName: string | undefined;
}

export class CreateLeadOutput implements ICreateLeadOutput {
    id!: number | undefined;
    contactId!: number | undefined;

    constructor(data?: ICreateLeadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
        }
    }

    static fromJS(data: any): CreateLeadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        return data; 
    }
}

export interface ICreateLeadOutput {
    id: number | undefined;
    contactId: number | undefined;
}

export class CancelLeadInfo implements ICancelLeadInfo {
    leadId!: number;
    cancellationReasonId!: string;
    comment!: string | undefined;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: ICancelLeadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.cancellationReasonId = data["cancellationReasonId"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): CancelLeadInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CancelLeadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["cancellationReasonId"] = this.cancellationReasonId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface ICancelLeadInfo {
    leadId: number;
    cancellationReasonId: string;
    comment: string | undefined;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class LeadCancellationReasonDto implements ILeadCancellationReasonDto {
    id!: string | undefined;
    name!: string | undefined;
    isCommentRequired!: boolean | undefined;
    sortOrder!: number | undefined;

    constructor(data?: ILeadCancellationReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isCommentRequired = data["isCommentRequired"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): LeadCancellationReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isCommentRequired"] = this.isCommentRequired;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ILeadCancellationReasonDto {
    id: string | undefined;
    name: string | undefined;
    isCommentRequired: boolean | undefined;
    sortOrder: number | undefined;
}

export class LeadCancellationReasonDtoListResultDto implements ILeadCancellationReasonDtoListResultDto {
    items!: LeadCancellationReasonDto[] | undefined;

    constructor(data?: ILeadCancellationReasonDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LeadCancellationReasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeadCancellationReasonDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadCancellationReasonDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILeadCancellationReasonDtoListResultDto {
    items: LeadCancellationReasonDto[] | undefined;
}

export class PackageInfoDto implements IPackageInfoDto {
    module!: ModuleType;
    packageName!: string;
    seatCount!: number;

    constructor(data?: IPackageInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.module = data["module"];
            this.packageName = data["packageName"];
            this.seatCount = data["seatCount"];
        }
    }

    static fromJS(data: any): PackageInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["packageName"] = this.packageName;
        data["seatCount"] = this.seatCount;
        return data; 
    }
}

export interface IPackageInfoDto {
    module: ModuleType;
    packageName: string;
    seatCount: number;
}

export class SubmitTenancyRequestInput implements ISubmitTenancyRequestInput {
    leadRequestXref!: string | undefined;
    companyName!: string | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    packages!: PackageInfoDto[] | undefined;
    website!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    stage!: string | undefined;
    tag!: string | undefined;
    firstName!: string;
    lastName!: string;
    email!: string;
    phone!: string | undefined;
    phoneExt!: string | undefined;
    comments!: string | undefined;
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;
    isHelpNeeded!: boolean | undefined;

    constructor(data?: ISubmitTenancyRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.companyName = data["companyName"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["packages"] && data["packages"].constructor === Array) {
                this.packages = [];
                for (let item of data["packages"])
                    this.packages.push(PackageInfoDto.fromJS(item));
            }
            this.website = data["website"];
            this.city = data["city"];
            this.state = data["state"];
            this.stage = data["stage"];
            this.tag = data["tag"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.phoneExt = data["phoneExt"];
            this.comments = data["comments"];
            this.sourceCode = data["sourceCode"];
            this.channelCode = data["channelCode"];
            this.affiliateCode = data["affiliateCode"];
            this.isHelpNeeded = data["isHelpNeeded"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["companyName"] = this.companyName;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.packages && this.packages.constructor === Array) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        data["website"] = this.website;
        data["city"] = this.city;
        data["state"] = this.state;
        data["stage"] = this.stage;
        data["tag"] = this.tag;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["phoneExt"] = this.phoneExt;
        data["comments"] = this.comments;
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        data["isHelpNeeded"] = this.isHelpNeeded;
        return data; 
    }
}

export interface ISubmitTenancyRequestInput {
    leadRequestXref: string | undefined;
    companyName: string | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    packages: PackageInfoDto[] | undefined;
    website: string | undefined;
    city: string | undefined;
    state: string | undefined;
    stage: string | undefined;
    tag: string | undefined;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | undefined;
    phoneExt: string | undefined;
    comments: string | undefined;
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
    isHelpNeeded: boolean | undefined;
}

export class SubmitTenancyRequestOutput implements ISubmitTenancyRequestOutput {
    leadRequestXref!: string | undefined;
    contactId!: number | undefined;

    constructor(data?: ISubmitTenancyRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadRequestXref = data["leadRequestXref"];
            this.contactId = data["contactId"];
        }
    }

    static fromJS(data: any): SubmitTenancyRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTenancyRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadRequestXref"] = this.leadRequestXref;
        data["contactId"] = this.contactId;
        return data; 
    }
}

export interface ISubmitTenancyRequestOutput {
    leadRequestXref: string | undefined;
    contactId: number | undefined;
}

export class SubmitFreeTrialRequestInput implements ISubmitFreeTrialRequestInput {
    contactGroupId!: string | undefined;
    email!: string;
    tag!: string | undefined;

    constructor(data?: ISubmitFreeTrialRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactGroupId = data["contactGroupId"];
            this.email = data["email"];
            this.tag = data["tag"];
        }
    }

    static fromJS(data: any): SubmitFreeTrialRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitFreeTrialRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactGroupId"] = this.contactGroupId;
        data["email"] = this.email;
        data["tag"] = this.tag;
        return data; 
    }
}

export interface ISubmitFreeTrialRequestInput {
    contactGroupId: string | undefined;
    email: string;
    tag: string | undefined;
}

export class UpdateLeadStageInfo implements IUpdateLeadStageInfo {
    leadId!: number;
    stageId!: number;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateLeadStageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateLeadStageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadStageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateLeadStageInfo {
    leadId: number;
    stageId: number;
    sortOrder: number | undefined;
}

export class ProcessLeadInput implements IProcessLeadInput {
    leadId!: number;
    orderStageId!: number | undefined;
    amount!: number | undefined;
    comment!: string | undefined;
    sortOrder!: number | undefined;

    constructor(data?: IProcessLeadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leadId = data["leadId"];
            this.orderStageId = data["orderStageId"];
            this.amount = data["amount"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): ProcessLeadInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leadId"] = this.leadId;
        data["orderStageId"] = this.orderStageId;
        data["amount"] = this.amount;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IProcessLeadInput {
    leadId: number;
    orderStageId: number | undefined;
    amount: number | undefined;
    comment: string | undefined;
    sortOrder: number | undefined;
}

export class LeadInfoDto implements ILeadInfoDto {
    id!: number | undefined;
    contactGroupId!: string | undefined;
    stage!: string | undefined;
    amount!: number | undefined;
    creationDate!: moment.Moment | undefined;
    modificationDate!: moment.Moment | undefined;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    comments!: string | undefined;
    clientIp!: string | undefined;
    userAgent!: string | undefined;
    applicantId!: string | undefined;
    applicationId!: string | undefined;
    clickId!: string | undefined;
    siteId!: string | undefined;
    siteUrl!: string | undefined;
    refererUrl!: string | undefined;
    entryUrl!: string | undefined;
    primaryLeadRequestId!: number | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ILeadInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactGroupId = data["contactGroupId"];
            this.stage = data["stage"];
            this.amount = data["amount"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = data["modificationDate"] ? moment(data["modificationDate"].toString()) : <any>undefined;
            this.sourceCode = data["sourceCode"];
            this.campaignCode = data["campaignCode"];
            this.affiliateCode = data["affiliateCode"];
            this.channelCode = data["channelCode"];
            this.comments = data["comments"];
            this.clientIp = data["clientIp"];
            this.userAgent = data["userAgent"];
            this.applicantId = data["applicantId"];
            this.applicationId = data["applicationId"];
            this.clickId = data["clickId"];
            this.siteId = data["siteId"];
            this.siteUrl = data["siteUrl"];
            this.refererUrl = data["refererUrl"];
            this.entryUrl = data["entryUrl"];
            this.primaryLeadRequestId = data["primaryLeadRequestId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): LeadInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactGroupId"] = this.contactGroupId;
        data["stage"] = this.stage;
        data["amount"] = this.amount;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["comments"] = this.comments;
        data["clientIp"] = this.clientIp;
        data["userAgent"] = this.userAgent;
        data["applicantId"] = this.applicantId;
        data["applicationId"] = this.applicationId;
        data["clickId"] = this.clickId;
        data["siteId"] = this.siteId;
        data["siteUrl"] = this.siteUrl;
        data["refererUrl"] = this.refererUrl;
        data["entryUrl"] = this.entryUrl;
        data["primaryLeadRequestId"] = this.primaryLeadRequestId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ILeadInfoDto {
    id: number | undefined;
    contactGroupId: string | undefined;
    stage: string | undefined;
    amount: number | undefined;
    creationDate: moment.Moment | undefined;
    modificationDate: moment.Moment | undefined;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    comments: string | undefined;
    clientIp: string | undefined;
    userAgent: string | undefined;
    applicantId: string | undefined;
    applicationId: string | undefined;
    clickId: string | undefined;
    siteId: string | undefined;
    siteUrl: string | undefined;
    refererUrl: string | undefined;
    entryUrl: string | undefined;
    primaryLeadRequestId: number | undefined;
    organizationUnitId: number | undefined;
}

export class UpdateLeadInfoInput implements IUpdateLeadInfoInput {
    id!: number;
    sourceCode!: string | undefined;
    campaignCode!: string | undefined;
    affiliateCode!: string | undefined;
    channelCode!: string | undefined;
    comments!: string | undefined;

    constructor(data?: IUpdateLeadInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sourceCode = data["sourceCode"];
            this.campaignCode = data["campaignCode"];
            this.affiliateCode = data["affiliateCode"];
            this.channelCode = data["channelCode"];
            this.comments = data["comments"];
        }
    }

    static fromJS(data: any): UpdateLeadInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeadInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceCode"] = this.sourceCode;
        data["campaignCode"] = this.campaignCode;
        data["affiliateCode"] = this.affiliateCode;
        data["channelCode"] = this.channelCode;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IUpdateLeadInfoInput {
    id: number;
    sourceCode: string | undefined;
    campaignCode: string | undefined;
    affiliateCode: string | undefined;
    channelCode: string | undefined;
    comments: string | undefined;
}

export class LeadTypeDto implements ILeadTypeDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: ILeadTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): LeadTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeadTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILeadTypeDto {
    id: number | undefined;
    name: string | undefined;
}

export class LocalizationSourceDto implements ILocalizationSourceDto {
    values!: { [key: string] : string; } | undefined;
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: ILocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {};
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key];
                }
            }
            this.name = data["name"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): LocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface ILocalizationSourceDto {
    values: { [key: string] : string; } | undefined;
    name: string | undefined;
    type: string | undefined;
}

export class MemberAddressDto implements IMemberAddressDto {
    streetAddress!: string | undefined;
    zip!: string | undefined;
    city!: string | undefined;
    stateId!: string | undefined;
    state!: string | undefined;
    countryId!: string | undefined;
    country!: string | undefined;

    constructor(data?: IMemberAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.streetAddress = data["streetAddress"];
            this.zip = data["zip"];
            this.city = data["city"];
            this.stateId = data["stateId"];
            this.state = data["state"];
            this.countryId = data["countryId"];
            this.country = data["country"];
        }
    }

    static fromJS(data: any): MemberAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAddress"] = this.streetAddress;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["stateId"] = this.stateId;
        data["state"] = this.state;
        data["countryId"] = this.countryId;
        data["country"] = this.country;
        return data; 
    }
}

export interface IMemberAddressDto {
    streetAddress: string | undefined;
    zip: string | undefined;
    city: string | undefined;
    stateId: string | undefined;
    state: string | undefined;
    countryId: string | undefined;
    country: string | undefined;
}

export class UTMParameterInfo implements IUTMParameterInfo {
    source!: string;
    medium!: string | undefined;
    campaign!: string | undefined;
    term!: string | undefined;
    content!: string | undefined;
    keyword!: string | undefined;
    adGroup!: string | undefined;
    name!: string | undefined;

    constructor(data?: IUTMParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"];
            this.medium = data["medium"];
            this.campaign = data["campaign"];
            this.term = data["term"];
            this.content = data["content"];
            this.keyword = data["keyword"];
            this.adGroup = data["adGroup"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UTMParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UTMParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["medium"] = this.medium;
        data["campaign"] = this.campaign;
        data["term"] = this.term;
        data["content"] = this.content;
        data["keyword"] = this.keyword;
        data["adGroup"] = this.adGroup;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUTMParameterInfo {
    source: string;
    medium: string | undefined;
    campaign: string | undefined;
    term: string | undefined;
    content: string | undefined;
    keyword: string | undefined;
    adGroup: string | undefined;
    name: string | undefined;
}

export class TrackingInfo implements ITrackingInfo {
    sourceCode!: string | undefined;
    channelCode!: string | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: ITrackingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceCode = data["sourceCode"];
            this.channelCode = data["channelCode"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): TrackingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCode"] = this.sourceCode;
        data["channelCode"] = this.channelCode;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface ITrackingInfo {
    sourceCode: string | undefined;
    channelCode: string | undefined;
    affiliateCode: string | undefined;
}

export class MemberInfoDto implements IMemberInfoDto {
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberInfoDto {
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class SelectPackageResponseDto implements ISelectPackageResponseDto {
    registrationId!: string | undefined;
    memberInfo!: MemberInfoDto | undefined;
    paymentAuthorizationRequired!: boolean | undefined;

    constructor(data?: ISelectPackageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.memberInfo = data["memberInfo"] ? MemberInfoDto.fromJS(data["memberInfo"]) : <any>undefined;
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SelectPackageResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectPackageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISelectPackageResponseDto {
    registrationId: string | undefined;
    memberInfo: MemberInfoDto | undefined;
    paymentAuthorizationRequired: boolean | undefined;
}

export class SubmitMemberInfoResultDto implements ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired!: boolean | undefined;

    constructor(data?: ISubmitMemberInfoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentAuthorizationRequired = data["paymentAuthorizationRequired"];
        }
    }

    static fromJS(data: any): SubmitMemberInfoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitMemberInfoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAuthorizationRequired"] = this.paymentAuthorizationRequired;
        return data; 
    }
}

export interface ISubmitMemberInfoResultDto {
    paymentAuthorizationRequired: boolean | undefined;
}

export class BankCardDto implements IBankCardDto {
    holderName!: string;
    cardNumber!: string;
    expirationMonth!: string;
    expirationYear!: string;
    cvv!: string;
    billingAddress!: string;
    billingZip!: string;
    billingCity!: string;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.cvv = data["cvv"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingState = data["billingState"];
            this.billingCountryCode = data["billingCountryCode"];
            this.billingCountry = data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data; 
    }
}

export interface IBankCardDto {
    holderName: string;
    cardNumber: string;
    expirationMonth: string;
    expirationYear: string;
    cvv: string;
    billingAddress: string;
    billingZip: string;
    billingCity: string;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string;
    billingCountry: string | undefined;
}

export class ACHCustomerDto implements IACHCustomerDto {
    customerRoutingNo!: string;
    customerAcctNo!: string;

    constructor(data?: IACHCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerRoutingNo = data["customerRoutingNo"];
            this.customerAcctNo = data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data; 
    }
}

export interface IACHCustomerDto {
    customerRoutingNo: string;
    customerAcctNo: string;
}

export class PayPalDto implements IPayPalDto {
    paymentId!: string;
    payerId!: string;

    constructor(data?: IPayPalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
        }
    }

    static fromJS(data: any): PayPalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data; 
    }
}

export interface IPayPalDto {
    paymentId: string;
    payerId: string;
}

export class MemberPaymentAuthorizeRequestDto implements IMemberPaymentAuthorizeRequestDto {
    registrationId!: string;
    packageId!: number | undefined;
    paymentInfoType!: PaymentInfoType | undefined;
    bankCard!: BankCardDto | undefined;
    achCustomer!: ACHCustomerDto | undefined;
    payPal!: PayPalDto | undefined;

    constructor(data?: IMemberPaymentAuthorizeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.registrationId = data["registrationId"];
            this.packageId = data["packageId"];
            this.paymentInfoType = data["paymentInfoType"];
            this.bankCard = data["bankCard"] ? BankCardDto.fromJS(data["bankCard"]) : <any>undefined;
            this.achCustomer = data["achCustomer"] ? ACHCustomerDto.fromJS(data["achCustomer"]) : <any>undefined;
            this.payPal = data["payPal"] ? PayPalDto.fromJS(data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberPaymentAuthorizeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberPaymentAuthorizeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["packageId"] = this.packageId;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberPaymentAuthorizeRequestDto {
    registrationId: string;
    packageId: number | undefined;
    paymentInfoType: PaymentInfoType | undefined;
    bankCard: BankCardDto | undefined;
    achCustomer: ACHCustomerDto | undefined;
    payPal: PayPalDto | undefined;
}

export class PaymentAuthorizeResponseDto implements IPaymentAuthorizeResponseDto {
    success!: boolean | undefined;
    errors!: string[] | undefined;

    constructor(data?: IPaymentAuthorizeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(item);
            }
        }
    }

    static fromJS(data: any): PaymentAuthorizeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAuthorizeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IPaymentAuthorizeResponseDto {
    success: boolean | undefined;
    errors: string[] | undefined;
}

export class RegisterMemberRequest implements IRegisterMemberRequest {
    password!: string;
    registrationId!: string;
    name!: string;
    surname!: string;
    email!: string;
    phone!: string | undefined;
    address!: MemberAddressDto | undefined;
    doB!: moment.Moment;
    ssn!: string;
    gender!: Gender;
    isUSCitizen!: boolean;
    packageId!: number;
    utmParameter!: UTMParameterInfo | undefined;
    trackingInfo!: TrackingInfo | undefined;

    constructor(data?: IRegisterMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"];
            this.registrationId = data["registrationId"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"] ? MemberAddressDto.fromJS(data["address"]) : <any>undefined;
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.packageId = data["packageId"];
            this.utmParameter = data["utmParameter"] ? UTMParameterInfo.fromJS(data["utmParameter"]) : <any>undefined;
            this.trackingInfo = data["trackingInfo"] ? TrackingInfo.fromJS(data["trackingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["registrationId"] = this.registrationId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["packageId"] = this.packageId;
        data["utmParameter"] = this.utmParameter ? this.utmParameter.toJSON() : <any>undefined;
        data["trackingInfo"] = this.trackingInfo ? this.trackingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterMemberRequest {
    password: string;
    registrationId: string;
    name: string;
    surname: string;
    email: string;
    phone: string | undefined;
    address: MemberAddressDto | undefined;
    doB: moment.Moment;
    ssn: string;
    gender: Gender;
    isUSCitizen: boolean;
    packageId: number;
    utmParameter: UTMParameterInfo | undefined;
    trackingInfo: TrackingInfo | undefined;
}

export class GetProviderUITokenOutput implements IGetProviderUITokenOutput {
    token!: string | undefined;

    constructor(data?: IGetProviderUITokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): GetProviderUITokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProviderUITokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IGetProviderUITokenOutput {
    token: string | undefined;
}

export class SyncAllAccountsOutput implements ISyncAllAccountsOutput {
    syncInProgressAccountsCount!: number | undefined;
    failedSyncAccountsCount!: number | undefined;

    constructor(data?: ISyncAllAccountsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.syncInProgressAccountsCount = data["syncInProgressAccountsCount"];
            this.failedSyncAccountsCount = data["failedSyncAccountsCount"];
        }
    }

    static fromJS(data: any): SyncAllAccountsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAllAccountsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["syncInProgressAccountsCount"] = this.syncInProgressAccountsCount;
        data["failedSyncAccountsCount"] = this.failedSyncAccountsCount;
        return data; 
    }
}

export interface ISyncAllAccountsOutput {
    syncInProgressAccountsCount: number | undefined;
    failedSyncAccountsCount: number | undefined;
}

export class NoteInfoDto implements INoteInfoDto {
    contactId!: number | undefined;
    id!: number | undefined;
    text!: string | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserName!: string | undefined;
    noteType!: NoteType | undefined;
    noteTypeName!: string | undefined;
    contactPhoneNumber!: string | undefined;
    contactName!: string | undefined;

    constructor(data?: INoteInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.id = data["id"];
            this.text = data["text"];
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserName = data["addedByUserName"];
            this.noteType = data["noteType"];
            this.noteTypeName = data["noteTypeName"];
            this.contactPhoneNumber = data["contactPhoneNumber"];
            this.contactName = data["contactName"];
        }
    }

    static fromJS(data: any): NoteInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoteInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserName"] = this.addedByUserName;
        data["noteType"] = this.noteType;
        data["noteTypeName"] = this.noteTypeName;
        data["contactPhoneNumber"] = this.contactPhoneNumber;
        data["contactName"] = this.contactName;
        return data; 
    }
}

export interface INoteInfoDto {
    contactId: number | undefined;
    id: number | undefined;
    text: string | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserName: string | undefined;
    noteType: NoteType | undefined;
    noteTypeName: string | undefined;
    contactPhoneNumber: string | undefined;
    contactName: string | undefined;
}

export class CreateNoteInput implements ICreateNoteInput {
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: ICreateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.text = data["text"];
            this.contactPhoneId = data["contactPhoneId"];
            this.orderId = data["orderId"];
            this.noteType = data["noteType"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
        }
    }

    static fromJS(data: any): CreateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data; 
    }
}

export interface ICreateNoteInput {
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export class CreateNoteOutput implements ICreateNoteOutput {
    id!: number | undefined;

    constructor(data?: ICreateNoteOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateNoteOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateNoteOutput {
    id: number | undefined;
}

export class UpdateNoteInput implements IUpdateNoteInput {
    id!: number;
    contactId!: number;
    text!: string;
    contactPhoneId!: number | undefined;
    orderId!: number | undefined;
    noteType!: NoteType;
    followUpDateTime!: moment.Moment | undefined;
    dateTime!: moment.Moment | undefined;
    addedByUserId!: number | undefined;

    constructor(data?: IUpdateNoteInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contactId = data["contactId"];
            this.text = data["text"];
            this.contactPhoneId = data["contactPhoneId"];
            this.orderId = data["orderId"];
            this.noteType = data["noteType"];
            this.followUpDateTime = data["followUpDateTime"] ? moment(data["followUpDateTime"].toString()) : <any>undefined;
            this.dateTime = data["dateTime"] ? moment(data["dateTime"].toString()) : <any>undefined;
            this.addedByUserId = data["addedByUserId"];
        }
    }

    static fromJS(data: any): UpdateNoteInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoteInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["text"] = this.text;
        data["contactPhoneId"] = this.contactPhoneId;
        data["orderId"] = this.orderId;
        data["noteType"] = this.noteType;
        data["followUpDateTime"] = this.followUpDateTime ? this.followUpDateTime.toISOString() : <any>undefined;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["addedByUserId"] = this.addedByUserId;
        return data; 
    }
}

export interface IUpdateNoteInput {
    id: number;
    contactId: number;
    text: string;
    contactPhoneId: number | undefined;
    orderId: number | undefined;
    noteType: NoteType;
    followUpDateTime: moment.Moment | undefined;
    dateTime: moment.Moment | undefined;
    addedByUserId: number | undefined;
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export class NotificationData implements INotificationData {
    type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
}

export class TenantNotificationDto implements ITenantNotificationDto {
    id!: string | undefined;
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: ITenantNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityTypeName = data["entityTypeName"];
            if (data["entityId"]) {
                this.entityId = {};
                for (let key in data["entityId"]) {
                    if (data["entityId"].hasOwnProperty(key))
                        this.entityId[key] = data["entityId"][key];
                }
            }
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        if (this.entityId) {
            data["entityId"] = {};
            for (let key in this.entityId) {
                if (this.entityId.hasOwnProperty(key))
                    data["entityId"][key] = this.entityId[key];
            }
        }
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITenantNotificationDto {
    id: string | undefined;
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
}

export class UserNotificationDto implements IUserNotificationDto {
    id!: string | undefined;
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotificationDto | undefined;

    constructor(data?: IUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotificationDto.fromJS(data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserNotificationDto {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotificationDto | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotificationDto[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotificationDto[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id!: string | undefined;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IGuidEntityDto {
    id: string | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export enum CampaignCategory {
    PaydayLoans = "PaydayLoans", 
    PersonalLoans = "PersonalLoans", 
    Beauty = "Beauty", 
    InstallmentLoans = "InstallmentLoans", 
    AutoLoans = "AutoLoans", 
    Legal = "Legal", 
    CreditRepair = "CreditRepair", 
    CreditScore = "CreditScore", 
    Travel = "Travel", 
    Jobs = "Jobs", 
    BusinessLoans = "BusinessLoans", 
    DebtConsolidation = "DebtConsolidation", 
    CreditCards = "CreditCards", 
    MerchantServices = "MerchantServices", 
    Dating = "Dating", 
    Miscellaneous = "Miscellaneous", 
    Crypto = "Crypto", 
    CreditMonitoring = "CreditMonitoring", 
}

export enum CampaignType {
    MultiOfferSinglePage = "MultiOfferSinglePage", 
    TrafficDistribution = "TrafficDistribution", 
    DirectPost = "DirectPost", 
    Carrier = "Carrier", 
}

export enum OfferCollection {
    Best = "Best", 
    BalanceTransfer = "BalanceTransfer", 
    CashBack = "CashBack", 
    RewardPoints = "RewardPoints", 
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases", 
    TravelAirlineHotel = "TravelAirlineHotel", 
    SecuredOrPrepaid = "SecuredOrPrepaid", 
    BusinessCards = "BusinessCards", 
    NoAnnualFees = "NoAnnualFees", 
    Excellent = "Excellent", 
    Good = "Good", 
    Fair = "Fair", 
    Bad = "Bad", 
    NoCredit = "NoCredit", 
    Newest = "Newest", 
    SpecialDeals = "SpecialDeals", 
}

export enum CardNetwork {
    AmEx = "AmEx", 
    Discover = "Discover", 
    Mastercard = "Mastercard", 
    Visa = "Visa", 
    Store = "Store", 
}

export enum CardType {
    Credit = "Credit", 
    Debit = "Debit", 
}

export enum SecuringType {
    Unsecured = "Unsecured", 
    Secured = "Secured", 
    Prepaid = "Prepaid", 
}

export enum TargetAudience {
    Consumer = "Consumer", 
    Business = "Business", 
    Students = "Students", 
}

export enum SortOrderType {
    Best = "Best", 
    Newest = "Newest", 
}

export class GetAllInput implements IGetAllInput {
    testMode!: boolean;
    category!: CampaignCategory | undefined;
    type!: CampaignType | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    sortOrderType!: SortOrderType | undefined;
    topCount!: number | undefined;
    strictMatch!: boolean | undefined;

    constructor(data?: IGetAllInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.testMode = data["testMode"];
            this.category = data["category"];
            this.type = data["type"];
            this.country = data["country"];
            this.state = data["state"];
            this.creditScore = data["creditScore"];
            this.isOfferCollection = data["isOfferCollection"];
            this.itemOfOfferCollection = data["itemOfOfferCollection"];
            this.loanAmount = data["loanAmount"];
            if (data["cardNetworks"] && data["cardNetworks"].constructor === Array) {
                this.cardNetworks = [];
                for (let item of data["cardNetworks"])
                    this.cardNetworks.push(item);
            }
            this.cardType = data["cardType"];
            this.securingType = data["securingType"];
            this.targetAudience = data["targetAudience"];
            this.annualIncome = data["annualIncome"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            if (data["campaignIds"] && data["campaignIds"].constructor === Array) {
                this.campaignIds = [];
                for (let item of data["campaignIds"])
                    this.campaignIds.push(item);
            }
            this.sortOrderType = data["sortOrderType"];
            this.topCount = data["topCount"];
            this.strictMatch = data["strictMatch"];
        }
    }

    static fromJS(data: any): GetAllInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testMode"] = this.testMode;
        data["category"] = this.category;
        data["type"] = this.type;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (this.cardNetworks && this.cardNetworks.constructor === Array) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (this.campaignIds && this.campaignIds.constructor === Array) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        data["sortOrderType"] = this.sortOrderType;
        data["topCount"] = this.topCount;
        data["strictMatch"] = this.strictMatch;
        return data; 
    }
}

export interface IGetAllInput {
    testMode: boolean;
    category: CampaignCategory | undefined;
    type: CampaignType | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    sortOrderType: SortOrderType | undefined;
    topCount: number | undefined;
    strictMatch: boolean | undefined;
}

export enum CampaignProviderType {
    CreditLand = "CreditLand", 
}

export class OfferDto implements IOfferDto {
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.redirectUrl = data["redirectUrl"];
            this.logoUrl = data["logoUrl"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            this.annualFee = data["annualFee"];
            this.rewardsRate = data["rewardsRate"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.regularAPR = data["regularAPR"];
            this.offerCollection = data["offerCollection"];
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.campaignProviderType = data["campaignProviderType"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data; 
    }
}

export interface IOfferDto {
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class OfferDetailsDto implements IOfferDetailsDto {
    description!: string | undefined;
    introAPR!: string | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    redirectUrl!: string | undefined;
    logoUrl!: string | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    annualFee!: string | undefined;
    rewardsRate!: string | undefined;
    introRewardsBonus!: string | undefined;
    regularAPR!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    details!: string[] | undefined;

    constructor(data?: IOfferDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.introAPR = data["introAPR"];
            if (data["creditScores"] && data["creditScores"].constructor === Array) {
                this.creditScores = [];
                for (let item of data["creditScores"])
                    this.creditScores.push(item);
            }
            if (data["pros"] && data["pros"].constructor === Array) {
                this.pros = [];
                for (let item of data["pros"])
                    this.pros.push(item);
            }
            if (data["cons"] && data["cons"].constructor === Array) {
                this.cons = [];
                for (let item of data["cons"])
                    this.cons.push(item);
            }
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.redirectUrl = data["redirectUrl"];
            this.logoUrl = data["logoUrl"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            this.annualFee = data["annualFee"];
            this.rewardsRate = data["rewardsRate"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.regularAPR = data["regularAPR"];
            this.offerCollection = data["offerCollection"];
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.campaignProviderType = data["campaignProviderType"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
        }
    }

    static fromJS(data: any): OfferDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["introAPR"] = this.introAPR;
        if (this.creditScores && this.creditScores.constructor === Array) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (this.pros && this.pros.constructor === Array) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (this.cons && this.cons.constructor === Array) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["redirectUrl"] = this.redirectUrl;
        data["logoUrl"] = this.logoUrl;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        data["annualFee"] = this.annualFee;
        data["rewardsRate"] = this.rewardsRate;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["regularAPR"] = this.regularAPR;
        data["offerCollection"] = this.offerCollection;
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["campaignProviderType"] = this.campaignProviderType;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        return data; 
    }
}

export interface IOfferDetailsDto {
    description: string | undefined;
    introAPR: string | undefined;
    creditScores: CreditScoreRating[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    redirectUrl: string | undefined;
    logoUrl: string | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    annualFee: string | undefined;
    rewardsRate: string | undefined;
    introRewardsBonus: string | undefined;
    regularAPR: string | undefined;
    offerCollection: OfferCollection | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    details: string[] | undefined;
}

export class GetApplicationDetailsOutput implements IGetApplicationDetailsOutput {
    systemType!: OfferProviderType | undefined;
    campaignId!: number | undefined;
    clickId!: string | undefined;
    personalInformation!: PersonalInformation | undefined;
    debtInformation!: DebtInformation | undefined;
    loanInformation!: LoanInformation | undefined;
    employmentInformation!: EmploymentInformation | undefined;
    bankInformation!: BankInformation | undefined;
    legalInformation!: LegalInformation | undefined;

    constructor(data?: IGetApplicationDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.campaignId = data["campaignId"];
            this.clickId = data["clickId"];
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : <any>undefined;
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : <any>undefined;
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : <any>undefined;
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : <any>undefined;
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : <any>undefined;
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApplicationDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["clickId"] = this.clickId;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetApplicationDetailsOutput {
    systemType: OfferProviderType | undefined;
    campaignId: number | undefined;
    clickId: string | undefined;
    personalInformation: PersonalInformation | undefined;
    debtInformation: DebtInformation | undefined;
    loanInformation: LoanInformation | undefined;
    employmentInformation: EmploymentInformation | undefined;
    bankInformation: BankInformation | undefined;
    legalInformation: LegalInformation | undefined;
}

export class OfferApplicationGroup implements IOfferApplicationGroup {
    date!: moment.Moment | undefined;
    count!: number | undefined;

    constructor(data?: IOfferApplicationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.count = data["count"];
        }
    }

    static fromJS(data: any): OfferApplicationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OfferApplicationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["count"] = this.count;
        return data; 
    }
}

export interface IOfferApplicationGroup {
    date: moment.Moment | undefined;
    count: number | undefined;
}

export class SubmitRequestInput implements ISubmitRequestInput {
    systemType!: OfferProviderType;
    campaignId!: number;
    redirectUrl!: string | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    zipCode!: string | undefined;
    monthsAtAddress!: number | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;

    constructor(data?: ISubmitRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemType = data["systemType"];
            this.campaignId = data["campaignId"];
            this.redirectUrl = data["redirectUrl"];
            this.clickId = data["clickId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.countryCode = data["countryCode"];
            this.zipCode = data["zipCode"];
            this.monthsAtAddress = data["monthsAtAddress"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.creditScore = data["creditScore"];
        }
    }

    static fromJS(data: any): SubmitRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemType"] = this.systemType;
        data["campaignId"] = this.campaignId;
        data["redirectUrl"] = this.redirectUrl;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["zipCode"] = this.zipCode;
        data["monthsAtAddress"] = this.monthsAtAddress;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        return data; 
    }
}

export interface ISubmitRequestInput {
    systemType: OfferProviderType;
    campaignId: number;
    redirectUrl: string | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    zipCode: string | undefined;
    monthsAtAddress: number | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
}

export class SubmitRequestOutput implements ISubmitRequestOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitRequestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
            this.applicationId = data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitRequestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitRequestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data; 
    }
}

export interface ISubmitRequestOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export class SubmitApplicationInput implements ISubmitApplicationInput {
    campaignId!: number | undefined;
    systemType!: OfferProviderType;
    personalInformation!: PersonalInformation;
    debtInformation!: DebtInformation;
    loanInformation!: LoanInformation;
    employmentInformation!: EmploymentInformation;
    bankInformation!: BankInformation;
    legalInformation!: LegalInformation;

    constructor(data?: ISubmitApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.personalInformation = new PersonalInformation();
            this.debtInformation = new DebtInformation();
            this.loanInformation = new LoanInformation();
            this.employmentInformation = new EmploymentInformation();
            this.bankInformation = new BankInformation();
            this.legalInformation = new LegalInformation();
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.systemType = data["systemType"];
            this.personalInformation = data["personalInformation"] ? PersonalInformation.fromJS(data["personalInformation"]) : new PersonalInformation();
            this.debtInformation = data["debtInformation"] ? DebtInformation.fromJS(data["debtInformation"]) : new DebtInformation();
            this.loanInformation = data["loanInformation"] ? LoanInformation.fromJS(data["loanInformation"]) : new LoanInformation();
            this.employmentInformation = data["employmentInformation"] ? EmploymentInformation.fromJS(data["employmentInformation"]) : new EmploymentInformation();
            this.bankInformation = data["bankInformation"] ? BankInformation.fromJS(data["bankInformation"]) : new BankInformation();
            this.legalInformation = data["legalInformation"] ? LegalInformation.fromJS(data["legalInformation"]) : new LegalInformation();
        }
    }

    static fromJS(data: any): SubmitApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["systemType"] = this.systemType;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        data["debtInformation"] = this.debtInformation ? this.debtInformation.toJSON() : <any>undefined;
        data["loanInformation"] = this.loanInformation ? this.loanInformation.toJSON() : <any>undefined;
        data["employmentInformation"] = this.employmentInformation ? this.employmentInformation.toJSON() : <any>undefined;
        data["bankInformation"] = this.bankInformation ? this.bankInformation.toJSON() : <any>undefined;
        data["legalInformation"] = this.legalInformation ? this.legalInformation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISubmitApplicationInput {
    campaignId: number | undefined;
    systemType: OfferProviderType;
    personalInformation: PersonalInformation;
    debtInformation: DebtInformation;
    loanInformation: LoanInformation;
    employmentInformation: EmploymentInformation;
    bankInformation: BankInformation;
    legalInformation: LegalInformation;
}

export class SubmitApplicationOutput implements ISubmitApplicationOutput {
    status!: string | undefined;
    redirectUrl!: string | undefined;
    applicationId!: string | undefined;

    constructor(data?: ISubmitApplicationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
            this.applicationId = data["applicationId"];
        }
    }

    static fromJS(data: any): SubmitApplicationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitApplicationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        data["applicationId"] = this.applicationId;
        return data; 
    }
}

export interface ISubmitApplicationOutput {
    status: string | undefined;
    redirectUrl: string | undefined;
    applicationId: string | undefined;
}

export enum FinalizeApplicationStatus {
    Approved = "Approved", 
    Declined = "Declined", 
}

export class FinalizeApplicationResponse implements IFinalizeApplicationResponse {
    status!: FinalizeApplicationStatus | undefined;
    redirectUrl!: string | undefined;

    constructor(data?: IFinalizeApplicationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.redirectUrl = data["redirectUrl"];
        }
    }

    static fromJS(data: any): FinalizeApplicationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FinalizeApplicationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["redirectUrl"] = this.redirectUrl;
        return data; 
    }
}

export interface IFinalizeApplicationResponse {
    status: FinalizeApplicationStatus | undefined;
    redirectUrl: string | undefined;
}

export class GetMemberInfoResponse implements IGetMemberInfoResponse {
    applicantId!: string | undefined;
    incompleteApplicationId!: number | undefined;
    clickId!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    phoneExtension!: string | undefined;
    zipCode!: string | undefined;
    streetAddress!: string | undefined;
    city!: string | undefined;
    stateCode!: string | undefined;
    countryCode!: string | undefined;
    doB!: moment.Moment | undefined;
    creditScore!: CreditScoreRating | undefined;
    testMode!: boolean | undefined;
    profileSubmissionDate!: moment.Moment | undefined;

    constructor(data?: IGetMemberInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicantId = data["applicantId"];
            this.incompleteApplicationId = data["incompleteApplicationId"];
            this.clickId = data["clickId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.phoneExtension = data["phoneExtension"];
            this.zipCode = data["zipCode"];
            this.streetAddress = data["streetAddress"];
            this.city = data["city"];
            this.stateCode = data["stateCode"];
            this.countryCode = data["countryCode"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.creditScore = data["creditScore"];
            this.testMode = data["testMode"];
            this.profileSubmissionDate = data["profileSubmissionDate"] ? moment(data["profileSubmissionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMemberInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantId"] = this.applicantId;
        data["incompleteApplicationId"] = this.incompleteApplicationId;
        data["clickId"] = this.clickId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExtension"] = this.phoneExtension;
        data["zipCode"] = this.zipCode;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["stateCode"] = this.stateCode;
        data["countryCode"] = this.countryCode;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["creditScore"] = this.creditScore;
        data["testMode"] = this.testMode;
        data["profileSubmissionDate"] = this.profileSubmissionDate ? this.profileSubmissionDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetMemberInfoResponse {
    applicantId: string | undefined;
    incompleteApplicationId: number | undefined;
    clickId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    phoneExtension: string | undefined;
    zipCode: string | undefined;
    streetAddress: string | undefined;
    city: string | undefined;
    stateCode: string | undefined;
    countryCode: string | undefined;
    doB: moment.Moment | undefined;
    creditScore: CreditScoreRating | undefined;
    testMode: boolean | undefined;
    profileSubmissionDate: moment.Moment | undefined;
}

export class RankRequest implements IRankRequest {
    ids!: number[];
    rank!: number;

    constructor(data?: IRankRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
            this.rank = data["rank"];
        }
    }

    static fromJS(data: any): RankRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RankRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["rank"] = this.rank;
        return data; 
    }
}

export interface IRankRequest {
    ids: number[];
    rank: number;
}

export enum MailSenderType {
    EPCVIP = "EPCVIP", 
    IAge = "IAge", 
    Ongage = "Ongage", 
    Platform = "Platform", 
}

export class SendAnnouncementRequest implements ISendAnnouncementRequest {
    campaignId!: number;
    offerDetailsLink!: string;
    serviceName!: MailSenderType;
    contactListName!: string | undefined;
    emailAddresses!: string[] | undefined;

    constructor(data?: ISendAnnouncementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaignId = data["campaignId"];
            this.offerDetailsLink = data["offerDetailsLink"];
            this.serviceName = data["serviceName"];
            this.contactListName = data["contactListName"];
            if (data["emailAddresses"] && data["emailAddresses"].constructor === Array) {
                this.emailAddresses = [];
                for (let item of data["emailAddresses"])
                    this.emailAddresses.push(item);
            }
        }
    }

    static fromJS(data: any): SendAnnouncementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendAnnouncementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaignId"] = this.campaignId;
        data["offerDetailsLink"] = this.offerDetailsLink;
        data["serviceName"] = this.serviceName;
        data["contactListName"] = this.contactListName;
        if (this.emailAddresses && this.emailAddresses.constructor === Array) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        return data; 
    }
}

export interface ISendAnnouncementRequest {
    campaignId: number;
    offerDetailsLink: string;
    serviceName: MailSenderType;
    contactListName: string | undefined;
    emailAddresses: string[] | undefined;
}

export enum CampaignTrafficSource {
    PPC_Default = "PPC_Default", 
    Email = "Email", 
    SEO = "SEO", 
    SMS = "SMS", 
    Decline = "Decline", 
    Reject = "Reject", 
    Display = "Display", 
    Mixed = "Mixed", 
    TypeIn = "TypeIn", 
    QualityControl = "QualityControl", 
    PPC_Email = "PPC_Email", 
    PPC_SEO = "PPC_SEO", 
    PPC_Decline = "PPC_Decline", 
    PPC_Reject = "PPC_Reject", 
    PPC_Display = "PPC_Display", 
}

export class OfferCategoryDto implements IOfferCategoryDto {
    name!: string | undefined;
    category!: CampaignCategory | undefined;

    constructor(data?: IOfferCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.category = data["category"];
        }
    }

    static fromJS(data: any): OfferCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        return data; 
    }
}

export interface IOfferCategoryDto {
    name: string | undefined;
    category: CampaignCategory | undefined;
}

export enum ParameterHandlerType {
    Default = "Default", 
}

export class ExtendOfferDto implements IExtendOfferDto {
    customName!: string | undefined;
    subId!: string | undefined;
    isPublished!: boolean | undefined;
    overallRating!: number | undefined;
    interestRating!: number | undefined;
    feesRating!: number | undefined;
    benefitsRating!: number | undefined;
    rewardsRating!: number | undefined;
    serviceRating!: number | undefined;
    cardNetwork!: CardNetwork | undefined;
    cardType!: CardType | undefined;
    targetAudience!: TargetAudience | undefined;
    securingType!: SecuringType | undefined;
    regularAPR!: string | undefined;
    introAPR!: string | undefined;
    balanceTransferFee!: string | undefined;
    annualFee!: string | undefined;
    monthlyFee!: string | undefined;
    activationFee!: string | undefined;
    introRewardsBonus!: string | undefined;
    rewardsRate!: string | undefined;
    durationForZeroPercentagePurchasesInMonths!: number | undefined;
    zeroPercentageInterestTransfers!: string | undefined;
    durationForZeroPercentageTransfersInMonths!: number | undefined;
    issuingBank!: string | undefined;
    offerCollection!: OfferCollection | undefined;
    details!: string[] | undefined;
    pros!: string[] | undefined;
    cons!: string[] | undefined;
    minLoanAmount!: number | undefined;
    maxLoanAmount!: number | undefined;
    minLoanTermMonths!: number | undefined;
    maxLoanTermMonths!: number | undefined;
    minAnnualIncome!: number | undefined;
    maxAnnualIncome!: number | undefined;
    campaignProviderType!: CampaignProviderType | undefined;
    parameterHandlerType!: ParameterHandlerType | undefined;
    flags!: Flags | undefined;
    creditScores!: CreditScoreRating[] | undefined;
    states!: string[] | undefined;

    constructor(data?: IExtendOfferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customName = data["customName"];
            this.subId = data["subId"];
            this.isPublished = data["isPublished"];
            this.overallRating = data["overallRating"];
            this.interestRating = data["interestRating"];
            this.feesRating = data["feesRating"];
            this.benefitsRating = data["benefitsRating"];
            this.rewardsRating = data["rewardsRating"];
            this.serviceRating = data["serviceRating"];
            this.cardNetwork = data["cardNetwork"];
            this.cardType = data["cardType"];
            this.targetAudience = data["targetAudience"];
            this.securingType = data["securingType"];
            this.regularAPR = data["regularAPR"];
            this.introAPR = data["introAPR"];
            this.balanceTransferFee = data["balanceTransferFee"];
            this.annualFee = data["annualFee"];
            this.monthlyFee = data["monthlyFee"];
            this.activationFee = data["activationFee"];
            this.introRewardsBonus = data["introRewardsBonus"];
            this.rewardsRate = data["rewardsRate"];
            this.durationForZeroPercentagePurchasesInMonths = data["durationForZeroPercentagePurchasesInMonths"];
            this.zeroPercentageInterestTransfers = data["zeroPercentageInterestTransfers"];
            this.durationForZeroPercentageTransfersInMonths = data["durationForZeroPercentageTransfersInMonths"];
            this.issuingBank = data["issuingBank"];
            this.offerCollection = data["offerCollection"];
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(item);
            }
            if (data["pros"] && data["pros"].constructor === Array) {
                this.pros = [];
                for (let item of data["pros"])
                    this.pros.push(item);
            }
            if (data["cons"] && data["cons"].constructor === Array) {
                this.cons = [];
                for (let item of data["cons"])
                    this.cons.push(item);
            }
            this.minLoanAmount = data["minLoanAmount"];
            this.maxLoanAmount = data["maxLoanAmount"];
            this.minLoanTermMonths = data["minLoanTermMonths"];
            this.maxLoanTermMonths = data["maxLoanTermMonths"];
            this.minAnnualIncome = data["minAnnualIncome"];
            this.maxAnnualIncome = data["maxAnnualIncome"];
            this.campaignProviderType = data["campaignProviderType"];
            this.parameterHandlerType = data["parameterHandlerType"];
            this.flags = data["flags"] ? Flags.fromJS(data["flags"]) : <any>undefined;
            if (data["creditScores"] && data["creditScores"].constructor === Array) {
                this.creditScores = [];
                for (let item of data["creditScores"])
                    this.creditScores.push(item);
            }
            if (data["states"] && data["states"].constructor === Array) {
                this.states = [];
                for (let item of data["states"])
                    this.states.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendOfferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendOfferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customName"] = this.customName;
        data["subId"] = this.subId;
        data["isPublished"] = this.isPublished;
        data["overallRating"] = this.overallRating;
        data["interestRating"] = this.interestRating;
        data["feesRating"] = this.feesRating;
        data["benefitsRating"] = this.benefitsRating;
        data["rewardsRating"] = this.rewardsRating;
        data["serviceRating"] = this.serviceRating;
        data["cardNetwork"] = this.cardNetwork;
        data["cardType"] = this.cardType;
        data["targetAudience"] = this.targetAudience;
        data["securingType"] = this.securingType;
        data["regularAPR"] = this.regularAPR;
        data["introAPR"] = this.introAPR;
        data["balanceTransferFee"] = this.balanceTransferFee;
        data["annualFee"] = this.annualFee;
        data["monthlyFee"] = this.monthlyFee;
        data["activationFee"] = this.activationFee;
        data["introRewardsBonus"] = this.introRewardsBonus;
        data["rewardsRate"] = this.rewardsRate;
        data["durationForZeroPercentagePurchasesInMonths"] = this.durationForZeroPercentagePurchasesInMonths;
        data["zeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["durationForZeroPercentageTransfersInMonths"] = this.durationForZeroPercentageTransfersInMonths;
        data["issuingBank"] = this.issuingBank;
        data["offerCollection"] = this.offerCollection;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item);
        }
        if (this.pros && this.pros.constructor === Array) {
            data["pros"] = [];
            for (let item of this.pros)
                data["pros"].push(item);
        }
        if (this.cons && this.cons.constructor === Array) {
            data["cons"] = [];
            for (let item of this.cons)
                data["cons"].push(item);
        }
        data["minLoanAmount"] = this.minLoanAmount;
        data["maxLoanAmount"] = this.maxLoanAmount;
        data["minLoanTermMonths"] = this.minLoanTermMonths;
        data["maxLoanTermMonths"] = this.maxLoanTermMonths;
        data["minAnnualIncome"] = this.minAnnualIncome;
        data["maxAnnualIncome"] = this.maxAnnualIncome;
        data["campaignProviderType"] = this.campaignProviderType;
        data["parameterHandlerType"] = this.parameterHandlerType;
        data["flags"] = this.flags ? this.flags.toJSON() : <any>undefined;
        if (this.creditScores && this.creditScores.constructor === Array) {
            data["creditScores"] = [];
            for (let item of this.creditScores)
                data["creditScores"].push(item);
        }
        if (this.states && this.states.constructor === Array) {
            data["states"] = [];
            for (let item of this.states)
                data["states"].push(item);
        }
        return data; 
    }
}

export interface IExtendOfferDto {
    customName: string | undefined;
    subId: string | undefined;
    isPublished: boolean | undefined;
    overallRating: number | undefined;
    interestRating: number | undefined;
    feesRating: number | undefined;
    benefitsRating: number | undefined;
    rewardsRating: number | undefined;
    serviceRating: number | undefined;
    cardNetwork: CardNetwork | undefined;
    cardType: CardType | undefined;
    targetAudience: TargetAudience | undefined;
    securingType: SecuringType | undefined;
    regularAPR: string | undefined;
    introAPR: string | undefined;
    balanceTransferFee: string | undefined;
    annualFee: string | undefined;
    monthlyFee: string | undefined;
    activationFee: string | undefined;
    introRewardsBonus: string | undefined;
    rewardsRate: string | undefined;
    durationForZeroPercentagePurchasesInMonths: number | undefined;
    zeroPercentageInterestTransfers: string | undefined;
    durationForZeroPercentageTransfersInMonths: number | undefined;
    issuingBank: string | undefined;
    offerCollection: OfferCollection | undefined;
    details: string[] | undefined;
    pros: string[] | undefined;
    cons: string[] | undefined;
    minLoanAmount: number | undefined;
    maxLoanAmount: number | undefined;
    minLoanTermMonths: number | undefined;
    maxLoanTermMonths: number | undefined;
    minAnnualIncome: number | undefined;
    maxAnnualIncome: number | undefined;
    campaignProviderType: CampaignProviderType | undefined;
    parameterHandlerType: ParameterHandlerType | undefined;
    flags: Flags | undefined;
    creditScores: CreditScoreRating[] | undefined;
    states: string[] | undefined;
}

export enum CampaignStatus {
    PendingReview = "PendingReview", 
    Active = "Active", 
    Denied = "Denied", 
    Suspended = "Suspended", 
    SuspendedRisk = "SuspendedRisk", 
    Inactive = "Inactive", 
    Dormant = "Dormant", 
    Deleted = "Deleted", 
}

export class OfferDetailsForEditDto implements IOfferDetailsForEditDto {
    daysOfWeekAvailability!: string | undefined;
    effectiveTimeOfDay!: string | undefined;
    expireTimeOfDay!: string | undefined;
    termsOfService!: string | undefined;
    trafficSource!: CampaignTrafficSource | undefined;
    categories!: OfferCategoryDto[] | undefined;
    description!: string | undefined;
    countries!: string[] | undefined;
    extendedInfo!: ExtendOfferDto | undefined;
    campaignId!: number | undefined;
    name!: string | undefined;
    systemType!: OfferProviderType | undefined;
    campaignUrl!: string | undefined;
    logoUrl!: string | undefined;
    status!: CampaignStatus | undefined;
    type!: CampaignType | undefined;
    isPublished!: boolean | undefined;

    constructor(data?: IOfferDetailsForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.daysOfWeekAvailability = data["daysOfWeekAvailability"];
            this.effectiveTimeOfDay = data["effectiveTimeOfDay"];
            this.expireTimeOfDay = data["expireTimeOfDay"];
            this.termsOfService = data["termsOfService"];
            this.trafficSource = data["trafficSource"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(OfferCategoryDto.fromJS(item));
            }
            this.description = data["description"];
            if (data["countries"] && data["countries"].constructor === Array) {
                this.countries = [];
                for (let item of data["countries"])
                    this.countries.push(item);
            }
            this.extendedInfo = data["extendedInfo"] ? ExtendOfferDto.fromJS(data["extendedInfo"]) : <any>undefined;
            this.campaignId = data["campaignId"];
            this.name = data["name"];
            this.systemType = data["systemType"];
            this.campaignUrl = data["campaignUrl"];
            this.logoUrl = data["logoUrl"];
            this.status = data["status"];
            this.type = data["type"];
            this.isPublished = data["isPublished"];
        }
    }

    static fromJS(data: any): OfferDetailsForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OfferDetailsForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["daysOfWeekAvailability"] = this.daysOfWeekAvailability;
        data["effectiveTimeOfDay"] = this.effectiveTimeOfDay;
        data["expireTimeOfDay"] = this.expireTimeOfDay;
        data["termsOfService"] = this.termsOfService;
        data["trafficSource"] = this.trafficSource;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["description"] = this.description;
        if (this.countries && this.countries.constructor === Array) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item);
        }
        data["extendedInfo"] = this.extendedInfo ? this.extendedInfo.toJSON() : <any>undefined;
        data["campaignId"] = this.campaignId;
        data["name"] = this.name;
        data["systemType"] = this.systemType;
        data["campaignUrl"] = this.campaignUrl;
        data["logoUrl"] = this.logoUrl;
        data["status"] = this.status;
        data["type"] = this.type;
        data["isPublished"] = this.isPublished;
        return data; 
    }
}

export interface IOfferDetailsForEditDto {
    daysOfWeekAvailability: string | undefined;
    effectiveTimeOfDay: string | undefined;
    expireTimeOfDay: string | undefined;
    termsOfService: string | undefined;
    trafficSource: CampaignTrafficSource | undefined;
    categories: OfferCategoryDto[] | undefined;
    description: string | undefined;
    countries: string[] | undefined;
    extendedInfo: ExtendOfferDto | undefined;
    campaignId: number | undefined;
    name: string | undefined;
    systemType: OfferProviderType | undefined;
    campaignUrl: string | undefined;
    logoUrl: string | undefined;
    status: CampaignStatus | undefined;
    type: CampaignType | undefined;
    isPublished: boolean | undefined;
}

export enum OfferAttributeType {
    SubId = "SubId", 
    IsPublished = "IsPublished", 
    OverallRating = "OverallRating", 
    IssuingBank = "IssuingBank", 
    AnnualFee = "AnnualFee", 
    RewardsRate = "RewardsRate", 
    IntroRewardsBonus = "IntroRewardsBonus", 
    RegularAPR = "RegularAPR", 
    CampaignProviderType = "CampaignProviderType", 
    OfferCollection = "OfferCollection", 
    MinLoanAmount = "MinLoanAmount", 
    MaxLoanAmount = "MaxLoanAmount", 
    MinLoanTermMonths = "MinLoanTermMonths", 
    MaxLoanTermMonths = "MaxLoanTermMonths", 
    MinAnnualIncome = "MinAnnualIncome", 
    MaxAnnualIncome = "MaxAnnualIncome", 
    States = "States", 
    ParameterHandlerType = "ParameterHandlerType", 
}

export class OfferFilter implements IOfferFilter {
    status!: CampaignStatus | undefined;
    type!: CampaignType | undefined;
    category!: CampaignCategory | undefined;
    country!: string | undefined;
    state!: string | undefined;
    creditScore!: CreditScoreRating | undefined;
    isOfferCollection!: boolean | undefined;
    itemOfOfferCollection!: OfferCollection | undefined;
    loanAmount!: number | undefined;
    cardNetworks!: CardNetwork[] | undefined;
    cardType!: CardType | undefined;
    securingType!: SecuringType | undefined;
    targetAudience!: TargetAudience | undefined;
    annualIncome!: number | undefined;
    overallRating!: number | undefined;
    issuingBank!: string | undefined;
    campaignIds!: number[] | undefined;
    campaignUrls!: string[] | undefined;
    strictMatch!: boolean | undefined;

    constructor(data?: IOfferFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.type = data["type"];
            this.category = data["category"];
            this.country = data["country"];
            this.state = data["state"];
            this.creditScore = data["creditScore"];
            this.isOfferCollection = data["isOfferCollection"];
            this.itemOfOfferCollection = data["itemOfOfferCollection"];
            this.loanAmount = data["loanAmount"];
            if (data["cardNetworks"] && data["cardNetworks"].constructor === Array) {
                this.cardNetworks = [];
                for (let item of data["cardNetworks"])
                    this.cardNetworks.push(item);
            }
            this.cardType = data["cardType"];
            this.securingType = data["securingType"];
            this.targetAudience = data["targetAudience"];
            this.annualIncome = data["annualIncome"];
            this.overallRating = data["overallRating"];
            this.issuingBank = data["issuingBank"];
            if (data["campaignIds"] && data["campaignIds"].constructor === Array) {
                this.campaignIds = [];
                for (let item of data["campaignIds"])
                    this.campaignIds.push(item);
            }
            if (data["campaignUrls"] && data["campaignUrls"].constructor === Array) {
                this.campaignUrls = [];
                for (let item of data["campaignUrls"])
                    this.campaignUrls.push(item);
            }
            this.strictMatch = data["strictMatch"];
        }
    }

    static fromJS(data: any): OfferFilter {
        data = typeof data === 'object' ? data : {};
        let result = new OfferFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["type"] = this.type;
        data["category"] = this.category;
        data["country"] = this.country;
        data["state"] = this.state;
        data["creditScore"] = this.creditScore;
        data["isOfferCollection"] = this.isOfferCollection;
        data["itemOfOfferCollection"] = this.itemOfOfferCollection;
        data["loanAmount"] = this.loanAmount;
        if (this.cardNetworks && this.cardNetworks.constructor === Array) {
            data["cardNetworks"] = [];
            for (let item of this.cardNetworks)
                data["cardNetworks"].push(item);
        }
        data["cardType"] = this.cardType;
        data["securingType"] = this.securingType;
        data["targetAudience"] = this.targetAudience;
        data["annualIncome"] = this.annualIncome;
        data["overallRating"] = this.overallRating;
        data["issuingBank"] = this.issuingBank;
        if (this.campaignIds && this.campaignIds.constructor === Array) {
            data["campaignIds"] = [];
            for (let item of this.campaignIds)
                data["campaignIds"].push(item);
        }
        if (this.campaignUrls && this.campaignUrls.constructor === Array) {
            data["campaignUrls"] = [];
            for (let item of this.campaignUrls)
                data["campaignUrls"].push(item);
        }
        data["strictMatch"] = this.strictMatch;
        return data; 
    }
}

export interface IOfferFilter {
    status: CampaignStatus | undefined;
    type: CampaignType | undefined;
    category: CampaignCategory | undefined;
    country: string | undefined;
    state: string | undefined;
    creditScore: CreditScoreRating | undefined;
    isOfferCollection: boolean | undefined;
    itemOfOfferCollection: OfferCollection | undefined;
    loanAmount: number | undefined;
    cardNetworks: CardNetwork[] | undefined;
    cardType: CardType | undefined;
    securingType: SecuringType | undefined;
    targetAudience: TargetAudience | undefined;
    annualIncome: number | undefined;
    overallRating: number | undefined;
    issuingBank: string | undefined;
    campaignIds: number[] | undefined;
    campaignUrls: string[] | undefined;
    strictMatch: boolean | undefined;
}

export enum OfferFlagType {
    Choice = "Choice", 
    Best = "Best", 
    TravelAndAirlineMiles = "TravelAndAirlineMiles", 
    DinigRewards = "DinigRewards", 
    GasRewards = "GasRewards", 
    CashBackRewards = "CashBackRewards", 
    InstantDecision = "InstantDecision", 
    InstantResponse = "InstantResponse", 
    NoCreditCheck = "NoCreditCheck", 
    GuaranteedApproval = "GuaranteedApproval", 
    RebuildCredit = "RebuildCredit", 
    ChipCard = "ChipCard", 
    ApplePay = "ApplePay", 
    GroceryRewards = "GroceryRewards", 
    EntertainmentRewards = "EntertainmentRewards", 
    HotelRewards = "HotelRewards", 
    HasNoRewards = "HasNoRewards", 
    ZeroPercentageOnPurchases = "ZeroPercentageOnPurchases", 
    ZeroPercentageInterestTransfers = "ZeroPercentageInterestTransfers", 
    Special = "Special", 
    Newest = "Newest", 
}

export class ExtendFromCSVOutput implements IExtendFromCSVOutput {
    notMatchedUrls!: string[] | undefined;

    constructor(data?: IExtendFromCSVOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["notMatchedUrls"] && data["notMatchedUrls"].constructor === Array) {
                this.notMatchedUrls = [];
                for (let item of data["notMatchedUrls"])
                    this.notMatchedUrls.push(item);
            }
        }
    }

    static fromJS(data: any): ExtendFromCSVOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendFromCSVOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.notMatchedUrls && this.notMatchedUrls.constructor === Array) {
            data["notMatchedUrls"] = [];
            for (let item of this.notMatchedUrls)
                data["notMatchedUrls"].push(item);
        }
        return data; 
    }
}

export interface IExtendFromCSVOutput {
    notMatchedUrls: string[] | undefined;
}

export class OrderHistoryInfo implements IOrderHistoryInfo {
    time!: moment.Moment | undefined;
    type!: string | undefined;
    userId!: number | undefined;
    userFullName!: string | undefined;
    action!: string | undefined;
    stage!: string | undefined;

    constructor(data?: IOrderHistoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? moment(data["time"].toString()) : <any>undefined;
            this.type = data["type"];
            this.userId = data["userId"];
            this.userFullName = data["userFullName"];
            this.action = data["action"];
            this.stage = data["stage"];
        }
    }

    static fromJS(data: any): OrderHistoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrderHistoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["userId"] = this.userId;
        data["userFullName"] = this.userFullName;
        data["action"] = this.action;
        data["stage"] = this.stage;
        return data; 
    }
}

export interface IOrderHistoryInfo {
    time: moment.Moment | undefined;
    type: string | undefined;
    userId: number | undefined;
    userFullName: string | undefined;
    action: string | undefined;
    stage: string | undefined;
}

export class SetAmountInfo implements ISetAmountInfo {
    orderId!: number;
    amount!: number;

    constructor(data?: ISetAmountInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): SetAmountInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SetAmountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface ISetAmountInfo {
    orderId: number;
    amount: number;
}

export class UpdateOrderStageInfo implements IUpdateOrderStageInfo {
    orderId!: number;
    stageId!: number;
    sortOrder!: number | undefined;

    constructor(data?: IUpdateOrderStageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.stageId = data["stageId"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateOrderStageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["stageId"] = this.stageId;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateOrderStageInfo {
    orderId: number;
    stageId: number;
    sortOrder: number | undefined;
}

export class ProcessOrderInfo implements IProcessOrderInfo {
    id!: number;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: IProcessOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): ProcessOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface IProcessOrderInfo {
    id: number;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class CancelOrderInfo implements ICancelOrderInfo {
    orderId!: number;
    comment!: string;
    sortOrder!: number | undefined;
    stageId!: number | undefined;

    constructor(data?: ICancelOrderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.comment = data["comment"];
            this.sortOrder = data["sortOrder"];
            this.stageId = data["stageId"];
        }
    }

    static fromJS(data: any): CancelOrderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["comment"] = this.comment;
        data["sortOrder"] = this.sortOrder;
        data["stageId"] = this.stageId;
        return data; 
    }
}

export interface ICancelOrderInfo {
    orderId: number;
    comment: string;
    sortOrder: number | undefined;
    stageId: number | undefined;
}

export class OrderSbuscriptionPaymentDto implements IOrderSbuscriptionPaymentDto {
    id!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    status!: string | undefined;
    fee!: number | undefined;
    isSubscription!: boolean | undefined;

    constructor(data?: IOrderSbuscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.fee = data["fee"];
            this.isSubscription = data["isSubscription"];
        }
    }

    static fromJS(data: any): OrderSbuscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSbuscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["fee"] = this.fee;
        data["isSubscription"] = this.isSubscription;
        return data; 
    }
}

export interface IOrderSbuscriptionPaymentDto {
    id: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    status: string | undefined;
    fee: number | undefined;
    isSubscription: boolean | undefined;
}

export class OrderSubscriptionDto implements IOrderSubscriptionDto {
    id!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    fee!: number | undefined;
    tenantId!: string | undefined;
    serviceType!: string | undefined;
    serviceTypeName!: string | undefined;
    systemType!: string | undefined;
    orderType!: string | undefined;
    trialEndDate!: moment.Moment | undefined;
    statusCode!: string | undefined;
    status!: string | undefined;
    orderSubscriptionPayments!: OrderSbuscriptionPaymentDto[] | undefined;

    constructor(data?: IOrderSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.fee = data["fee"];
            this.tenantId = data["tenantId"];
            this.serviceType = data["serviceType"];
            this.serviceTypeName = data["serviceTypeName"];
            this.systemType = data["systemType"];
            this.orderType = data["orderType"];
            this.trialEndDate = data["trialEndDate"] ? moment(data["trialEndDate"].toString()) : <any>undefined;
            this.statusCode = data["statusCode"];
            this.status = data["status"];
            if (data["orderSubscriptionPayments"] && data["orderSubscriptionPayments"].constructor === Array) {
                this.orderSubscriptionPayments = [];
                for (let item of data["orderSubscriptionPayments"])
                    this.orderSubscriptionPayments.push(OrderSbuscriptionPaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["fee"] = this.fee;
        data["tenantId"] = this.tenantId;
        data["serviceType"] = this.serviceType;
        data["serviceTypeName"] = this.serviceTypeName;
        data["systemType"] = this.systemType;
        data["orderType"] = this.orderType;
        data["trialEndDate"] = this.trialEndDate ? this.trialEndDate.toISOString() : <any>undefined;
        data["statusCode"] = this.statusCode;
        data["status"] = this.status;
        if (this.orderSubscriptionPayments && this.orderSubscriptionPayments.constructor === Array) {
            data["orderSubscriptionPayments"] = [];
            for (let item of this.orderSubscriptionPayments)
                data["orderSubscriptionPayments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderSubscriptionDto {
    id: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    fee: number | undefined;
    tenantId: string | undefined;
    serviceType: string | undefined;
    serviceTypeName: string | undefined;
    systemType: string | undefined;
    orderType: string | undefined;
    trialEndDate: moment.Moment | undefined;
    statusCode: string | undefined;
    status: string | undefined;
    orderSubscriptionPayments: OrderSbuscriptionPaymentDto[] | undefined;
}

export class OrganizationInfoDto implements IOrganizationInfoDto {
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    organizationUnitId!: number | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IOrganizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.organizationUnitId = data["organizationUnitId"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): OrganizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["organizationUnitId"] = this.organizationUnitId;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IOrganizationInfoDto {
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    organizationUnitId: number | undefined;
    affiliateCode: string | undefined;
}

export class PersonShortInfoDto implements IPersonShortInfoDto {
    id!: number | undefined;
    fullName!: string | undefined;
    jobTitle!: string | undefined;
    ratingId!: number | undefined;
    thumbnail!: string | undefined;

    constructor(data?: IPersonShortInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.jobTitle = data["jobTitle"];
            this.ratingId = data["ratingId"];
            this.thumbnail = data["thumbnail"];
        }
    }

    static fromJS(data: any): PersonShortInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonShortInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["jobTitle"] = this.jobTitle;
        data["ratingId"] = this.ratingId;
        data["thumbnail"] = this.thumbnail;
        return data; 
    }
}

export interface IPersonShortInfoDto {
    id: number | undefined;
    fullName: string | undefined;
    jobTitle: string | undefined;
    ratingId: number | undefined;
    thumbnail: string | undefined;
}

export class OrganizationContactInfoDto implements IOrganizationContactInfoDto {
    groupId!: string | undefined;
    organization!: OrganizationInfoDto | undefined;
    contactPersons!: PersonShortInfoDto[] | undefined;
    id!: number | undefined;
    fullName!: string | undefined;
    userId!: number | undefined;
    primaryPhoneId!: number | undefined;
    primaryAddressId!: number | undefined;
    primaryPhoto!: string | undefined;
    details!: ContactInfoDetailsDto | undefined;
    comment!: string | undefined;

    constructor(data?: IOrganizationContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.organization = data["organization"] ? OrganizationInfoDto.fromJS(data["organization"]) : <any>undefined;
            if (data["contactPersons"] && data["contactPersons"].constructor === Array) {
                this.contactPersons = [];
                for (let item of data["contactPersons"])
                    this.contactPersons.push(PersonShortInfoDto.fromJS(item));
            }
            this.id = data["id"];
            this.fullName = data["fullName"];
            this.userId = data["userId"];
            this.primaryPhoneId = data["primaryPhoneId"];
            this.primaryAddressId = data["primaryAddressId"];
            this.primaryPhoto = data["primaryPhoto"];
            this.details = data["details"] ? ContactInfoDetailsDto.fromJS(data["details"]) : <any>undefined;
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): OrganizationContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (this.contactPersons && this.contactPersons.constructor === Array) {
            data["contactPersons"] = [];
            for (let item of this.contactPersons)
                data["contactPersons"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userId"] = this.userId;
        data["primaryPhoneId"] = this.primaryPhoneId;
        data["primaryAddressId"] = this.primaryAddressId;
        data["primaryPhoto"] = this.primaryPhoto;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IOrganizationContactInfoDto {
    groupId: string | undefined;
    organization: OrganizationInfoDto | undefined;
    contactPersons: PersonShortInfoDto[] | undefined;
    id: number | undefined;
    fullName: string | undefined;
    userId: number | undefined;
    primaryPhoneId: number | undefined;
    primaryAddressId: number | undefined;
    primaryPhoto: string | undefined;
    details: ContactInfoDetailsDto | undefined;
    comment: string | undefined;
}

export class CreateOrganizationInput implements ICreateOrganizationInput {
    relatedContactId!: number;
    relationTypeId!: string;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    organizationUnitId!: number | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: ICreateOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.relatedContactId = data["relatedContactId"];
            this.relationTypeId = data["relationTypeId"];
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.organizationUnitId = data["organizationUnitId"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): CreateOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedContactId"] = this.relatedContactId;
        data["relationTypeId"] = this.relationTypeId;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["organizationUnitId"] = this.organizationUnitId;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface ICreateOrganizationInput {
    relatedContactId: number;
    relationTypeId: string;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    organizationUnitId: number | undefined;
    affiliateCode: string | undefined;
}

export class CreateOrganizationOutput implements ICreateOrganizationOutput {
    id!: number | undefined;

    constructor(data?: ICreateOrganizationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrganizationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrganizationOutput {
    id: number | undefined;
}

export class UpdateOrganizationInfoInput implements IUpdateOrganizationInfoInput {
    id!: number;
    companyName!: string;
    shortName!: string | undefined;
    typeId!: string | undefined;
    industry!: string | undefined;
    annualRevenue!: number | undefined;
    ein!: string | undefined;
    businessSicCode!: number | undefined;
    formedCountryId!: string | undefined;
    formedStateId!: string | undefined;
    description!: string | undefined;
    formedDate!: moment.Moment | undefined;
    sizeFrom!: number | undefined;
    sizeTo!: number | undefined;
    duns!: string | undefined;
    ticker!: string | undefined;
    organizationUnitId!: number | undefined;
    affiliateCode!: string | undefined;

    constructor(data?: IUpdateOrganizationInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyName = data["companyName"];
            this.shortName = data["shortName"];
            this.typeId = data["typeId"];
            this.industry = data["industry"];
            this.annualRevenue = data["annualRevenue"];
            this.ein = data["ein"];
            this.businessSicCode = data["businessSicCode"];
            this.formedCountryId = data["formedCountryId"];
            this.formedStateId = data["formedStateId"];
            this.description = data["description"];
            this.formedDate = data["formedDate"] ? moment(data["formedDate"].toString()) : <any>undefined;
            this.sizeFrom = data["sizeFrom"];
            this.sizeTo = data["sizeTo"];
            this.duns = data["duns"];
            this.ticker = data["ticker"];
            this.organizationUnitId = data["organizationUnitId"];
            this.affiliateCode = data["affiliateCode"];
        }
    }

    static fromJS(data: any): UpdateOrganizationInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["shortName"] = this.shortName;
        data["typeId"] = this.typeId;
        data["industry"] = this.industry;
        data["annualRevenue"] = this.annualRevenue;
        data["ein"] = this.ein;
        data["businessSicCode"] = this.businessSicCode;
        data["formedCountryId"] = this.formedCountryId;
        data["formedStateId"] = this.formedStateId;
        data["description"] = this.description;
        data["formedDate"] = this.formedDate ? this.formedDate.toISOString() : <any>undefined;
        data["sizeFrom"] = this.sizeFrom;
        data["sizeTo"] = this.sizeTo;
        data["duns"] = this.duns;
        data["ticker"] = this.ticker;
        data["organizationUnitId"] = this.organizationUnitId;
        data["affiliateCode"] = this.affiliateCode;
        return data; 
    }
}

export interface IUpdateOrganizationInfoInput {
    id: number;
    companyName: string;
    shortName: string | undefined;
    typeId: string | undefined;
    industry: string | undefined;
    annualRevenue: number | undefined;
    ein: string | undefined;
    businessSicCode: number | undefined;
    formedCountryId: string | undefined;
    formedStateId: string | undefined;
    description: string | undefined;
    formedDate: moment.Moment | undefined;
    sizeFrom: number | undefined;
    sizeTo: number | undefined;
    duns: string | undefined;
    ticker: string | undefined;
    organizationUnitId: number | undefined;
    affiliateCode: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PackageDto implements IPackageDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    initialPaymentAmount!: number | undefined;
    trialPeriodDays!: number | undefined;
    monthlyPaymentAmount!: number | undefined;
    isActive!: boolean | undefined;
    isDemo!: boolean | undefined;
    isSimulatorEnabled!: boolean | undefined;

    constructor(data?: IPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            this.initialPaymentAmount = data["initialPaymentAmount"];
            this.trialPeriodDays = data["trialPeriodDays"];
            this.monthlyPaymentAmount = data["monthlyPaymentAmount"];
            this.isActive = data["isActive"];
            this.isDemo = data["isDemo"];
            this.isSimulatorEnabled = data["isSimulatorEnabled"];
        }
    }

    static fromJS(data: any): PackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["initialPaymentAmount"] = this.initialPaymentAmount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["monthlyPaymentAmount"] = this.monthlyPaymentAmount;
        data["isActive"] = this.isActive;
        data["isDemo"] = this.isDemo;
        data["isSimulatorEnabled"] = this.isSimulatorEnabled;
        return data; 
    }
}

export interface IPackageDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    initialPaymentAmount: number | undefined;
    trialPeriodDays: number | undefined;
    monthlyPaymentAmount: number | undefined;
    isActive: boolean | undefined;
    isDemo: boolean | undefined;
    isSimulatorEnabled: boolean | undefined;
}

export class PackageDtoListResultDto implements IPackageDtoListResultDto {
    items!: PackageDto[] | undefined;

    constructor(data?: IPackageDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageDtoListResultDto {
    items: PackageDto[] | undefined;
}

export class ModuleSubscriptionInfoExtended implements IModuleSubscriptionInfoExtended {
    isTrial!: boolean | undefined;
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfoExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isTrial = data["isTrial"];
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
            this.frequency = data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoExtended {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTrial"] = this.isTrial;
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data; 
    }
}

export interface IModuleSubscriptionInfoExtended {
    isTrial: boolean | undefined;
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export class LocalizableString implements ILocalizableString {
    sourceName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ILocalizableString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceName = data["sourceName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): LocalizableString {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILocalizableString {
    sourceName: string | undefined;
    name: string | undefined;
}

export enum MeasurementUnit {
    GB = "GB", 
}

export class PricingTableFeatureDefinition implements IPricingTableFeatureDefinition {
    name!: string | undefined;
    displayName!: LocalizableString | undefined;
    isVariable!: boolean | undefined;
    sortOrder!: number | undefined;
    isStatic!: boolean | undefined;
    measurementUnit!: MeasurementUnit | undefined;
    isCommon!: boolean | undefined;

    constructor(data?: IPricingTableFeatureDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"] ? LocalizableString.fromJS(data["displayName"]) : <any>undefined;
            this.isVariable = data["isVariable"];
            this.sortOrder = data["sortOrder"];
            this.isStatic = data["isStatic"];
            this.measurementUnit = data["measurementUnit"];
            this.isCommon = data["isCommon"];
        }
    }

    static fromJS(data: any): PricingTableFeatureDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new PricingTableFeatureDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["isVariable"] = this.isVariable;
        data["sortOrder"] = this.sortOrder;
        data["isStatic"] = this.isStatic;
        data["measurementUnit"] = this.measurementUnit;
        data["isCommon"] = this.isCommon;
        return data; 
    }
}

export interface IPricingTableFeatureDefinition {
    name: string | undefined;
    displayName: LocalizableString | undefined;
    isVariable: boolean | undefined;
    sortOrder: number | undefined;
    isStatic: boolean | undefined;
    measurementUnit: MeasurementUnit | undefined;
    isCommon: boolean | undefined;
}

export class PackageEditionConfigFeatureDto implements IPackageEditionConfigFeatureDto {
    definition!: PricingTableFeatureDefinition | undefined;
    value!: string | undefined;

    constructor(data?: IPackageEditionConfigFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.definition = data["definition"] ? PricingTableFeatureDefinition.fromJS(data["definition"]) : <any>undefined;
            this.value = data["value"];
        }
    }

    static fromJS(data: any): PackageEditionConfigFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["definition"] = this.definition ? this.definition.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPackageEditionConfigFeatureDto {
    definition: PricingTableFeatureDefinition | undefined;
    value: string | undefined;
}

export class PackageEditionConfigDto implements IPackageEditionConfigDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    maxUserCount!: number | undefined;
    features!: PackageEditionConfigFeatureDto[] | undefined;

    constructor(data?: IPackageEditionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.maxUserCount = data["maxUserCount"];
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(PackageEditionConfigFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageEditionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageEditionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["maxUserCount"] = this.maxUserCount;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageEditionConfigDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    maxUserCount: number | undefined;
    features: PackageEditionConfigFeatureDto[] | undefined;
}

export class PackageConfigDto implements IPackageConfigDto {
    id!: number | undefined;
    module!: ModuleType | undefined;
    moduleName!: string | undefined;
    name!: string | undefined;
    bestValue!: boolean | undefined;
    sortOrder!: number | undefined;
    isForPartner!: boolean | undefined;
    editions!: PackageEditionConfigDto[] | undefined;

    constructor(data?: IPackageConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.module = data["module"];
            this.moduleName = data["moduleName"];
            this.name = data["name"];
            this.bestValue = data["bestValue"];
            this.sortOrder = data["sortOrder"];
            this.isForPartner = data["isForPartner"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(PackageEditionConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new PackageConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["module"] = this.module;
        data["moduleName"] = this.moduleName;
        data["name"] = this.name;
        data["bestValue"] = this.bestValue;
        data["sortOrder"] = this.sortOrder;
        data["isForPartner"] = this.isForPartner;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPackageConfigDto {
    id: number | undefined;
    module: ModuleType | undefined;
    moduleName: string | undefined;
    name: string | undefined;
    bestValue: boolean | undefined;
    sortOrder: number | undefined;
    isForPartner: boolean | undefined;
    editions: PackageEditionConfigDto[] | undefined;
}

export class GetPackagesConfigOutput implements IGetPackagesConfigOutput {
    currentSubscriptionInfo!: ModuleSubscriptionInfoExtended | undefined;
    packages!: PackageConfigDto[] | undefined;

    constructor(data?: IGetPackagesConfigOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentSubscriptionInfo = data["currentSubscriptionInfo"] ? ModuleSubscriptionInfoExtended.fromJS(data["currentSubscriptionInfo"]) : <any>undefined;
            if (data["packages"] && data["packages"].constructor === Array) {
                this.packages = [];
                for (let item of data["packages"])
                    this.packages.push(PackageConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPackagesConfigOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackagesConfigOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentSubscriptionInfo"] = this.currentSubscriptionInfo ? this.currentSubscriptionInfo.toJSON() : <any>undefined;
        if (this.packages && this.packages.constructor === Array) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPackagesConfigOutput {
    currentSubscriptionInfo: ModuleSubscriptionInfoExtended | undefined;
    packages: PackageConfigDto[] | undefined;
}

export class PartnerInfoDto implements IPartnerInfoDto {
    typeId!: number | undefined;

    constructor(data?: IPartnerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): PartnerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        return data; 
    }
}

export interface IPartnerInfoDto {
    typeId: number | undefined;
}

export class UpdatePartnerTypeInput implements IUpdatePartnerTypeInput {
    partnerId!: number;
    typeName!: string | undefined;

    constructor(data?: IUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.partnerId = data["partnerId"];
            this.typeName = data["typeName"];
        }
    }

    static fromJS(data: any): UpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partnerId"] = this.partnerId;
        data["typeName"] = this.typeName;
        return data; 
    }
}

export interface IUpdatePartnerTypeInput {
    partnerId: number;
    typeName: string | undefined;
}

export class BulkUpdatePartnerTypeInput implements IBulkUpdatePartnerTypeInput {
    partnerIds!: number[];
    typeName!: string | undefined;

    constructor(data?: IBulkUpdatePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.partnerIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["partnerIds"] && data["partnerIds"].constructor === Array) {
                this.partnerIds = [];
                for (let item of data["partnerIds"])
                    this.partnerIds.push(item);
            }
            this.typeName = data["typeName"];
        }
    }

    static fromJS(data: any): BulkUpdatePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdatePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.partnerIds && this.partnerIds.constructor === Array) {
            data["partnerIds"] = [];
            for (let item of this.partnerIds)
                data["partnerIds"].push(item);
        }
        data["typeName"] = this.typeName;
        return data; 
    }
}

export interface IBulkUpdatePartnerTypeInput {
    partnerIds: number[];
    typeName: string | undefined;
}

export class RenamePartnerTypeInput implements IRenamePartnerTypeInput {
    id!: number;
    name!: string;

    constructor(data?: IRenamePartnerTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenamePartnerTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePartnerTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenamePartnerTypeInput {
    id: number;
    name: string;
}

export class MonthlyPaymentInfo implements IMonthlyPaymentInfo {
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IMonthlyPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): MonthlyPaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MonthlyPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IMonthlyPaymentInfo {
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    amount: number | undefined;
}

export class ACHCustomerShortInfo implements IACHCustomerShortInfo {
    firstName!: string | undefined;
    lastName!: string | undefined;
    customerAcctType!: CustomerAccountingType | undefined;

    constructor(data?: IACHCustomerShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.customerAcctType = data["customerAcctType"];
        }
    }

    static fromJS(data: any): ACHCustomerShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["customerAcctType"] = this.customerAcctType;
        return data; 
    }
}

export interface IACHCustomerShortInfo {
    firstName: string | undefined;
    lastName: string | undefined;
    customerAcctType: CustomerAccountingType | undefined;
}

export class BankCardShortInfo implements IBankCardShortInfo {
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;

    constructor(data?: IBankCardShortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
        }
    }

    static fromJS(data: any): BankCardShortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardShortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        return data; 
    }
}

export interface IBankCardShortInfo {
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
}

export class PaymentMethodInfo implements IPaymentMethodInfo {
    type!: PaymentInfoType | undefined;
    achCustomerInfo!: ACHCustomerShortInfo | undefined;
    bankCardInfo!: BankCardShortInfo | undefined;

    constructor(data?: IPaymentMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.achCustomerInfo = data["achCustomerInfo"] ? ACHCustomerShortInfo.fromJS(data["achCustomerInfo"]) : <any>undefined;
            this.bankCardInfo = data["bankCardInfo"] ? BankCardShortInfo.fromJS(data["bankCardInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentMethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["achCustomerInfo"] = this.achCustomerInfo ? this.achCustomerInfo.toJSON() : <any>undefined;
        data["bankCardInfo"] = this.bankCardInfo ? this.bankCardInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaymentMethodInfo {
    type: PaymentInfoType | undefined;
    achCustomerInfo: ACHCustomerShortInfo | undefined;
    bankCardInfo: BankCardShortInfo | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class FlatPermissionWithLevelDtoListResultDto implements IFlatPermissionWithLevelDtoListResultDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IFlatPermissionWithLevelDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFlatPermissionWithLevelDtoListResultDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class UpdatePersonInfoInput implements IUpdatePersonInfoInput {
    dob!: moment.Moment | undefined;
    ssn!: string | undefined;
    timeZone!: string | undefined;
    maritalStatus!: MaritalStatus | undefined;
    marriageDate!: moment.Moment | undefined;
    divorceDate!: moment.Moment | undefined;
    gender!: Gender | undefined;
    isUSCitizen!: boolean | undefined;
    citizenship!: string | undefined;
    experience!: string | undefined;
    profileSummary!: string | undefined;
    preferredToD!: TimeOfDay | undefined;
    drivingLicense!: string | undefined;
    drivingLicenseState!: string | undefined;
    isActiveMilitaryDuty!: boolean | undefined;
    interests!: string[] | undefined;
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.ssn = data["ssn"];
            this.timeZone = data["timeZone"];
            this.maritalStatus = data["maritalStatus"];
            this.marriageDate = data["marriageDate"] ? moment(data["marriageDate"].toString()) : <any>undefined;
            this.divorceDate = data["divorceDate"] ? moment(data["divorceDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.isUSCitizen = data["isUSCitizen"];
            this.citizenship = data["citizenship"];
            this.experience = data["experience"];
            this.profileSummary = data["profileSummary"];
            this.preferredToD = data["preferredToD"];
            this.drivingLicense = data["drivingLicense"];
            this.drivingLicenseState = data["drivingLicenseState"];
            this.isActiveMilitaryDuty = data["isActiveMilitaryDuty"];
            if (data["interests"] && data["interests"].constructor === Array) {
                this.interests = [];
                for (let item of data["interests"])
                    this.interests.push(item);
            }
            this.id = data["id"];
            this.bankCode = data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["ssn"] = this.ssn;
        data["timeZone"] = this.timeZone;
        data["maritalStatus"] = this.maritalStatus;
        data["marriageDate"] = this.marriageDate ? this.marriageDate.toISOString() : <any>undefined;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isUSCitizen"] = this.isUSCitizen;
        data["citizenship"] = this.citizenship;
        data["experience"] = this.experience;
        data["profileSummary"] = this.profileSummary;
        data["preferredToD"] = this.preferredToD;
        data["drivingLicense"] = this.drivingLicense;
        data["drivingLicenseState"] = this.drivingLicenseState;
        data["isActiveMilitaryDuty"] = this.isActiveMilitaryDuty;
        if (this.interests && this.interests.constructor === Array) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item);
        }
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data; 
    }
}

export interface IUpdatePersonInfoInput {
    dob: moment.Moment | undefined;
    ssn: string | undefined;
    timeZone: string | undefined;
    maritalStatus: MaritalStatus | undefined;
    marriageDate: moment.Moment | undefined;
    divorceDate: moment.Moment | undefined;
    gender: Gender | undefined;
    isUSCitizen: boolean | undefined;
    citizenship: string | undefined;
    experience: string | undefined;
    profileSummary: string | undefined;
    preferredToD: TimeOfDay | undefined;
    drivingLicense: string | undefined;
    drivingLicenseState: string | undefined;
    isActiveMilitaryDuty: boolean | undefined;
    interests: string[] | undefined;
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonBANKCodeInput implements IUpdatePersonBANKCodeInput {
    id!: number;
    bankCode!: string | undefined;

    constructor(data?: IUpdatePersonBANKCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankCode = data["bankCode"];
        }
    }

    static fromJS(data: any): UpdatePersonBANKCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonBANKCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankCode"] = this.bankCode;
        return data; 
    }
}

export interface IUpdatePersonBANKCodeInput {
    id: number;
    bankCode: string | undefined;
}

export class UpdatePersonNameInput implements IUpdatePersonNameInput {
    id!: number;
    namePrefix!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    nameSuffix!: string | undefined;
    nickName!: string | undefined;

    constructor(data?: IUpdatePersonNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.namePrefix = data["namePrefix"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.nameSuffix = data["nameSuffix"];
            this.nickName = data["nickName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["namePrefix"] = this.namePrefix;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["nameSuffix"] = this.nameSuffix;
        data["nickName"] = this.nickName;
        return data; 
    }
}

export interface IUpdatePersonNameInput {
    id: number;
    namePrefix: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    nameSuffix: string | undefined;
    nickName: string | undefined;
}

export class UpdatePersonNameOutput implements IUpdatePersonNameOutput {
    fullName!: string | undefined;

    constructor(data?: IUpdatePersonNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fullName = data["fullName"];
        }
    }

    static fromJS(data: any): UpdatePersonNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IUpdatePersonNameOutput {
    fullName: string | undefined;
}

export class CreateUserForContactInput implements ICreateUserForContactInput {
    contactId!: number;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    assignedRoleNames!: string[] | undefined;
    organizationUnitIds!: number[] | undefined;

    constructor(data?: ICreateUserForContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contactId = data["contactId"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            if (data["organizationUnitIds"] && data["organizationUnitIds"].constructor === Array) {
                this.organizationUnitIds = [];
                for (let item of data["organizationUnitIds"])
                    this.organizationUnitIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserForContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserForContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        if (this.organizationUnitIds && this.organizationUnitIds.constructor === Array) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateUserForContactInput {
    contactId: number;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    assignedRoleNames: string[] | undefined;
    organizationUnitIds: number[] | undefined;
}

export class CreatePersonOrgRelationInput implements ICreatePersonOrgRelationInput {
    personId!: number;
    organizationId!: number | undefined;
    organizationName!: string | undefined;
    relationshipType!: string;
    jobTitle!: string;

    constructor(data?: ICreatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.relationshipType = data["relationshipType"];
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface ICreatePersonOrgRelationInput {
    personId: number;
    organizationId: number | undefined;
    organizationName: string | undefined;
    relationshipType: string;
    jobTitle: string;
}

export class CreatePersonOrgRelationOutput implements ICreatePersonOrgRelationOutput {
    id!: number | undefined;
    organizationId!: number | undefined;

    constructor(data?: ICreatePersonOrgRelationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.organizationId = data["organizationId"];
        }
    }

    static fromJS(data: any): CreatePersonOrgRelationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonOrgRelationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        return data; 
    }
}

export interface ICreatePersonOrgRelationOutput {
    id: number | undefined;
    organizationId: number | undefined;
}

export class UpdatePersonOrgRelationInput implements IUpdatePersonOrgRelationInput {
    id!: number;
    relationshipType!: string;
    jobTitle!: string;

    constructor(data?: IUpdatePersonOrgRelationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.relationshipType = data["relationshipType"];
            this.jobTitle = data["jobTitle"];
        }
    }

    static fromJS(data: any): UpdatePersonOrgRelationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonOrgRelationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["relationshipType"] = this.relationshipType;
        data["jobTitle"] = this.jobTitle;
        return data; 
    }
}

export interface IUpdatePersonOrgRelationInput {
    id: number;
    relationshipType: string;
    jobTitle: string;
}

export class ActionDto implements IActionDto {
    id!: number | undefined;
    name!: string | undefined;
    sysId!: string | undefined;
    targetStageId!: number | undefined;

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sysId = data["sysId"];
            this.targetStageId = data["targetStageId"];
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sysId"] = this.sysId;
        data["targetStageId"] = this.targetStageId;
        return data; 
    }
}

export interface IActionDto {
    id: number | undefined;
    name: string | undefined;
    sysId: string | undefined;
    targetStageId: number | undefined;
}

export class StageDto implements IStageDto {
    id!: number | undefined;
    name!: string | undefined;
    sortOrder!: number | undefined;
    color!: string | undefined;
    isFinal!: boolean | undefined;
    accessibleActions!: ActionDto[] | undefined;

    constructor(data?: IStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
            this.color = data["color"];
            this.isFinal = data["isFinal"];
            if (data["accessibleActions"] && data["accessibleActions"].constructor === Array) {
                this.accessibleActions = [];
                for (let item of data["accessibleActions"])
                    this.accessibleActions.push(ActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        data["color"] = this.color;
        data["isFinal"] = this.isFinal;
        if (this.accessibleActions && this.accessibleActions.constructor === Array) {
            data["accessibleActions"] = [];
            for (let item of this.accessibleActions)
                data["accessibleActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStageDto {
    id: number | undefined;
    name: string | undefined;
    sortOrder: number | undefined;
    color: string | undefined;
    isFinal: boolean | undefined;
    accessibleActions: ActionDto[] | undefined;
}

export class PipelineDto implements IPipelineDto {
    id!: number | undefined;
    name!: string | undefined;
    purpose!: string | undefined;
    contactGroupId!: string | undefined;
    stages!: StageDto[] | undefined;

    constructor(data?: IPipelineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.purpose = data["purpose"];
            this.contactGroupId = data["contactGroupId"];
            if (data["stages"] && data["stages"].constructor === Array) {
                this.stages = [];
                for (let item of data["stages"])
                    this.stages.push(StageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDto {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["purpose"] = this.purpose;
        data["contactGroupId"] = this.contactGroupId;
        if (this.stages && this.stages.constructor === Array) {
            data["stages"] = [];
            for (let item of this.stages)
                data["stages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPipelineDto {
    id: number | undefined;
    name: string | undefined;
    purpose: string | undefined;
    contactGroupId: string | undefined;
    stages: StageDto[] | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    originalImage!: string;
    thumbnail!: string;
    source!: string | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.originalImage = data["originalImage"];
            this.thumbnail = data["thumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalImage"] = this.originalImage;
        data["thumbnail"] = this.thumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    originalImage: string;
    thumbnail: string;
    source: string | undefined;
}

export class DownloadPictureInput implements IDownloadPictureInput {
    url!: string;

    constructor(data?: IDownloadPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
        }
    }

    static fromJS(data: any): DownloadPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IDownloadPictureInput {
    url: string;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum QuestionType {
    QuestionWithOptions = "QuestionWithOptions", 
}

export class OptionDto implements IOptionDto {
    id!: number | undefined;
    questionId!: number | undefined;
    sortOrder!: number | undefined;
    text!: string | undefined;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.questionId = data["questionId"];
            this.sortOrder = data["sortOrder"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["sortOrder"] = this.sortOrder;
        data["text"] = this.text;
        return data; 
    }
}

export interface IOptionDto {
    id: number | undefined;
    questionId: number | undefined;
    sortOrder: number | undefined;
    text: string | undefined;
}

export class QuestionDto implements IQuestionDto {
    id!: number | undefined;
    questionnaireId!: number | undefined;
    type!: QuestionType | undefined;
    text!: string | undefined;
    sortOrder!: number | undefined;
    options!: OptionDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.questionnaireId = data["questionnaireId"];
            this.type = data["type"];
            this.text = data["text"];
            this.sortOrder = data["sortOrder"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(OptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionnaireId"] = this.questionnaireId;
        data["type"] = this.type;
        data["text"] = this.text;
        data["sortOrder"] = this.sortOrder;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionDto {
    id: number | undefined;
    questionnaireId: number | undefined;
    type: QuestionType | undefined;
    text: string | undefined;
    sortOrder: number | undefined;
    options: OptionDto[] | undefined;
}

export class QuestionnaireDto implements IQuestionnaireDto {
    id!: number | undefined;
    questions!: QuestionDto[] | undefined;

    constructor(data?: IQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [];
                for (let item of data["questions"])
                    this.questions.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionnaireDto {
    id: number | undefined;
    questions: QuestionDto[] | undefined;
}

export class AnswerDto implements IAnswerDto {
    questionId!: number | undefined;
    options!: number[] | undefined;

    constructor(data?: IAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionId = data["questionId"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(item);
            }
        }
    }

    static fromJS(data: any): AnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        return data; 
    }
}

export interface IAnswerDto {
    questionId: number | undefined;
    options: number[] | undefined;
}

export class QuestionnaireResponseDto implements IQuestionnaireResponseDto {
    questionnaireId!: number | undefined;
    answers!: AnswerDto[] | undefined;

    constructor(data?: IQuestionnaireResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionnaireId = data["questionnaireId"];
            if (data["answers"] && data["answers"].constructor === Array) {
                this.answers = [];
                for (let item of data["answers"])
                    this.answers.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionnaireResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaireId"] = this.questionnaireId;
        if (this.answers && this.answers.constructor === Array) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQuestionnaireResponseDto {
    questionnaireId: number | undefined;
    answers: AnswerDto[] | undefined;
}

export class QuickBookConnectionLinkResult implements IQuickBookConnectionLinkResult {
    connectionLink!: string | undefined;

    constructor(data?: IQuickBookConnectionLinkResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionLink = data["connectionLink"];
        }
    }

    static fromJS(data: any): QuickBookConnectionLinkResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuickBookConnectionLinkResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionLink"] = this.connectionLink;
        return data; 
    }
}

export interface IQuickBookConnectionLinkResult {
    connectionLink: string | undefined;
}

export class GetReportUrlOutput implements IGetReportUrlOutput {
    url!: string | undefined;
    validityPeriodSeconds!: number | undefined;

    constructor(data?: IGetReportUrlOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.validityPeriodSeconds = data["validityPeriodSeconds"];
        }
    }

    static fromJS(data: any): GetReportUrlOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportUrlOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["validityPeriodSeconds"] = this.validityPeriodSeconds;
        return data; 
    }
}

export interface IGetReportUrlOutput {
    url: string | undefined;
    validityPeriodSeconds: number | undefined;
}

export enum ReportPeriod {
    Monthly = "Monthly", 
    Quarterly = "Quarterly", 
    Annual = "Annual", 
}

export class SendReportNotificationInput implements ISendReportNotificationInput {
    reportId!: string | undefined;
    recipientUserEmailAddress!: string | undefined;
    sendReportInAttachments!: boolean | undefined;

    constructor(data?: ISendReportNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportId = data["reportId"];
            this.recipientUserEmailAddress = data["recipientUserEmailAddress"];
            this.sendReportInAttachments = data["sendReportInAttachments"];
        }
    }

    static fromJS(data: any): SendReportNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendReportNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["recipientUserEmailAddress"] = this.recipientUserEmailAddress;
        data["sendReportInAttachments"] = this.sendReportInAttachments;
        return data; 
    }
}

export interface ISendReportNotificationInput {
    reportId: string | undefined;
    recipientUserEmailAddress: string | undefined;
    sendReportInAttachments: boolean | undefined;
}

export class GenerateInput implements IGenerateInput {
    from!: moment.Moment;
    to!: moment.Moment;
    period!: ReportPeriod;
    currencyId!: string;
    businessEntityIds!: number[] | undefined;
    bankAccountIds!: number[] | undefined;
    notificationData!: SendReportNotificationInput | undefined;

    constructor(data?: IGenerateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            this.period = data["period"];
            this.currencyId = data["currencyId"];
            if (data["businessEntityIds"] && data["businessEntityIds"].constructor === Array) {
                this.businessEntityIds = [];
                for (let item of data["businessEntityIds"])
                    this.businessEntityIds.push(item);
            }
            if (data["bankAccountIds"] && data["bankAccountIds"].constructor === Array) {
                this.bankAccountIds = [];
                for (let item of data["bankAccountIds"])
                    this.bankAccountIds.push(item);
            }
            this.notificationData = data["notificationData"] ? SendReportNotificationInput.fromJS(data["notificationData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateInput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["period"] = this.period;
        data["currencyId"] = this.currencyId;
        if (this.businessEntityIds && this.businessEntityIds.constructor === Array) {
            data["businessEntityIds"] = [];
            for (let item of this.businessEntityIds)
                data["businessEntityIds"].push(item);
        }
        if (this.bankAccountIds && this.bankAccountIds.constructor === Array) {
            data["bankAccountIds"] = [];
            for (let item of this.bankAccountIds)
                data["bankAccountIds"].push(item);
        }
        data["notificationData"] = this.notificationData ? this.notificationData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGenerateInput {
    from: moment.Moment;
    to: moment.Moment;
    period: ReportPeriod;
    currencyId: string;
    businessEntityIds: number[] | undefined;
    bankAccountIds: number[] | undefined;
    notificationData: SendReportNotificationInput | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    moduleId!: ModuleType | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.moduleId = data["moduleId"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["moduleId"] = this.moduleId;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    moduleId: ModuleType | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export enum Permissions {
    None = "None", 
    Read = "Read", 
    Write = "Write", 
    All = "All", 
}

export class BankAccountUsers implements IBankAccountUsers {
    bankAccountId!: number | undefined;
    userIds!: number[] | undefined;

    constructor(data?: IBankAccountUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankAccountId = data["bankAccountId"];
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountUsers {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankAccountId"] = this.bankAccountId;
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data; 
    }
}

export interface IBankAccountUsers {
    bankAccountId: number | undefined;
    userIds: number[] | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    profileThumbnailId!: string | undefined;
    bankCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.profileThumbnailId = data["profileThumbnailId"];
            this.bankCode = data["bankCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["bankCode"] = this.bankCode;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    profileThumbnailId: string | undefined;
    bankCode: string | undefined;
    id: number | undefined;
}

export enum LayoutType {
    Default = "Default", 
    LendSpace = "LendSpace", 
    AdvicePeriod = "AdvicePeriod", 
    BankCode = "BankCode", 
}

export class FaviconDto implements IFaviconDto {
    name!: string | undefined;
    type!: string | undefined;
    relationship!: string | undefined;
    size!: string | undefined;

    constructor(data?: IFaviconDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
            this.relationship = data["relationship"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): FaviconDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaviconDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["relationship"] = this.relationship;
        data["size"] = this.size;
        return data; 
    }
}

export interface IFaviconDto {
    name: string | undefined;
    type: string | undefined;
    relationship: string | undefined;
    size: string | undefined;
}

export class TenantCustomizationInfoDto implements ITenantCustomizationInfoDto {
    siteTitle!: string | undefined;
    faviconBaseUrl!: string | undefined;
    favicons!: FaviconDto[] | undefined;

    constructor(data?: ITenantCustomizationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.siteTitle = data["siteTitle"];
            this.faviconBaseUrl = data["faviconBaseUrl"];
            if (data["favicons"] && data["favicons"].constructor === Array) {
                this.favicons = [];
                for (let item of data["favicons"])
                    this.favicons.push(FaviconDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantCustomizationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCustomizationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteTitle"] = this.siteTitle;
        data["faviconBaseUrl"] = this.faviconBaseUrl;
        if (this.favicons && this.favicons.constructor === Array) {
            data["favicons"] = [];
            for (let item of this.favicons)
                data["favicons"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantCustomizationInfoDto {
    siteTitle: string | undefined;
    faviconBaseUrl: string | undefined;
    favicons: FaviconDto[] | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    customToSDocumentId!: string | undefined;
    customPrivacyPolicyDocumentId!: string | undefined;
    customLayoutType!: LayoutType | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    creationTimeString!: string | undefined;
    tenantCustomizations!: TenantCustomizationInfoDto | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.customToSDocumentId = data["customToSDocumentId"];
            this.customPrivacyPolicyDocumentId = data["customPrivacyPolicyDocumentId"];
            this.customLayoutType = data["customLayoutType"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.creationTimeString = data["creationTimeString"];
            this.tenantCustomizations = data["tenantCustomizations"] ? TenantCustomizationInfoDto.fromJS(data["tenantCustomizations"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["customToSDocumentId"] = this.customToSDocumentId;
        data["customPrivacyPolicyDocumentId"] = this.customPrivacyPolicyDocumentId;
        data["customLayoutType"] = this.customLayoutType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["creationTimeString"] = this.creationTimeString;
        data["tenantCustomizations"] = this.tenantCustomizations ? this.tenantCustomizations.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    customToSDocumentId: string | undefined;
    customPrivacyPolicyDocumentId: string | undefined;
    customLayoutType: LayoutType | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    creationTimeString: string | undefined;
    tenantCustomizations: TenantCustomizationInfoDto | undefined;
    id: number | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value!: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    features!: { [key: string] : AbpStringValueDto; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key] ? AbpStringValueDto.fromJS(data["features"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : AbpStringValueDto; } | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class AuthTestOutput implements IAuthTestOutput {
    tenantName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IAuthTestOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): AuthTestOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTestOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IAuthTestOutput {
    tenantName: string | undefined;
    userName: string | undefined;
}

export class CreateStageInput implements ICreateStageInput {
    pipelineId!: number;
    name!: string;
    sortOrder!: number;

    constructor(data?: ICreateStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelineId = data["pipelineId"];
            this.name = data["name"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): CreateStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICreateStageInput {
    pipelineId: number;
    name: string;
    sortOrder: number;
}

export class RenameStageInput implements IRenameStageInput {
    id!: number;
    name!: string;

    constructor(data?: IRenameStageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RenameStageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameStageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRenameStageInput {
    id: number;
    name: string;
}

export class MergeStagesInput implements IMergeStagesInput {
    pipelineId!: number;
    sourceStageId!: number;
    destinationStageId!: number | undefined;

    constructor(data?: IMergeStagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pipelineId = data["pipelineId"];
            this.sourceStageId = data["sourceStageId"];
            this.destinationStageId = data["destinationStageId"];
        }
    }

    static fromJS(data: any): MergeStagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new MergeStagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pipelineId"] = this.pipelineId;
        data["sourceStageId"] = this.sourceStageId;
        data["destinationStageId"] = this.destinationStageId;
        return data; 
    }
}

export interface IMergeStagesInput {
    pipelineId: number;
    sourceStageId: number;
    destinationStageId: number | undefined;
}

export class UpdateSortOrderInput implements IUpdateSortOrderInput {
    id!: number;
    sortOrder!: number;

    constructor(data?: IUpdateSortOrderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
        }
    }

    static fromJS(data: any): UpdateSortOrderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSortOrderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface IUpdateSortOrderInput {
    id: number;
    sortOrder: number;
}

export class GetSetupAccountsLinkOutput implements IGetSetupAccountsLinkOutput {
    setupAccountsLink!: string | undefined;

    constructor(data?: IGetSetupAccountsLinkOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setupAccountsLink = data["setupAccountsLink"];
        }
    }

    static fromJS(data: any): GetSetupAccountsLinkOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSetupAccountsLinkOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setupAccountsLink"] = this.setupAccountsLink;
        return data; 
    }
}

export interface IGetSetupAccountsLinkOutput {
    setupAccountsLink: string | undefined;
}

export class SyncProgressDto implements ISyncProgressDto {
    accountId!: number | undefined;
    accountName!: string | undefined;
    syncStatusMessage!: string | undefined;
    progressPercent!: number | undefined;
    syncStatus!: SyncProgressStatus | undefined;
    lastSyncDate!: moment.Moment | undefined;

    constructor(data?: ISyncProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.syncStatusMessage = data["syncStatusMessage"];
            this.progressPercent = data["progressPercent"];
            this.syncStatus = data["syncStatus"];
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SyncProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["syncStatusMessage"] = this.syncStatusMessage;
        data["progressPercent"] = this.progressPercent;
        data["syncStatus"] = this.syncStatus;
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISyncProgressDto {
    accountId: number | undefined;
    accountName: string | undefined;
    syncStatusMessage: string | undefined;
    progressPercent: number | undefined;
    syncStatus: SyncProgressStatus | undefined;
    lastSyncDate: moment.Moment | undefined;
}

export class SyncProgressOutput implements ISyncProgressOutput {
    lastSyncDate!: moment.Moment | undefined;
    totalProgress!: SyncProgressDto | undefined;
    accountProgresses!: SyncProgressDto[] | undefined;

    constructor(data?: ISyncProgressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastSyncDate = data["lastSyncDate"] ? moment(data["lastSyncDate"].toString()) : <any>undefined;
            this.totalProgress = data["totalProgress"] ? SyncProgressDto.fromJS(data["totalProgress"]) : <any>undefined;
            if (data["accountProgresses"] && data["accountProgresses"].constructor === Array) {
                this.accountProgresses = [];
                for (let item of data["accountProgresses"])
                    this.accountProgresses.push(SyncProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncProgressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SyncProgressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastSyncDate"] = this.lastSyncDate ? this.lastSyncDate.toISOString() : <any>undefined;
        data["totalProgress"] = this.totalProgress ? this.totalProgress.toJSON() : <any>undefined;
        if (this.accountProgresses && this.accountProgresses.constructor === Array) {
            data["accountProgresses"] = [];
            for (let item of this.accountProgresses)
                data["accountProgresses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISyncProgressOutput {
    lastSyncDate: moment.Moment | undefined;
    totalProgress: SyncProgressDto | undefined;
    accountProgresses: SyncProgressDto[] | undefined;
}

export class SyncAccountDto implements ISyncAccountDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: ISyncAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SyncAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new SyncAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISyncAccountDto {
    id: number | undefined;
    name: string | undefined;
}

export class CreateSyncAccountInput implements ICreateSyncAccountInput {
    typeId!: string;
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;
    isSyncBankAccountsEnabled!: boolean | undefined;

    constructor(data?: ICreateSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.consumerKey = data["consumerKey"];
            this.consumerSecret = data["consumerSecret"];
            this.isSyncBankAccountsEnabled = data["isSyncBankAccountsEnabled"];
        }
    }

    static fromJS(data: any): CreateSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        data["isSyncBankAccountsEnabled"] = this.isSyncBankAccountsEnabled;
        return data; 
    }
}

export interface ICreateSyncAccountInput {
    typeId: string;
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
    isSyncBankAccountsEnabled: boolean | undefined;
}

export class UpdateSyncAccountInput implements IUpdateSyncAccountInput {
    id!: number | undefined;
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: IUpdateSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.consumerKey = data["consumerKey"];
            this.consumerSecret = data["consumerSecret"];
        }
    }

    static fromJS(data: any): UpdateSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data; 
    }
}

export interface IUpdateSyncAccountInput {
    id: number | undefined;
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class RenameSyncAccountInput implements IRenameSyncAccountInput {
    id!: number;
    newName!: string;

    constructor(data?: IRenameSyncAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): RenameSyncAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameSyncAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IRenameSyncAccountInput {
    id: number;
    newName: string;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    hasOwnDatabase!: boolean | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.hasOwnDatabase = data["hasOwnDatabase"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["hasOwnDatabase"] = this.hasOwnDatabase;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    hasOwnDatabase: boolean | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class TenantListDtoPagedResultDto implements ITenantListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: ITenantListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantListDtoPagedResultDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantEditEditionDto implements ITenantEditEditionDto {
    editionId!: number;
    maxUserCount!: number | undefined;

    constructor(data?: ITenantEditEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
        }
    }

    static fromJS(data: any): TenantEditEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        return data; 
    }
}

export interface ITenantEditEditionDto {
    editionId: number;
    maxUserCount: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    crmConnectionString!: string | undefined;
    memberDbConnectionString!: string | undefined;
    cfoConnectionString!: string | undefined;
    editions!: TenantEditEditionDto[] | undefined;
    isActive!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.crmConnectionString = data["crmConnectionString"];
            this.memberDbConnectionString = data["memberDbConnectionString"];
            this.cfoConnectionString = data["cfoConnectionString"];
            if (data["editions"] && data["editions"].constructor === Array) {
                this.editions = [];
                for (let item of data["editions"])
                    this.editions.push(TenantEditEditionDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["crmConnectionString"] = this.crmConnectionString;
        data["memberDbConnectionString"] = this.memberDbConnectionString;
        data["cfoConnectionString"] = this.cfoConnectionString;
        if (this.editions && this.editions.constructor === Array) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    crmConnectionString: string | undefined;
    memberDbConnectionString: string | undefined;
    cfoConnectionString: string | undefined;
    editions: TenantEditEditionDto[] | undefined;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class TenantAppHostOutput implements ITenantAppHostOutput {
    appHostName!: string | undefined;

    constructor(data?: ITenantAppHostOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appHostName = data["appHostName"];
        }
    }

    static fromJS(data: any): TenantAppHostOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppHostOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appHostName"] = this.appHostName;
        return data; 
    }
}

export interface ITenantAppHostOutput {
    appHostName: string | undefined;
}

export enum TenantHostType {
    PlatformApp = "PlatformApp", 
}

export class CheckHostNameDnsMappingInput implements ICheckHostNameDnsMappingInput {
    tenantHostType!: TenantHostType | undefined;
    hostName!: string | undefined;

    constructor(data?: ICheckHostNameDnsMappingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.hostName = data["hostName"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["hostName"] = this.hostName;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingInput {
    tenantHostType: TenantHostType | undefined;
    hostName: string | undefined;
}

export class CheckHostNameDnsMappingOutput implements ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped!: boolean | undefined;

    constructor(data?: ICheckHostNameDnsMappingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hostNameDnsMapped = data["hostNameDnsMapped"];
        }
    }

    static fromJS(data: any): CheckHostNameDnsMappingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckHostNameDnsMappingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostNameDnsMapped"] = this.hostNameDnsMapped;
        return data; 
    }
}

export interface ICheckHostNameDnsMappingOutput {
    hostNameDnsMapped: boolean | undefined;
}

export class TenantSslBindingInfo implements ITenantSslBindingInfo {
    id!: number | undefined;
    hostName!: string | undefined;
    hostType!: TenantHostType | undefined;
    isActive!: boolean | undefined;
    sslCertificateId!: number | undefined;
    sslCertificateExpiration!: moment.Moment | undefined;
    sslCertificateThumbprint!: string | undefined;

    constructor(data?: ITenantSslBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostName = data["hostName"];
            this.hostType = data["hostType"];
            this.isActive = data["isActive"];
            this.sslCertificateId = data["sslCertificateId"];
            this.sslCertificateExpiration = data["sslCertificateExpiration"] ? moment(data["sslCertificateExpiration"].toString()) : <any>undefined;
            this.sslCertificateThumbprint = data["sslCertificateThumbprint"];
        }
    }

    static fromJS(data: any): TenantSslBindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslBindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostName"] = this.hostName;
        data["hostType"] = this.hostType;
        data["isActive"] = this.isActive;
        data["sslCertificateId"] = this.sslCertificateId;
        data["sslCertificateExpiration"] = this.sslCertificateExpiration ? this.sslCertificateExpiration.toISOString() : <any>undefined;
        data["sslCertificateThumbprint"] = this.sslCertificateThumbprint;
        return data; 
    }
}

export interface ITenantSslBindingInfo {
    id: number | undefined;
    hostName: string | undefined;
    hostType: TenantHostType | undefined;
    isActive: boolean | undefined;
    sslCertificateId: number | undefined;
    sslCertificateExpiration: moment.Moment | undefined;
    sslCertificateThumbprint: string | undefined;
}

export class AddSslBindingInput implements IAddSslBindingInput {
    tenantHostType!: TenantHostType;
    domainName!: string | undefined;
    sslCertificateId!: number | undefined;

    constructor(data?: IAddSslBindingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.domainName = data["domainName"];
            this.sslCertificateId = data["sslCertificateId"];
        }
    }

    static fromJS(data: any): AddSslBindingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSslBindingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["domainName"] = this.domainName;
        data["sslCertificateId"] = this.sslCertificateId;
        return data; 
    }
}

export interface IAddSslBindingInput {
    tenantHostType: TenantHostType;
    domainName: string | undefined;
    sslCertificateId: number | undefined;
}

export class UpdateSslBindingCertificateInput implements IUpdateSslBindingCertificateInput {
    tenantHostType!: TenantHostType;
    sslCertificateId!: number | undefined;

    constructor(data?: IUpdateSslBindingCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.sslCertificateId = data["sslCertificateId"];
        }
    }

    static fromJS(data: any): UpdateSslBindingCertificateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSslBindingCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["sslCertificateId"] = this.sslCertificateId;
        return data; 
    }
}

export interface IUpdateSslBindingCertificateInput {
    tenantHostType: TenantHostType;
    sslCertificateId: number | undefined;
}

export class UpdateSslBindingIsActiveInput implements IUpdateSslBindingIsActiveInput {
    tenantHostType!: TenantHostType;
    isActive!: boolean;

    constructor(data?: IUpdateSslBindingIsActiveInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantHostType = data["tenantHostType"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateSslBindingIsActiveInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSslBindingIsActiveInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantHostType"] = this.tenantHostType;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateSslBindingIsActiveInput {
    tenantHostType: TenantHostType;
    isActive: boolean;
}

export class IntegrationsSettings implements IIntegrationsSettings {
    googleMapsJavascriptApiKey!: string;

    constructor(data?: IIntegrationsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.googleMapsJavascriptApiKey = data["googleMapsJavascriptApiKey"];
        }
    }

    static fromJS(data: any): IntegrationsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleMapsJavascriptApiKey"] = this.googleMapsJavascriptApiKey;
        return data; 
    }
}

export interface IIntegrationsSettings {
    googleMapsJavascriptApiKey: string;
}

export class EPCVIPOfferProviderSettings implements IEPCVIPOfferProviderSettings {
    apiKey!: string | undefined;
    postbackPassCode!: string | undefined;

    constructor(data?: IEPCVIPOfferProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.postbackPassCode = data["postbackPassCode"];
        }
    }

    static fromJS(data: any): EPCVIPOfferProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPOfferProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["postbackPassCode"] = this.postbackPassCode;
        return data; 
    }
}

export interface IEPCVIPOfferProviderSettings {
    apiKey: string | undefined;
    postbackPassCode: string | undefined;
}

export class BaseCommercePaymentSettings implements IBaseCommercePaymentSettings {
    userName!: string | undefined;
    password!: string | undefined;
    key!: string | undefined;
    sandBox!: boolean | undefined;

    constructor(data?: IBaseCommercePaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.key = data["key"];
            this.sandBox = data["sandBox"];
        }
    }

    static fromJS(data: any): BaseCommercePaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BaseCommercePaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["key"] = this.key;
        data["sandBox"] = this.sandBox;
        return data; 
    }
}

export interface IBaseCommercePaymentSettings {
    userName: string | undefined;
    password: string | undefined;
    key: string | undefined;
    sandBox: boolean | undefined;
}

export class ACHWorksSettings implements IACHWorksSettings {
    sss!: string | undefined;
    locID!: string | undefined;
    soapUser!: string | undefined;
    soapKey!: string | undefined;

    constructor(data?: IACHWorksSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sss = data["sss"];
            this.locID = data["locID"];
            this.soapUser = data["soapUser"];
            this.soapKey = data["soapKey"];
        }
    }

    static fromJS(data: any): ACHWorksSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ACHWorksSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sss"] = this.sss;
        data["locID"] = this.locID;
        data["soapUser"] = this.soapUser;
        data["soapKey"] = this.soapKey;
        return data; 
    }
}

export interface IACHWorksSettings {
    sss: string | undefined;
    locID: string | undefined;
    soapUser: string | undefined;
    soapKey: string | undefined;
}

export class RecurlyPaymentSettings implements IRecurlyPaymentSettings {
    apiKey!: string | undefined;
    subdomain!: string | undefined;
    privateKey!: string | undefined;
    pageSize!: number | undefined;

    constructor(data?: IRecurlyPaymentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.subdomain = data["subdomain"];
            this.privateKey = data["privateKey"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): RecurlyPaymentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new RecurlyPaymentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["subdomain"] = this.subdomain;
        data["privateKey"] = this.privateKey;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IRecurlyPaymentSettings {
    apiKey: string | undefined;
    subdomain: string | undefined;
    privateKey: string | undefined;
    pageSize: number | undefined;
}

export class PayPalSettings implements IPayPalSettings {
    environment!: string | undefined;
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IPayPalSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.environment = data["environment"];
            this.clientId = data["clientId"];
            this.clientSecret = data["clientSecret"];
        }
    }

    static fromJS(data: any): PayPalSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["environment"] = this.environment;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data; 
    }
}

export interface IPayPalSettings {
    environment: string | undefined;
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class BeneficiaryInfo implements IBeneficiaryInfo {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.streetAddress = data["streetAddress"];
            this.cityAddress = data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data; 
    }
}

export interface IBeneficiaryInfo {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BankTransferSettings implements IBankTransferSettings {
    beneficiaryInfo!: BeneficiaryInfo | undefined;
    beneficiaryBank!: BeneficiaryInfo | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beneficiaryInfo = data["beneficiaryInfo"] ? BeneficiaryInfo.fromJS(data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = data["beneficiaryBank"] ? BeneficiaryInfo.fromJS(data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankRoutingNumberForACH = data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = data["swiftCodeForUSDollar"];
            this.swiftCode = data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettings {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankTransferSettings {
    beneficiaryInfo: BeneficiaryInfo | undefined;
    beneficiaryBank: BeneficiaryInfo | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
}

export enum EPCVIPServer {
    AmazonSES = "AmazonSES", 
    Mailgun = "Mailgun", 
    SendGrid = "SendGrid", 
    SparkPost = "SparkPost", 
}

export class EPCVIPMailerSettingsEditDto implements IEPCVIPMailerSettingsEditDto {
    baseUrl!: string | undefined;
    apiKey!: string | undefined;
    server!: EPCVIPServer | undefined;

    constructor(data?: IEPCVIPMailerSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseUrl = data["baseUrl"];
            this.apiKey = data["apiKey"];
            this.server = data["server"];
        }
    }

    static fromJS(data: any): EPCVIPMailerSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EPCVIPMailerSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["apiKey"] = this.apiKey;
        data["server"] = this.server;
        return data; 
    }
}

export interface IEPCVIPMailerSettingsEditDto {
    baseUrl: string | undefined;
    apiKey: string | undefined;
    server: EPCVIPServer | undefined;
}

export class OngageSettingsEditDto implements IOngageSettingsEditDto {
    userName!: string | undefined;
    password!: string | undefined;
    accountCode!: string | undefined;
    defaultListId!: number | undefined;
    activationEmailMessageId!: number | undefined;
    isEnabled!: boolean | undefined;
    offerAnnouncementCampaignId!: string | undefined;

    constructor(data?: IOngageSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.accountCode = data["accountCode"];
            this.defaultListId = data["defaultListId"];
            this.activationEmailMessageId = data["activationEmailMessageId"];
            this.isEnabled = data["isEnabled"];
            this.offerAnnouncementCampaignId = data["offerAnnouncementCampaignId"];
        }
    }

    static fromJS(data: any): OngageSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OngageSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["accountCode"] = this.accountCode;
        data["defaultListId"] = this.defaultListId;
        data["activationEmailMessageId"] = this.activationEmailMessageId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementCampaignId"] = this.offerAnnouncementCampaignId;
        return data; 
    }
}

export interface IOngageSettingsEditDto {
    userName: string | undefined;
    password: string | undefined;
    accountCode: string | undefined;
    defaultListId: number | undefined;
    activationEmailMessageId: number | undefined;
    isEnabled: boolean | undefined;
    offerAnnouncementCampaignId: string | undefined;
}

export class IAgeSettingsEditDto implements IIAgeSettingsEditDto {
    apiKey!: string | undefined;
    activationEmailId!: number | undefined;
    passwordResetEmailId!: number | undefined;
    isEnabled!: boolean | undefined;
    offerAnnouncementEmailId!: number | undefined;

    constructor(data?: IIAgeSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apiKey = data["apiKey"];
            this.activationEmailId = data["activationEmailId"];
            this.passwordResetEmailId = data["passwordResetEmailId"];
            this.isEnabled = data["isEnabled"];
            this.offerAnnouncementEmailId = data["offerAnnouncementEmailId"];
        }
    }

    static fromJS(data: any): IAgeSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new IAgeSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["activationEmailId"] = this.activationEmailId;
        data["passwordResetEmailId"] = this.passwordResetEmailId;
        data["isEnabled"] = this.isEnabled;
        data["offerAnnouncementEmailId"] = this.offerAnnouncementEmailId;
        return data; 
    }
}

export interface IIAgeSettingsEditDto {
    apiKey: string | undefined;
    activationEmailId: number | undefined;
    passwordResetEmailId: number | undefined;
    isEnabled: boolean | undefined;
    offerAnnouncementEmailId: number | undefined;
}

export class IdcsSettings implements IIdcsSettings {
    requestSource!: string | undefined;
    partnerCode!: string | undefined;
    partnerAccount!: string | undefined;
    password!: string | undefined;
    branding!: string | undefined;

    constructor(data?: IIdcsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestSource = data["requestSource"];
            this.partnerCode = data["partnerCode"];
            this.partnerAccount = data["partnerAccount"];
            this.password = data["password"];
            this.branding = data["branding"];
        }
    }

    static fromJS(data: any): IdcsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new IdcsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestSource"] = this.requestSource;
        data["partnerCode"] = this.partnerCode;
        data["partnerAccount"] = this.partnerAccount;
        data["password"] = this.password;
        data["branding"] = this.branding;
        return data; 
    }
}

export interface IIdcsSettings {
    requestSource: string | undefined;
    partnerCode: string | undefined;
    partnerAccount: string | undefined;
    password: string | undefined;
    branding: string | undefined;
}

export class TenantSslCertificateInfo implements ITenantSslCertificateInfo {
    id!: number | undefined;
    hostNames!: string | undefined;
    expiration!: moment.Moment | undefined;
    thumbprint!: string | undefined;

    constructor(data?: ITenantSslCertificateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hostNames = data["hostNames"];
            this.expiration = data["expiration"] ? moment(data["expiration"].toString()) : <any>undefined;
            this.thumbprint = data["thumbprint"];
        }
    }

    static fromJS(data: any): TenantSslCertificateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSslCertificateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostNames"] = this.hostNames;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["thumbprint"] = this.thumbprint;
        return data; 
    }
}

export interface ITenantSslCertificateInfo {
    id: number | undefined;
    hostNames: string | undefined;
    expiration: moment.Moment | undefined;
    thumbprint: string | undefined;
}

export class AddTenantSslCertificateInput implements IAddTenantSslCertificateInput {
    base64EncodedCertificate!: string;
    password!: string | undefined;

    constructor(data?: IAddTenantSslCertificateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base64EncodedCertificate = data["base64EncodedCertificate"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): AddTenantSslCertificateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddTenantSslCertificateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64EncodedCertificate"] = this.base64EncodedCertificate;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAddTenantSslCertificateInput {
    base64EncodedCertificate: string;
    password: string | undefined;
}

export enum PaymentMethod {
    Recurring = "Recurring", 
    Charge = "Charge", 
    Capture = "Capture", 
    Void = "Void", 
    Manual = "Manual", 
}

export class BankCardInfoDto implements IBankCardInfoDto {
    holderName!: string | undefined;
    cardNumber!: string | undefined;
    expirationMonth!: string | undefined;
    expirationYear!: string | undefined;
    cvv!: string | undefined;
    billingAddress!: string | undefined;
    billingZip!: string | undefined;
    billingCity!: string | undefined;
    billingStateCode!: string | undefined;
    billingState!: string | undefined;
    billingCountryCode!: string | undefined;
    billingCountry!: string | undefined;

    constructor(data?: IBankCardInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.holderName = data["holderName"];
            this.cardNumber = data["cardNumber"];
            this.expirationMonth = data["expirationMonth"];
            this.expirationYear = data["expirationYear"];
            this.cvv = data["cvv"];
            this.billingAddress = data["billingAddress"];
            this.billingZip = data["billingZip"];
            this.billingCity = data["billingCity"];
            this.billingStateCode = data["billingStateCode"];
            this.billingState = data["billingState"];
            this.billingCountryCode = data["billingCountryCode"];
            this.billingCountry = data["billingCountry"];
        }
    }

    static fromJS(data: any): BankCardInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holderName"] = this.holderName;
        data["cardNumber"] = this.cardNumber;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["cvv"] = this.cvv;
        data["billingAddress"] = this.billingAddress;
        data["billingZip"] = this.billingZip;
        data["billingCity"] = this.billingCity;
        data["billingStateCode"] = this.billingStateCode;
        data["billingState"] = this.billingState;
        data["billingCountryCode"] = this.billingCountryCode;
        data["billingCountry"] = this.billingCountry;
        return data; 
    }
}

export interface IBankCardInfoDto {
    holderName: string | undefined;
    cardNumber: string | undefined;
    expirationMonth: string | undefined;
    expirationYear: string | undefined;
    cvv: string | undefined;
    billingAddress: string | undefined;
    billingZip: string | undefined;
    billingCity: string | undefined;
    billingStateCode: string | undefined;
    billingState: string | undefined;
    billingCountryCode: string | undefined;
    billingCountry: string | undefined;
}

export class ACHCustomerInfoDto implements IACHCustomerInfoDto {
    customerRoutingNo!: string | undefined;
    customerAcctNo!: string | undefined;

    constructor(data?: IACHCustomerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerRoutingNo = data["customerRoutingNo"];
            this.customerAcctNo = data["customerAcctNo"];
        }
    }

    static fromJS(data: any): ACHCustomerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ACHCustomerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerRoutingNo"] = this.customerRoutingNo;
        data["customerAcctNo"] = this.customerAcctNo;
        return data; 
    }
}

export interface IACHCustomerInfoDto {
    customerRoutingNo: string | undefined;
    customerAcctNo: string | undefined;
}

export class PayPalInfoDto implements IPayPalInfoDto {
    paymentId!: string | undefined;
    payerId!: string | undefined;

    constructor(data?: IPayPalInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
        }
    }

    static fromJS(data: any): PayPalInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        return data; 
    }
}

export interface IPayPalInfoDto {
    paymentId: string | undefined;
    payerId: string | undefined;
}

export class PaymentRequestInfoDto implements IPaymentRequestInfoDto {
    paymentMethod!: PaymentMethod | undefined;
    paymentInfoType!: PaymentInfoType | undefined;
    bankCard!: BankCardInfoDto | undefined;
    achCustomer!: ACHCustomerInfoDto | undefined;
    payPal!: PayPalInfoDto | undefined;

    constructor(data?: IPaymentRequestInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentMethod = data["paymentMethod"];
            this.paymentInfoType = data["paymentInfoType"];
            this.bankCard = data["bankCard"] ? BankCardInfoDto.fromJS(data["bankCard"]) : <any>undefined;
            this.achCustomer = data["achCustomer"] ? ACHCustomerInfoDto.fromJS(data["achCustomer"]) : <any>undefined;
            this.payPal = data["payPal"] ? PayPalInfoDto.fromJS(data["payPal"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRequestInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod;
        data["paymentInfoType"] = this.paymentInfoType;
        data["bankCard"] = this.bankCard ? this.bankCard.toJSON() : <any>undefined;
        data["achCustomer"] = this.achCustomer ? this.achCustomer.toJSON() : <any>undefined;
        data["payPal"] = this.payPal ? this.payPal.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPaymentRequestInfoDto {
    paymentMethod: PaymentMethod | undefined;
    paymentInfoType: PaymentInfoType | undefined;
    bankCard: BankCardInfoDto | undefined;
    achCustomer: ACHCustomerInfoDto | undefined;
    payPal: PayPalInfoDto | undefined;
}

export class ModuleSubscriptionInfo implements IModuleSubscriptionInfo {
    editionId!: number;
    maxUserCount!: number | undefined;
    frequency!: PaymentPeriodType;

    constructor(data?: IModuleSubscriptionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.maxUserCount = data["maxUserCount"];
            this.frequency = data["frequency"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["maxUserCount"] = this.maxUserCount;
        data["frequency"] = this.frequency;
        return data; 
    }
}

export interface IModuleSubscriptionInfo {
    editionId: number;
    maxUserCount: number | undefined;
    frequency: PaymentPeriodType;
}

export class SetupSubscriptionInfoDto implements ISetupSubscriptionInfoDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    billingInfo!: PaymentRequestInfoDto | undefined;

    constructor(data?: ISetupSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionInfo = data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(data["subscriptionInfo"]) : <any>undefined;
            this.billingInfo = data["billingInfo"] ? PaymentRequestInfoDto.fromJS(data["billingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetupSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetupSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["billingInfo"] = this.billingInfo ? this.billingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetupSubscriptionInfoDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    billingInfo: PaymentRequestInfoDto | undefined;
}

export enum RequestPaymentType {
    PayPal = "PayPal", 
    ManualBankTransfer = "ManualBankTransfer", 
}

export class RequestPaymentDto implements IRequestPaymentDto {
    subscriptionInfo!: ModuleSubscriptionInfo | undefined;
    requestType!: RequestPaymentType | undefined;

    constructor(data?: IRequestPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionInfo = data["subscriptionInfo"] ? ModuleSubscriptionInfo.fromJS(data["subscriptionInfo"]) : <any>undefined;
            this.requestType = data["requestType"];
        }
    }

    static fromJS(data: any): RequestPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionInfo"] = this.subscriptionInfo ? this.subscriptionInfo.toJSON() : <any>undefined;
        data["requestType"] = this.requestType;
        return data; 
    }
}

export interface IRequestPaymentDto {
    subscriptionInfo: ModuleSubscriptionInfo | undefined;
    requestType: RequestPaymentType | undefined;
}

export class RequestPaymentResult implements IRequestPaymentResult {
    transactionId!: string | undefined;
    code!: string | undefined;

    constructor(data?: IRequestPaymentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionId = data["transactionId"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): RequestPaymentResult {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPaymentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["code"] = this.code;
        return data; 
    }
}

export interface IRequestPaymentResult {
    transactionId: string | undefined;
    code: string | undefined;
}

export class ModuleSubscriptionInfoDto implements IModuleSubscriptionInfoDto {
    module!: ModuleType | undefined;
    endDate!: moment.Moment | undefined;
    editionName!: string | undefined;
    isTrial!: boolean | undefined;
    isLocked!: boolean | undefined;
    trackingCode!: string | undefined;
    hasRecurringBilling!: boolean | undefined;
    isUpgradable!: boolean | undefined;

    constructor(data?: IModuleSubscriptionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.module = data["module"];
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.editionName = data["editionName"];
            this.isTrial = data["isTrial"];
            this.isLocked = data["isLocked"];
            this.trackingCode = data["trackingCode"];
            this.hasRecurringBilling = data["hasRecurringBilling"];
            this.isUpgradable = data["isUpgradable"];
        }
    }

    static fromJS(data: any): ModuleSubscriptionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleSubscriptionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["editionName"] = this.editionName;
        data["isTrial"] = this.isTrial;
        data["isLocked"] = this.isLocked;
        data["trackingCode"] = this.trackingCode;
        data["hasRecurringBilling"] = this.hasRecurringBilling;
        data["isUpgradable"] = this.isUpgradable;
        return data; 
    }
}

export interface IModuleSubscriptionInfoDto {
    module: ModuleType | undefined;
    endDate: moment.Moment | undefined;
    editionName: string | undefined;
    isTrial: boolean | undefined;
    isLocked: boolean | undefined;
    trackingCode: string | undefined;
    hasRecurringBilling: boolean | undefined;
    isUpgradable: boolean | undefined;
}

export class CompleteTenantRegistrationInput implements ICompleteTenantRegistrationInput {
    requestXref!: string;
    tenancyName!: string | undefined;
    tenantName!: string | undefined;
    companyName!: string | undefined;
    siteUrl!: string | undefined;
    adminPassword!: string;

    constructor(data?: ICompleteTenantRegistrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestXref = data["requestXref"];
            this.tenancyName = data["tenancyName"];
            this.tenantName = data["tenantName"];
            this.companyName = data["companyName"];
            this.siteUrl = data["siteUrl"];
            this.adminPassword = data["adminPassword"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestXref"] = this.requestXref;
        data["tenancyName"] = this.tenancyName;
        data["tenantName"] = this.tenantName;
        data["companyName"] = this.companyName;
        data["siteUrl"] = this.siteUrl;
        data["adminPassword"] = this.adminPassword;
        return data; 
    }
}

export interface ICompleteTenantRegistrationInput {
    requestXref: string;
    tenancyName: string | undefined;
    tenantName: string | undefined;
    companyName: string | undefined;
    siteUrl: string | undefined;
    adminPassword: string;
}

export class CompleteTenantRegistrationOutput implements ICompleteTenantRegistrationOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isEmailConfirmationRequired!: boolean | undefined;
    loginLink!: string | undefined;

    constructor(data?: ICompleteTenantRegistrationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
            this.loginLink = data["loginLink"];
        }
    }

    static fromJS(data: any): CompleteTenantRegistrationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTenantRegistrationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        data["loginLink"] = this.loginLink;
        return data; 
    }
}

export interface ICompleteTenantRegistrationOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isEmailConfirmationRequired: boolean | undefined;
    loginLink: string | undefined;
}

export class BeneficiaryInfoDto implements IBeneficiaryInfoDto {
    name!: string | undefined;
    streetAddress!: string | undefined;
    cityAddress!: string | undefined;

    constructor(data?: IBeneficiaryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.streetAddress = data["streetAddress"];
            this.cityAddress = data["cityAddress"];
        }
    }

    static fromJS(data: any): BeneficiaryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BeneficiaryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["streetAddress"] = this.streetAddress;
        data["cityAddress"] = this.cityAddress;
        return data; 
    }
}

export interface IBeneficiaryInfoDto {
    name: string | undefined;
    streetAddress: string | undefined;
    cityAddress: string | undefined;
}

export class BankTransferSettingsDto implements IBankTransferSettingsDto {
    beneficiaryInfo!: BeneficiaryInfoDto | undefined;
    beneficiaryBank!: BeneficiaryInfoDto | undefined;
    bankAccountNumber!: string | undefined;
    bankRoutingNumberForACH!: string | undefined;
    bankRoutingNumber!: string | undefined;
    swiftCodeForUSDollar!: string | undefined;
    swiftCode!: string | undefined;

    constructor(data?: IBankTransferSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.beneficiaryInfo = data["beneficiaryInfo"] ? BeneficiaryInfoDto.fromJS(data["beneficiaryInfo"]) : <any>undefined;
            this.beneficiaryBank = data["beneficiaryBank"] ? BeneficiaryInfoDto.fromJS(data["beneficiaryBank"]) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankRoutingNumberForACH = data["bankRoutingNumberForACH"];
            this.bankRoutingNumber = data["bankRoutingNumber"];
            this.swiftCodeForUSDollar = data["swiftCodeForUSDollar"];
            this.swiftCode = data["swiftCode"];
        }
    }

    static fromJS(data: any): BankTransferSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransferSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beneficiaryInfo"] = this.beneficiaryInfo ? this.beneficiaryInfo.toJSON() : <any>undefined;
        data["beneficiaryBank"] = this.beneficiaryBank ? this.beneficiaryBank.toJSON() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankRoutingNumberForACH"] = this.bankRoutingNumberForACH;
        data["bankRoutingNumber"] = this.bankRoutingNumber;
        data["swiftCodeForUSDollar"] = this.swiftCodeForUSDollar;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankTransferSettingsDto {
    beneficiaryInfo: BeneficiaryInfoDto | undefined;
    beneficiaryBank: BeneficiaryInfoDto | undefined;
    bankAccountNumber: string | undefined;
    bankRoutingNumberForACH: string | undefined;
    bankRoutingNumber: string | undefined;
    swiftCodeForUSDollar: string | undefined;
    swiftCode: string | undefined;
}

export class PayPalSettingsDto implements IPayPalSettingsDto {
    clientId!: string | undefined;

    constructor(data?: IPayPalSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): PayPalSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        return data; 
    }
}

export interface IPayPalSettingsDto {
    clientId: string | undefined;
}

export enum SettingScopes {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export class NameValueDtoListResultDto implements INameValueDtoListResultDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: INameValueDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NameValueDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INameValueDtoListResultDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    autoDetectTenancy!: boolean | undefined;
    features!: string[] | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoDetectTenancy = false;
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.autoDetectTenancy = data["autoDetectTenancy"] !== undefined ? data["autoDetectTenancy"] : false;
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["autoDetectTenancy"] = this.autoDetectTenancy;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    autoDetectTenancy: boolean | undefined;
    features: string[] | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    userId!: number | undefined;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    userId: number | undefined;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {};
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;
    autoRegistration!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.autoRegistration = data["autoRegistration"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["autoRegistration"] = this.autoRegistration;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
    autoRegistration: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    waitingForActivation!: boolean | undefined;
    userNotFound!: boolean | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    email!: string | undefined;
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    detectedTenancies!: TenantModel[] | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waitingForActivation = data["waitingForActivation"];
            this.userNotFound = data["userNotFound"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            if (data["detectedTenancies"] && data["detectedTenancies"].constructor === Array) {
                this.detectedTenancies = [];
                for (let item of data["detectedTenancies"])
                    this.detectedTenancies.push(TenantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waitingForActivation"] = this.waitingForActivation;
        data["userNotFound"] = this.userNotFound;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        if (this.detectedTenancies && this.detectedTenancies.constructor === Array) {
            data["detectedTenancies"] = [];
            for (let item of this.detectedTenancies)
                data["detectedTenancies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    waitingForActivation: boolean | undefined;
    userNotFound: boolean | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    detectedTenancies: TenantModel[] | undefined;
}

export class StringFilterElementDto implements IStringFilterElementDto {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IStringFilterElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StringFilterElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringFilterElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IStringFilterElementDto {
    id: string | undefined;
    name: string | undefined;
}

export class Int32FilterElementDto implements IInt32FilterElementDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IInt32FilterElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Int32FilterElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32FilterElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt32FilterElementDto {
    id: number | undefined;
    name: string | undefined;
}

export class FiltersInitialData implements IFiltersInitialData {
    banks!: BankDto[] | undefined;
    cashflowTypes!: StringFilterElementDto[] | undefined;
    currencies!: StringFilterElementDto[] | undefined;
    businessEntities!: Int32FilterElementDto[] | undefined;

    constructor(data?: IFiltersInitialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["banks"] && data["banks"].constructor === Array) {
                this.banks = [];
                for (let item of data["banks"])
                    this.banks.push(BankDto.fromJS(item));
            }
            if (data["cashflowTypes"] && data["cashflowTypes"].constructor === Array) {
                this.cashflowTypes = [];
                for (let item of data["cashflowTypes"])
                    this.cashflowTypes.push(StringFilterElementDto.fromJS(item));
            }
            if (data["currencies"] && data["currencies"].constructor === Array) {
                this.currencies = [];
                for (let item of data["currencies"])
                    this.currencies.push(StringFilterElementDto.fromJS(item));
            }
            if (data["businessEntities"] && data["businessEntities"].constructor === Array) {
                this.businessEntities = [];
                for (let item of data["businessEntities"])
                    this.businessEntities.push(Int32FilterElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FiltersInitialData {
        data = typeof data === 'object' ? data : {};
        let result = new FiltersInitialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.banks && this.banks.constructor === Array) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        if (this.cashflowTypes && this.cashflowTypes.constructor === Array) {
            data["cashflowTypes"] = [];
            for (let item of this.cashflowTypes)
                data["cashflowTypes"].push(item.toJSON());
        }
        if (this.currencies && this.currencies.constructor === Array) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        if (this.businessEntities && this.businessEntities.constructor === Array) {
            data["businessEntities"] = [];
            for (let item of this.businessEntities)
                data["businessEntities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFiltersInitialData {
    banks: BankDto[] | undefined;
    cashflowTypes: StringFilterElementDto[] | undefined;
    currencies: StringFilterElementDto[] | undefined;
    businessEntities: Int32FilterElementDto[] | undefined;
}

export class TransactionAttributeTypeDto implements ITransactionAttributeTypeDto {
    name!: string | undefined;
    parserCode!: string | undefined;

    constructor(data?: ITransactionAttributeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parserCode = data["parserCode"];
        }
    }

    static fromJS(data: any): TransactionAttributeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAttributeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parserCode"] = this.parserCode;
        return data; 
    }
}

export interface ITransactionAttributeTypeDto {
    name: string | undefined;
    parserCode: string | undefined;
}

export class GetTransactionAttributeTypesOutput implements IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes!: { [key: string] : TransactionAttributeTypeDto; } | undefined;

    constructor(data?: IGetTransactionAttributeTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["transactionAttributeTypes"]) {
                this.transactionAttributeTypes = {};
                for (let key in data["transactionAttributeTypes"]) {
                    if (data["transactionAttributeTypes"].hasOwnProperty(key))
                        this.transactionAttributeTypes[key] = data["transactionAttributeTypes"][key] ? TransactionAttributeTypeDto.fromJS(data["transactionAttributeTypes"][key]) : new TransactionAttributeTypeDto();
                }
            }
        }
    }

    static fromJS(data: any): GetTransactionAttributeTypesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionAttributeTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.transactionAttributeTypes) {
            data["transactionAttributeTypes"] = {};
            for (let key in this.transactionAttributeTypes) {
                if (this.transactionAttributeTypes.hasOwnProperty(key))
                    data["transactionAttributeTypes"][key] = this.transactionAttributeTypes[key];
            }
        }
        return data; 
    }
}

export interface IGetTransactionAttributeTypesOutput {
    transactionAttributeTypes: { [key: string] : TransactionAttributeTypeDto; } | undefined;
}

export enum TransactionStatus {
    Pending = "Pending", 
    Settled = "Settled", 
}

export class TransactionCommentDto implements ITransactionCommentDto {
    commentId!: number | undefined;
    text!: string | undefined;

    constructor(data?: ITransactionCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commentId = data["commentId"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): TransactionCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commentId"] = this.commentId;
        data["text"] = this.text;
        return data; 
    }
}

export interface ITransactionCommentDto {
    commentId: number | undefined;
    text: string | undefined;
}

export class TransactionDetailsDto implements ITransactionDetailsDto {
    id!: number | undefined;
    bankAccountBankName!: string | undefined;
    bankAccountNumber!: string | undefined;
    bankAccountName!: string | undefined;
    date!: moment.Moment | undefined;
    currency!: string | undefined;
    amount!: number | undefined;
    description!: string | undefined;
    cashFlowTypeId!: string | undefined;
    transactionStatus!: TransactionStatus | undefined;
    cashflowCategoryId!: number | undefined;
    cashflowCategory!: string | undefined;
    cashflowSubCategoryId!: number | undefined;
    cashflowSubCategory!: string | undefined;
    accountingTypeId!: number | undefined;
    accountingType!: string | undefined;
    transactionDescriptor!: string | undefined;
    isDescriptorCalculated!: boolean | undefined;
    counterpartyName!: string | undefined;
    comments!: TransactionCommentDto[] | undefined;
    attributes!: TransactionAttributeDto[] | undefined;

    constructor(data?: ITransactionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bankAccountBankName = data["bankAccountBankName"];
            this.bankAccountNumber = data["bankAccountNumber"];
            this.bankAccountName = data["bankAccountName"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.amount = data["amount"];
            this.description = data["description"];
            this.cashFlowTypeId = data["cashFlowTypeId"];
            this.transactionStatus = data["transactionStatus"];
            this.cashflowCategoryId = data["cashflowCategoryId"];
            this.cashflowCategory = data["cashflowCategory"];
            this.cashflowSubCategoryId = data["cashflowSubCategoryId"];
            this.cashflowSubCategory = data["cashflowSubCategory"];
            this.accountingTypeId = data["accountingTypeId"];
            this.accountingType = data["accountingType"];
            this.transactionDescriptor = data["transactionDescriptor"];
            this.isDescriptorCalculated = data["isDescriptorCalculated"];
            this.counterpartyName = data["counterpartyName"];
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [];
                for (let item of data["comments"])
                    this.comments.push(TransactionCommentDto.fromJS(item));
            }
            if (data["attributes"] && data["attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["attributes"])
                    this.attributes.push(TransactionAttributeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountBankName"] = this.bankAccountBankName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankAccountName"] = this.bankAccountName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["cashFlowTypeId"] = this.cashFlowTypeId;
        data["transactionStatus"] = this.transactionStatus;
        data["cashflowCategoryId"] = this.cashflowCategoryId;
        data["cashflowCategory"] = this.cashflowCategory;
        data["cashflowSubCategoryId"] = this.cashflowSubCategoryId;
        data["cashflowSubCategory"] = this.cashflowSubCategory;
        data["accountingTypeId"] = this.accountingTypeId;
        data["accountingType"] = this.accountingType;
        data["transactionDescriptor"] = this.transactionDescriptor;
        data["isDescriptorCalculated"] = this.isDescriptorCalculated;
        data["counterpartyName"] = this.counterpartyName;
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionDetailsDto {
    id: number | undefined;
    bankAccountBankName: string | undefined;
    bankAccountNumber: string | undefined;
    bankAccountName: string | undefined;
    date: moment.Moment | undefined;
    currency: string | undefined;
    amount: number | undefined;
    description: string | undefined;
    cashFlowTypeId: string | undefined;
    transactionStatus: TransactionStatus | undefined;
    cashflowCategoryId: number | undefined;
    cashflowCategory: string | undefined;
    cashflowSubCategoryId: number | undefined;
    cashflowSubCategory: string | undefined;
    accountingTypeId: number | undefined;
    accountingType: string | undefined;
    transactionDescriptor: string | undefined;
    isDescriptorCalculated: boolean | undefined;
    counterpartyName: string | undefined;
    comments: TransactionCommentDto[] | undefined;
    attributes: TransactionAttributeDto[] | undefined;
}

export class GetTransactionDetailsOutput implements IGetTransactionDetailsOutput {
    transactionDetails!: TransactionDetailsDto | undefined;

    constructor(data?: IGetTransactionDetailsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionDetails = data["transactionDetails"] ? TransactionDetailsDto.fromJS(data["transactionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransactionDetailsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransactionDetailsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionDetails"] = this.transactionDetails ? this.transactionDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTransactionDetailsOutput {
    transactionDetails: TransactionDetailsDto | undefined;
}

export class TransactionTypeDto implements ITransactionTypeDto {
    id!: string | undefined;
    name!: string | undefined;
    categories!: string[] | undefined;

    constructor(data?: ITransactionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(item);
            }
        }
    }

    static fromJS(data: any): TransactionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        return data; 
    }
}

export interface ITransactionTypeDto {
    id: string | undefined;
    name: string | undefined;
    categories: string[] | undefined;
}

export class TransactionTypesAndCategoriesDto implements ITransactionTypesAndCategoriesDto {
    types!: TransactionTypeDto[] | undefined;
    categories!: StringFilterElementDto[] | undefined;

    constructor(data?: ITransactionTypesAndCategoriesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [];
                for (let item of data["types"])
                    this.types.push(TransactionTypeDto.fromJS(item));
            }
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(StringFilterElementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionTypesAndCategoriesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypesAndCategoriesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionTypesAndCategoriesDto {
    types: TransactionTypeDto[] | undefined;
    categories: StringFilterElementDto[] | undefined;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType!: string | undefined;
    contentSkin!: string | undefined;
    theme!: string | undefined;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["theme"] = this.theme;
        return data; 
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader!: boolean | undefined;
    desktopMinimizeMode!: string | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    displaySubmenuArrowDesktop!: boolean | undefined;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        return data; 
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    allowAsideHiding!: boolean | undefined;
    defaultHiddenAside!: boolean | undefined;
    submenuToggle!: string | undefined;
    dropdownSubmenuSkin!: string | undefined;
    dropdownSubmenuArrow!: boolean | undefined;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout!: UiCustomizationLayoutSettingsEditDto | undefined;
    header!: UiCustomizationHeaderSettingsEditDto | undefined;
    menu!: UiCustomizationMenuSettingsEditDto | undefined;
    footer!: UiCustomizationFooterSettingsEditDto | undefined;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;
}

export enum UserGroup {
    Employee = "Employee", 
    Member = "Member", 
    Partner = "Partner", 
    Investor = "Investor", 
    Vendor = "Vendor", 
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profileThumbnailId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    lastLoginTime!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profileThumbnailId = data["profileThumbnailId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profileThumbnailId"] = this.profileThumbnailId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profileThumbnailId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListDtoPagedResultDto implements IUserListDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserListDtoPagedResultDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id!: number | undefined;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IInt64EntityDto {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class UpdateUserPictureInput implements IUpdateUserPictureInput {
    userId!: number | undefined;
    image!: string | undefined;
    imageThumbnail!: string | undefined;
    source!: string | undefined;

    constructor(data?: IUpdateUserPictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.image = data["image"];
            this.imageThumbnail = data["imageThumbnail"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): UpdateUserPictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["image"] = this.image;
        data["imageThumbnail"] = this.imageThumbnail;
        data["source"] = this.source;
        return data; 
    }
}

export interface IUpdateUserPictureInput {
    userId: number | undefined;
    image: string | undefined;
    imageThumbnail: string | undefined;
    source: string | undefined;
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    profilePicture!: string | undefined;
    profileThumbnail!: string | undefined;
    pictureSource!: string | undefined;
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.profilePicture = data["profilePicture"];
            this.profileThumbnail = data["profileThumbnail"];
            this.pictureSource = data["pictureSource"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["profilePicture"] = this.profilePicture;
        data["profileThumbnail"] = this.profileThumbnail;
        data["pictureSource"] = this.pictureSource;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    profilePicture: string | undefined;
    profileThumbnail: string | undefined;
    pictureSource: string | undefined;
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class InviteUserInput implements IInviteUserInput {
    name!: string;
    surname!: string;
    emailAddress!: string;
    assignedRoleNames!: string[];
    moduleType!: ModuleType | undefined;

    constructor(data?: IInviteUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.moduleType = data["moduleType"];
        }
    }

    static fromJS(data: any): InviteUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new InviteUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["moduleType"] = this.moduleType;
        return data; 
    }
}

export interface IInviteUserInput {
    name: string;
    surname: string;
    emailAddress: string;
    assignedRoleNames: string[];
    moduleType: ModuleType | undefined;
}

export class UpdateUserEmailDto implements IUpdateUserEmailDto {
    id!: number;
    emailAddress!: string;

    constructor(data?: IUpdateUserEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): UpdateUserEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface IUpdateUserEmailDto {
    id: number;
    emailAddress: string;
}

export class UpdateUserPhoneDto implements IUpdateUserPhoneDto {
    id!: number;
    phoneNumber!: string;

    constructor(data?: IUpdateUserPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateUserPhoneDto {
    id: number;
    phoneNumber: string;
}

export class ResetUserPasswordDto implements IResetUserPasswordDto {
    id!: number;
    password!: string | undefined;
    setRandomPassword!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;

    constructor(data?: IResetUserPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.password = data["password"];
            this.setRandomPassword = data["setRandomPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
        }
    }

    static fromJS(data: any): ResetUserPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        data["setRandomPassword"] = this.setRandomPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        return data; 
    }
}

export interface IResetUserPasswordDto {
    id: number;
    password: string | undefined;
    setRandomPassword: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
}

export class UpdateUserOptionsDto implements IUpdateUserOptionsDto {
    id!: number;
    isActive!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUpdateUserOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActive = data["isActive"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UpdateUserOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUpdateUserOptionsDto {
    id: number;
    isActive: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class GrantPermissionInput implements IGrantPermissionInput {
    id!: number | undefined;
    permissionName!: string;

    constructor(data?: IGrantPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.permissionName = data["permissionName"];
        }
    }

    static fromJS(data: any): GrantPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GrantPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data; 
    }
}

export interface IGrantPermissionInput {
    id: number | undefined;
    permissionName: string;
}

export class ProhibitPermissionInput implements IProhibitPermissionInput {
    id!: number | undefined;
    permissionName!: string;

    constructor(data?: IProhibitPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.permissionName = data["permissionName"];
        }
    }

    static fromJS(data: any): ProhibitPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProhibitPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["permissionName"] = this.permissionName;
        return data; 
    }
}

export interface IProhibitPermissionInput {
    id: number | undefined;
    permissionName: string;
}

export class UpdateUserRoleInput implements IUpdateUserRoleInput {
    id!: number | undefined;
    roleName!: string;

    constructor(data?: IUpdateUserRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UpdateUserRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUpdateUserRoleInput {
    id: number | undefined;
    roleName: string;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    lastLoginTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    id: number | undefined;
}

export class LinkedUserDtoPagedResultDto implements ILinkedUserDtoPagedResultDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: ILinkedUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILinkedUserDtoPagedResultDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDtoListResultDto implements ILinkedUserDtoListResultDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: ILinkedUserDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedUserDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILinkedUserDtoListResultDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class UserLoginAttemptDtoListResultDto implements IUserLoginAttemptDtoListResultDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IUserLoginAttemptDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLoginAttemptDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserLoginAttemptDtoListResultDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AddWorkflowRuleDto implements IAddWorkflowRuleDto {
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean | undefined;

    constructor(data?: IAddWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): AddWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IAddWorkflowRuleDto {
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean | undefined;
}

export class EditWorkflowRuleDto implements IEditWorkflowRuleDto {
    id!: number;
    triggerIdentifier!: string;
    actionIdentifier!: string;
    configurationOptions!: string;
    isActive!: boolean | undefined;

    constructor(data?: IEditWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): EditWorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditWorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IEditWorkflowRuleDto {
    id: number;
    triggerIdentifier: string;
    actionIdentifier: string;
    configurationOptions: string;
    isActive: boolean | undefined;
}

export class WorkflowRuleDto implements IWorkflowRuleDto {
    id!: number | undefined;
    triggerIdentifier!: string | undefined;
    actionIdentifier!: string | undefined;
    configurationType!: string | undefined;
    configurationOptions!: string | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IWorkflowRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.triggerIdentifier = data["triggerIdentifier"];
            this.actionIdentifier = data["actionIdentifier"];
            this.configurationType = data["configurationType"];
            this.configurationOptions = data["configurationOptions"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): WorkflowRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["triggerIdentifier"] = this.triggerIdentifier;
        data["actionIdentifier"] = this.actionIdentifier;
        data["configurationType"] = this.configurationType;
        data["configurationOptions"] = this.configurationOptions;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IWorkflowRuleDto {
    id: number | undefined;
    triggerIdentifier: string | undefined;
    actionIdentifier: string | undefined;
    configurationType: string | undefined;
    configurationOptions: string | undefined;
    isActive: boolean | undefined;
}

export class WorkflowActionDto implements IWorkflowActionDto {
    name!: string | undefined;
    configurationType!: string | undefined;

    constructor(data?: IWorkflowActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.configurationType = data["configurationType"];
        }
    }

    static fromJS(data: any): WorkflowActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["configurationType"] = this.configurationType;
        return data; 
    }
}

export interface IWorkflowActionDto {
    name: string | undefined;
    configurationType: string | undefined;
}

export class WorkflowTriggerDto implements IWorkflowTriggerDto {
    name!: string | undefined;
    supportedActions!: WorkflowActionDto[] | undefined;

    constructor(data?: IWorkflowTriggerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["supportedActions"] && data["supportedActions"].constructor === Array) {
                this.supportedActions = [];
                for (let item of data["supportedActions"])
                    this.supportedActions.push(WorkflowActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTriggerDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTriggerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.supportedActions && this.supportedActions.constructor === Array) {
            data["supportedActions"] = [];
            for (let item of this.supportedActions)
                data["supportedActions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkflowTriggerDto {
    name: string | undefined;
    supportedActions: WorkflowActionDto[] | undefined;
}

export class ChangeStageConfiguration implements IChangeStageConfiguration {
    fromStageIds!: number[];
    toStageId!: number;

    constructor(data?: IChangeStageConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fromStageIds = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["fromStageIds"] && data["fromStageIds"].constructor === Array) {
                this.fromStageIds = [];
                for (let item of data["fromStageIds"])
                    this.fromStageIds.push(item);
            }
            this.toStageId = data["toStageId"];
        }
    }

    static fromJS(data: any): ChangeStageConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStageConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fromStageIds && this.fromStageIds.constructor === Array) {
            data["fromStageIds"] = [];
            for (let item of this.fromStageIds)
                data["fromStageIds"].push(item);
        }
        data["toStageId"] = this.toStageId;
        return data; 
    }
}

export interface IChangeStageConfiguration {
    fromStageIds: number[];
    toStageId: number;
}

export class ProcessLeadConfiguration implements IProcessLeadConfiguration {

    constructor(data?: IProcessLeadConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ProcessLeadConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessLeadConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IProcessLeadConfiguration {
}

export class Flags implements IFlags {
    choice!: boolean | undefined;
    best!: boolean | undefined;
    travelAndAirlineMiles!: boolean | undefined;
    dinigRewards!: boolean | undefined;
    gasRewards!: boolean | undefined;
    cashBackRewards!: boolean | undefined;
    instantDecision!: boolean | undefined;
    instantResponse!: boolean | undefined;
    noCreditCheck!: boolean | undefined;
    guaranteedApproval!: boolean | undefined;
    rebuildCredit!: boolean | undefined;
    chipCard!: boolean | undefined;
    applePay!: boolean | undefined;
    groceryRewards!: boolean | undefined;
    entertainmentRewards!: boolean | undefined;
    hotelRewards!: boolean | undefined;
    hasNoRewards!: boolean | undefined;
    zeroPercentageOnPurchases!: boolean | undefined;
    zeroPercentageInterestTransfers!: boolean | undefined;
    special!: boolean | undefined;
    newest!: boolean | undefined;

    constructor(data?: IFlags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.choice = data["Choice"];
            this.best = data["Best"];
            this.travelAndAirlineMiles = data["TravelAndAirlineMiles"];
            this.dinigRewards = data["DinigRewards"];
            this.gasRewards = data["GasRewards"];
            this.cashBackRewards = data["CashBackRewards"];
            this.instantDecision = data["InstantDecision"];
            this.instantResponse = data["InstantResponse"];
            this.noCreditCheck = data["NoCreditCheck"];
            this.guaranteedApproval = data["GuaranteedApproval"];
            this.rebuildCredit = data["RebuildCredit"];
            this.chipCard = data["ChipCard"];
            this.applePay = data["ApplePay"];
            this.groceryRewards = data["GroceryRewards"];
            this.entertainmentRewards = data["EntertainmentRewards"];
            this.hotelRewards = data["HotelRewards"];
            this.hasNoRewards = data["HasNoRewards"];
            this.zeroPercentageOnPurchases = data["ZeroPercentageOnPurchases"];
            this.zeroPercentageInterestTransfers = data["ZeroPercentageInterestTransfers"];
            this.special = data["Special"];
            this.newest = data["Newest"];
        }
    }

    static fromJS(data: any): Flags {
        data = typeof data === 'object' ? data : {};
        let result = new Flags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Choice"] = this.choice;
        data["Best"] = this.best;
        data["TravelAndAirlineMiles"] = this.travelAndAirlineMiles;
        data["DinigRewards"] = this.dinigRewards;
        data["GasRewards"] = this.gasRewards;
        data["CashBackRewards"] = this.cashBackRewards;
        data["InstantDecision"] = this.instantDecision;
        data["InstantResponse"] = this.instantResponse;
        data["NoCreditCheck"] = this.noCreditCheck;
        data["GuaranteedApproval"] = this.guaranteedApproval;
        data["RebuildCredit"] = this.rebuildCredit;
        data["ChipCard"] = this.chipCard;
        data["ApplePay"] = this.applePay;
        data["GroceryRewards"] = this.groceryRewards;
        data["EntertainmentRewards"] = this.entertainmentRewards;
        data["HotelRewards"] = this.hotelRewards;
        data["HasNoRewards"] = this.hasNoRewards;
        data["ZeroPercentageOnPurchases"] = this.zeroPercentageOnPurchases;
        data["ZeroPercentageInterestTransfers"] = this.zeroPercentageInterestTransfers;
        data["Special"] = this.special;
        data["Newest"] = this.newest;
        return data; 
    }
}

export interface IFlags {
    choice: boolean | undefined;
    best: boolean | undefined;
    travelAndAirlineMiles: boolean | undefined;
    dinigRewards: boolean | undefined;
    gasRewards: boolean | undefined;
    cashBackRewards: boolean | undefined;
    instantDecision: boolean | undefined;
    instantResponse: boolean | undefined;
    noCreditCheck: boolean | undefined;
    guaranteedApproval: boolean | undefined;
    rebuildCredit: boolean | undefined;
    chipCard: boolean | undefined;
    applePay: boolean | undefined;
    groceryRewards: boolean | undefined;
    entertainmentRewards: boolean | undefined;
    hotelRewards: boolean | undefined;
    hasNoRewards: boolean | undefined;
    zeroPercentageOnPurchases: boolean | undefined;
    zeroPercentageInterestTransfers: boolean | undefined;
    special: boolean | undefined;
    newest: boolean | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}